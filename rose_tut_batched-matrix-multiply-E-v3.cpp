namespace std
{
typedef unsigned long size_t;
typedef long ptrdiff_t;
typedef decltype(nullptr) nullptr_t;
}
namespace std
{
inline namespace __cxx11
{
}
}
namespace __gnu_cxx
{
inline namespace __cxx11
{
}
}
extern "C++" {
namespace std
{

struct __true_type 
{
}
;

struct __false_type 
{
}
;
template < bool >
    struct __truth_type
    { typedef __false_type __type; };
template<> struct __truth_type< true > 
{
typedef struct __true_type __type;
};
template < class _Sp, class _Tp >
    struct __traitor
    {
      enum { __value = bool ( _Sp :: __value ) || bool ( _Tp :: __value ) };
      typedef typename __truth_type < __value > :: __type __type;
    };
template < typename, typename >
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
template < typename _Tp >
    struct __are_same < _Tp, _Tp >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
template < typename _Tp >
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
template<> struct __is_void< void  > 
{
enum __anonymous_0x116f760 {__value=1} ;
typedef struct __true_type __type;
};
template < typename _Tp >
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
template<> struct __is_integer< bool  > 
{
enum __anonymous_0x1172470 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< char  > 
{
enum __anonymous_0x1173c40 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< signed char  > 
{
enum __anonymous_0x1175530 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< unsigned char  > 
{
enum __anonymous_0x1176d00 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< wchar_t  > 
{
enum __anonymous_0x11785f0 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< char16_t  > 
{
enum __anonymous_0x1179ee0 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< char32_t  > 
{
enum __anonymous_0x117b890 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< short  > 
{
enum __anonymous_0x117d060 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< unsigned short  > 
{
enum __anonymous_0x117e830 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< int  > 
{
enum __anonymous_0x1180000 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< unsigned int  > 
{
enum __anonymous_0x11817d0 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< long  > 
{
enum __anonymous_0x1182fa0 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< unsigned long  > 
{
enum __anonymous_0x1184770 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< long long  > 
{
enum __anonymous_0x1185f40 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_integer< unsigned long long  > 
{
enum __anonymous_0x1187710 {__value=1} ;
typedef struct __true_type __type;
};
template < typename _Tp >
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
template<> struct __is_floating< float  > 
{
enum __anonymous_0x118a420 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_floating< double  > 
{
enum __anonymous_0x119bca0 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_floating< long double  > 
{
enum __anonymous_0x119d470 {__value=1} ;
typedef struct __true_type __type;
};
template < typename _Tp >
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
template < typename _Tp >
    struct __is_pointer < _Tp * >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
template < typename _Tp >
    struct __is_arithmetic
    : public __traitor < __is_integer < _Tp >, __is_floating < _Tp > >
    { };
template < typename _Tp >
    struct __is_scalar
    : public __traitor < __is_arithmetic < _Tp >, __is_pointer < _Tp > >
    { };
template < typename _Tp >
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
template<> struct __is_char< char  > 
{
enum __anonymous_0x11a5790 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_char< wchar_t  > 
{
enum __anonymous_0x11a6f60 {__value=1} ;
typedef struct __true_type __type;
};
template < typename _Tp >
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
template<> struct __is_byte< char  > 
{
enum __anonymous_0x11a9c70 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_byte< signed char  > 
{
enum __anonymous_0x11ab4d0 {__value=1} ;
typedef struct __true_type __type;
};
template<> struct __is_byte< unsigned char  > 
{
enum __anonymous_0x11acca0 {__value=1} ;
typedef struct __true_type __type;
};
template < typename _Tp >
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
template < typename _Iterator >
    inline _Iterator
    __miter_base ( _Iterator __it )
    { return __it; }
}
}
extern "C++" {
namespace __gnu_cxx
{
template < bool, typename >
    struct __enable_if
    { };
template < typename _Tp >
    struct __enable_if < true, _Tp >
    { typedef _Tp __type; };
template < bool _Cond, typename _Iftrue, typename _Iffalse >
    struct __conditional_type
    { typedef _Iftrue __type; };
template < typename _Iftrue, typename _Iffalse >
    struct __conditional_type < false, _Iftrue, _Iffalse >
    { typedef _Iffalse __type; };
template < typename _Tp >
    struct __add_unsigned
    {
    private :
      typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;
    public :
      typedef typename __if_type :: __type __type;
    };
template<> struct __add_unsigned< char  > 
{
typedef unsigned char __type;
};
template<> struct __add_unsigned< signed char  > 
{
typedef unsigned char __type;
};
template<> struct __add_unsigned< short  > 
{
typedef unsigned short __type;
};
template<> struct __add_unsigned< int  > 
{
typedef unsigned int __type;
};
template<> struct __add_unsigned< long  > 
{
typedef unsigned long __type;
};
template<> struct __add_unsigned< long long  > 
{
typedef unsigned long long __type;
};
template<> struct __add_unsigned< bool  > ;
template<> struct __add_unsigned< wchar_t  > ;
template < typename _Tp >
    struct __remove_unsigned
    {
    private :
      typedef __enable_if < std :: __is_integer < _Tp > :: __value, _Tp > __if_type;
    public :
      typedef typename __if_type :: __type __type;
    };
template<> struct __remove_unsigned< char  > 
{
typedef signed char __type;
};
template<> struct __remove_unsigned< unsigned char  > 
{
typedef signed char __type;
};
template<> struct __remove_unsigned< unsigned short  > 
{
typedef short __type;
};
template<> struct __remove_unsigned< unsigned int  > 
{
typedef int __type;
};
template<> struct __remove_unsigned< unsigned long  > 
{
typedef long __type;
};
template<> struct __remove_unsigned< unsigned long long  > 
{
typedef long long __type;
};
template<> struct __remove_unsigned< bool  > ;
template<> struct __remove_unsigned< wchar_t  > ;
template < typename _Type >
    inline bool
    __is_null_pointer ( _Type * __ptr )
    { return __ptr == 0; }
template < typename _Type >
    inline bool
    __is_null_pointer ( _Type )
    { return false; }

inline bool  __attribute__((visibility("default"))) __is_null_pointer(std::nullptr_t )
{
return true;
}
template < typename _Tp, bool = std :: __is_integer < _Tp > :: __value >
    struct __promote
    { typedef double __type; };
template < typename _Tp >
    struct __promote < _Tp, false >
    { };
template<> struct __promote< long double  , false > 
{
typedef long double __type;
};
template<> struct __promote< double  , false > 
{
typedef double __type;
};
template<> struct __promote< float  , false > 
{
typedef float __type;
};
template < typename _Tp, typename _Up,
           typename _Tp2 = typename __promote < _Tp > :: __type,
           typename _Up2 = typename __promote < _Up > :: __type >
    struct __promote_2
    {
      typedef __typeof__ ( _Tp2 ( ) + _Up2 ( ) ) __type;
    };
template < typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote < _Tp > :: __type,
           typename _Up2 = typename __promote < _Up > :: __type,
           typename _Vp2 = typename __promote < _Vp > :: __type >
    struct __promote_3
    {
      typedef __typeof__ ( _Tp2 ( ) + _Up2 ( ) + _Vp2 ( ) ) __type;
    };
template < typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote < _Tp > :: __type,
           typename _Up2 = typename __promote < _Up > :: __type,
           typename _Vp2 = typename __promote < _Vp > :: __type,
           typename _Wp2 = typename __promote < _Wp > :: __type >
    struct __promote_4
    {
      typedef __typeof__ ( _Tp2 ( ) + _Up2 ( ) + _Vp2 ( ) + _Wp2 ( ) ) __type;
    };
}
}
extern "C" {
typedef float float_t;
typedef double double_t;
extern "C" { double acos(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __acos(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double asin(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __asin(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double atan(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __atan(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double atan2(double __y,double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __atan2(double __y,double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double cos(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __cos(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double sin(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __sin(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double tan(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __tan(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double cosh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __cosh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double sinh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __sinh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double tanh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __tanh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { void sincos(double __x,double *__sinx,double *__cosx) throw() __attribute__((no_throw)) ; }
extern "C" { void __sincos(double __x,double *__sinx,double *__cosx) throw() __attribute__((no_throw)) ; }
extern "C" { double acosh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __acosh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double asinh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __asinh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double atanh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __atanh(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double exp(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __exp(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double frexp(double __x,int *__exponent) throw() __attribute__((no_throw)) ; }
extern "C" { double __frexp(double __x,int *__exponent) throw() __attribute__((no_throw)) ; }
extern "C" { double ldexp(double __x,int __exponent) throw() __attribute__((no_throw)) ; }
extern "C" { double __ldexp(double __x,int __exponent) throw() __attribute__((no_throw)) ; }
extern "C" { double log(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __log(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double log10(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __log10(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double modf(double __x,double *__iptr) throw() __attribute__((no_throw)) ; }
extern "C" { double __modf(double __x,double *__iptr) throw() __attribute__((no_throw)) ; }
extern "C" { double exp10(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __exp10(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double pow10(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __pow10(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double expm1(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __expm1(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double log1p(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __log1p(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double logb(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __logb(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double exp2(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __exp2(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double log2(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __log2(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double pow(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double __pow(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double sqrt(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __sqrt(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double hypot(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double __hypot(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double cbrt(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __cbrt(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double ceil(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __ceil(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double fabs(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __fabs(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double floor(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __floor(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double fmod(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double __fmod(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { int __isinf(double __value) throw() __attribute__((no_throw)) ; }
extern "C" { int __finite(double __value) throw() __attribute__((no_throw)) ; }
extern "C" { int isinf(double __value) throw() __attribute__((no_throw)) ; }
extern "C" { int finite(double __value) throw() __attribute__((no_throw)) ; }
extern "C" { double drem(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double __drem(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double significand(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __significand(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double copysign(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double __copysign(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double nan(const char *__tagb) throw() __attribute__((no_throw)) ; }
extern "C" { double __nan(const char *__tagb) throw() __attribute__((no_throw)) ; }
extern "C" { int __isnan(double __value) throw() __attribute__((no_throw)) ; }
extern "C" { int isnan(double __value) throw() __attribute__((no_throw)) ; }
extern "C" { double j0(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double __j0(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double j1(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double __j1(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double jn(int ,double ) throw() __attribute__((no_throw)) ; }
extern "C" { double __jn(int ,double ) throw() __attribute__((no_throw)) ; }
extern "C" { double y0(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double __y0(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double y1(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double __y1(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double yn(int ,double ) throw() __attribute__((no_throw)) ; }
extern "C" { double __yn(int ,double ) throw() __attribute__((no_throw)) ; }
extern "C" { double erf(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double __erf(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double erfc(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double __erfc(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double lgamma(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double __lgamma(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double tgamma(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double __tgamma(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double gamma(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double __gamma(double ) throw() __attribute__((no_throw)) ; }
extern "C" { double lgamma_r(double ,int *__signgamp) throw() __attribute__((no_throw)) ; }
extern "C" { double __lgamma_r(double ,int *__signgamp) throw() __attribute__((no_throw)) ; }
extern "C" { double rint(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __rint(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double nextafter(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double __nextafter(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double nexttoward(double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double __nexttoward(double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double remainder(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double __remainder(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double scalbn(double __x,int __n) throw() __attribute__((no_throw)) ; }
extern "C" { double __scalbn(double __x,int __n) throw() __attribute__((no_throw)) ; }
extern "C" { int ilogb(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { int __ilogb(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double scalbln(double __x,long __n) throw() __attribute__((no_throw)) ; }
extern "C" { double __scalbln(double __x,long __n) throw() __attribute__((no_throw)) ; }
extern "C" { double nearbyint(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __nearbyint(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double round(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __round(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double trunc(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double __trunc(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double remquo(double __x,double __y,int *__quo) throw() __attribute__((no_throw)) ; }
extern "C" { double __remquo(double __x,double __y,int *__quo) throw() __attribute__((no_throw)) ; }
extern "C" { long lrint(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long __lrint(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long llrint(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long __llrint(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long lround(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long __lround(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long llround(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long __llround(double __x) throw() __attribute__((no_throw)) ; }
extern "C" { double fdim(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double __fdim(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double fmax(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double __fmax(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double fmin(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { double __fmin(double __x,double __y) throw() __attribute__((no_throw)) ; }
extern "C" { int __fpclassify(double __value) throw() __attribute__((no_throw)) ; }
extern "C" { inline int __signbit(double __value) throw() __attribute__((always_inline))  __attribute__((no_throw)) ; }
extern "C" { double fma(double __x,double __y,double __z) throw() __attribute__((no_throw)) ; }
extern "C" { double __fma(double __x,double __y,double __z) throw() __attribute__((no_throw)) ; }
extern "C" { double scalb(double __x,double __n) throw() __attribute__((no_throw)) ; }
extern "C" { double __scalb(double __x,double __n) throw() __attribute__((no_throw)) ; }
extern "C" { float acosf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __acosf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float asinf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __asinf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float atanf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __atanf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float atan2f(float __y,float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __atan2f(float __y,float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float cosf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __cosf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float sinf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __sinf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float tanf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __tanf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float coshf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __coshf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float sinhf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __sinhf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float tanhf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __tanhf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { void sincosf(float __x,float *__sinx,float *__cosx) throw() __attribute__((no_throw)) ; }
extern "C" { void __sincosf(float __x,float *__sinx,float *__cosx) throw() __attribute__((no_throw)) ; }
extern "C" { float acoshf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __acoshf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float asinhf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __asinhf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float atanhf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __atanhf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float expf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __expf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float frexpf(float __x,int *__exponent) throw() __attribute__((no_throw)) ; }
extern "C" { float __frexpf(float __x,int *__exponent) throw() __attribute__((no_throw)) ; }
extern "C" { float ldexpf(float __x,int __exponent) throw() __attribute__((no_throw)) ; }
extern "C" { float __ldexpf(float __x,int __exponent) throw() __attribute__((no_throw)) ; }
extern "C" { float logf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __logf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float log10f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __log10f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float modff(float __x,float *__iptr) throw() __attribute__((no_throw)) ; }
extern "C" { float __modff(float __x,float *__iptr) throw() __attribute__((no_throw)) ; }
extern "C" { float exp10f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __exp10f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float pow10f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __pow10f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float expm1f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __expm1f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float log1pf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __log1pf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float logbf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __logbf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float exp2f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __exp2f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float log2f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __log2f(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float powf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float __powf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float sqrtf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __sqrtf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float hypotf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float __hypotf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float cbrtf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __cbrtf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float ceilf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __ceilf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float fabsf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __fabsf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float floorf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __floorf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float fmodf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float __fmodf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { int __isinff(float __value) throw() __attribute__((no_throw)) ; }
extern "C" { int __finitef(float __value) throw() __attribute__((no_throw)) ; }
extern "C" { int isinff(float __value) throw() __attribute__((no_throw)) ; }
extern "C" { int finitef(float __value) throw() __attribute__((no_throw)) ; }
extern "C" { float dremf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float __dremf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float significandf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __significandf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float copysignf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float __copysignf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float nanf(const char *__tagb) throw() __attribute__((no_throw)) ; }
extern "C" { float __nanf(const char *__tagb) throw() __attribute__((no_throw)) ; }
extern "C" { int __isnanf(float __value) throw() __attribute__((no_throw)) ; }
extern "C" { int isnanf(float __value) throw() __attribute__((no_throw)) ; }
extern "C" { float j0f(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float __j0f(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float j1f(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float __j1f(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float jnf(int ,float ) throw() __attribute__((no_throw)) ; }
extern "C" { float __jnf(int ,float ) throw() __attribute__((no_throw)) ; }
extern "C" { float y0f(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float __y0f(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float y1f(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float __y1f(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float ynf(int ,float ) throw() __attribute__((no_throw)) ; }
extern "C" { float __ynf(int ,float ) throw() __attribute__((no_throw)) ; }
extern "C" { float erff(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float __erff(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float erfcf(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float __erfcf(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float lgammaf(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float __lgammaf(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float tgammaf(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float __tgammaf(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float gammaf(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float __gammaf(float ) throw() __attribute__((no_throw)) ; }
extern "C" { float lgammaf_r(float ,int *__signgamp) throw() __attribute__((no_throw)) ; }
extern "C" { float __lgammaf_r(float ,int *__signgamp) throw() __attribute__((no_throw)) ; }
extern "C" { float rintf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __rintf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float nextafterf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float __nextafterf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float nexttowardf(float __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { float __nexttowardf(float __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { float remainderf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float __remainderf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float scalbnf(float __x,int __n) throw() __attribute__((no_throw)) ; }
extern "C" { float __scalbnf(float __x,int __n) throw() __attribute__((no_throw)) ; }
extern "C" { int ilogbf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { int __ilogbf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float scalblnf(float __x,long __n) throw() __attribute__((no_throw)) ; }
extern "C" { float __scalblnf(float __x,long __n) throw() __attribute__((no_throw)) ; }
extern "C" { float nearbyintf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __nearbyintf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float roundf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __roundf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float truncf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float __truncf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float remquof(float __x,float __y,int *__quo) throw() __attribute__((no_throw)) ; }
extern "C" { float __remquof(float __x,float __y,int *__quo) throw() __attribute__((no_throw)) ; }
extern "C" { long lrintf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { long __lrintf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long llrintf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long __llrintf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { long lroundf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { long __lroundf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long llroundf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long __llroundf(float __x) throw() __attribute__((no_throw)) ; }
extern "C" { float fdimf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float __fdimf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float fmaxf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float __fmaxf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float fminf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { float __fminf(float __x,float __y) throw() __attribute__((no_throw)) ; }
extern "C" { int __fpclassifyf(float __value) throw() __attribute__((no_throw)) ; }
extern "C" { inline int __signbitf(float __value) throw() __attribute__((always_inline))  __attribute__((no_throw)) ; }
extern "C" { float fmaf(float __x,float __y,float __z) throw() __attribute__((no_throw)) ; }
extern "C" { float __fmaf(float __x,float __y,float __z) throw() __attribute__((no_throw)) ; }
extern "C" { float scalbf(float __x,float __n) throw() __attribute__((no_throw)) ; }
extern "C" { float __scalbf(float __x,float __n) throw() __attribute__((no_throw)) ; }
extern "C" { long double acosl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __acosl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double asinl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __asinl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double atanl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __atanl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double atan2l(long double __y,long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __atan2l(long double __y,long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double cosl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __cosl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double sinl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __sinl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double tanl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __tanl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double coshl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __coshl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double sinhl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __sinhl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double tanhl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __tanhl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { void sincosl(long double __x,long double *__sinx,long double *__cosx) throw() __attribute__((no_throw)) ; }
extern "C" { void __sincosl(long double __x,long double *__sinx,long double *__cosx) throw() __attribute__((no_throw)) ; }
extern "C" { long double acoshl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __acoshl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double asinhl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __asinhl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double atanhl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __atanhl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double expl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __expl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double frexpl(long double __x,int *__exponent) throw() __attribute__((no_throw)) ; }
extern "C" { long double __frexpl(long double __x,int *__exponent) throw() __attribute__((no_throw)) ; }
extern "C" { long double ldexpl(long double __x,int __exponent) throw() __attribute__((no_throw)) ; }
extern "C" { long double __ldexpl(long double __x,int __exponent) throw() __attribute__((no_throw)) ; }
extern "C" { long double logl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __logl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double log10l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __log10l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double modfl(long double __x,long double *__iptr) throw() __attribute__((no_throw)) ; }
extern "C" { long double __modfl(long double __x,long double *__iptr) throw() __attribute__((no_throw)) ; }
extern "C" { long double exp10l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __exp10l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double pow10l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __pow10l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double expm1l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __expm1l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double log1pl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __log1pl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double logbl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __logbl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double exp2l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __exp2l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double log2l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __log2l(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double powl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double __powl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double sqrtl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __sqrtl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double hypotl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double __hypotl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double cbrtl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __cbrtl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double ceill(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __ceill(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double fabsl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __fabsl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double floorl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __floorl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double fmodl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double __fmodl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { int __isinfl(long double __value) throw() __attribute__((no_throw)) ; }
extern "C" { int __finitel(long double __value) throw() __attribute__((no_throw)) ; }
extern "C" { int isinfl(long double __value) throw() __attribute__((no_throw)) ; }
extern "C" { int finitel(long double __value) throw() __attribute__((no_throw)) ; }
extern "C" { long double dreml(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double __dreml(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double significandl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __significandl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double copysignl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double __copysignl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double nanl(const char *__tagb) throw() __attribute__((no_throw)) ; }
extern "C" { long double __nanl(const char *__tagb) throw() __attribute__((no_throw)) ; }
extern "C" { int __isnanl(long double __value) throw() __attribute__((no_throw)) ; }
extern "C" { int isnanl(long double __value) throw() __attribute__((no_throw)) ; }
extern "C" { long double j0l(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double __j0l(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double j1l(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double __j1l(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double jnl(int ,long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double __jnl(int ,long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double y0l(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double __y0l(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double y1l(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double __y1l(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double ynl(int ,long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double __ynl(int ,long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double erfl(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double __erfl(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double erfcl(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double __erfcl(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double lgammal(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double __lgammal(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double tgammal(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double __tgammal(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double gammal(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double __gammal(long double ) throw() __attribute__((no_throw)) ; }
extern "C" { long double lgammal_r(long double ,int *__signgamp) throw() __attribute__((no_throw)) ; }
extern "C" { long double __lgammal_r(long double ,int *__signgamp) throw() __attribute__((no_throw)) ; }
extern "C" { long double rintl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __rintl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double nextafterl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double __nextafterl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double nexttowardl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double __nexttowardl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double remainderl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double __remainderl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double scalbnl(long double __x,int __n) throw() __attribute__((no_throw)) ; }
extern "C" { long double __scalbnl(long double __x,int __n) throw() __attribute__((no_throw)) ; }
extern "C" { int ilogbl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { int __ilogbl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double scalblnl(long double __x,long __n) throw() __attribute__((no_throw)) ; }
extern "C" { long double __scalblnl(long double __x,long __n) throw() __attribute__((no_throw)) ; }
extern "C" { long double nearbyintl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __nearbyintl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double roundl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __roundl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double truncl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double __truncl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double remquol(long double __x,long double __y,int *__quo) throw() __attribute__((no_throw)) ; }
extern "C" { long double __remquol(long double __x,long double __y,int *__quo) throw() __attribute__((no_throw)) ; }
extern "C" { long lrintl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long __lrintl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long llrintl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long __llrintl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long lroundl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long __lroundl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long llroundl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long __llroundl(long double __x) throw() __attribute__((no_throw)) ; }
extern "C" { long double fdiml(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double __fdiml(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double fmaxl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double __fmaxl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double fminl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { long double __fminl(long double __x,long double __y) throw() __attribute__((no_throw)) ; }
extern "C" { int __fpclassifyl(long double __value) throw() __attribute__((no_throw)) ; }
extern "C" { inline int __signbitl(long double __value) throw() __attribute__((always_inline))  __attribute__((no_throw)) ; }
extern "C" { long double fmal(long double __x,long double __y,long double __z) throw() __attribute__((no_throw)) ; }
extern "C" { long double __fmal(long double __x,long double __y,long double __z) throw() __attribute__((no_throw)) ; }
extern "C" { long double scalbl(long double __x,long double __n) throw() __attribute__((no_throw)) ; }
extern "C" { long double __scalbl(long double __x,long double __n) throw() __attribute__((no_throw)) ; }
extern int signgam;
enum __anonymous_0x136da20 {FP_NAN=0,FP_INFINITE=1,FP_ZERO=2,FP_SUBNORMAL=3,FP_NORMAL=4} ;
typedef enum _LIB_VERSION_TYPE {_IEEE_=-1,_SVID_=0,_XOPEN_=1,_POSIX_=2,_ISOC_=3}_LIB_VERSION_TYPE;
extern ::_LIB_VERSION_TYPE _LIB_VERSION;

struct __exception 
{
int type;
char *name;
double arg1;
double arg2;
double retval;
}
;
extern "C" { int matherr(struct __exception *__exc) throw() __attribute__((no_throw)) ; }

inline int  __attribute__((always_inline))  __attribute__((no_throw)) __signbitf(float __x) throw()
{
int __m;
__asm__ ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
return ((__m & 0x8) != 0);
}

inline int  __attribute__((always_inline))  __attribute__((no_throw)) __signbit(double __x) throw()
{
int __m;
__asm__ ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
return ((__m & 0x80) != 0);
}

inline int  __attribute__((always_inline))  __attribute__((no_throw)) __signbitl(long double __x) throw()
{
union {
long double __l;
int __i[3];}__u = {.__l = {__x}};
return ((__u . __i[2] & 0x8000) != 0);
}
}
extern "C++"
{
namespace std
{

constexpr inline double  __attribute__((visibility("default"))) abs(double __x)
{
return __builtin_fabs(__x);
}

constexpr inline float  __attribute__((visibility("default"))) abs(float __x)
{
return __builtin_fabsf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) abs(long double __x)
{
return __builtin_fabsl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    abs ( _Tp __x )
    { return __builtin_fabs ( __x ); }
using ::acos;

constexpr inline float  __attribute__((visibility("default"))) acos(float __x)
{
return __builtin_acosf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) acos(long double __x)
{
return __builtin_acosl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    acos ( _Tp __x )
    { return __builtin_acos ( __x ); }
using ::asin;

constexpr inline float  __attribute__((visibility("default"))) asin(float __x)
{
return __builtin_asinf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) asin(long double __x)
{
return __builtin_asinl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    asin ( _Tp __x )
    { return __builtin_asin ( __x ); }
using ::atan;

constexpr inline float  __attribute__((visibility("default"))) atan(float __x)
{
return __builtin_atanf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) atan(long double __x)
{
return __builtin_atanl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    atan ( _Tp __x )
    { return __builtin_atan ( __x ); }
using ::atan2;

constexpr inline float  __attribute__((visibility("default"))) atan2(float __y,float __x)
{
return __builtin_atan2f(__y,__x);
}

constexpr inline long double  __attribute__((visibility("default"))) atan2(long double __y,long double __x)
{
return __builtin_atan2l(__y,__x);
}
template < typename _Tp, typename _Up >
    inline constexpr
    typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type
    atan2 ( _Tp __y, _Up __x )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return atan2 ( __type ( __y ), __type ( __x ) );
    }
using ::ceil;

constexpr inline float  __attribute__((visibility("default"))) ceil(float __x)
{
return __builtin_ceilf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) ceil(long double __x)
{
return __builtin_ceill(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    ceil ( _Tp __x )
    { return __builtin_ceil ( __x ); }
using ::cos;

constexpr inline float  __attribute__((visibility("default"))) cos(float __x)
{
return __builtin_cosf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) cos(long double __x)
{
return __builtin_cosl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    cos ( _Tp __x )
    { return __builtin_cos ( __x ); }
using ::cosh;

constexpr inline float  __attribute__((visibility("default"))) cosh(float __x)
{
return __builtin_coshf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) cosh(long double __x)
{
return __builtin_coshl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    cosh ( _Tp __x )
    { return __builtin_cosh ( __x ); }
using ::exp;

constexpr inline float  __attribute__((visibility("default"))) exp(float __x)
{
return __builtin_expf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) exp(long double __x)
{
return __builtin_expl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    exp ( _Tp __x )
    { return __builtin_exp ( __x ); }
using ::fabs;

constexpr inline float  __attribute__((visibility("default"))) fabs(float __x)
{
return __builtin_fabsf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) fabs(long double __x)
{
return __builtin_fabsl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    fabs ( _Tp __x )
    { return __builtin_fabs ( __x ); }
using ::floor;

constexpr inline float  __attribute__((visibility("default"))) floor(float __x)
{
return __builtin_floorf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) floor(long double __x)
{
return __builtin_floorl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    floor ( _Tp __x )
    { return __builtin_floor ( __x ); }
using ::fmod;

constexpr inline float  __attribute__((visibility("default"))) fmod(float __x,float __y)
{
return __builtin_fmodf(__x,__y);
}

constexpr inline long double  __attribute__((visibility("default"))) fmod(long double __x,long double __y)
{
return __builtin_fmodl(__x,__y);
}
template < typename _Tp, typename _Up >
    inline constexpr
    typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type
    fmod ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return fmod ( __type ( __x ), __type ( __y ) );
    }
using ::frexp;

inline float  __attribute__((visibility("default"))) frexp(float __x,int *__exp)
{
return __builtin_frexpf(__x,__exp);
}

inline long double  __attribute__((visibility("default"))) frexp(long double __x,int *__exp)
{
return __builtin_frexpl(__x,__exp);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    frexp ( _Tp __x, int * __exp )
    { return __builtin_frexp ( __x, __exp ); }
using ::ldexp;

constexpr inline float  __attribute__((visibility("default"))) ldexp(float __x,int __exp)
{
return __builtin_ldexpf(__x,__exp);
}

constexpr inline long double  __attribute__((visibility("default"))) ldexp(long double __x,int __exp)
{
return __builtin_ldexpl(__x,__exp);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    ldexp ( _Tp __x, int __exp )
    { return __builtin_ldexp ( __x, __exp ); }
using ::log;

constexpr inline float  __attribute__((visibility("default"))) log(float __x)
{
return __builtin_logf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) log(long double __x)
{
return __builtin_logl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    log ( _Tp __x )
    { return __builtin_log ( __x ); }
using ::log10;

constexpr inline float  __attribute__((visibility("default"))) log10(float __x)
{
return __builtin_log10f(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) log10(long double __x)
{
return __builtin_log10l(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    log10 ( _Tp __x )
    { return __builtin_log10 ( __x ); }
using ::modf;

inline float  __attribute__((visibility("default"))) modf(float __x,float *__iptr)
{
return __builtin_modff(__x,__iptr);
}

inline long double  __attribute__((visibility("default"))) modf(long double __x,long double *__iptr)
{
return __builtin_modfl(__x,__iptr);
}
using ::pow;

constexpr inline float  __attribute__((visibility("default"))) pow(float __x,float __y)
{
return __builtin_powf(__x,__y);
}

constexpr inline long double  __attribute__((visibility("default"))) pow(long double __x,long double __y)
{
return __builtin_powl(__x,__y);
}
template < typename _Tp, typename _Up >
    inline constexpr
    typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type
    pow ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return pow ( __type ( __x ), __type ( __y ) );
    }
using ::sin;

constexpr inline float  __attribute__((visibility("default"))) sin(float __x)
{
return __builtin_sinf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) sin(long double __x)
{
return __builtin_sinl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    sin ( _Tp __x )
    { return __builtin_sin ( __x ); }
using ::sinh;

constexpr inline float  __attribute__((visibility("default"))) sinh(float __x)
{
return __builtin_sinhf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) sinh(long double __x)
{
return __builtin_sinhl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    sinh ( _Tp __x )
    { return __builtin_sinh ( __x ); }
using ::sqrt;

constexpr inline float  __attribute__((visibility("default"))) sqrt(float __x)
{
return __builtin_sqrtf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) sqrt(long double __x)
{
return __builtin_sqrtl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    sqrt ( _Tp __x )
    { return __builtin_sqrt ( __x ); }
using ::tan;

constexpr inline float  __attribute__((visibility("default"))) tan(float __x)
{
return __builtin_tanf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) tan(long double __x)
{
return __builtin_tanl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    tan ( _Tp __x )
    { return __builtin_tan ( __x ); }
using ::tanh;

constexpr inline float  __attribute__((visibility("default"))) tanh(float __x)
{
return __builtin_tanhf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) tanh(long double __x)
{
return __builtin_tanhl(__x);
}
template < typename _Tp >
    inline constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    double > :: __type
    tanh ( _Tp __x )
    { return __builtin_tanh ( __x ); }
}
namespace std
{

constexpr inline int  __attribute__((visibility("default"))) fpclassify(float __x)
{
return __builtin_fpclassify(0,1,4,3,2,__x);
}

constexpr inline int  __attribute__((visibility("default"))) fpclassify(double __x)
{
return __builtin_fpclassify(0,1,4,3,2,__x);
}

constexpr inline int  __attribute__((visibility("default"))) fpclassify(long double __x)
{
return __builtin_fpclassify(0,1,4,3,2,__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              int > :: __type
    fpclassify ( _Tp __x )
    { return __x != 0 ? 4 : 2; }

constexpr inline bool  __attribute__((visibility("default"))) isfinite(float __x)
{
return (__builtin_isfinite(__x));
}

constexpr inline bool  __attribute__((visibility("default"))) isfinite(double __x)
{
return (__builtin_isfinite(__x));
}

constexpr inline bool  __attribute__((visibility("default"))) isfinite(long double __x)
{
return (__builtin_isfinite(__x));
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              bool > :: __type
    isfinite ( _Tp __x )
    { return true; }

constexpr inline bool  __attribute__((visibility("default"))) isinf(float __x)
{
return (__builtin_isinf(__x));
}
using ::isinf;

constexpr inline bool  __attribute__((visibility("default"))) isinf(long double __x)
{
return (__builtin_isinf(__x));
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              bool > :: __type
    isinf ( _Tp __x )
    { return false; }

constexpr inline bool  __attribute__((visibility("default"))) isnan(float __x)
{
return (__builtin_isnan(__x));
}
using ::isnan;

constexpr inline bool  __attribute__((visibility("default"))) isnan(long double __x)
{
return (__builtin_isnan(__x));
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              bool > :: __type
    isnan ( _Tp __x )
    { return false; }

constexpr inline bool  __attribute__((visibility("default"))) isnormal(float __x)
{
return (__builtin_isnormal(__x));
}

constexpr inline bool  __attribute__((visibility("default"))) isnormal(double __x)
{
return (__builtin_isnormal(__x));
}

constexpr inline bool  __attribute__((visibility("default"))) isnormal(long double __x)
{
return (__builtin_isnormal(__x));
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              bool > :: __type
    isnormal ( _Tp __x )
    { return __x != 0 ? true : false; }

constexpr inline bool  __attribute__((visibility("default"))) signbit(float __x)
{
return (__builtin_signbit(__x));
}

constexpr inline bool  __attribute__((visibility("default"))) signbit(double __x)
{
return (__builtin_signbit(__x));
}

constexpr inline bool  __attribute__((visibility("default"))) signbit(long double __x)
{
return (__builtin_signbit(__x));
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              bool > :: __type
    signbit ( _Tp __x )
    { return __x < 0 ? true : false; }

constexpr inline bool  __attribute__((visibility("default"))) isgreater(float __x,float __y)
{
return (__builtin_isgreater(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) isgreater(double __x,double __y)
{
return (__builtin_isgreater(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) isgreater(long double __x,long double __y)
{
return (__builtin_isgreater(__x,__y));
}
template < typename _Tp, typename _Up >
    constexpr typename
    __gnu_cxx :: __enable_if < ( __is_arithmetic < _Tp > :: __value
       && __is_arithmetic < _Up > :: __value ), bool > :: __type
    isgreater ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return __builtin_isgreater ( __type ( __x ), __type ( __y ) );
    }

constexpr inline bool  __attribute__((visibility("default"))) isgreaterequal(float __x,float __y)
{
return (__builtin_isgreaterequal(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) isgreaterequal(double __x,double __y)
{
return (__builtin_isgreaterequal(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) isgreaterequal(long double __x,long double __y)
{
return (__builtin_isgreaterequal(__x,__y));
}
template < typename _Tp, typename _Up >
    constexpr typename
    __gnu_cxx :: __enable_if < ( __is_arithmetic < _Tp > :: __value
       && __is_arithmetic < _Up > :: __value ), bool > :: __type
    isgreaterequal ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return __builtin_isgreaterequal ( __type ( __x ), __type ( __y ) );
    }

constexpr inline bool  __attribute__((visibility("default"))) isless(float __x,float __y)
{
return (__builtin_isless(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) isless(double __x,double __y)
{
return (__builtin_isless(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) isless(long double __x,long double __y)
{
return (__builtin_isless(__x,__y));
}
template < typename _Tp, typename _Up >
    constexpr typename
    __gnu_cxx :: __enable_if < ( __is_arithmetic < _Tp > :: __value
       && __is_arithmetic < _Up > :: __value ), bool > :: __type
    isless ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return __builtin_isless ( __type ( __x ), __type ( __y ) );
    }

constexpr inline bool  __attribute__((visibility("default"))) islessequal(float __x,float __y)
{
return (__builtin_islessequal(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) islessequal(double __x,double __y)
{
return (__builtin_islessequal(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) islessequal(long double __x,long double __y)
{
return (__builtin_islessequal(__x,__y));
}
template < typename _Tp, typename _Up >
    constexpr typename
    __gnu_cxx :: __enable_if < ( __is_arithmetic < _Tp > :: __value
       && __is_arithmetic < _Up > :: __value ), bool > :: __type
    islessequal ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return __builtin_islessequal ( __type ( __x ), __type ( __y ) );
    }

constexpr inline bool  __attribute__((visibility("default"))) islessgreater(float __x,float __y)
{
return (__builtin_islessgreater(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) islessgreater(double __x,double __y)
{
return (__builtin_islessgreater(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) islessgreater(long double __x,long double __y)
{
return (__builtin_islessgreater(__x,__y));
}
template < typename _Tp, typename _Up >
    constexpr typename
    __gnu_cxx :: __enable_if < ( __is_arithmetic < _Tp > :: __value
       && __is_arithmetic < _Up > :: __value ), bool > :: __type
    islessgreater ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return __builtin_islessgreater ( __type ( __x ), __type ( __y ) );
    }

constexpr inline bool  __attribute__((visibility("default"))) isunordered(float __x,float __y)
{
return (__builtin_isunordered(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) isunordered(double __x,double __y)
{
return (__builtin_isunordered(__x,__y));
}

constexpr inline bool  __attribute__((visibility("default"))) isunordered(long double __x,long double __y)
{
return (__builtin_isunordered(__x,__y));
}
template < typename _Tp, typename _Up >
    constexpr typename
    __gnu_cxx :: __enable_if < ( __is_arithmetic < _Tp > :: __value
       && __is_arithmetic < _Up > :: __value ), bool > :: __type
    isunordered ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return __builtin_isunordered ( __type ( __x ), __type ( __y ) );
    }
}
namespace std
{
using ::double_t;
using ::float_t;
using ::acosh;
using ::acoshf;
using ::acoshl;
using ::asinh;
using ::asinhf;
using ::asinhl;
using ::atanh;
using ::atanhf;
using ::atanhl;
using ::cbrt;
using ::cbrtf;
using ::cbrtl;
using ::copysign;
using ::copysignf;
using ::copysignl;
using ::erf;
using ::erff;
using ::erfl;
using ::erfc;
using ::erfcf;
using ::erfcl;
using ::exp2;
using ::exp2f;
using ::exp2l;
using ::expm1;
using ::expm1f;
using ::expm1l;
using ::fdim;
using ::fdimf;
using ::fdiml;
using ::fma;
using ::fmaf;
using ::fmal;
using ::fmax;
using ::fmaxf;
using ::fmaxl;
using ::fmin;
using ::fminf;
using ::fminl;
using ::hypot;
using ::hypotf;
using ::hypotl;
using ::ilogb;
using ::ilogbf;
using ::ilogbl;
using ::lgamma;
using ::lgammaf;
using ::lgammal;
using ::llrint;
using ::llrintf;
using ::llrintl;
using ::llround;
using ::llroundf;
using ::llroundl;
using ::log1p;
using ::log1pf;
using ::log1pl;
using ::log2;
using ::log2f;
using ::log2l;
using ::logb;
using ::logbf;
using ::logbl;
using ::lrint;
using ::lrintf;
using ::lrintl;
using ::lround;
using ::lroundf;
using ::lroundl;
using ::nan;
using ::nanf;
using ::nanl;
using ::nearbyint;
using ::nearbyintf;
using ::nearbyintl;
using ::nextafter;
using ::nextafterf;
using ::nextafterl;
using ::nexttoward;
using ::nexttowardf;
using ::nexttowardl;
using ::remainder;
using ::remainderf;
using ::remainderl;
using ::remquo;
using ::remquof;
using ::remquol;
using ::rint;
using ::rintf;
using ::rintl;
using ::round;
using ::roundf;
using ::roundl;
using ::scalbln;
using ::scalblnf;
using ::scalblnl;
using ::scalbn;
using ::scalbnf;
using ::scalbnl;
using ::tgamma;
using ::tgammaf;
using ::tgammal;
using ::trunc;
using ::truncf;
using ::truncl;

constexpr inline float  __attribute__((visibility("default"))) acosh(float __x)
{
return __builtin_acoshf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) acosh(long double __x)
{
return __builtin_acoshl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    acosh ( _Tp __x )
    { return __builtin_acosh ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) asinh(float __x)
{
return __builtin_asinhf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) asinh(long double __x)
{
return __builtin_asinhl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    asinh ( _Tp __x )
    { return __builtin_asinh ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) atanh(float __x)
{
return __builtin_atanhf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) atanh(long double __x)
{
return __builtin_atanhl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    atanh ( _Tp __x )
    { return __builtin_atanh ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) cbrt(float __x)
{
return __builtin_cbrtf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) cbrt(long double __x)
{
return __builtin_cbrtl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    cbrt ( _Tp __x )
    { return __builtin_cbrt ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) copysign(float __x,float __y)
{
return __builtin_copysignf(__x,__y);
}

constexpr inline long double  __attribute__((visibility("default"))) copysign(long double __x,long double __y)
{
return __builtin_copysignl(__x,__y);
}
template < typename _Tp, typename _Up >
    constexpr typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type
    copysign ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return copysign ( __type ( __x ), __type ( __y ) );
    }

constexpr inline float  __attribute__((visibility("default"))) erf(float __x)
{
return __builtin_erff(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) erf(long double __x)
{
return __builtin_erfl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    erf ( _Tp __x )
    { return __builtin_erf ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) erfc(float __x)
{
return __builtin_erfcf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) erfc(long double __x)
{
return __builtin_erfcl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    erfc ( _Tp __x )
    { return __builtin_erfc ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) exp2(float __x)
{
return __builtin_exp2f(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) exp2(long double __x)
{
return __builtin_exp2l(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    exp2 ( _Tp __x )
    { return __builtin_exp2 ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) expm1(float __x)
{
return __builtin_expm1f(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) expm1(long double __x)
{
return __builtin_expm1l(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    expm1 ( _Tp __x )
    { return __builtin_expm1 ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) fdim(float __x,float __y)
{
return __builtin_fdimf(__x,__y);
}

constexpr inline long double  __attribute__((visibility("default"))) fdim(long double __x,long double __y)
{
return __builtin_fdiml(__x,__y);
}
template < typename _Tp, typename _Up >
    constexpr typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type
    fdim ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return fdim ( __type ( __x ), __type ( __y ) );
    }

constexpr inline float  __attribute__((visibility("default"))) fma(float __x,float __y,float __z)
{
return __builtin_fmaf(__x,__y,__z);
}

constexpr inline long double  __attribute__((visibility("default"))) fma(long double __x,long double __y,long double __z)
{
return __builtin_fmal(__x,__y,__z);
}
template < typename _Tp, typename _Up, typename _Vp >
    constexpr typename __gnu_cxx :: __promote_3 < _Tp, _Up, _Vp > :: __type
    fma ( _Tp __x, _Up __y, _Vp __z )
    {
      typedef typename __gnu_cxx :: __promote_3 < _Tp, _Up, _Vp > :: __type __type;
      return fma ( __type ( __x ), __type ( __y ), __type ( __z ) );
    }

constexpr inline float  __attribute__((visibility("default"))) fmax(float __x,float __y)
{
return __builtin_fmaxf(__x,__y);
}

constexpr inline long double  __attribute__((visibility("default"))) fmax(long double __x,long double __y)
{
return __builtin_fmaxl(__x,__y);
}
template < typename _Tp, typename _Up >
    constexpr typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type
    fmax ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return fmax ( __type ( __x ), __type ( __y ) );
    }

constexpr inline float  __attribute__((visibility("default"))) fmin(float __x,float __y)
{
return __builtin_fminf(__x,__y);
}

constexpr inline long double  __attribute__((visibility("default"))) fmin(long double __x,long double __y)
{
return __builtin_fminl(__x,__y);
}
template < typename _Tp, typename _Up >
    constexpr typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type
    fmin ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return fmin ( __type ( __x ), __type ( __y ) );
    }

constexpr inline float  __attribute__((visibility("default"))) hypot(float __x,float __y)
{
return __builtin_hypotf(__x,__y);
}

constexpr inline long double  __attribute__((visibility("default"))) hypot(long double __x,long double __y)
{
return __builtin_hypotl(__x,__y);
}
template < typename _Tp, typename _Up >
    constexpr typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type
    hypot ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return hypot ( __type ( __x ), __type ( __y ) );
    }

constexpr inline int  __attribute__((visibility("default"))) ilogb(float __x)
{
return __builtin_ilogbf(__x);
}

constexpr inline int  __attribute__((visibility("default"))) ilogb(long double __x)
{
return __builtin_ilogbl(__x);
}
template < typename _Tp >
    constexpr
    typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                    int > :: __type
    ilogb ( _Tp __x )
    { return __builtin_ilogb ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) lgamma(float __x)
{
return __builtin_lgammaf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) lgamma(long double __x)
{
return __builtin_lgammal(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    lgamma ( _Tp __x )
    { return __builtin_lgamma ( __x ); }

constexpr inline long long  __attribute__((visibility("default"))) llrint(float __x)
{
return __builtin_llrintf(__x);
}

constexpr inline long long  __attribute__((visibility("default"))) llrint(long double __x)
{
return __builtin_llrintl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              long long > :: __type
    llrint ( _Tp __x )
    { return __builtin_llrint ( __x ); }

constexpr inline long long  __attribute__((visibility("default"))) llround(float __x)
{
return __builtin_llroundf(__x);
}

constexpr inline long long  __attribute__((visibility("default"))) llround(long double __x)
{
return __builtin_llroundl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              long long > :: __type
    llround ( _Tp __x )
    { return __builtin_llround ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) log1p(float __x)
{
return __builtin_log1pf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) log1p(long double __x)
{
return __builtin_log1pl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    log1p ( _Tp __x )
    { return __builtin_log1p ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) log2(float __x)
{
return __builtin_log2f(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) log2(long double __x)
{
return __builtin_log2l(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    log2 ( _Tp __x )
    { return __builtin_log2 ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) logb(float __x)
{
return __builtin_logbf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) logb(long double __x)
{
return __builtin_logbl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    logb ( _Tp __x )
    { return __builtin_logb ( __x ); }

constexpr inline long  __attribute__((visibility("default"))) lrint(float __x)
{
return __builtin_lrintf(__x);
}

constexpr inline long  __attribute__((visibility("default"))) lrint(long double __x)
{
return __builtin_lrintl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              long > :: __type
    lrint ( _Tp __x )
    { return __builtin_lrint ( __x ); }

constexpr inline long  __attribute__((visibility("default"))) lround(float __x)
{
return __builtin_lroundf(__x);
}

constexpr inline long  __attribute__((visibility("default"))) lround(long double __x)
{
return __builtin_lroundl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              long > :: __type
    lround ( _Tp __x )
    { return __builtin_lround ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) nearbyint(float __x)
{
return __builtin_nearbyintf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) nearbyint(long double __x)
{
return __builtin_nearbyintl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    nearbyint ( _Tp __x )
    { return __builtin_nearbyint ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) nextafter(float __x,float __y)
{
return __builtin_nextafterf(__x,__y);
}

constexpr inline long double  __attribute__((visibility("default"))) nextafter(long double __x,long double __y)
{
return __builtin_nextafterl(__x,__y);
}
template < typename _Tp, typename _Up >
    constexpr typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type
    nextafter ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return nextafter ( __type ( __x ), __type ( __y ) );
    }

constexpr inline float  __attribute__((visibility("default"))) nexttoward(float __x,long double __y)
{
return __builtin_nexttowardf(__x,__y);
}

constexpr inline long double  __attribute__((visibility("default"))) nexttoward(long double __x,long double __y)
{
return __builtin_nexttowardl(__x,__y);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    nexttoward ( _Tp __x, long double __y )
    { return __builtin_nexttoward ( __x, __y ); }

constexpr inline float  __attribute__((visibility("default"))) remainder(float __x,float __y)
{
return __builtin_remainderf(__x,__y);
}

constexpr inline long double  __attribute__((visibility("default"))) remainder(long double __x,long double __y)
{
return __builtin_remainderl(__x,__y);
}
template < typename _Tp, typename _Up >
    constexpr typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type
    remainder ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return remainder ( __type ( __x ), __type ( __y ) );
    }

inline float  __attribute__((visibility("default"))) remquo(float __x,float __y,int *__pquo)
{
return __builtin_remquof(__x,__y,__pquo);
}

inline long double  __attribute__((visibility("default"))) remquo(long double __x,long double __y,int *__pquo)
{
return __builtin_remquol(__x,__y,__pquo);
}
template < typename _Tp, typename _Up >
    inline typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type
    remquo ( _Tp __x, _Up __y, int * __pquo )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return remquo ( __type ( __x ), __type ( __y ), __pquo );
    }

constexpr inline float  __attribute__((visibility("default"))) rint(float __x)
{
return __builtin_rintf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) rint(long double __x)
{
return __builtin_rintl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    rint ( _Tp __x )
    { return __builtin_rint ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) round(float __x)
{
return __builtin_roundf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) round(long double __x)
{
return __builtin_roundl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    round ( _Tp __x )
    { return __builtin_round ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) scalbln(float __x,long __ex)
{
return __builtin_scalblnf(__x,__ex);
}

constexpr inline long double  __attribute__((visibility("default"))) scalbln(long double __x,long __ex)
{
return __builtin_scalblnl(__x,__ex);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    scalbln ( _Tp __x, long __ex )
    { return __builtin_scalbln ( __x, __ex ); }

constexpr inline float  __attribute__((visibility("default"))) scalbn(float __x,int __ex)
{
return __builtin_scalbnf(__x,__ex);
}

constexpr inline long double  __attribute__((visibility("default"))) scalbn(long double __x,int __ex)
{
return __builtin_scalbnl(__x,__ex);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    scalbn ( _Tp __x, int __ex )
    { return __builtin_scalbn ( __x, __ex ); }

constexpr inline float  __attribute__((visibility("default"))) tgamma(float __x)
{
return __builtin_tgammaf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) tgamma(long double __x)
{
return __builtin_tgammal(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    tgamma ( _Tp __x )
    { return __builtin_tgamma ( __x ); }

constexpr inline float  __attribute__((visibility("default"))) trunc(float __x)
{
return __builtin_truncf(__x);
}

constexpr inline long double  __attribute__((visibility("default"))) trunc(long double __x)
{
return __builtin_truncl(__x);
}
template < typename _Tp >
    constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
                                              double > :: __type
    trunc ( _Tp __x )
    { return __builtin_trunc ( __x ); }
}
}
typedef unsigned long size_t;
extern "C" {
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
typedef signed long __int64_t;
typedef unsigned long __uint64_t;
typedef long __quad_t;
typedef unsigned long __u_quad_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef struct {
int __val[2];}__fsid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef unsigned long __rlim64_t;
typedef unsigned int __id_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt_t;
typedef unsigned long __fsfilcnt64_t;
typedef long __fsword_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned long __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;
typedef long __intptr_t;
typedef unsigned int __socklen_t;

inline static unsigned int __bswap_32(unsigned int __bsx)
{
return __builtin_bswap32(__bsx);
}

inline static __uint64_t __bswap_64(__uint64_t __bsx)
{
return (__builtin_bswap64(__bsx));
}

union wait 
{
int w_status;
struct {
unsigned int __w_termsig:7;
unsigned int __w_coredump:1;
unsigned int __w_retcode:8;
unsigned int :16;}__wait_terminated;
struct {
unsigned int __w_stopval:8;
unsigned int __w_stopsig:8;
unsigned int :16;}__wait_stopped;
}
;
typedef struct {
int quot;
int rem;}div_t;
typedef struct {
long quot;
long rem;}ldiv_t;
typedef struct {
long long quot;
long long rem;}lldiv_t;
extern "C" { size_t __ctype_get_mb_cur_max() throw() __attribute__((no_throw)) ; }
extern "C" { inline double atof(const char *__nptr) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { inline int atoi(const char *__nptr) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { inline long atol(const char *__nptr) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { inline long long atoll(const char *__nptr) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { double strtod(const char *__nptr,char **__endptr) throw() __attribute__((no_throw)) ; }
extern "C" { float strtof(const char *__nptr,char **__endptr) throw() __attribute__((no_throw)) ; }
extern "C" { long double strtold(const char *__nptr,char **__endptr) throw() __attribute__((no_throw)) ; }
extern "C" { long strtol(const char *__nptr,char **__endptr,int __base) throw() __attribute__((no_throw)) ; }
extern "C" { unsigned long strtoul(const char *__nptr,char **__endptr,int __base) throw() __attribute__((no_throw)) ; }
extern "C" { long long strtoq(const char *__nptr,char **__endptr,int __base) throw() __attribute__((no_throw)) ; }
extern "C" { unsigned long long strtouq(const char *__nptr,char **__endptr,int __base) throw() __attribute__((no_throw)) ; }
extern "C" { long long strtoll(const char *__nptr,char **__endptr,int __base) throw() __attribute__((no_throw)) ; }
extern "C" { unsigned long long strtoull(const char *__nptr,char **__endptr,int __base) throw() __attribute__((no_throw)) ; }
typedef struct __locale_struct {
struct __locale_data *__locales[13];
const unsigned short *__ctype_b;
const int *__ctype_tolower;
const int *__ctype_toupper;
const char *__names[13];}*__locale_t;
typedef __locale_t locale_t;
extern "C" { long strtol_l(const char *__nptr,char **__endptr,int __base,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { unsigned long strtoul_l(const char *__nptr,char **__endptr,int __base,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { long long strtoll_l(const char *__nptr,char **__endptr,int __base,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { unsigned long long strtoull_l(const char *__nptr,char **__endptr,int __base,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { double strtod_l(const char *__nptr,char **__endptr,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { float strtof_l(const char *__nptr,char **__endptr,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { long double strtold_l(const char *__nptr,char **__endptr,__locale_t __loc) throw() __attribute__((no_throw)) ; }

inline int  __attribute__((pure))  __attribute__((no_throw)) atoi(const char *__nptr) throw()
{
return (int )(strtol(__nptr,(char **)0L,10));
}

inline long  __attribute__((pure))  __attribute__((no_throw)) atol(const char *__nptr) throw()
{
return strtol(__nptr,(char **)0L,10);
}

inline long long  __attribute__((pure))  __attribute__((no_throw)) atoll(const char *__nptr) throw()
{
return strtoll(__nptr,(char **)0L,10);
}
extern "C" { char *l64a(long __n) throw() __attribute__((no_throw)) ; }
extern "C" { long a64l(const char *__s) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" {
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
typedef __loff_t loff_t;
typedef __ino_t ino_t;
typedef __ino64_t ino64_t;
typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __uid_t uid_t;
typedef __off_t off_t;
typedef __off64_t off64_t;
typedef __pid_t pid_t;
typedef __id_t id_t;
typedef __ssize_t ssize_t;
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
typedef __key_t key_t;
typedef __clock_t clock_t;
typedef __time_t time_t;
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
typedef __useconds_t useconds_t;
typedef __suseconds_t suseconds_t;
typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long int64_t;
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long u_int64_t;
typedef long register_t;
typedef int __sig_atomic_t;
typedef struct {
unsigned long __val[16];}__sigset_t;
typedef __sigset_t sigset_t;

struct timespec 
{
__time_t tv_sec;
__syscall_slong_t tv_nsec;
}
;

struct timeval 
{
__time_t tv_sec;
__suseconds_t tv_usec;
}
;
typedef long __fd_mask;
typedef struct {
__fd_mask fds_bits[16];}fd_set;
typedef __fd_mask fd_mask;
extern "C" {
extern "C" { int select(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,struct timeval *__timeout); }
extern "C" { int pselect(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,const struct timespec *__timeout,const __sigset_t *__sigmask); }
}
extern "C" {
extern "C" { inline unsigned int gnu_dev_major(unsigned long long __dev) throw() __attribute__((no_throw)) ; }
extern "C" { inline unsigned int gnu_dev_minor(unsigned long long __dev) throw() __attribute__((no_throw)) ; }
extern "C" { inline unsigned long long gnu_dev_makedev(unsigned int __major,unsigned int __minor) throw() __attribute__((no_throw)) ; }

inline unsigned int  __attribute__((no_throw)) gnu_dev_major(unsigned long long __dev) throw()
{
return (__dev >> 8 & 0xfff | (((unsigned int )(__dev >> 32)) & (~0xfff)));
}

inline unsigned int  __attribute__((no_throw)) gnu_dev_minor(unsigned long long __dev) throw()
{
return (__dev & 0xff | (((unsigned int )(__dev >> 12)) & (~0xff)));
}

inline unsigned long long  __attribute__((no_throw)) gnu_dev_makedev(unsigned int __major,unsigned int __minor) throw()
{
return (__minor & 0xff | (__major & 0xfff) << 8) | ((unsigned long long )(__minor & (~0xff))) << 12 | ((unsigned long long )(__major & (~0xfff))) << 32;
}
}
typedef __blksize_t blksize_t;
typedef __blkcnt_t blkcnt_t;
typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
typedef unsigned long pthread_t;

union pthread_attr_t 
{
char __size[56];
long __align;
}
;
typedef union pthread_attr_t pthread_attr_t;
typedef struct __pthread_internal_list {
struct __pthread_internal_list *__prev;
struct __pthread_internal_list *__next;}__pthread_list_t;
typedef union {
struct __pthread_mutex_s {
int __lock;
unsigned int __count;
int __owner;
unsigned int __nusers;
int __kind;
short __spins;
short __elision;
__pthread_list_t __list;}__data;
char __size[40];
long __align;}pthread_mutex_t;
typedef union {
char __size[4];
int __align;}pthread_mutexattr_t;
typedef union {
struct {
int __lock;
unsigned int __futex;
unsigned long long __total_seq;
unsigned long long __wakeup_seq;
unsigned long long __woken_seq;
void *__mutex;
unsigned int __nwaiters;
unsigned int __broadcast_seq;}__data;
char __size[48];
long long __align;}pthread_cond_t;
typedef union {
char __size[4];
int __align;}pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
typedef union {
struct {
int __lock;
unsigned int __nr_readers;
unsigned int __readers_wakeup;
unsigned int __writer_wakeup;
unsigned int __nr_readers_queued;
unsigned int __nr_writers_queued;
int __writer;
int __shared;
unsigned long __pad1;
unsigned long __pad2;
unsigned int __flags;}__data;
char __size[56];
long __align;}pthread_rwlock_t;
typedef union {
char __size[8];
long __align;}pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
typedef union {
char __size[32];
long __align;}pthread_barrier_t;
typedef union {
char __size[4];
int __align;}pthread_barrierattr_t;
}
extern "C" { long random() throw() __attribute__((no_throw)) ; }
extern "C" { void srandom(unsigned int __seed) throw() __attribute__((no_throw)) ; }
extern "C" { char *initstate(unsigned int __seed,char *__statebuf,size_t __statelen) throw() __attribute__((no_throw)) ; }
extern "C" { char *setstate(char *__statebuf) throw() __attribute__((no_throw)) ; }

struct random_data 
{
int32_t *fptr;
int32_t *rptr;
int32_t *state;
int rand_type;
int rand_deg;
int rand_sep;
int32_t *end_ptr;
}
;
extern "C" { int random_r(struct random_data *__buf,int32_t *__result) throw() __attribute__((no_throw)) ; }
extern "C" { int srandom_r(unsigned int __seed,struct random_data *__buf) throw() __attribute__((no_throw)) ; }
extern "C" { int initstate_r(unsigned int __seed,char *__statebuf,size_t __statelen,struct random_data *__buf) throw() __attribute__((no_throw)) ; }
extern "C" { int setstate_r(char *__statebuf,struct random_data *__buf) throw() __attribute__((no_throw)) ; }
extern "C" { int rand() throw() __attribute__((no_throw)) ; }
extern "C" { void srand(unsigned int __seed) throw() __attribute__((no_throw)) ; }
extern "C" { int rand_r(unsigned int *__seed) throw() __attribute__((no_throw)) ; }
extern "C" { double drand48() throw() __attribute__((no_throw)) ; }
extern "C" { double erand48(unsigned short __xsubi[3]) throw() __attribute__((no_throw)) ; }
extern "C" { long lrand48() throw() __attribute__((no_throw)) ; }
extern "C" { long nrand48(unsigned short __xsubi[3]) throw() __attribute__((no_throw)) ; }
extern "C" { long mrand48() throw() __attribute__((no_throw)) ; }
extern "C" { long jrand48(unsigned short __xsubi[3]) throw() __attribute__((no_throw)) ; }
extern "C" { void srand48(long __seedval) throw() __attribute__((no_throw)) ; }
extern "C" { unsigned short *seed48(unsigned short __seed16v[3]) throw() __attribute__((no_throw)) ; }
extern "C" { void lcong48(unsigned short __param[7]) throw() __attribute__((no_throw)) ; }

struct drand48_data 
{
unsigned short __x[3];
unsigned short __old_x[3];
unsigned short __c;
unsigned short __init;
unsigned long long __a;
}
;
extern "C" { int drand48_r(struct drand48_data *__buffer,double *__result) throw() __attribute__((no_throw)) ; }
extern "C" { int erand48_r(unsigned short __xsubi[3],struct drand48_data *__buffer,double *__result) throw() __attribute__((no_throw)) ; }
extern "C" { int lrand48_r(struct drand48_data *__buffer,long *__result) throw() __attribute__((no_throw)) ; }
extern "C" { int nrand48_r(unsigned short __xsubi[3],struct drand48_data *__buffer,long *__result) throw() __attribute__((no_throw)) ; }
extern "C" { int mrand48_r(struct drand48_data *__buffer,long *__result) throw() __attribute__((no_throw)) ; }
extern "C" { int jrand48_r(unsigned short __xsubi[3],struct drand48_data *__buffer,long *__result) throw() __attribute__((no_throw)) ; }
extern "C" { int srand48_r(long __seedval,struct drand48_data *__buffer) throw() __attribute__((no_throw)) ; }
extern "C" { int seed48_r(unsigned short __seed16v[3],struct drand48_data *__buffer) throw() __attribute__((no_throw)) ; }
extern "C" { int lcong48_r(unsigned short __param[7],struct drand48_data *__buffer) throw() __attribute__((no_throw)) ; }
extern "C" { void *malloc(size_t __size) throw() __attribute__((malloc))  __attribute__((no_throw)) ; }
extern "C" { void *calloc(size_t __nmemb,size_t __size) throw() __attribute__((malloc))  __attribute__((no_throw)) ; }
extern "C" { void *realloc(void *__ptr,size_t __size) throw() __attribute__((no_throw)) ; }
extern "C" { void free(void *__ptr) throw() __attribute__((no_throw)) ; }
extern "C" { void cfree(void *__ptr) throw() __attribute__((no_throw)) ; }
extern "C" {
extern "C" { void *alloca(size_t __size) throw() __attribute__((no_throw)) ; }
}
extern "C" { void *valloc(size_t __size) throw() __attribute__((malloc))  __attribute__((no_throw)) ; }
extern "C" { int posix_memalign(void **__memptr,size_t __alignment,size_t __size) throw() __attribute__((no_throw)) ; }
extern "C" { void *aligned_alloc(size_t __alignment,size_t __size) throw() __attribute__((malloc))  __attribute__((no_throw)) ; }
extern "C" { void abort() throw() __attribute__((no_throw))  __attribute__((noreturn)); }
extern "C" { int atexit(void (*__func)()) throw() __attribute__((no_throw)) ; }
extern int at_quick_exit(void (*__func)()) throw() __asm__ ("at_quick_exit") __attribute__((no_throw)) ;
extern "C" { int on_exit(void (*__func)(int , void *),void *__arg) throw() __attribute__((no_throw)) ; }
extern "C" { void exit(int __status) throw() __attribute__((no_throw))  __attribute__((noreturn)); }
extern "C" { void quick_exit(int __status) throw() __attribute__((no_throw))  __attribute__((noreturn)); }
extern "C" { void _Exit(int __status) throw() __attribute__((no_throw))  __attribute__((noreturn)); }
extern "C" { char *getenv(const char *__name) throw() __attribute__((no_throw)) ; }
extern "C" { char *secure_getenv(const char *__name) throw() __attribute__((no_throw)) ; }
extern "C" { int putenv(char *__string) throw() __attribute__((no_throw)) ; }
extern "C" { int setenv(const char *__name,const char *__value,int __replace) throw() __attribute__((no_throw)) ; }
extern "C" { int unsetenv(const char *__name) throw() __attribute__((no_throw)) ; }
extern "C" { int clearenv() throw() __attribute__((no_throw)) ; }
extern "C" { char *mktemp(char *__template) throw() __attribute__((no_throw)) ; }
extern "C" { int mkstemp(char *__template); }
extern "C" { int mkstemp64(char *__template); }
extern "C" { int mkstemps(char *__template,int __suffixlen); }
extern "C" { int mkstemps64(char *__template,int __suffixlen); }
extern "C" { char *mkdtemp(char *__template) throw() __attribute__((no_throw)) ; }
extern "C" { int mkostemp(char *__template,int __flags); }
extern "C" { int mkostemp64(char *__template,int __flags); }
extern "C" { int mkostemps(char *__template,int __suffixlen,int __flags); }
extern "C" { int mkostemps64(char *__template,int __suffixlen,int __flags); }
extern "C" { int system(const char *__command); }
extern "C" { char *canonicalize_file_name(const char *__name) throw() __attribute__((no_throw)) ; }
extern "C" { char *realpath(const char *__name,char *__resolved) throw() __attribute__((no_throw)) ; }
typedef int (*__compar_fn_t)(const void *, const void *);
typedef __compar_fn_t comparison_fn_t;
typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
extern "C" { void *bsearch(const void *__key,const void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar); }
extern "C" { void qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar); }
extern "C" { void qsort_r(void *__base,size_t __nmemb,size_t __size,__compar_d_fn_t __compar,void *__arg); }
extern "C" { int abs(int __x) throw() __attribute__((no_throw)) ; }
extern "C" { long labs(long __x) throw() __attribute__((no_throw)) ; }
extern "C" { long long llabs(long long __x) throw() __attribute__((no_throw)) ; }
extern "C" { div_t div(int __numer,int __denom) throw() __attribute__((no_throw)) ; }
extern "C" { ldiv_t ldiv(long __numer,long __denom) throw() __attribute__((no_throw)) ; }
extern "C" { lldiv_t lldiv(long long __numer,long long __denom) throw() __attribute__((no_throw)) ; }
extern "C" { char *ecvt(double __value,int __ndigit,int *__decpt,int *__sign) throw() __attribute__((no_throw)) ; }
extern "C" { char *fcvt(double __value,int __ndigit,int *__decpt,int *__sign) throw() __attribute__((no_throw)) ; }
extern "C" { char *gcvt(double __value,int __ndigit,char *__buf) throw() __attribute__((no_throw)) ; }
extern "C" { char *qecvt(long double __value,int __ndigit,int *__decpt,int *__sign) throw() __attribute__((no_throw)) ; }
extern "C" { char *qfcvt(long double __value,int __ndigit,int *__decpt,int *__sign) throw() __attribute__((no_throw)) ; }
extern "C" { char *qgcvt(long double __value,int __ndigit,char *__buf) throw() __attribute__((no_throw)) ; }
extern "C" { int ecvt_r(double __value,int __ndigit,int *__decpt,int *__sign,char *__buf,size_t __len) throw() __attribute__((no_throw)) ; }
extern "C" { int fcvt_r(double __value,int __ndigit,int *__decpt,int *__sign,char *__buf,size_t __len) throw() __attribute__((no_throw)) ; }
extern "C" { int qecvt_r(long double __value,int __ndigit,int *__decpt,int *__sign,char *__buf,size_t __len) throw() __attribute__((no_throw)) ; }
extern "C" { int qfcvt_r(long double __value,int __ndigit,int *__decpt,int *__sign,char *__buf,size_t __len) throw() __attribute__((no_throw)) ; }
extern "C" { int mblen(const char *__s,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { int mbtowc(wchar_t *__pwc,const char *__s,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { int wctomb(char *__s,wchar_t __wchar) throw() __attribute__((no_throw)) ; }
extern "C" { size_t mbstowcs(wchar_t *__pwcs,const char *__s,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { size_t wcstombs(char *__s,const wchar_t *__pwcs,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { int rpmatch(const char *__response) throw() __attribute__((no_throw)) ; }
extern "C" { int getsubopt(char **__optionp,char *const *__tokens,char **__valuep) throw() __attribute__((no_throw)) ; }
extern "C" { void setkey(const char *__key) throw() __attribute__((no_throw)) ; }
extern "C" { int posix_openpt(int __oflag); }
extern "C" { int grantpt(int __fd) throw() __attribute__((no_throw)) ; }
extern "C" { int unlockpt(int __fd) throw() __attribute__((no_throw)) ; }
extern "C" { char *ptsname(int __fd) throw() __attribute__((no_throw)) ; }
extern "C" { int ptsname_r(int __fd,char *__buf,size_t __buflen) throw() __attribute__((no_throw)) ; }
extern "C" { int getpt(); }
extern "C" { int getloadavg(double __loadavg[],int __nelem) throw() __attribute__((no_throw)) ; }

inline double  __attribute__((pure))  __attribute__((no_throw)) atof(const char *__nptr) throw()
{
return strtod(__nptr,(char **)0L);
}
}
extern "C++"
{
namespace std
{
using ::div_t;
using ::ldiv_t;
using ::abort;
using ::abs;
using ::atexit;
using ::at_quick_exit;
using ::atof;
using ::atoi;
using ::atol;
using ::bsearch;
using ::calloc;
using ::div;
using ::exit;
using ::free;
using ::getenv;
using ::labs;
using ::ldiv;
using ::malloc;
using ::mblen;
using ::mbstowcs;
using ::mbtowc;
using ::qsort;
using ::quick_exit;
using ::rand;
using ::realloc;
using ::srand;
using ::strtod;
using ::strtol;
using ::strtoul;
using ::system;
using ::wcstombs;
using ::wctomb;

inline long  __attribute__((visibility("default"))) abs(long __i)
{
return __builtin_labs(__i);
}

inline ldiv_t  __attribute__((visibility("default"))) div(long __i,long __j)
{
return ldiv(__i,__j);
}

inline long long  __attribute__((visibility("default"))) abs(long long __x)
{
return __builtin_llabs(__x);
}
}
namespace __gnu_cxx
{
using ::lldiv_t;
using ::_Exit;
using ::llabs;

inline lldiv_t  __attribute__((visibility("default"))) div(long long __n,long long __d)
{
lldiv_t __q;
__q . quot = __n / __d;
__q . rem = __n % __d;
return __q;
}
using ::lldiv;
using ::atoll;
using ::strtoll;
using ::strtoull;
using ::strtof;
using ::strtold;
}
namespace std
{
using ::lldiv_t;
using ::_Exit;
using ::llabs;
using __gnu_cxx::div;
using ::lldiv;
using ::atoll;
using ::strtof;
using ::strtoll;
using ::strtoull;
using ::strtold;
}
}
extern "C" {
extern "C" { void *memcpy(void *__dest,const void *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { void *memmove(void *__dest,const void *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { void *memccpy(void *__dest,const void *__src,int __c,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { void *memset(void *__s,int __c,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { int memcmp(const void *__s1,const void *__s2,size_t __n) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C++"
{
inline void *memchr(void *__s,int __c,size_t __n) throw() __asm__ ("memchr") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;
inline const void *memchr(const void *__s,int __c,size_t __n) throw() __asm__ ("memchr") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;

inline void * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) memchr(void *__s,int __c,size_t __n) throw()
{
return __builtin_memchr(__s,__c,__n);
}

inline const void * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) memchr(const void *__s,int __c,size_t __n) throw()
{
return (__builtin_memchr(__s,__c,__n));
}
}
extern void *rawmemchr(void *__s,int __c) throw() __asm__ ("rawmemchr") __attribute__((pure))  __attribute__((no_throw)) ;
extern const void *rawmemchr(const void *__s,int __c) throw() __asm__ ("rawmemchr") __attribute__((pure))  __attribute__((no_throw)) ;
extern void *memrchr(void *__s,int __c,size_t __n) throw() __asm__ ("memrchr") __attribute__((pure))  __attribute__((no_throw)) ;
extern const void *memrchr(const void *__s,int __c,size_t __n) throw() __asm__ ("memrchr") __attribute__((pure))  __attribute__((no_throw)) ;
extern "C" { char *strcpy(char *__dest,const char *__src) throw() __attribute__((no_throw)) ; }
extern "C" { char *strncpy(char *__dest,const char *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { char *strcat(char *__dest,const char *__src) throw() __attribute__((no_throw)) ; }
extern "C" { char *strncat(char *__dest,const char *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { int strcmp(const char *__s1,const char *__s2) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { int strncmp(const char *__s1,const char *__s2,size_t __n) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { int strcoll(const char *__s1,const char *__s2) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { size_t strxfrm(char *__dest,const char *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { int strcoll_l(const char *__s1,const char *__s2,__locale_t __l) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { size_t strxfrm_l(char *__dest,const char *__src,size_t __n,__locale_t __l) throw() __attribute__((no_throw)) ; }
extern "C" { char *strdup(const char *__s) throw() __attribute__((malloc))  __attribute__((no_throw)) ; }
extern "C" { char *strndup(const char *__string,size_t __n) throw() __attribute__((malloc))  __attribute__((no_throw)) ; }
extern "C++"
{
inline char *strchr(char *__s,int __c) throw() __asm__ ("strchr") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;
inline const char *strchr(const char *__s,int __c) throw() __asm__ ("strchr") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;

inline char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) strchr(char *__s,int __c) throw()
{
return __builtin_strchr(__s,__c);
}

inline const char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) strchr(const char *__s,int __c) throw()
{
return (__builtin_strchr(__s,__c));
}
}
extern "C++"
{
inline char *strrchr(char *__s,int __c) throw() __asm__ ("strrchr") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;
inline const char *strrchr(const char *__s,int __c) throw() __asm__ ("strrchr") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;

inline char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) strrchr(char *__s,int __c) throw()
{
return __builtin_strrchr(__s,__c);
}

inline const char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) strrchr(const char *__s,int __c) throw()
{
return (__builtin_strrchr(__s,__c));
}
}
extern char *strchrnul(char *__s,int __c) throw() __asm__ ("strchrnul") __attribute__((pure))  __attribute__((no_throw)) ;
extern const char *strchrnul(const char *__s,int __c) throw() __asm__ ("strchrnul") __attribute__((pure))  __attribute__((no_throw)) ;
extern "C" { size_t strcspn(const char *__s,const char *__reject) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { size_t strspn(const char *__s,const char *__accept) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C++"
{
inline char *strpbrk(char *__s,const char *__accept) throw() __asm__ ("strpbrk") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;
inline const char *strpbrk(const char *__s,const char *__accept) throw() __asm__ ("strpbrk") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;

inline char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) strpbrk(char *__s,const char *__accept) throw()
{
return __builtin_strpbrk(__s,__accept);
}

inline const char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) strpbrk(const char *__s,const char *__accept) throw()
{
return (__builtin_strpbrk(__s,__accept));
}
}
extern "C++"
{
inline char *strstr(char *__haystack,const char *__needle) throw() __asm__ ("strstr") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;
inline const char *strstr(const char *__haystack,const char *__needle) throw() __asm__ ("strstr") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;

inline char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) strstr(char *__haystack,const char *__needle) throw()
{
return __builtin_strstr(__haystack,__needle);
}

inline const char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) strstr(const char *__haystack,const char *__needle) throw()
{
return (__builtin_strstr(__haystack,__needle));
}
}
extern "C" { char *strtok(char *__s,const char *__delim) throw() __attribute__((no_throw)) ; }
extern "C" { char *__strtok_r(char *__s,const char *__delim,char **__save_ptr) throw() __attribute__((no_throw)) ; }
extern "C" { char *strtok_r(char *__s,const char *__delim,char **__save_ptr) throw() __attribute__((no_throw)) ; }
extern char *strcasestr(char *__haystack,const char *__needle) throw() __asm__ ("strcasestr") __attribute__((pure))  __attribute__((no_throw)) ;
extern const char *strcasestr(const char *__haystack,const char *__needle) throw() __asm__ ("strcasestr") __attribute__((pure))  __attribute__((no_throw)) ;
extern "C" { void *memmem(const void *__haystack,size_t __haystacklen,const void *__needle,size_t __needlelen) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { void *__mempcpy(void *__dest,const void *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { void *mempcpy(void *__dest,const void *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { size_t strlen(const char *__s) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { size_t strnlen(const char *__string,size_t __maxlen) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { char *strerror(int __errnum) throw() __attribute__((no_throw)) ; }
extern "C" { char *strerror_r(int __errnum,char *__buf,size_t __buflen) throw() __attribute__((no_throw)) ; }
extern "C" { char *strerror_l(int __errnum,__locale_t __l) throw() __attribute__((no_throw)) ; }
extern "C" { void __bzero(void *__s,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { void bcopy(const void *__src,void *__dest,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { void bzero(void *__s,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { int bcmp(const void *__s1,const void *__s2,size_t __n) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C++"
{
inline char *index(char *__s,int __c) throw() __asm__ ("index") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;
inline const char *index(const char *__s,int __c) throw() __asm__ ("index") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;

inline char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) index(char *__s,int __c) throw()
{
return __builtin_index(__s,__c);
}

inline const char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) index(const char *__s,int __c) throw()
{
return (__builtin_index(__s,__c));
}
}
extern "C++"
{
inline char *rindex(char *__s,int __c) throw() __asm__ ("rindex") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;
inline const char *rindex(const char *__s,int __c) throw() __asm__ ("rindex") __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) ;

inline char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) rindex(char *__s,int __c) throw()
{
return __builtin_rindex(__s,__c);
}

inline const char * __attribute__((pure))  __attribute__((always_inline))  __attribute__((no_throw)) rindex(const char *__s,int __c) throw()
{
return (__builtin_rindex(__s,__c));
}
}
extern "C" { int ffs(int __i) throw() __attribute__((no_throw)) ; }
extern "C" { int ffsl(long __l) throw() __attribute__((no_throw)) ; }
extern "C" { int ffsll(long long __ll) throw() __attribute__((no_throw)) ; }
extern "C" { int strcasecmp(const char *__s1,const char *__s2) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { int strncasecmp(const char *__s1,const char *__s2,size_t __n) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { int strcasecmp_l(const char *__s1,const char *__s2,__locale_t __loc) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { int strncasecmp_l(const char *__s1,const char *__s2,size_t __n,__locale_t __loc) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { char *strsep(char **__stringp,const char *__delim) throw() __attribute__((no_throw)) ; }
extern "C" { char *strsignal(int __sig) throw() __attribute__((no_throw)) ; }
extern "C" { char *__stpcpy(char *__dest,const char *__src) throw() __attribute__((no_throw)) ; }
extern "C" { char *stpcpy(char *__dest,const char *__src) throw() __attribute__((no_throw)) ; }
extern "C" { char *__stpncpy(char *__dest,const char *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { char *stpncpy(char *__dest,const char *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { int strverscmp(const char *__s1,const char *__s2) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { char *strfry(char *__string) throw() __attribute__((no_throw)) ; }
extern "C" { void *memfrob(void *__s,size_t __n) throw() __attribute__((no_throw)) ; }
extern char *basename(char *__filename) throw() __asm__ ("basename") __attribute__((no_throw)) ;
extern const char *basename(const char *__filename) throw() __asm__ ("basename") __attribute__((no_throw)) ;
}
namespace std
{
using ::memchr;
using ::memcmp;
using ::memcpy;
using ::memmove;
using ::memset;
using ::strcat;
using ::strcmp;
using ::strcoll;
using ::strcpy;
using ::strcspn;
using ::strerror;
using ::strlen;
using ::strncat;
using ::strncmp;
using ::strncpy;
using ::strspn;
using ::strtok;
using ::strxfrm;
using ::strchr;
using ::strpbrk;
using ::strrchr;
using ::strstr;
}
namespace std
{
template < typename >
    class allocator;
extern "C" {
}
extern "C++" {
}
extern "C++" {
}
extern "C++" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
extern "C" {
}
}
extern "C" {
}
extern "C++" {
}
template<> class allocator< void  > ;
template<> class allocator< void  > ;
template < typename, typename >
    struct uses_allocator;
}
namespace std
{
template < class _CharT >
    struct char_traits;
template<> struct char_traits< char  > ;
template<> struct char_traits< char  > ;
template<> struct char_traits< wchar_t  > ;
template<> struct char_traits< wchar_t  > ;
template<> struct char_traits< char16_t  > ;
template<> struct char_traits< char16_t  > ;
template<> struct char_traits< char32_t  > ;
template<> struct char_traits< char32_t  > ;
namespace __cxx11
{
template < typename _CharT, typename _Traits = char_traits < _CharT >,
           typename _Alloc = allocator < _CharT > >
    class basic_string;
typedef class basic_string< char  , char_traits< char  >  , allocator< char  >  > string;
typedef class basic_string< wchar_t  , char_traits< wchar_t  >  , allocator< wchar_t  >  > wstring;
typedef class basic_string< char16_t  , char_traits< char16_t  >  , allocator< char16_t  >  > u16string;
typedef class basic_string< char32_t  , char_traits< char32_t  >  , allocator< char32_t  >  > u32string;
}
}
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
typedef struct _IO_FILE __FILE;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned int wint_t;
typedef struct {
int __count;
union {
unsigned int __wch;
char __wchb[4];}__value;}__mbstate_t;
typedef __mbstate_t mbstate_t;
struct tm ;
extern "C" { wchar_t *wcscpy(wchar_t *__dest,const wchar_t *__src) throw() __attribute__((no_throw)) ; }
extern "C" { wchar_t *wcsncpy(wchar_t *__dest,const wchar_t *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { wchar_t *wcscat(wchar_t *__dest,const wchar_t *__src) throw() __attribute__((no_throw)) ; }
extern "C" { wchar_t *wcsncat(wchar_t *__dest,const wchar_t *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { int wcscmp(const wchar_t *__s1,const wchar_t *__s2) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { int wcsncmp(const wchar_t *__s1,const wchar_t *__s2,size_t __n) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { int wcscasecmp(const wchar_t *__s1,const wchar_t *__s2) throw() __attribute__((no_throw)) ; }
extern "C" { int wcsncasecmp(const wchar_t *__s1,const wchar_t *__s2,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { int wcscasecmp_l(const wchar_t *__s1,const wchar_t *__s2,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { int wcsncasecmp_l(const wchar_t *__s1,const wchar_t *__s2,size_t __n,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { int wcscoll(const wchar_t *__s1,const wchar_t *__s2) throw() __attribute__((no_throw)) ; }
extern "C" { size_t wcsxfrm(wchar_t *__s1,const wchar_t *__s2,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { int wcscoll_l(const wchar_t *__s1,const wchar_t *__s2,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { size_t wcsxfrm_l(wchar_t *__s1,const wchar_t *__s2,size_t __n,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { wchar_t *wcsdup(const wchar_t *__s) throw() __attribute__((malloc))  __attribute__((no_throw)) ; }
extern wchar_t *wcschr(wchar_t *__wcs,wchar_t __wc) throw() __asm__ ("wcschr") __attribute__((pure))  __attribute__((no_throw)) ;
extern const wchar_t *wcschr(const wchar_t *__wcs,wchar_t __wc) throw() __asm__ ("wcschr") __attribute__((pure))  __attribute__((no_throw)) ;
extern wchar_t *wcsrchr(wchar_t *__wcs,wchar_t __wc) throw() __asm__ ("wcsrchr") __attribute__((pure))  __attribute__((no_throw)) ;
extern const wchar_t *wcsrchr(const wchar_t *__wcs,wchar_t __wc) throw() __asm__ ("wcsrchr") __attribute__((pure))  __attribute__((no_throw)) ;
extern "C" { wchar_t *wcschrnul(const wchar_t *__s,wchar_t __wc) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { size_t wcscspn(const wchar_t *__wcs,const wchar_t *__reject) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { size_t wcsspn(const wchar_t *__wcs,const wchar_t *__accept) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern wchar_t *wcspbrk(wchar_t *__wcs,const wchar_t *__accept) throw() __asm__ ("wcspbrk") __attribute__((pure))  __attribute__((no_throw)) ;
extern const wchar_t *wcspbrk(const wchar_t *__wcs,const wchar_t *__accept) throw() __asm__ ("wcspbrk") __attribute__((pure))  __attribute__((no_throw)) ;
extern wchar_t *wcsstr(wchar_t *__haystack,const wchar_t *__needle) throw() __asm__ ("wcsstr") __attribute__((pure))  __attribute__((no_throw)) ;
extern const wchar_t *wcsstr(const wchar_t *__haystack,const wchar_t *__needle) throw() __asm__ ("wcsstr") __attribute__((pure))  __attribute__((no_throw)) ;
extern "C" { wchar_t *wcstok(wchar_t *__s,const wchar_t *__delim,wchar_t **__ptr) throw() __attribute__((no_throw)) ; }
extern "C" { size_t wcslen(const wchar_t *__s) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern wchar_t *wcswcs(wchar_t *__haystack,const wchar_t *__needle) throw() __asm__ ("wcswcs") __attribute__((pure))  __attribute__((no_throw)) ;
extern const wchar_t *wcswcs(const wchar_t *__haystack,const wchar_t *__needle) throw() __asm__ ("wcswcs") __attribute__((pure))  __attribute__((no_throw)) ;
extern "C" { size_t wcsnlen(const wchar_t *__s,size_t __maxlen) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern wchar_t *wmemchr(wchar_t *__s,wchar_t __c,size_t __n) throw() __asm__ ("wmemchr") __attribute__((pure))  __attribute__((no_throw)) ;
extern const wchar_t *wmemchr(const wchar_t *__s,wchar_t __c,size_t __n) throw() __asm__ ("wmemchr") __attribute__((pure))  __attribute__((no_throw)) ;
extern "C" { int wmemcmp(const wchar_t *__s1,const wchar_t *__s2,size_t __n) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { wchar_t *wmemcpy(wchar_t *__s1,const wchar_t *__s2,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { wchar_t *wmemmove(wchar_t *__s1,const wchar_t *__s2,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { wchar_t *wmemset(wchar_t *__s,wchar_t __c,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { wchar_t *wmempcpy(wchar_t *__s1,const wchar_t *__s2,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { inline wint_t btowc(int __c) throw() __attribute__((no_throw)) ; }
extern "C" { inline int wctob(wint_t __c) throw() __attribute__((no_throw)) ; }
extern "C" { int mbsinit(const mbstate_t *__ps) throw() __attribute__((pure))  __attribute__((no_throw)) ; }
extern "C" { size_t mbrtowc(wchar_t *__pwc,const char *__s,size_t __n,mbstate_t *__p) throw() __attribute__((no_throw)) ; }
extern "C" { size_t wcrtomb(char *__s,wchar_t __wc,mbstate_t *__ps) throw() __attribute__((no_throw)) ; }
extern "C" { size_t __mbrlen(const char *__s,size_t __n,mbstate_t *__ps) throw() __attribute__((no_throw)) ; }
extern "C" { inline size_t mbrlen(const char *__s,size_t __n,mbstate_t *__ps) throw() __attribute__((no_throw)) ; }
extern "C" { wint_t __btowc_alias(int __c) __asm__ ("btowc"); }

inline wint_t  __attribute__((no_throw)) btowc(int __c) throw()
{
return (__builtin_constant_p(__c)) && __c >= '\0' && __c <= '\x7f'?((wint_t )__c) : __btowc_alias(__c);
}
extern "C" { int __wctob_alias(wint_t __c) __asm__ ("wctob"); }

inline int  __attribute__((no_throw)) wctob(wint_t __wc) throw()
{
return (__builtin_constant_p(__wc)) && __wc >= L'\0' && __wc <= L'\x7f'?((int )__wc) : __wctob_alias(__wc);
}

inline size_t  __attribute__((no_throw)) mbrlen(const char *__s,size_t __n,mbstate_t *__ps) throw()
{
return __ps != 0L?mbrtowc(0L,__s,__n,__ps) : __mbrlen(__s,__n,0L);
}
extern "C" { size_t mbsrtowcs(wchar_t *__dst,const char **__src,size_t __len,mbstate_t *__ps) throw() __attribute__((no_throw)) ; }
extern "C" { size_t wcsrtombs(char *__dst,const wchar_t **__src,size_t __len,mbstate_t *__ps) throw() __attribute__((no_throw)) ; }
extern "C" { size_t mbsnrtowcs(wchar_t *__dst,const char **__src,size_t __nmc,size_t __len,mbstate_t *__ps) throw() __attribute__((no_throw)) ; }
extern "C" { size_t wcsnrtombs(char *__dst,const wchar_t **__src,size_t __nwc,size_t __len,mbstate_t *__ps) throw() __attribute__((no_throw)) ; }
extern "C" { int wcwidth(wchar_t __c) throw() __attribute__((no_throw)) ; }
extern "C" { int wcswidth(const wchar_t *__s,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { double wcstod(const wchar_t *__nptr,wchar_t **__endptr) throw() __attribute__((no_throw)) ; }
extern "C" { float wcstof(const wchar_t *__nptr,wchar_t **__endptr) throw() __attribute__((no_throw)) ; }
extern "C" { long double wcstold(const wchar_t *__nptr,wchar_t **__endptr) throw() __attribute__((no_throw)) ; }
extern "C" { long wcstol(const wchar_t *__nptr,wchar_t **__endptr,int __base) throw() __attribute__((no_throw)) ; }
extern "C" { unsigned long wcstoul(const wchar_t *__nptr,wchar_t **__endptr,int __base) throw() __attribute__((no_throw)) ; }
extern "C" { long long wcstoll(const wchar_t *__nptr,wchar_t **__endptr,int __base) throw() __attribute__((no_throw)) ; }
extern "C" { unsigned long long wcstoull(const wchar_t *__nptr,wchar_t **__endptr,int __base) throw() __attribute__((no_throw)) ; }
extern "C" { long long wcstoq(const wchar_t *__nptr,wchar_t **__endptr,int __base) throw() __attribute__((no_throw)) ; }
extern "C" { unsigned long long wcstouq(const wchar_t *__nptr,wchar_t **__endptr,int __base) throw() __attribute__((no_throw)) ; }
extern "C" { long wcstol_l(const wchar_t *__nptr,wchar_t **__endptr,int __base,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { unsigned long wcstoul_l(const wchar_t *__nptr,wchar_t **__endptr,int __base,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { long long wcstoll_l(const wchar_t *__nptr,wchar_t **__endptr,int __base,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { unsigned long long wcstoull_l(const wchar_t *__nptr,wchar_t **__endptr,int __base,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { double wcstod_l(const wchar_t *__nptr,wchar_t **__endptr,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { float wcstof_l(const wchar_t *__nptr,wchar_t **__endptr,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { long double wcstold_l(const wchar_t *__nptr,wchar_t **__endptr,__locale_t __loc) throw() __attribute__((no_throw)) ; }
extern "C" { wchar_t *wcpcpy(wchar_t *__dest,const wchar_t *__src) throw() __attribute__((no_throw)) ; }
extern "C" { wchar_t *wcpncpy(wchar_t *__dest,const wchar_t *__src,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { __FILE *open_wmemstream(wchar_t **__bufloc,size_t *__sizeloc) throw() __attribute__((no_throw)) ; }
extern "C" { int fwide(__FILE *__fp,int __mode) throw() __attribute__((no_throw)) ; }
extern "C" { int fwprintf(__FILE *__stream,const wchar_t *__format,... ); }
extern "C" { int wprintf(const wchar_t *__format,... ); }
extern "C" { int swprintf(wchar_t *__s,size_t __n,const wchar_t *__format,... ) throw() __attribute__((no_throw)) ; }
extern "C" { int vfwprintf(__FILE *__s,const wchar_t *__format,__gnuc_va_list __arg); }
extern "C" { int vwprintf(const wchar_t *__format,__gnuc_va_list __arg); }
extern "C" { int vswprintf(wchar_t *__s,size_t __n,const wchar_t *__format,__gnuc_va_list __arg) throw() __attribute__((no_throw)) ; }
extern "C" { int fwscanf(__FILE *__stream,const wchar_t *__format,... ); }
extern "C" { int wscanf(const wchar_t *__format,... ); }
extern "C" { int swscanf(const wchar_t *__s,const wchar_t *__format,... ) throw() __attribute__((no_throw)) ; }
extern "C" { int vfwscanf(__FILE *__s,const wchar_t *__format,__gnuc_va_list __arg); }
extern "C" { int vwscanf(const wchar_t *__format,__gnuc_va_list __arg); }
extern "C" { int vswscanf(const wchar_t *__s,const wchar_t *__format,__gnuc_va_list __arg) throw() __attribute__((no_throw)) ; }
extern "C" { wint_t fgetwc(__FILE *__stream); }
extern "C" { wint_t getwc(__FILE *__stream); }
extern "C" { wint_t getwchar(); }
extern "C" { wint_t fputwc(wchar_t __wc,__FILE *__stream); }
extern "C" { wint_t putwc(wchar_t __wc,__FILE *__stream); }
extern "C" { wint_t putwchar(wchar_t __wc); }
extern "C" { wchar_t *fgetws(wchar_t *__ws,int __n,__FILE *__stream); }
extern "C" { int fputws(const wchar_t *__ws,__FILE *__stream); }
extern "C" { wint_t ungetwc(wint_t __wc,__FILE *__stream); }
extern "C" { wint_t getwc_unlocked(__FILE *__stream); }
extern "C" { wint_t getwchar_unlocked(); }
extern "C" { wint_t fgetwc_unlocked(__FILE *__stream); }
extern "C" { wint_t fputwc_unlocked(wchar_t __wc,__FILE *__stream); }
extern "C" { wint_t putwc_unlocked(wchar_t __wc,__FILE *__stream); }
extern "C" { wint_t putwchar_unlocked(wchar_t __wc); }
extern "C" { wchar_t *fgetws_unlocked(wchar_t *__ws,int __n,__FILE *__stream); }
extern "C" { int fputws_unlocked(const wchar_t *__ws,__FILE *__stream); }
extern "C" { size_t wcsftime(wchar_t *__s,size_t __maxsize,const wchar_t *__format,const struct tm *__tp) throw() __attribute__((no_throw)) ; }
extern "C" { size_t wcsftime_l(wchar_t *__s,size_t __maxsize,const wchar_t *__format,const struct tm *__tp,__locale_t __loc) throw() __attribute__((no_throw)) ; }
namespace std
{
using ::mbstate_t;
}
namespace std
{
using ::wint_t;
using ::btowc;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::fwprintf;
using ::fwscanf;
using ::getwc;
using ::getwchar;
using ::mbrlen;
using ::mbrtowc;
using ::mbsinit;
using ::mbsrtowcs;
using ::putwc;
using ::putwchar;
using ::swprintf;
using ::swscanf;
using ::ungetwc;
using ::vfwprintf;
using ::vfwscanf;
using ::vswprintf;
using ::vswscanf;
using ::vwprintf;
using ::vwscanf;
using ::wcrtomb;
using ::wcscat;
using ::wcscmp;
using ::wcscoll;
using ::wcscpy;
using ::wcscspn;
using ::wcsftime;
using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcsrtombs;
using ::wcsspn;
using ::wcstod;
using ::wcstof;
using ::wcstok;
using ::wcstol;
using ::wcstoul;
using ::wcsxfrm;
using ::wctob;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wprintf;
using ::wscanf;
using ::wcschr;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsstr;
using ::wmemchr;
}
namespace __gnu_cxx
{
using ::wcstold;
using ::wcstoll;
using ::wcstoull;
}
namespace std
{
using ::wcstold;
using ::wcstoll;
using ::wcstoull;
}
namespace std
{
}
namespace std
{
typedef long streamoff;
typedef ptrdiff_t streamsize;
template < typename _StateT >
    class fpos
    {
    private :
      streamoff _M_off;
      _StateT _M_state;
    public :
      fpos ( )
      ;
      fpos ( streamoff __off )
      ;
      operator streamoff ( ) const;
      void
      state ( _StateT __st )
      ;
      _StateT
      state ( ) const
      ;
      fpos &
      operator += ( streamoff __off )
      ;
      fpos &
      operator -= ( streamoff __off )
      ;
      fpos
      operator + ( streamoff __off ) const
      ;
      fpos
      operator - ( streamoff __off ) const
      ;
      streamoff
      operator - ( const fpos & __other ) const
      ;
    };
template < typename _StateT >
    inline bool
    operator == ( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs )
    { return streamoff ( __lhs ) == streamoff ( __rhs ); }
template < typename _StateT >
    inline bool
    operator != ( const fpos < _StateT > & __lhs, const fpos < _StateT > & __rhs )
    { return streamoff ( __lhs ) != streamoff ( __rhs ); }
typedef class fpos< mbstate_t  > streampos;
typedef class fpos< mbstate_t  > wstreampos;
typedef class fpos< mbstate_t  > u16streampos;
typedef class fpos< mbstate_t  > u32streampos;
}
namespace std
{
class ios_base ;
template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_ios;
template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_streambuf;
template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_istream;
template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_ostream;
template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_iostream;
namespace __cxx11
{
template < typename _CharT, typename _Traits = char_traits < _CharT >,
     typename _Alloc = allocator < _CharT > >
    class basic_stringbuf;
template < typename _CharT, typename _Traits = char_traits < _CharT >,
    typename _Alloc = allocator < _CharT > >
    class basic_istringstream;
template < typename _CharT, typename _Traits = char_traits < _CharT >,
    typename _Alloc = allocator < _CharT > >
    class basic_ostringstream;
template < typename _CharT, typename _Traits = char_traits < _CharT >,
    typename _Alloc = allocator < _CharT > >
    class basic_stringstream;
}
template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_filebuf;
template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_ifstream;
template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_ofstream;
template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_fstream;
template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class istreambuf_iterator;
template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class ostreambuf_iterator;
typedef class basic_ios< char  , char_traits< char  >  > ios;
typedef class basic_streambuf< char  , char_traits< char  >  > streambuf;
typedef class basic_istream< char  , char_traits< char  >  > istream;
typedef class basic_ostream< char  , char_traits< char  >  > ostream;
typedef class basic_iostream< char  , char_traits< char  >  > iostream;
typedef class __cxx11::basic_stringbuf< char  , char_traits< char  >  , class std::allocator< char  >  > stringbuf;
typedef class __cxx11::basic_istringstream< char  , char_traits< char  >  , class std::allocator< char  >  > istringstream;
typedef class __cxx11::basic_ostringstream< char  , char_traits< char  >  , class std::allocator< char  >  > ostringstream;
typedef class __cxx11::basic_stringstream< char  , char_traits< char  >  , class std::allocator< char  >  > stringstream;
typedef class basic_filebuf< char  , char_traits< char  >  > filebuf;
typedef class basic_ifstream< char  , char_traits< char  >  > ifstream;
typedef class basic_ofstream< char  , char_traits< char  >  > ofstream;
typedef class basic_fstream< char  , char_traits< char  >  > fstream;
typedef class basic_ios< wchar_t  , char_traits< wchar_t  >  > wios;
typedef class basic_streambuf< wchar_t  , char_traits< wchar_t  >  > wstreambuf;
typedef class basic_istream< wchar_t  , char_traits< wchar_t  >  > wistream;
typedef class basic_ostream< wchar_t  , char_traits< wchar_t  >  > wostream;
typedef class basic_iostream< wchar_t  , char_traits< wchar_t  >  > wiostream;
typedef class __cxx11::basic_stringbuf< wchar_t  , char_traits< wchar_t  >  , class std::allocator< wchar_t  >  > wstringbuf;
typedef class __cxx11::basic_istringstream< wchar_t  , char_traits< wchar_t  >  , class std::allocator< wchar_t  >  > wistringstream;
typedef class __cxx11::basic_ostringstream< wchar_t  , char_traits< wchar_t  >  , class std::allocator< wchar_t  >  > wostringstream;
typedef class __cxx11::basic_stringstream< wchar_t  , char_traits< wchar_t  >  , class std::allocator< wchar_t  >  > wstringstream;
typedef class basic_filebuf< wchar_t  , char_traits< wchar_t  >  > wfilebuf;
typedef class basic_ifstream< wchar_t  , char_traits< wchar_t  >  > wifstream;
typedef class basic_ofstream< wchar_t  , char_traits< wchar_t  >  > wofstream;
typedef class basic_fstream< wchar_t  , char_traits< wchar_t  >  > wfstream;
}
#pragma GCC visibility push ( default )
namespace std
{

class exception 
{

public: inline exception()
{
}
virtual ~exception();
virtual const char *what() const;
}
;

class bad_exception : public exception
{

public: inline bad_exception()
{
}
virtual ~bad_exception();
virtual const char *what() const;
}
;
typedef void (*terminate_handler)();
typedef void (*unexpected_handler)();
extern terminate_handler set_terminate(terminate_handler ) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern terminate_handler get_terminate() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void terminate() __attribute__((no_throw))  __attribute__((visibility("default")))  __attribute__((noreturn));
extern unexpected_handler set_unexpected(unexpected_handler ) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern unexpected_handler get_unexpected() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void unexpected() __attribute__((visibility("default")))  __attribute__((noreturn));
extern bool uncaught_exception() __attribute__((pure))  __attribute__((no_throw))  __attribute__((visibility("default"))) ;
}
namespace __gnu_cxx
{
extern void __verbose_terminate_handler() __attribute__((visibility("default"))) ;
}
#pragma GCC visibility pop
#pragma GCC visibility push ( default )
namespace std
{
class type_info ;
namespace __exception_ptr
{
class exception_ptr ;
}
using std::__exception_ptr::exception_ptr;
extern class __exception_ptr::exception_ptr current_exception() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void rethrow_exception(class __exception_ptr::exception_ptr ) __attribute__((visibility("default")))  __attribute__((noreturn));
namespace __exception_ptr
{
using std::rethrow_exception;

class exception_ptr 
{
private: void *_M_exception_object;
explicit exception_ptr(void *__e);
void _M_addref();
void _M_release();
void *_M_get() const;
public: friend class exception_ptr current_exception() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
friend void rethrow_exception(class __exception_ptr::exception_ptr ) __attribute__((visibility("default")))  __attribute__((noreturn));
exception_ptr();
exception_ptr(const class exception_ptr &);

inline exception_ptr(nullptr_t ) : _M_exception_object(0)
{
}

inline exception_ptr(class exception_ptr &&__o) : _M_exception_object(__o . _M_exception_object)
{
__o . _M_exception_object = 0;
}
exception_ptr &operator=(const class exception_ptr &);

inline exception_ptr &operator=(class exception_ptr &&__o)
{
exception_ptr(((class exception_ptr &&)__o)) .  swap (( *(this)));
return  *(this);
}
~exception_ptr();
void swap(class exception_ptr &);

inline explicit operator bool() const
{
return ((this) -> _M_exception_object);
}
friend bool operator==(const class exception_ptr &,const class exception_ptr &) __attribute__((pure))  __attribute__((no_throw))  __attribute__((visibility("default"))) ;
const type_info *__cxa_exception_type() const;
}
;
extern bool operator==(const class exception_ptr &,const class exception_ptr &) __attribute__((pure))  __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern bool operator!=(const class exception_ptr &,const class exception_ptr &) __attribute__((pure))  __attribute__((no_throw))  __attribute__((visibility("default"))) ;

inline void  __attribute__((visibility("default"))) swap(class exception_ptr &__lhs,class exception_ptr &__rhs)
{
__lhs .  swap (__rhs);
}
}
template < typename _Ex >
    exception_ptr
    make_exception_ptr ( _Ex __ex ) noexcept
    {
      try
 {
   throw __ex;
 }
      catch ( ... )
 {
   return current_exception ( );
 }
    }
template < typename _Ex >
    exception_ptr
    copy_exception ( _Ex __ex ) noexcept __attribute__ ( ( __deprecated__ ) );
template < typename _Ex >
    exception_ptr
    copy_exception ( _Ex __ex ) noexcept
    { return std :: make_exception_ptr < _Ex > ( __ex ); }
}
#pragma GCC visibility pop
#pragma GCC visibility push ( default )
namespace std
{
template < typename _Tp >
    inline _Tp *
    __addressof ( _Tp & __r ) noexcept
    {
      return reinterpret_cast < _Tp * >
 ( & const_cast < char & > ( reinterpret_cast < const volatile char & > ( __r ) ) );
    }
}
namespace std
{
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
}
namespace std
{
template < typename _Tp, _Tp __v >
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant < _Tp, __v > type;
      constexpr operator value_type ( ) const;
      constexpr value_type operator ( ) ( ) const;
    };
template < typename _Tp, _Tp __v >
    constexpr _Tp integral_constant < _Tp, __v > :: value;
typedef struct integral_constant< bool  , true > true_type;
typedef struct integral_constant< bool  , false > false_type;
template < bool __v >
    using __bool_constant = integral_constant < bool, __v >;
template < bool, typename, typename >
    struct conditional;
template < typename ... >
    struct __or_;
template<> struct __or_<   > ;
template<> struct __or_<   > : public integral_constant< bool  , false > 
{
};
template < typename _B1 >
    struct __or_ < _B1 >
    : public _B1
    { };
template < typename _B1, typename _B2 >
    struct __or_ < _B1, _B2 >
    : public conditional < _B1 :: value, _B1, _B2 > :: type
    { };
template < typename _B1, typename _B2, typename _B3, typename ... _Bn >
    struct __or_ < _B1, _B2, _B3, _Bn ... >
    : public conditional < _B1 :: value, _B1, __or_ < _B2, _B3, _Bn ... >> :: type
    { };
template < typename ... >
    struct __and_;
template<> struct __and_<   > ;
template<> struct __and_<   > : public integral_constant< bool  , true > 
{
};
template < typename _B1 >
    struct __and_ < _B1 >
    : public _B1
    { };
template < typename _B1, typename _B2 >
    struct __and_ < _B1, _B2 >
    : public conditional < _B1 :: value, _B2, _B1 > :: type
    { };
template < typename _B1, typename _B2, typename _B3, typename ... _Bn >
    struct __and_ < _B1, _B2, _B3, _Bn ... >
    : public conditional < _B1 :: value, __and_ < _B2, _B3, _Bn ... >, _B1 > :: type
    { };
template < typename _Pp >
    struct __not_
    : public integral_constant < bool, ! _Pp :: value >
    { };
template < typename _Tp >
    struct __success_type
    { typedef _Tp type; };

struct __failure_type 
{
}
;
template < typename >
    struct remove_cv;
template < typename >
    struct __is_void_helper
    : public false_type { };
template<> struct __is_void_helper< void  > : public integral_constant< bool  , true > 
{
};
template < typename _Tp >
    struct is_void
    : public __is_void_helper < typename remove_cv < _Tp > :: type > :: type
    { };
template < typename >
    struct __is_integral_helper
    : public false_type { };
template<> struct __is_integral_helper< bool  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< char  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< signed char  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< unsigned char  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< wchar_t  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< char16_t  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< char32_t  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< short  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< unsigned short  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< int  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< unsigned int  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< long  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< unsigned long  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< long long  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_integral_helper< unsigned long long  > : public integral_constant< bool  , true > 
{
};
template < typename _Tp >
    struct is_integral
    : public __is_integral_helper < typename remove_cv < _Tp > :: type > :: type
    { };
template < typename >
    struct __is_floating_point_helper
    : public false_type { };
template<> struct __is_floating_point_helper< float  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_floating_point_helper< double  > : public integral_constant< bool  , true > 
{
};
template<> struct __is_floating_point_helper< long double  > : public integral_constant< bool  , true > 
{
};
template < typename _Tp >
    struct is_floating_point
    : public __is_floating_point_helper < typename remove_cv < _Tp > :: type > :: type
    { };
template < typename >
    struct is_array
    : public false_type { };
template < typename _Tp, std :: size_t _Size >
    struct is_array < _Tp [ _Size ] >
    : public true_type { };
template < typename _Tp >
    struct is_array < _Tp [ ] >
    : public true_type { };
template < typename >
    struct __is_pointer_helper
    : public false_type { };
template < typename _Tp >
    struct __is_pointer_helper < _Tp * >
    : public true_type { };
template < typename _Tp >
    struct is_pointer
    : public __is_pointer_helper < typename remove_cv < _Tp > :: type > :: type
    { };
template < typename >
    struct is_lvalue_reference
    : public false_type { };
template < typename _Tp >
    struct is_lvalue_reference < _Tp & >
    : public true_type { };
template < typename >
    struct is_rvalue_reference
    : public false_type { };
template < typename _Tp >
    struct is_rvalue_reference < _Tp && >
    : public true_type { };
template < typename >
    struct is_function;
template < typename >
    struct __is_member_object_pointer_helper
    : public false_type { };
template < typename _Tp, typename _Cp >
    struct __is_member_object_pointer_helper < _Tp _Cp :: * >
    : public integral_constant < bool, ! is_function < _Tp > :: value > { };
template < typename _Tp >
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper <
    typename remove_cv < _Tp > :: type > :: type
    { };
template < typename >
    struct __is_member_function_pointer_helper
    : public false_type { };
template < typename _Tp, typename _Cp >
    struct __is_member_function_pointer_helper < _Tp _Cp :: * >
    : public integral_constant < bool, is_function < _Tp > :: value > { };
template < typename _Tp >
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper <
    typename remove_cv < _Tp > :: type > :: type
    { };
template < typename _Tp >
    struct is_enum
    : public integral_constant < bool, __is_enum ( _Tp ) >
    { };
template < typename _Tp >
    struct is_union
    : public integral_constant < bool, __is_union ( _Tp ) >
    { };
template < typename _Tp >
    struct is_class
    : public integral_constant < bool, __is_class ( _Tp ) >
    { };
template < typename >
    struct is_function
    : public false_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) & >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) && >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) & >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) && >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) const >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) const & >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) const && >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) const >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) const & >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) const && >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) volatile >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) volatile & >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) volatile && >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) volatile >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) volatile & >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) volatile && >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) const volatile >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) const volatile & >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ) const volatile && >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) const volatile >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) const volatile & >
    : public true_type { };
template < typename _Res, typename ... _ArgTypes >
    struct is_function < _Res ( _ArgTypes ... ... ) const volatile && >
    : public true_type { };
template < typename >
    struct __is_null_pointer_helper
    : public false_type { };
template<> struct __is_null_pointer_helper< nullptr_t  > : public integral_constant< bool  , true > 
{
};
template < typename _Tp >
    struct is_null_pointer
    : public __is_null_pointer_helper < typename remove_cv < _Tp > :: type > :: type
    { };
template < typename _Tp >
    struct __is_nullptr_t
    : public is_null_pointer < _Tp >
    { };
template < typename _Tp >
    struct is_reference
    : public __or_ < is_lvalue_reference < _Tp >,
                   is_rvalue_reference < _Tp >> :: type
    { };
template < typename _Tp >
    struct is_arithmetic
    : public __or_ < is_integral < _Tp >, is_floating_point < _Tp >> :: type
    { };
template < typename _Tp >
    struct is_fundamental
    : public __or_ < is_arithmetic < _Tp >, is_void < _Tp >,
     is_null_pointer < _Tp >> :: type
    { };
template < typename _Tp >
    struct is_object
    : public __not_ < __or_ < is_function < _Tp >, is_reference < _Tp >,
                          is_void < _Tp >>> :: type
    { };
template < typename >
    struct is_member_pointer;
template < typename _Tp >
    struct is_scalar
    : public __or_ < is_arithmetic < _Tp >, is_enum < _Tp >, is_pointer < _Tp >,
                   is_member_pointer < _Tp >, is_null_pointer < _Tp >> :: type
    { };
template < typename _Tp >
    struct is_compound
    : public integral_constant < bool, ! is_fundamental < _Tp > :: value > { };
template < typename _Tp >
    struct __is_member_pointer_helper
    : public false_type { };
template < typename _Tp, typename _Cp >
    struct __is_member_pointer_helper < _Tp _Cp :: * >
    : public true_type { };
template < typename _Tp >
    struct is_member_pointer
    : public __is_member_pointer_helper < typename remove_cv < _Tp > :: type > :: type
    { };
template < typename _Tp >
    struct __is_referenceable
    : public __or_ < is_object < _Tp >, is_reference < _Tp >> :: type
    { };
template < typename _Res, typename ... _Args >
    struct __is_referenceable < _Res ( _Args ... ) >
    : public true_type
    { };
template < typename _Res, typename ... _Args >
    struct __is_referenceable < _Res ( _Args ... ... ) >
    : public true_type
    { };
template < typename >
    struct is_const
    : public false_type { };
template < typename _Tp >
    struct is_const < _Tp const >
    : public true_type { };
template < typename >
    struct is_volatile
    : public false_type { };
template < typename _Tp >
    struct is_volatile < _Tp volatile >
    : public true_type { };
template < typename _Tp >
    struct is_trivial
    : public integral_constant < bool, __is_trivial ( _Tp ) >
    { };
template < typename _Tp >
    struct is_trivially_copyable
    : public integral_constant < bool, __is_trivially_copyable ( _Tp ) >
    { };
template < typename _Tp >
    struct is_standard_layout
    : public integral_constant < bool, __is_standard_layout ( _Tp ) >
    { };
template < typename _Tp >
    struct is_pod
    : public integral_constant < bool, __is_pod ( _Tp ) >
    { };
template < typename _Tp >
    struct is_literal_type
    : public integral_constant < bool, __is_literal_type ( _Tp ) >
    { };
template < typename _Tp >
    struct is_empty
    : public integral_constant < bool, __is_empty ( _Tp ) >
    { };
template < typename _Tp >
    struct is_polymorphic
    : public integral_constant < bool, __is_polymorphic ( _Tp ) >
    { };
template < typename _Tp >
    struct is_final
    : public integral_constant < bool, __is_final ( _Tp ) >
    { };
template < typename _Tp >
    struct is_abstract
    : public integral_constant < bool, __is_abstract ( _Tp ) >
    { };
template < typename _Tp,
    bool = is_arithmetic < _Tp > :: value >
    struct __is_signed_helper
    : public false_type { };
template < typename _Tp >
    struct __is_signed_helper < _Tp, true >
    : public integral_constant < bool, _Tp ( - 1 ) < _Tp ( 0 ) >
    { };
template < typename _Tp >
    struct is_signed
    : public __is_signed_helper < _Tp > :: type
    { };
template < typename _Tp >
    struct is_unsigned
    : public __and_ < is_arithmetic < _Tp >, __not_ < is_signed < _Tp >>>
    { };
template < typename >
    struct add_rvalue_reference;
template < typename _Tp >
    typename add_rvalue_reference < _Tp > :: type declval ( ) noexcept;
template < typename, unsigned = 0 >
    struct extent;
template < typename >
    struct remove_all_extents;
template < typename _Tp >
    struct __is_array_known_bounds
    : public integral_constant < bool, ( extent < _Tp > :: value > 0 ) >
    { };
template < typename _Tp >
    struct __is_array_unknown_bounds
    : public __and_ < is_array < _Tp >, __not_ < extent < _Tp >>>
    { };

struct __do_is_destructible_impl 
{
template < typename _Tp, typename = decltype ( declval < _Tp & > ( ) . ~ _Tp ( ) ) >
      static true_type __test ( int );
template < typename >
      static false_type __test ( ... );
}
;
template < typename _Tp >
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype ( __test < _Tp > ( 0 ) ) type;
    };
template < typename _Tp,
           bool = __or_ < is_void < _Tp >,
                        __is_array_unknown_bounds < _Tp >,
                        is_function < _Tp > > :: value,
           bool = __or_ < is_reference < _Tp >, is_scalar < _Tp > > :: value >
    struct __is_destructible_safe;
template < typename _Tp >
    struct __is_destructible_safe < _Tp, false, false >
    : public __is_destructible_impl < typename
               remove_all_extents < _Tp > :: type > :: type
    { };
template < typename _Tp >
    struct __is_destructible_safe < _Tp, true, false >
    : public false_type { };
template < typename _Tp >
    struct __is_destructible_safe < _Tp, false, true >
    : public true_type { };
template < typename _Tp >
    struct is_destructible
    : public __is_destructible_safe < _Tp > :: type
    { };

struct __do_is_nt_destructible_impl 
{
template < typename _Tp >
      static integral_constant < bool, noexcept ( declval < _Tp & > ( ) . ~ _Tp ( ) ) >
        __test ( int );
template < typename >
      static false_type __test ( ... );
}
;
template < typename _Tp >
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype ( __test < _Tp > ( 0 ) ) type;
    };
template < typename _Tp,
           bool = __or_ < is_void < _Tp >,
                        __is_array_unknown_bounds < _Tp >,
                        is_function < _Tp > > :: value,
           bool = __or_ < is_reference < _Tp >, is_scalar < _Tp > > :: value >
    struct __is_nt_destructible_safe;
template < typename _Tp >
    struct __is_nt_destructible_safe < _Tp, false, false >
    : public __is_nt_destructible_impl < typename
               remove_all_extents < _Tp > :: type > :: type
    { };
template < typename _Tp >
    struct __is_nt_destructible_safe < _Tp, true, false >
    : public false_type { };
template < typename _Tp >
    struct __is_nt_destructible_safe < _Tp, false, true >
    : public true_type { };
template < typename _Tp >
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe < _Tp > :: type
    { };

struct __do_is_default_constructible_impl 
{
template < typename _Tp, typename = decltype ( _Tp ( ) ) >
      static true_type __test ( int );
template < typename >
      static false_type __test ( ... );
}
;
template < typename _Tp >
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype ( __test < _Tp > ( 0 ) ) type;
    };
template < typename _Tp >
    struct __is_default_constructible_atom
    : public __and_ < __not_ < is_void < _Tp >>,
                    __is_default_constructible_impl < _Tp >>
    { };
template < typename _Tp, bool = is_array < _Tp > :: value >
    struct __is_default_constructible_safe;
template < typename _Tp >
    struct __is_default_constructible_safe < _Tp, true >
    : public __and_ < __is_array_known_bounds < _Tp >,
      __is_default_constructible_atom < typename
                      remove_all_extents < _Tp > :: type >>
    { };
template < typename _Tp >
    struct __is_default_constructible_safe < _Tp, false >
    : public __is_default_constructible_atom < _Tp > :: type
    { };
template < typename _Tp >
    struct is_default_constructible
    : public __is_default_constructible_safe < _Tp > :: type
    { };

struct __do_is_static_castable_impl 
{
template < typename _From, typename _To, typename
             = decltype ( static_cast < _To > ( declval < _From > ( ) ) ) >
      static true_type __test ( int );
template < typename, typename >
      static false_type __test ( ... );
}
;
template < typename _From, typename _To >
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype ( __test < _From, _To > ( 0 ) ) type;
    };
template < typename _From, typename _To >
    struct __is_static_castable_safe
    : public __is_static_castable_impl < _From, _To > :: type
    { };
template < typename _From, typename _To >
    struct __is_static_castable
    : public integral_constant < bool, ( __is_static_castable_safe <
          _From, _To > :: value ) >
    { };

struct __do_is_direct_constructible_impl 
{
template < typename _Tp, typename _Arg, typename
      = decltype ( :: new _Tp ( declval < _Arg > ( ) ) ) >
      static true_type __test ( int );
template < typename, typename >
      static false_type __test ( ... );
}
;
template < typename _Tp, typename _Arg >
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype ( __test < _Tp, _Arg > ( 0 ) ) type;
    };
template < typename _Tp, typename _Arg >
    struct __is_direct_constructible_new_safe
    : public __and_ < is_destructible < _Tp >,
                    __is_direct_constructible_impl < _Tp, _Arg >>
    { };
template < typename, typename >
    struct is_same;
template < typename, typename >
    struct is_base_of;
template < typename >
    struct remove_reference;
template < typename _From, typename _To, bool
           = __not_ < __or_ < is_void < _From >,
                          is_function < _From > > > :: value >
    struct __is_base_to_derived_ref;
template < typename _From, typename _To >
    struct __is_base_to_derived_ref < _From, _To, true >
    {
      typedef typename remove_cv < typename remove_reference < _From
        > :: type > :: type __src_t;
      typedef typename remove_cv < typename remove_reference < _To
        > :: type > :: type __dst_t;
      typedef __and_ < __not_ < is_same < __src_t, __dst_t >>,
       is_base_of < __src_t, __dst_t >> type;
      static constexpr bool value = type :: value;
    };
template < typename _From, typename _To >
    struct __is_base_to_derived_ref < _From, _To, false >
    : public false_type
    { };
template < typename _From, typename _To, bool
           = __and_ < is_lvalue_reference < _From >,
                    is_rvalue_reference < _To > > :: value >
    struct __is_lvalue_to_rvalue_ref;
template < typename _From, typename _To >
    struct __is_lvalue_to_rvalue_ref < _From, _To, true >
    {
      typedef typename remove_cv < typename remove_reference <
        _From > :: type > :: type __src_t;
      typedef typename remove_cv < typename remove_reference <
        _To > :: type > :: type __dst_t;
      typedef __and_ < __not_ < is_function < __src_t >>,
        __or_ < is_same < __src_t, __dst_t >,
      is_base_of < __dst_t, __src_t >>> type;
      static constexpr bool value = type :: value;
    };
template < typename _From, typename _To >
    struct __is_lvalue_to_rvalue_ref < _From, _To, false >
    : public false_type
    { };
template < typename _Tp, typename _Arg >
    struct __is_direct_constructible_ref_cast
    : public __and_ < __is_static_castable < _Arg, _Tp >,
                    __not_ < __or_ < __is_base_to_derived_ref < _Arg, _Tp >,
                                 __is_lvalue_to_rvalue_ref < _Arg, _Tp >
                   >>>
    { };
template < typename _Tp, typename _Arg >
    struct __is_direct_constructible_new
    : public conditional < is_reference < _Tp > :: value,
    __is_direct_constructible_ref_cast < _Tp, _Arg >,
    __is_direct_constructible_new_safe < _Tp, _Arg >
    > :: type
    { };
template < typename _Tp, typename _Arg >
    struct __is_direct_constructible
    : public __is_direct_constructible_new < _Tp, _Arg > :: type
    { };

struct __do_is_nary_constructible_impl 
{
template < typename _Tp, typename ... _Args, typename
             = decltype ( _Tp ( declval < _Args > ( ) ... ) ) >
      static true_type __test ( int );
template < typename, typename ... >
      static false_type __test ( ... );
}
;
template < typename _Tp, typename ... _Args >
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype ( __test < _Tp, _Args ... > ( 0 ) ) type;
    };
template < typename _Tp, typename ... _Args >
    struct __is_nary_constructible
    : public __is_nary_constructible_impl < _Tp, _Args ... > :: type
    {
      static_assert ( sizeof ... ( _Args ) > 1,
                    "Only useful for > 1 arguments" );
    };
template < typename _Tp, typename ... _Args >
    struct __is_constructible_impl
    : public __is_nary_constructible < _Tp, _Args ... >
    { };
template < typename _Tp, typename _Arg >
    struct __is_constructible_impl < _Tp, _Arg >
    : public __is_direct_constructible < _Tp, _Arg >
    { };
template < typename _Tp >
    struct __is_constructible_impl < _Tp >
    : public is_default_constructible < _Tp >
    { };
template < typename _Tp, typename ... _Args >
    struct is_constructible
    : public __is_constructible_impl < _Tp, _Args ... > :: type
    { };
template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_copy_constructible_impl;
template < typename _Tp >
    struct __is_copy_constructible_impl < _Tp, false >
    : public false_type { };
template < typename _Tp >
    struct __is_copy_constructible_impl < _Tp, true >
    : public is_constructible < _Tp, const _Tp & >
    { };
template < typename _Tp >
    struct is_copy_constructible
    : public __is_copy_constructible_impl < _Tp >
    { };
template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_move_constructible_impl;
template < typename _Tp >
    struct __is_move_constructible_impl < _Tp, false >
    : public false_type { };
template < typename _Tp >
    struct __is_move_constructible_impl < _Tp, true >
    : public is_constructible < _Tp, _Tp && >
    { };
template < typename _Tp >
    struct is_move_constructible
    : public __is_move_constructible_impl < _Tp >
    { };
template < typename _Tp >
    struct __is_nt_default_constructible_atom
    : public integral_constant < bool, noexcept ( _Tp ( ) ) >
    { };
template < typename _Tp, bool = is_array < _Tp > :: value >
    struct __is_nt_default_constructible_impl;
template < typename _Tp >
    struct __is_nt_default_constructible_impl < _Tp, true >
    : public __and_ < __is_array_known_bounds < _Tp >,
      __is_nt_default_constructible_atom < typename
                      remove_all_extents < _Tp > :: type >>
    { };
template < typename _Tp >
    struct __is_nt_default_constructible_impl < _Tp, false >
    : public __is_nt_default_constructible_atom < _Tp >
    { };
template < typename _Tp >
    struct is_nothrow_default_constructible
    : public __and_ < is_default_constructible < _Tp >,
                    __is_nt_default_constructible_impl < _Tp >>
    { };
template < typename _Tp, typename ... _Args >
    struct __is_nt_constructible_impl
    : public integral_constant < bool, noexcept ( _Tp ( declval < _Args > ( ) ... ) ) >
    { };
template < typename _Tp, typename _Arg >
    struct __is_nt_constructible_impl < _Tp, _Arg >
    : public integral_constant < bool,
                               noexcept ( static_cast < _Tp > ( declval < _Arg > ( ) ) ) >
    { };
template < typename _Tp >
    struct __is_nt_constructible_impl < _Tp >
    : public is_nothrow_default_constructible < _Tp >
    { };
template < typename _Tp, typename ... _Args >
    struct is_nothrow_constructible
    : public __and_ < is_constructible < _Tp, _Args ... >,
      __is_nt_constructible_impl < _Tp, _Args ... >>
    { };
template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_nothrow_copy_constructible_impl;
template < typename _Tp >
    struct __is_nothrow_copy_constructible_impl < _Tp, false >
    : public false_type { };
template < typename _Tp >
    struct __is_nothrow_copy_constructible_impl < _Tp, true >
    : public is_nothrow_constructible < _Tp, const _Tp & >
    { };
template < typename _Tp >
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl < _Tp >
    { };
template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_nothrow_move_constructible_impl;
template < typename _Tp >
    struct __is_nothrow_move_constructible_impl < _Tp, false >
    : public false_type { };
template < typename _Tp >
    struct __is_nothrow_move_constructible_impl < _Tp, true >
    : public is_nothrow_constructible < _Tp, _Tp && >
    { };
template < typename _Tp >
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl < _Tp >
    { };
template < typename _Tp, typename _Up >
    class __is_assignable_helper
    {
      template < typename _Tp1, typename _Up1,
        typename = decltype ( declval < _Tp1 > ( ) = declval < _Up1 > ( ) ) >
 static true_type
 __test ( int );
      template < typename, typename >
 static false_type
 __test ( ... );
    public :
      typedef decltype ( __test < _Tp, _Up > ( 0 ) ) type;
    };
template < typename _Tp, typename _Up >
    struct is_assignable
      : public __is_assignable_helper < _Tp, _Up > :: type
    { };
template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_copy_assignable_impl;
template < typename _Tp >
    struct __is_copy_assignable_impl < _Tp, false >
    : public false_type { };
template < typename _Tp >
    struct __is_copy_assignable_impl < _Tp, true >
    : public is_assignable < _Tp &, const _Tp & >
    { };
template < typename _Tp >
    struct is_copy_assignable
    : public __is_copy_assignable_impl < _Tp >
    { };
template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_move_assignable_impl;
template < typename _Tp >
    struct __is_move_assignable_impl < _Tp, false >
    : public false_type { };
template < typename _Tp >
    struct __is_move_assignable_impl < _Tp, true >
    : public is_assignable < _Tp &, _Tp && >
    { };
template < typename _Tp >
    struct is_move_assignable
    : public __is_move_assignable_impl < _Tp >
    { };
template < typename _Tp, typename _Up >
    struct __is_nt_assignable_impl
    : public integral_constant < bool, noexcept ( declval < _Tp > ( ) = declval < _Up > ( ) ) >
    { };
template < typename _Tp, typename _Up >
    struct is_nothrow_assignable
    : public __and_ < is_assignable < _Tp, _Up >,
      __is_nt_assignable_impl < _Tp, _Up >>
    { };
template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_nt_copy_assignable_impl;
template < typename _Tp >
    struct __is_nt_copy_assignable_impl < _Tp, false >
    : public false_type { };
template < typename _Tp >
    struct __is_nt_copy_assignable_impl < _Tp, true >
    : public is_nothrow_assignable < _Tp &, const _Tp & >
    { };
template < typename _Tp >
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl < _Tp >
    { };
template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_nt_move_assignable_impl;
template < typename _Tp >
    struct __is_nt_move_assignable_impl < _Tp, false >
    : public false_type { };
template < typename _Tp >
    struct __is_nt_move_assignable_impl < _Tp, true >
    : public is_nothrow_assignable < _Tp &, _Tp && >
    { };
template < typename _Tp >
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl < _Tp >
    { };
template < typename _Tp, typename ... _Args >
    struct is_trivially_constructible
    : public __and_ < is_constructible < _Tp, _Args ... >, integral_constant < bool,
   __is_trivially_constructible ( _Tp, _Args ... ) >>
    { };
template < typename _Tp >
    struct is_trivially_default_constructible
    : public is_trivially_constructible < _Tp > :: type
    { };

struct __do_is_implicitly_default_constructible_impl 
{
template < typename _Tp >
    static void __helper ( const _Tp & );
template < typename _Tp >
    static true_type __test ( const _Tp &,
                            decltype ( __helper < const _Tp & > ( { } ) ) * = 0 );
static false_type __test();
}
;
template < typename _Tp >
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype ( __test ( declval < _Tp > ( ) ) ) type;
  };
template < typename _Tp >
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl < _Tp > :: type
  { };
template < typename _Tp >
    struct __is_implicitly_default_constructible
      : public __and_ < is_default_constructible < _Tp >,
                      __is_implicitly_default_constructible_safe < _Tp >>
  { };
template < typename _Tp >
    struct is_trivially_copy_constructible
    : public __and_ < is_copy_constructible < _Tp >,
      integral_constant < bool,
   __is_trivially_constructible ( _Tp, const _Tp & ) >>
    { };
template < typename _Tp >
    struct is_trivially_move_constructible
    : public __and_ < is_move_constructible < _Tp >,
      integral_constant < bool,
   __is_trivially_constructible ( _Tp, _Tp && ) >>
    { };
template < typename _Tp, typename _Up >
    struct is_trivially_assignable
    : public __and_ < is_assignable < _Tp, _Up >,
      integral_constant < bool,
   __is_trivially_assignable ( _Tp, _Up ) >>
    { };
template < typename _Tp >
    struct is_trivially_copy_assignable
    : public __and_ < is_copy_assignable < _Tp >,
      integral_constant < bool,
   __is_trivially_assignable ( _Tp &, const _Tp & ) >>
    { };
template < typename _Tp >
    struct is_trivially_move_assignable
    : public __and_ < is_move_assignable < _Tp >,
      integral_constant < bool,
   __is_trivially_assignable ( _Tp &, _Tp && ) >>
    { };
template < typename _Tp >
    struct is_trivially_destructible
    : public __and_ < is_destructible < _Tp >, integral_constant < bool,
         __has_trivial_destructor ( _Tp ) >>
    { };
template < typename _Tp >
    struct has_trivial_default_constructor
    : public integral_constant < bool, __has_trivial_constructor ( _Tp ) >
    { } __attribute__ ( ( __deprecated__ ) );
template < typename _Tp >
    struct has_trivial_copy_constructor
    : public integral_constant < bool, __has_trivial_copy ( _Tp ) >
    { } __attribute__ ( ( __deprecated__ ) );
template < typename _Tp >
    struct has_trivial_copy_assign
    : public integral_constant < bool, __has_trivial_assign ( _Tp ) >
    { } __attribute__ ( ( __deprecated__ ) );
template < typename _Tp >
    struct has_virtual_destructor
    : public integral_constant < bool, __has_virtual_destructor ( _Tp ) >
    { };
template < typename _Tp >
    struct alignment_of
    : public integral_constant < std :: size_t, __alignof__ ( _Tp ) > { };
template < typename >
    struct rank
    : public integral_constant < std :: size_t, 0 > { };
template < typename _Tp, std :: size_t _Size >
    struct rank < _Tp [ _Size ] >
    : public integral_constant < std :: size_t, 1 + rank < _Tp > :: value > { };
template < typename _Tp >
    struct rank < _Tp [ ] >
    : public integral_constant < std :: size_t, 1 + rank < _Tp > :: value > { };
template < typename, unsigned _Uint >
    struct extent
    : public integral_constant < std :: size_t, 0 > { };
template < typename _Tp, unsigned _Uint, std :: size_t _Size >
    struct extent < _Tp [ _Size ], _Uint >
    : public integral_constant < std :: size_t,
          _Uint == 0 ? _Size : extent < _Tp,
          _Uint - 1 > :: value >
    { };
template < typename _Tp, unsigned _Uint >
    struct extent < _Tp [ ], _Uint >
    : public integral_constant < std :: size_t,
          _Uint == 0 ? 0 : extent < _Tp,
             _Uint - 1 > :: value >
    { };
template < typename, typename >
    struct is_same
    : public false_type { };
template < typename _Tp >
    struct is_same < _Tp, _Tp >
    : public true_type { };
template < typename _Base, typename _Derived >
    struct is_base_of
    : public integral_constant < bool, __is_base_of ( _Base, _Derived ) >
    { };
template < typename _From, typename _To,
           bool = __or_ < is_void < _From >, is_function < _To >,
                        is_array < _To > > :: value >
    struct __is_convertible_helper
    { typedef typename is_void < _To > :: type type; };
template < typename _From, typename _To >
    class __is_convertible_helper < _From, _To, false >
    {
       template < typename _To1 >
 static void __test_aux ( _To1 );
      template < typename _From1, typename _To1,
        typename = decltype ( __test_aux < _To1 > ( std :: declval < _From1 > ( ) ) ) >
 static true_type
 __test ( int );
      template < typename, typename >
 static false_type
 __test ( ... );
    public :
      typedef decltype ( __test < _From, _To > ( 0 ) ) type;
    };
template < typename _From, typename _To >
    struct is_convertible
    : public __is_convertible_helper < _From, _To > :: type
    { };
template < typename _Tp >
    struct remove_const
    { typedef _Tp type; };
template < typename _Tp >
    struct remove_const < _Tp const >
    { typedef _Tp type; };
template < typename _Tp >
    struct remove_volatile
    { typedef _Tp type; };
template < typename _Tp >
    struct remove_volatile < _Tp volatile >
    { typedef _Tp type; };
template < typename _Tp >
    struct remove_cv
    {
      typedef typename
      remove_const < typename remove_volatile < _Tp > :: type > :: type type;
    };
template < typename _Tp >
    struct add_const
    { typedef _Tp const type; };
template < typename _Tp >
    struct add_volatile
    { typedef _Tp volatile type; };
template < typename _Tp >
    struct add_cv
    {
      typedef typename
      add_const < typename add_volatile < _Tp > :: type > :: type type;
    };
template < typename _Tp >
    using remove_const_t = typename remove_const < _Tp > :: type;
template < typename _Tp >
    using remove_volatile_t = typename remove_volatile < _Tp > :: type;
template < typename _Tp >
    using remove_cv_t = typename remove_cv < _Tp > :: type;
template < typename _Tp >
    using add_const_t = typename add_const < _Tp > :: type;
template < typename _Tp >
    using add_volatile_t = typename add_volatile < _Tp > :: type;
template < typename _Tp >
    using add_cv_t = typename add_cv < _Tp > :: type;
template < typename _Tp >
    struct remove_reference
    { typedef _Tp type; };
template < typename _Tp >
    struct remove_reference < _Tp & >
    { typedef _Tp type; };
template < typename _Tp >
    struct remove_reference < _Tp && >
    { typedef _Tp type; };
template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };
template < typename _Tp >
    struct __add_lvalue_reference_helper < _Tp, true >
    { typedef _Tp & type; };
template < typename _Tp >
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper < _Tp >
    { };
template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };
template < typename _Tp >
    struct __add_rvalue_reference_helper < _Tp, true >
    { typedef _Tp && type; };
template < typename _Tp >
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper < _Tp >
    { };
template < typename _Tp >
    using remove_reference_t = typename remove_reference < _Tp > :: type;
template < typename _Tp >
    using add_lvalue_reference_t = typename add_lvalue_reference < _Tp > :: type;
template < typename _Tp >
    using add_rvalue_reference_t = typename add_rvalue_reference < _Tp > :: type;
template < typename _Unqualified, bool _IsConst, bool _IsVol >
    struct __cv_selector;
template < typename _Unqualified >
    struct __cv_selector < _Unqualified, false, false >
    { typedef _Unqualified __type; };
template < typename _Unqualified >
    struct __cv_selector < _Unqualified, false, true >
    { typedef volatile _Unqualified __type; };
template < typename _Unqualified >
    struct __cv_selector < _Unqualified, true, false >
    { typedef const _Unqualified __type; };
template < typename _Unqualified >
    struct __cv_selector < _Unqualified, true, true >
    { typedef const volatile _Unqualified __type; };
template < typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const < _Qualified > :: value,
    bool _IsVol = is_volatile < _Qualified > :: value >
    class __match_cv_qualifiers
    {
      typedef __cv_selector < _Unqualified, _IsConst, _IsVol > __match;
    public :
      typedef typename __match :: __type __type;
    };
template < typename _Tp >
    struct __make_unsigned
    { typedef _Tp __type; };
template<> struct __make_unsigned< char  > 
{
typedef unsigned char __type;
};
template<> struct __make_unsigned< signed char  > 
{
typedef unsigned char __type;
};
template<> struct __make_unsigned< short  > 
{
typedef unsigned short __type;
};
template<> struct __make_unsigned< int  > 
{
typedef unsigned int __type;
};
template<> struct __make_unsigned< long  > 
{
typedef unsigned long __type;
};
template<> struct __make_unsigned< long long  > 
{
typedef unsigned long long __type;
};
template<> struct __make_unsigned< wchar_t  > : public __make_unsigned< int  > 
{
};
template < typename _Tp,
    bool _IsInt = is_integral < _Tp > :: value,
    bool _IsEnum = is_enum < _Tp > :: value >
    class __make_unsigned_selector;
template < typename _Tp >
    class __make_unsigned_selector < _Tp, true, false >
    {
      typedef __make_unsigned < typename remove_cv < _Tp > :: type > __unsignedt;
      typedef typename __unsignedt :: __type __unsigned_type;
      typedef __match_cv_qualifiers < _Tp, __unsigned_type > __cv_unsigned;
    public :
      typedef typename __cv_unsigned :: __type __type;
    };
template < typename _Tp >
    class __make_unsigned_selector < _Tp, false, true >
    {
      typedef unsigned char __smallest;
      static const bool __b0 = sizeof ( _Tp ) <= sizeof ( __smallest );
      static const bool __b1 = sizeof ( _Tp ) <= sizeof ( unsigned short );
      static const bool __b2 = sizeof ( _Tp ) <= sizeof ( unsigned int );
      static const bool __b3 = sizeof ( _Tp ) <= sizeof ( unsigned long );
      typedef conditional < __b3, unsigned long, unsigned long long > __cond3;
      typedef typename __cond3 :: type __cond3_type;
      typedef conditional < __b2, unsigned int, __cond3_type > __cond2;
      typedef typename __cond2 :: type __cond2_type;
      typedef conditional < __b1, unsigned short, __cond2_type > __cond1;
      typedef typename __cond1 :: type __cond1_type;
      typedef typename conditional < __b0, __smallest, __cond1_type > :: type
 __unsigned_type;
      typedef __match_cv_qualifiers < _Tp, __unsigned_type > __cv_unsigned;
    public :
      typedef typename __cv_unsigned :: __type __type;
    };
template < typename _Tp >
    struct make_unsigned
    { typedef typename __make_unsigned_selector < _Tp > :: __type type; };
template<> struct make_unsigned< bool  > ;
template < typename _Tp >
    struct __make_signed
    { typedef _Tp __type; };
template<> struct __make_signed< char  > 
{
typedef signed char __type;
};
template<> struct __make_signed< unsigned char  > 
{
typedef signed char __type;
};
template<> struct __make_signed< unsigned short  > 
{
typedef signed short __type;
};
template<> struct __make_signed< unsigned int  > 
{
typedef signed int __type;
};
template<> struct __make_signed< unsigned long  > 
{
typedef signed long __type;
};
template<> struct __make_signed< unsigned long long  > 
{
typedef signed long long __type;
};
template<> struct __make_signed< char16_t  > : public __make_signed< unsigned short  > 
{
};
template<> struct __make_signed< char32_t  > : public __make_signed< unsigned int  > 
{
};
template < typename _Tp,
    bool _IsInt = is_integral < _Tp > :: value,
    bool _IsEnum = is_enum < _Tp > :: value >
    class __make_signed_selector;
template < typename _Tp >
    class __make_signed_selector < _Tp, true, false >
    {
      typedef __make_signed < typename remove_cv < _Tp > :: type > __signedt;
      typedef typename __signedt :: __type __signed_type;
      typedef __match_cv_qualifiers < _Tp, __signed_type > __cv_signed;
    public :
      typedef typename __cv_signed :: __type __type;
    };
template < typename _Tp >
    class __make_signed_selector < _Tp, false, true >
    {
      typedef typename __make_unsigned_selector < _Tp > :: __type __unsigned_type;
    public :
      typedef typename __make_signed_selector < __unsigned_type > :: __type __type;
    };
template < typename _Tp >
    struct make_signed
    { typedef typename __make_signed_selector < _Tp > :: __type type; };
template<> struct make_signed< bool  > ;
template < typename _Tp >
    using make_signed_t = typename make_signed < _Tp > :: type;
template < typename _Tp >
    using make_unsigned_t = typename make_unsigned < _Tp > :: type;
template < typename _Tp >
    struct remove_extent
    { typedef _Tp type; };
template < typename _Tp, std :: size_t _Size >
    struct remove_extent < _Tp [ _Size ] >
    { typedef _Tp type; };
template < typename _Tp >
    struct remove_extent < _Tp [ ] >
    { typedef _Tp type; };
template < typename _Tp >
    struct remove_all_extents
    { typedef _Tp type; };
template < typename _Tp, std :: size_t _Size >
    struct remove_all_extents < _Tp [ _Size ] >
    { typedef typename remove_all_extents < _Tp > :: type type; };
template < typename _Tp >
    struct remove_all_extents < _Tp [ ] >
    { typedef typename remove_all_extents < _Tp > :: type type; };
template < typename _Tp >
    using remove_extent_t = typename remove_extent < _Tp > :: type;
template < typename _Tp >
    using remove_all_extents_t = typename remove_all_extents < _Tp > :: type;
template < typename _Tp, typename >
    struct __remove_pointer_helper
    { typedef _Tp type; };
template < typename _Tp, typename _Up >
    struct __remove_pointer_helper < _Tp, _Up * >
    { typedef _Up type; };
template < typename _Tp >
    struct remove_pointer
    : public __remove_pointer_helper < _Tp, typename remove_cv < _Tp > :: type >
    { };
template < typename _Tp, bool = __or_ < __is_referenceable < _Tp >,
          is_void < _Tp > > :: value >
    struct __add_pointer_helper
    { typedef _Tp type; };
template < typename _Tp >
    struct __add_pointer_helper < _Tp, true >
    { typedef typename remove_reference < _Tp > :: type * type; };
template < typename _Tp >
    struct add_pointer
    : public __add_pointer_helper < _Tp >
    { };
template < typename _Tp >
    using remove_pointer_t = typename remove_pointer < _Tp > :: type;
template < typename _Tp >
    using add_pointer_t = typename add_pointer < _Tp > :: type;
template < std :: size_t _Len >
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data [ _Len ];
 struct __attribute__ ( ( __aligned__ ) ) { } __align;
      };
    };
template < std :: size_t _Len, std :: size_t _Align =
    __alignof__ ( typename __aligned_storage_msa < _Len > :: __type ) >
    struct aligned_storage
    {
      union type
      {
 unsigned char __data [ _Len ];
 struct __attribute__ ( ( __aligned__ ( ( _Align ) ) ) ) { } __align;
      };
    };
template < typename ... _Types >
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };
template < typename _Tp, typename ... _Types >
    struct __strictest_alignment < _Tp, _Types ... >
    {
      static const size_t _S_alignment =
        alignof ( _Tp ) > __strictest_alignment < _Types ... > :: _S_alignment
 ? alignof ( _Tp ) : __strictest_alignment < _Types ... > :: _S_alignment;
      static const size_t _S_size =
        sizeof ( _Tp ) > __strictest_alignment < _Types ... > :: _S_size
 ? sizeof ( _Tp ) : __strictest_alignment < _Types ... > :: _S_size;
    };
template < size_t _Len, typename ... _Types >
    struct aligned_union
    {
    private :
      static_assert ( sizeof ... ( _Types ) != 0, "At least one type is required" );
      using __strictest = __strictest_alignment < _Types ... >;
      static const size_t _S_len = _Len > __strictest :: _S_size
 ? _Len : __strictest :: _S_size;
    public :
      static const size_t alignment_value = __strictest :: _S_alignment;
      typedef typename aligned_storage < _S_len, alignment_value > :: type type;
    };
template < size_t _Len, typename ... _Types >
    const size_t aligned_union < _Len, _Types ... > :: alignment_value;
template < typename _Up,
    bool _IsArray = is_array < _Up > :: value,
    bool _IsFunction = is_function < _Up > :: value >
    struct __decay_selector;
template < typename _Up >
    struct __decay_selector < _Up, false, false >
    { typedef typename remove_cv < _Up > :: type __type; };
template < typename _Up >
    struct __decay_selector < _Up, true, false >
    { typedef typename remove_extent < _Up > :: type * __type; };
template < typename _Up >
    struct __decay_selector < _Up, false, true >
    { typedef typename add_pointer < _Up > :: type __type; };
template < typename _Tp >
    class decay
    {
      typedef typename remove_reference < _Tp > :: type __remove_type;
    public :
      typedef typename __decay_selector < __remove_type > :: __type type;
    };
template < typename _Tp >
    class reference_wrapper;
template < typename _Tp >
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };
template < typename _Tp >
    struct __strip_reference_wrapper < reference_wrapper < _Tp > >
    {
      typedef _Tp & __type;
    };
template < typename _Tp >
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper <
 typename decay < _Tp > :: type > :: __type __type;
    };
template < bool, typename _Tp = void >
    struct enable_if
    { };
template < typename _Tp >
    struct enable_if < true, _Tp >
    { typedef _Tp type; };
template < typename ... _Cond >
    using _Require = typename enable_if < __and_ < _Cond ... > :: value > :: type;
template < bool _Cond, typename _Iftrue, typename _Iffalse >
    struct conditional
    { typedef _Iftrue type; };
template < typename _Iftrue, typename _Iffalse >
    struct conditional < false, _Iftrue, _Iffalse >
    { typedef _Iffalse type; };
template < typename ... _Tp >
    struct common_type;

struct __do_common_type_impl 
{
template < typename _Tp, typename _Up >
      static __success_type < typename decay < decltype
       ( true ? std :: declval < _Tp > ( )
        : std :: declval < _Up > ( ) ) > :: type > _S_test ( int );
template < typename, typename >
      static __failure_type _S_test ( ... );
}
;
template < typename _Tp, typename _Up >
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype ( _S_test < _Tp, _Up > ( 0 ) ) type;
    };

struct __do_member_type_wrapper 
{
template < typename _Tp >
      static __success_type < typename _Tp :: type > _S_test ( int );
template < typename >
      static __failure_type _S_test ( ... );
}
;
template < typename _Tp >
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype ( _S_test < _Tp > ( 0 ) ) type;
    };
template < typename _CTp, typename ... _Args >
    struct __expanded_common_type_wrapper
    {
      typedef common_type < typename _CTp :: type, _Args ... > type;
    };
template < typename ... _Args >
    struct __expanded_common_type_wrapper < __failure_type, _Args ... >
    { typedef __failure_type type; };
template < typename _Tp >
    struct common_type < _Tp >
    { typedef typename decay < _Tp > :: type type; };
template < typename _Tp, typename _Up >
    struct common_type < _Tp, _Up >
    : public __common_type_impl < _Tp, _Up > :: type
    { };
template < typename _Tp, typename _Up, typename ... _Vp >
    struct common_type < _Tp, _Up, _Vp ... >
    : public __expanded_common_type_wrapper < typename __member_type_wrapper <
               common_type < _Tp, _Up >> :: type, _Vp ... > :: type
    { };
template < typename _Tp >
    struct underlying_type
    {
      typedef __underlying_type ( _Tp ) type;
    };
template < typename _Tp >
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference < _Tp > :: type __delegate ( );
    };
template < typename _Tp >
    inline typename add_rvalue_reference < _Tp > :: type
    declval ( ) noexcept
    {
      static_assert ( __declval_protector < _Tp > :: __stop,
      "declval() must not be used!" );
      return __declval_protector < _Tp > :: __delegate ( );
    }
template < typename _Signature >
    class result_of;

struct __invoke_memfun_ref 
{
}
;

struct __invoke_memfun_deref 
{
}
;

struct __invoke_memobj_ref 
{
}
;

struct __invoke_memobj_deref 
{
}
;

struct __invoke_other 
{
}
;
template < typename _Tp, typename _Tag >
    struct __result_of_success : __success_type < _Tp >
    { using __invoke_type = _Tag; };

struct __result_of_memfun_ref_impl 
{
template < typename _Fp, typename _Tp1, typename ... _Args >
      static __result_of_success < decltype (
      ( std :: declval < _Tp1 > ( ) .* std :: declval < _Fp > ( ) ) ( std :: declval < _Args > ( ) ... )
      ), __invoke_memfun_ref > _S_test ( int );
template < typename ... >
      static __failure_type _S_test ( ... );
}
;
template < typename _MemPtr, typename _Arg, typename ... _Args >
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype ( _S_test < _MemPtr, _Arg, _Args ... > ( 0 ) ) type;
    };

struct __result_of_memfun_deref_impl 
{
template < typename _Fp, typename _Tp1, typename ... _Args >
      static __result_of_success < decltype (
      ( ( * std :: declval < _Tp1 > ( ) ) .* std :: declval < _Fp > ( ) ) ( std :: declval < _Args > ( ) ... )
      ), __invoke_memfun_deref > _S_test ( int );
template < typename ... >
      static __failure_type _S_test ( ... );
}
;
template < typename _MemPtr, typename _Arg, typename ... _Args >
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype ( _S_test < _MemPtr, _Arg, _Args ... > ( 0 ) ) type;
    };

struct __result_of_memobj_ref_impl 
{
template < typename _Fp, typename _Tp1 >
      static __result_of_success < decltype (
      std :: declval < _Tp1 > ( ) .* std :: declval < _Fp > ( )
      ), __invoke_memobj_ref > _S_test ( int );
template < typename, typename >
      static __failure_type _S_test ( ... );
}
;
template < typename _MemPtr, typename _Arg >
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype ( _S_test < _MemPtr, _Arg > ( 0 ) ) type;
    };

struct __result_of_memobj_deref_impl 
{
template < typename _Fp, typename _Tp1 >
      static __result_of_success < decltype (
      ( * std :: declval < _Tp1 > ( ) ) .* std :: declval < _Fp > ( )
      ), __invoke_memobj_deref > _S_test ( int );
template < typename, typename >
      static __failure_type _S_test ( ... );
}
;
template < typename _MemPtr, typename _Arg >
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype ( _S_test < _MemPtr, _Arg > ( 0 ) ) type;
    };
template < typename _MemPtr, typename _Arg >
    struct __result_of_memobj;
template < typename _Res, typename _Class, typename _Arg >
    struct __result_of_memobj < _Res _Class :: *, _Arg >
    {
      typedef typename remove_cv < typename remove_reference <
        _Arg > :: type > :: type _Argval;
      typedef _Res _Class :: * _MemPtr;
      typedef typename conditional < __or_ < is_same < _Argval, _Class >,
        is_base_of < _Class, _Argval >> :: value,
        __result_of_memobj_ref < _MemPtr, _Arg >,
        __result_of_memobj_deref < _MemPtr, _Arg >
      > :: type :: type type;
    };
template < typename _MemPtr, typename _Arg, typename ... _Args >
    struct __result_of_memfun;
template < typename _Res, typename _Class, typename _Arg, typename ... _Args >
    struct __result_of_memfun < _Res _Class :: *, _Arg, _Args ... >
    {
      typedef typename remove_cv < typename remove_reference <
        _Arg > :: type > :: type _Argval;
      typedef _Res _Class :: * _MemPtr;
      typedef typename conditional < __or_ < is_same < _Argval, _Class >,
        is_base_of < _Class, _Argval >> :: value,
        __result_of_memfun_ref < _MemPtr, _Arg, _Args ... >,
        __result_of_memfun_deref < _MemPtr, _Arg, _Args ... >
      > :: type :: type type;
    };
template < typename _Res, typename _Class, typename _Arg >
    struct __result_of_memobj < _Res _Class :: *, reference_wrapper < _Arg > >
    : __result_of_memobj_ref < _Res _Class :: *, _Arg & >
    { };
template < typename _Res, typename _Class, typename _Arg >
    struct __result_of_memobj < _Res _Class :: *, reference_wrapper < _Arg > & >
    : __result_of_memobj_ref < _Res _Class :: *, _Arg & >
    { };
template < typename _Res, typename _Class, typename _Arg >
    struct __result_of_memobj < _Res _Class :: *, const reference_wrapper < _Arg > & >
    : __result_of_memobj_ref < _Res _Class :: *, _Arg & >
    { };
template < typename _Res, typename _Class, typename _Arg >
    struct __result_of_memobj < _Res _Class :: *, reference_wrapper < _Arg > && >
    : __result_of_memobj_ref < _Res _Class :: *, _Arg & >
    { };
template < typename _Res, typename _Class, typename _Arg >
    struct __result_of_memobj < _Res _Class :: *, const reference_wrapper < _Arg > && >
    : __result_of_memobj_ref < _Res _Class :: *, _Arg & >
    { };
template < typename _Res, typename _Class, typename _Arg, typename ... _Args >
    struct __result_of_memfun < _Res _Class :: *, reference_wrapper < _Arg >, _Args ... >
    : __result_of_memfun_ref < _Res _Class :: *, _Arg &, _Args ... >
    { };
template < typename _Res, typename _Class, typename _Arg, typename ... _Args >
    struct __result_of_memfun < _Res _Class :: *, reference_wrapper < _Arg > &,
         _Args ... >
    : __result_of_memfun_ref < _Res _Class :: *, _Arg &, _Args ... >
    { };
template < typename _Res, typename _Class, typename _Arg, typename ... _Args >
    struct __result_of_memfun < _Res _Class :: *, const reference_wrapper < _Arg > &,
         _Args ... >
    : __result_of_memfun_ref < _Res _Class :: *, _Arg &, _Args ... >
    { };
template < typename _Res, typename _Class, typename _Arg, typename ... _Args >
    struct __result_of_memfun < _Res _Class :: *, reference_wrapper < _Arg > &&,
         _Args ... >
    : __result_of_memfun_ref < _Res _Class :: *, _Arg &, _Args ... >
    { };
template < typename _Res, typename _Class, typename _Arg, typename ... _Args >
    struct __result_of_memfun < _Res _Class :: *, const reference_wrapper < _Arg > &&,
         _Args ... >
    : __result_of_memfun_ref < _Res _Class :: *, _Arg &, _Args ... >
    { };
template < bool, bool, typename _Functor, typename ... _ArgTypes >
    struct __result_of_impl
    {
      typedef __failure_type type;
    };
template < typename _MemPtr, typename _Arg >
    struct __result_of_impl < true, false, _MemPtr, _Arg >
    : public __result_of_memobj < typename decay < _MemPtr > :: type, _Arg >
    { };
template < typename _MemPtr, typename _Arg, typename ... _Args >
    struct __result_of_impl < false, true, _MemPtr, _Arg, _Args ... >
    : public __result_of_memfun < typename decay < _MemPtr > :: type, _Arg, _Args ... >
    { };

struct __result_of_other_impl 
{
template < typename _Fn, typename ... _Args >
      static __result_of_success < decltype (
      std :: declval < _Fn > ( ) ( std :: declval < _Args > ( ) ... )
      ), __invoke_other > _S_test ( int );
template < typename ... >
      static __failure_type _S_test ( ... );
}
;
template < typename _Functor, typename ... _ArgTypes >
    struct __result_of_impl < false, false, _Functor, _ArgTypes ... >
    : private __result_of_other_impl
    {
      typedef decltype ( _S_test < _Functor, _ArgTypes ... > ( 0 ) ) type;
    };
template < typename _Functor, typename ... _ArgTypes >
    struct result_of < _Functor ( _ArgTypes ... ) >
    : public __result_of_impl <
        is_member_object_pointer <
          typename remove_reference < _Functor > :: type
        > :: value,
        is_member_function_pointer <
          typename remove_reference < _Functor > :: type
        > :: value,
     _Functor, _ArgTypes ...
      > :: type
    { };
template < size_t _Len, size_t _Align =
     __alignof__ ( typename __aligned_storage_msa < _Len > :: __type ) >
    using aligned_storage_t = typename aligned_storage < _Len, _Align > :: type;
template < size_t _Len, typename ... _Types >
    using aligned_union_t = typename aligned_union < _Len, _Types ... > :: type;
template < typename _Tp >
    using decay_t = typename decay < _Tp > :: type;
template < bool _Cond, typename _Tp = void >
    using enable_if_t = typename enable_if < _Cond, _Tp > :: type;
template < bool _Cond, typename _Iftrue, typename _Iffalse >
    using conditional_t = typename conditional < _Cond, _Iftrue, _Iffalse > :: type;
template < typename ... _Tp >
    using common_type_t = typename common_type < _Tp ... > :: type;
template < typename _Tp >
    using underlying_type_t = typename underlying_type < _Tp > :: type;
template < typename _Tp >
    using result_of_t = typename result_of < _Tp > :: type;
template < typename ... > using __void_t = void;
template < typename _Default, typename _AlwaysVoid,
    template < typename ... > class _Op, typename ... _Args >
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };
template < typename _Default, template < typename ... > class _Op,
     typename ... _Args >
    struct __detector < _Default, __void_t < _Op < _Args ... > >, _Op, _Args ... >
    {
      using value_t = true_type;
      using type = _Op < _Args ... >;
    };
template < typename _Default, template < typename ... > class _Op,
    typename ... _Args >
    using __detected_or = __detector < _Default, void, _Op, _Args ... >;
template < typename _Default, template < typename ... > class _Op,
    typename ... _Args >
    using __detected_or_t
      = typename __detected_or < _Default, _Op, _Args ... > :: type;
template < template < typename ... > class _Default,
    template < typename ... > class _Op, typename ... _Args >
    using __detected_or_t_ =
      __detected_or_t < _Default < _Args ... >, _Op, _Args ... >;
template < typename _Tp >
    struct __is_swappable;
template < typename _Tp >
    struct __is_nothrow_swappable;
template < typename _Tp >
    inline
    typename enable_if < __and_ < is_move_constructible < _Tp >,
         is_move_assignable < _Tp > > :: value > :: type
    swap ( _Tp &, _Tp & )
    noexcept ( __and_ < is_nothrow_move_constructible < _Tp >,
             is_nothrow_move_assignable < _Tp >> :: value );
template < typename _Tp, size_t _Nm >
    inline
    typename enable_if < __is_swappable < _Tp > :: value > :: type
    swap ( _Tp ( & __a ) [ _Nm ], _Tp ( & __b ) [ _Nm ] )
    noexcept ( __is_nothrow_swappable < _Tp > :: value );
namespace __swappable_details
{
using std::swap;

struct __do_is_swappable_impl 
{
template < typename _Tp, typename
               = decltype ( swap ( std :: declval < _Tp & > ( ), std :: declval < _Tp & > ( ) ) ) >
        static true_type __test ( int );
template < typename >
        static false_type __test ( ... );
}
;

struct __do_is_nothrow_swappable_impl 
{
template < typename _Tp >
        static __bool_constant <
          noexcept ( swap ( std :: declval < _Tp & > ( ), std :: declval < _Tp & > ( ) ) )
        > __test ( int );
template < typename >
        static false_type __test ( ... );
}
;
}
template < typename _Tp >
    struct __is_swappable_impl
    : public __swappable_details :: __do_is_swappable_impl
    {
      typedef decltype ( __test < _Tp > ( 0 ) ) type;
    };
template < typename _Tp >
    struct __is_nothrow_swappable_impl
    : public __swappable_details :: __do_is_nothrow_swappable_impl
    {
      typedef decltype ( __test < _Tp > ( 0 ) ) type;
    };
template < typename _Tp >
    struct __is_swappable
    : public __is_swappable_impl < _Tp > :: type
    { };
template < typename _Tp >
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl < _Tp > :: type
    { };
}
namespace std
{
template < typename _Tp >
    constexpr _Tp &&
    forward ( typename std :: remove_reference < _Tp > :: type & __t ) noexcept
    { return static_cast < _Tp && > ( __t ); }
template < typename _Tp >
    constexpr _Tp &&
    forward ( typename std :: remove_reference < _Tp > :: type && __t ) noexcept
    {
      static_assert ( ! std :: is_lvalue_reference < _Tp > :: value, "template argument substituting _Tp is an lvalue reference type"
                                                     );
      return static_cast < _Tp && > ( __t );
    }
template < typename _Tp >
    constexpr typename std :: remove_reference < _Tp > :: type &&
    move ( _Tp && __t ) noexcept
    { return static_cast < typename std :: remove_reference < _Tp > :: type && > ( __t ); }
template < typename _Tp >
    struct __move_if_noexcept_cond
    : public __and_ < __not_ < is_nothrow_move_constructible < _Tp >>,
                    is_copy_constructible < _Tp >> :: type { };
template < typename _Tp >
    constexpr typename
    conditional < __move_if_noexcept_cond < _Tp > :: value, const _Tp &, _Tp && > :: type
    move_if_noexcept ( _Tp & __x ) noexcept
    { return std :: move ( __x ); }
template < typename _Tp >
    inline _Tp *
    addressof ( _Tp & __r ) noexcept
    { return std :: __addressof ( __r ); }
template < typename _Tp, typename _Up = _Tp >
    inline _Tp
    __exchange ( _Tp & __obj, _Up && __new_val )
    {
      _Tp __old_val = std :: move ( __obj );
      __obj = std :: forward < _Up > ( __new_val );
      return __old_val;
    }
}
namespace std
{
template < typename _Tp >
    inline
    typename enable_if < __and_ < is_move_constructible < _Tp >,
         is_move_assignable < _Tp > > :: value > :: type
    swap ( _Tp & __a, _Tp & __b )
    noexcept ( __and_ < is_nothrow_move_constructible < _Tp >,
             is_nothrow_move_assignable < _Tp >> :: value )
    {
      _Tp __tmp = std :: move ( __a );
      __a = std :: move ( __b );
      __b = std :: move ( __tmp );
    }
template < typename _Tp, size_t _Nm >
    inline
    typename enable_if < __is_swappable < _Tp > :: value > :: type
    swap ( _Tp ( & __a ) [ _Nm ], _Tp ( & __b ) [ _Nm ] )
    noexcept ( __is_nothrow_swappable < _Tp > :: value )
    {
      for ( size_t __n = 0; __n < _Nm; ++ __n )
 swap ( __a [ __n ], __b [ __n ] );
    }
}
namespace std
{

class nested_exception 
{
private: class __exception_ptr::exception_ptr _M_ptr;

public: inline nested_exception() : _M_ptr(current_exception())
{
}
inline nested_exception(const class nested_exception &) = default;

inline nested_exception &operator=(const class nested_exception &)
{
}
virtual ~nested_exception();

inline void rethrow_nested() const
{
if ((this) -> _M_ptr) 
rethrow_exception((this) -> _M_ptr);
terminate();
}

inline __exception_ptr::exception_ptr nested_ptr() const
{
return ((this) -> _M_ptr);
}
}
;
template < typename _Except >
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception ( const _Except & __ex )
      ;
      explicit _Nested_exception ( _Except && __ex )
      ;
    };
template < typename _Tp,
    bool __with_nested = ! __is_base_of ( nested_exception, _Tp ) >
    struct _Throw_with_nested_impl
    {
      template < typename _Up >
 static void _S_throw ( _Up && __t )
 { throw _Nested_exception < _Tp > { static_cast < _Up && > ( __t ) }; }
    };
template < typename _Tp >
    struct _Throw_with_nested_impl < _Tp, false >
    {
      template < typename _Up >
 static void _S_throw ( _Up && __t )
 { throw static_cast < _Up && > ( __t ); }
    };
template < typename _Tp, bool = __is_class ( _Tp ) && ! __is_final ( _Tp ) >
    struct _Throw_with_nested_helper : _Throw_with_nested_impl < _Tp >
    { };
template < typename _Tp >
    struct _Throw_with_nested_helper < _Tp, false >
    : _Throw_with_nested_impl < _Tp, false >
    { };
template < typename _Tp >
    struct _Throw_with_nested_helper < _Tp &, false >
    : _Throw_with_nested_helper < _Tp >
    { };
template < typename _Tp >
    struct _Throw_with_nested_helper < _Tp &&, false >
    : _Throw_with_nested_helper < _Tp >
    { };
template < typename _Tp >
    [ [ noreturn ] ]
    inline void
    throw_with_nested ( _Tp && __t )
    {
      _Throw_with_nested_helper < _Tp > :: _S_throw ( static_cast < _Tp && > ( __t ) );
    }
template < typename _Tp, bool = __is_polymorphic ( _Tp ) >
    struct _Rethrow_if_nested_impl
    {
      static void _S_rethrow ( const _Tp & __t )
      ;
    };
template < typename _Tp >
    struct _Rethrow_if_nested_impl < _Tp, false >
    {
      static void _S_rethrow ( const _Tp & );
    };
template < typename _Ex >
    inline void
    rethrow_if_nested ( const _Ex & __ex )
    {
      _Rethrow_if_nested_impl < _Ex > :: _S_rethrow ( __ex );
    }
}
#pragma GCC visibility pop
namespace std
{
void __throw_bad_exception() __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_bad_alloc() __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_bad_cast() __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_bad_typeid() __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_logic_error(const char *) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_domain_error(const char *) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_invalid_argument(const char *) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_length_error(const char *) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_out_of_range(const char *) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_out_of_range_fmt(const char *,... ) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_runtime_error(const char *) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_range_error(const char *) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_overflow_error(const char *) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_underflow_error(const char *) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_ios_failure(const char *) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_system_error(int ) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_future_error(int ) __attribute__((visibility("default")))  __attribute__((noreturn));
void __throw_bad_function_call() __attribute__((visibility("default")))  __attribute__((noreturn));
}
namespace __gnu_cxx
{
template < typename _Value >
    struct __numeric_traits_integer
    {
      static const _Value __min = ( ( ( _Value ) ( - 1 ) < 0 ) ? ( _Value ) 1 << ( sizeof ( _Value ) * 8 - ( ( _Value ) ( - 1 ) < 0 ) ) : ( _Value ) 0 );
      static const _Value __max = ( ( ( _Value ) ( - 1 ) < 0 ) ? ( ( ( ( ( _Value ) 1 << ( ( sizeof ( _Value ) * 8 - ( ( _Value ) ( - 1 ) < 0 ) ) - 1 ) ) - 1 ) << 1 ) + 1 ) : ~ ( _Value ) 0 );
      static const bool __is_signed = ( ( _Value ) ( - 1 ) < 0 );
      static const int __digits = ( sizeof ( _Value ) * 8 - ( ( _Value ) ( - 1 ) < 0 ) );
    };
template < typename _Value >
    const _Value __numeric_traits_integer < _Value > :: __min;
template < typename _Value >
    const _Value __numeric_traits_integer < _Value > :: __max;
template < typename _Value >
    const bool __numeric_traits_integer < _Value > :: __is_signed;
template < typename _Value >
    const int __numeric_traits_integer < _Value > :: __digits;
template < typename _Value >
    struct __numeric_traits_floating
    {
      static const int __max_digits10 = ( 2 + ( std :: __are_same < _Value, float > :: __value ? 24 : std :: __are_same < _Value, double > :: __value ? 53 : 64 ) * 643L / 2136 );
      static const bool __is_signed = true;
      static const int __digits10 = ( std :: __are_same < _Value, float > :: __value ? 6 : std :: __are_same < _Value, double > :: __value ? 15 : 18 );
      static const int __max_exponent10 = ( std :: __are_same < _Value, float > :: __value ? 38 : std :: __are_same < _Value, double > :: __value ? 308 : 4932 );
    };
template < typename _Value >
    const int __numeric_traits_floating < _Value > :: __max_digits10;
template < typename _Value >
    const bool __numeric_traits_floating < _Value > :: __is_signed;
template < typename _Value >
    const int __numeric_traits_floating < _Value > :: __digits10;
template < typename _Value >
    const int __numeric_traits_floating < _Value > :: __max_exponent10;
template < typename _Value >
    struct __numeric_traits
    : public __conditional_type < std :: __is_integer < _Value > :: __value,
    __numeric_traits_integer < _Value >,
    __numeric_traits_floating < _Value > > :: __type
    { };
}
namespace std
{

struct piecewise_construct_t 
{
inline explicit piecewise_construct_t() = default;
}
;
constexpr struct piecewise_construct_t piecewise_construct;
template < typename ... >
    class tuple;
template < std :: size_t ... >
    struct _Index_tuple;
template < typename _T1, typename _T2, typename _U1, typename _U2 >
  constexpr bool _ConstructiblePair ( )
  {
    return __and_ < __or_ < is_same < typename decay < _T1 > :: type,
    typename decay < _U1 > :: type >,
   is_constructible < _T1, const _U1 & >>,
    __or_ < is_same < typename decay < _T2 > :: type,
    typename decay < _U2 > :: type >,
   is_constructible < _T2, const _U2 & >>> :: value;
  }
template < typename _T1, typename _T2, typename _U1, typename _U2 >
  constexpr bool _ImplicitlyConvertiblePair ( )
  {
    return __and_ < __or_ < is_same < typename decay < _T1 > :: type,
    typename decay < _U1 > :: type >,
   is_convertible < const _U1 &, _T1 >>,
    __or_ < is_same < typename decay < _T2 > :: type,
    typename decay < _U2 > :: type >,
         is_convertible < const _U2 &, _T2 >>> :: value;
  }
template < typename _T1, typename _T2, typename _U1, typename _U2 >
  constexpr bool _MoveConstructiblePair ( )
  {
    return __and_ < __or_ < is_same < typename decay < _T1 > :: type,
    typename decay < _U1 > :: type >,
   is_constructible < _T1, _U1 && >>,
    __or_ < is_same < typename decay < _T2 > :: type,
    typename decay < _U2 > :: type >,
   is_constructible < _T2, _U2 && >>> :: value;
  }
template < typename _T1, typename _T2, typename _U1, typename _U2 >
  constexpr bool _ImplicitlyMoveConvertiblePair ( )
  {
    return __and_ < __or_ < is_same < typename decay < _T1 > :: type,
    typename decay < _U1 > :: type >,
   is_convertible < _U1 &&, _T1 >>,
    __or_ < is_same < typename decay < _T2 > :: type,
    typename decay < _U2 > :: type >,
         is_convertible < _U2 &&, _T2 >>> :: value;
  }
template < typename _T1, typename _T2 >
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;
      _T1 first;
      _T2 second;
      template < typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if < __and_ <
                                     __is_implicitly_default_constructible < _U1 >,
                                     __is_implicitly_default_constructible < _U2 >>
                                   :: value, bool > :: type = true >
      constexpr pair ( )
      : first ( ), second ( ) { }
      template < typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if < __and_ <
                       is_default_constructible < _U1 >,
                       is_default_constructible < _U2 >,
                       __not_ <
                         __and_ < __is_implicitly_default_constructible < _U1 >,
                                __is_implicitly_default_constructible < _U2 >>> >
                                   :: value, bool > :: type = false >
      explicit constexpr pair ( )
      : first ( ), second ( ) { }
      template < typename _U1 = _T1, typename _U2 = _T2, typename
                enable_if < _ConstructiblePair < _T1, _T2, _U1, _U2 > ( )
                         && _ImplicitlyConvertiblePair < _T1, _T2, _U1, _U2 > ( ),
                         bool > :: type = true >
      constexpr pair ( const _T1 & __a, const _T2 & __b )
      : first ( __a ), second ( __b ) { }
       template < typename _U1 = _T1, typename _U2 = _T2, typename
        enable_if < _ConstructiblePair < _T1, _T2, _U1, _U2 > ( )
                         && ! _ImplicitlyConvertiblePair < _T1, _T2, _U1, _U2 > ( ),
                         bool > :: type = false >
      explicit constexpr pair ( const _T1 & __a, const _T2 & __b )
      : first ( __a ), second ( __b ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _ConstructiblePair < _T1, _T2, _U1, _U2 > ( )
                         && _ImplicitlyConvertiblePair < _T1, _T2, _U1, _U2 > ( ),
                         bool > :: type = true >
        constexpr pair ( const pair < _U1, _U2 > & __p )
        : first ( __p . first ), second ( __p . second ) { }
      template < typename _U1, typename _U2, typename
               enable_if < _ConstructiblePair < _T1, _T2, _U1, _U2 > ( )
                         && ! _ImplicitlyConvertiblePair < _T1, _T2, _U1, _U2 > ( ),
                         bool > :: type = false >
 explicit constexpr pair ( const pair < _U1, _U2 > & __p )
 : first ( __p . first ), second ( __p . second ) { }
      constexpr pair ( const pair & ) = default;
      constexpr pair ( pair && ) = default;
      template < typename _U1, typename
               enable_if < _ConstructiblePair < _T2, _T2, _T2, _T2 > ( )
                         && _MoveConstructiblePair < _T1, _T2, _U1, _T2 > ( )
                         && _ImplicitlyConvertiblePair < _T2, _T2, _T2, _T2 > ( )
                         && _ImplicitlyMoveConvertiblePair < _T1, _T2,
         _U1, _T2 > ( ),
                         bool > :: type = true >
       constexpr pair ( _U1 && __x, const _T2 & __y )
       : first ( std :: forward < _U1 > ( __x ) ), second ( __y ) { }
      template < typename _U1, typename
               enable_if < _ConstructiblePair < _T2, _T2, _T2, _T2 > ( )
                         && _MoveConstructiblePair < _T1, _T2, _U1, _T2 > ( )
                         && ( ! _ImplicitlyConvertiblePair < _T2, _T2, _T2, _T2 > ( )
                             || ! _ImplicitlyMoveConvertiblePair < _T1, _T2,
                                                                _U1, _T2 > ( ) ),
                         bool > :: type = false >
       explicit constexpr pair ( _U1 && __x, const _T2 & __y )
       : first ( std :: forward < _U1 > ( __x ) ), second ( __y ) { }
      template < typename _U2, typename
               enable_if < _ConstructiblePair < _T1, _T1, _T1, _T1 > ( )
                         && _MoveConstructiblePair < _T1, _T2, _T1, _U2 > ( )
                         && _ImplicitlyConvertiblePair < _T1, _T1, _T1, _T1 > ( )
                         && _ImplicitlyMoveConvertiblePair < _T1, _T2,
                                                           _T1, _U2 > ( ),
                         bool > :: type = true >
       constexpr pair ( const _T1 & __x, _U2 && __y )
       : first ( __x ), second ( std :: forward < _U2 > ( __y ) ) { }
      template < typename _U2, typename
               enable_if < _ConstructiblePair < _T1, _T1, _T1, _T1 > ( )
                         && _MoveConstructiblePair < _T1, _T2, _T1, _U2 > ( )
                         && ( ! _ImplicitlyConvertiblePair < _T1, _T1, _T1, _T1 > ( )
                             || ! _ImplicitlyMoveConvertiblePair < _T1, _T2,
                                                                _T1, _U2 > ( ) ),
                         bool > :: type = false >
       explicit pair ( const _T1 & __x, _U2 && __y )
       : first ( __x ), second ( std :: forward < _U2 > ( __y ) ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _MoveConstructiblePair < _T1, _T2, _U1, _U2 > ( )
                         && _ImplicitlyMoveConvertiblePair < _T1, _T2,
          _U1, _U2 > ( ),
                         bool > :: type = true >
 constexpr pair ( _U1 && __x, _U2 && __y )
 : first ( std :: forward < _U1 > ( __x ) ), second ( std :: forward < _U2 > ( __y ) ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _MoveConstructiblePair < _T1, _T2, _U1, _U2 > ( )
                         && ! _ImplicitlyMoveConvertiblePair < _T1, _T2,
           _U1, _U2 > ( ),
                         bool > :: type = false >
 explicit constexpr pair ( _U1 && __x, _U2 && __y )
 : first ( std :: forward < _U1 > ( __x ) ), second ( std :: forward < _U2 > ( __y ) ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _MoveConstructiblePair < _T1, _T2, _U1, _U2 > ( )
                         && _ImplicitlyMoveConvertiblePair < _T1, _T2,
          _U1, _U2 > ( ),
                         bool > :: type = true >
 constexpr pair ( pair < _U1, _U2 > && __p )
 : first ( std :: forward < _U1 > ( __p . first ) ),
   second ( std :: forward < _U2 > ( __p . second ) ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _MoveConstructiblePair < _T1, _T2, _U1, _U2 > ( )
                         && ! _ImplicitlyMoveConvertiblePair < _T1, _T2,
          _U1, _U2 > ( ),
                         bool > :: type = false >
 explicit constexpr pair ( pair < _U1, _U2 > && __p )
 : first ( std :: forward < _U1 > ( __p . first ) ),
   second ( std :: forward < _U2 > ( __p . second ) ) { }
      template < typename ... _Args1, typename ... _Args2 >
        pair ( piecewise_construct_t, tuple < _Args1 ... >, tuple < _Args2 ... > );
      pair &
      operator = ( const pair & __p )
      ;
      pair &
      operator = ( pair && __p )
      noexcept ( __and_ < is_nothrow_move_assignable < _T1 >,
               is_nothrow_move_assignable < _T2 >> :: value )
      ;
      template < typename _U1, typename _U2 >
 pair &
 operator = ( const pair < _U1, _U2 > & __p )
 {
   first = __p . first;
   second = __p . second;
   return * this;
 }
      template < typename _U1, typename _U2 >
 pair &
 operator = ( pair < _U1, _U2 > && __p )
 {
   first = std :: forward < _U1 > ( __p . first );
   second = std :: forward < _U2 > ( __p . second );
   return * this;
 }
      void
      swap ( pair & __p )
      noexcept ( __is_nothrow_swappable < _T1 > :: value
               && __is_nothrow_swappable < _T2 > :: value )
      ;
    private :
      template < typename ... _Args1, std :: size_t ... _Indexes1,
               typename ... _Args2, std :: size_t ... _Indexes2 >
        pair ( tuple < _Args1 ... > &, tuple < _Args2 ... > &,
             _Index_tuple < _Indexes1 ... >, _Index_tuple < _Indexes2 ... > );
    };
template < typename _T1, typename _T2 >
    inline constexpr bool
    operator == ( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y )
    { return __x . first == __y . first && __x . second == __y . second; }
template < typename _T1, typename _T2 >
    inline constexpr bool
    operator < ( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y )
    { return __x . first < __y . first
      || ( ! ( __y . first < __x . first ) && __x . second < __y . second ); }
template < typename _T1, typename _T2 >
    inline constexpr bool
    operator != ( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y )
    { return ! ( __x == __y ); }
template < typename _T1, typename _T2 >
    inline constexpr bool
    operator > ( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y )
    { return __y < __x; }
template < typename _T1, typename _T2 >
    inline constexpr bool
    operator <= ( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y )
    { return ! ( __y < __x ); }
template < typename _T1, typename _T2 >
    inline constexpr bool
    operator >= ( const pair < _T1, _T2 > & __x, const pair < _T1, _T2 > & __y )
    { return ! ( __x < __y ); }
template < typename _T1, typename _T2 >
    inline void
    swap ( pair < _T1, _T2 > & __x, pair < _T1, _T2 > & __y )
    noexcept ( noexcept ( __x . swap ( __y ) ) )
    { __x . swap ( __y ); }
template < typename _T1, typename _T2 >
    constexpr pair < typename __decay_and_strip < _T1 > :: __type,
                   typename __decay_and_strip < _T2 > :: __type >
    make_pair ( _T1 && __x, _T2 && __y )
    {
      typedef typename __decay_and_strip < _T1 > :: __type __ds_type1;
      typedef typename __decay_and_strip < _T2 > :: __type __ds_type2;
      typedef pair < __ds_type1, __ds_type2 > __pair_type;
      return __pair_type ( std :: forward < _T1 > ( __x ), std :: forward < _T2 > ( __y ) );
    }
}
namespace std
{

struct input_iterator_tag 
{
}
;

struct output_iterator_tag 
{
}
;

struct forward_iterator_tag : public input_iterator_tag
{
}
;

struct bidirectional_iterator_tag : public forward_iterator_tag
{
}
;

struct random_access_iterator_tag : public bidirectional_iterator_tag
{
}
;
template < typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp *, typename _Reference = _Tp & >
    struct iterator
    {
      typedef _Category iterator_category;
      typedef _Tp value_type;
      typedef _Distance difference_type;
      typedef _Pointer pointer;
      typedef _Reference reference;
    };
template < typename _Iterator, typename = __void_t < > >
    struct __iterator_traits { };
template < typename _Iterator >
    struct __iterator_traits < _Iterator,
        __void_t < typename _Iterator :: iterator_category,
          typename _Iterator :: value_type,
          typename _Iterator :: difference_type,
          typename _Iterator :: pointer,
          typename _Iterator :: reference > >
    {
      typedef typename _Iterator :: iterator_category iterator_category;
      typedef typename _Iterator :: value_type value_type;
      typedef typename _Iterator :: difference_type difference_type;
      typedef typename _Iterator :: pointer pointer;
      typedef typename _Iterator :: reference reference;
    };
template < typename _Iterator >
    struct iterator_traits
    : public __iterator_traits < _Iterator > { };
template < typename _Tp >
    struct iterator_traits < _Tp * >
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp * pointer;
      typedef _Tp & reference;
    };
template < typename _Tp >
    struct iterator_traits < const _Tp * >
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp * pointer;
      typedef const _Tp & reference;
    };
template < typename _Iter >
    inline typename iterator_traits < _Iter > :: iterator_category
    __iterator_category ( const _Iter & )
    { return typename iterator_traits < _Iter > :: iterator_category ( ); }
template < typename _InIter >
    using _RequireInputIter = typename
      enable_if < is_convertible < typename
  iterator_traits < _InIter > :: iterator_category,
          input_iterator_tag > :: value > :: type;
}
namespace std
{
template < typename > struct _List_iterator;
template < typename > struct _List_const_iterator;
template < typename _InputIterator >
    inline typename iterator_traits < _InputIterator > :: difference_type
    __distance ( _InputIterator __first, _InputIterator __last,
               input_iterator_tag )
    {
      typename iterator_traits < _InputIterator > :: difference_type __n = 0;
      while ( __first != __last )
 {
   ++ __first;
   ++ __n;
 }
      return __n;
    }
template < typename _RandomAccessIterator >
    inline typename iterator_traits < _RandomAccessIterator > :: difference_type
    __distance ( _RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag )
    {
      return __last - __first;
    }
template < typename _Tp >
    ptrdiff_t
    __distance ( std :: _List_iterator < _Tp >,
        std :: _List_iterator < _Tp >,
        input_iterator_tag );
template < typename _Tp >
    ptrdiff_t
    __distance ( std :: _List_const_iterator < _Tp >,
        std :: _List_const_iterator < _Tp >,
        input_iterator_tag );
template < typename _InputIterator >
    inline typename iterator_traits < _InputIterator > :: difference_type
    distance ( _InputIterator __first, _InputIterator __last )
    {
      return std :: __distance ( __first, __last,
        std :: __iterator_category ( __first ) );
    }
template < typename _InputIterator, typename _Distance >
    inline void
    __advance ( _InputIterator & __i, _Distance __n, input_iterator_tag )
    {
      ;
      while ( __n -- )
 ++ __i;
    }
template < typename _BidirectionalIterator, typename _Distance >
    inline void
    __advance ( _BidirectionalIterator & __i, _Distance __n,
       bidirectional_iterator_tag )
    {
      if ( __n > 0 )
        while ( __n -- )
   ++ __i;
      else
        while ( __n ++ )
   -- __i;
    }
template < typename _RandomAccessIterator, typename _Distance >
    inline void
    __advance ( _RandomAccessIterator & __i, _Distance __n,
              random_access_iterator_tag )
    {
      __i += __n;
    }
template < typename _InputIterator, typename _Distance >
    inline void
    advance ( _InputIterator & __i, _Distance __n )
    {
      typename iterator_traits < _InputIterator > :: difference_type __d = __n;
      std :: __advance ( __i, __d, std :: __iterator_category ( __i ) );
    }
template < typename _ForwardIterator >
    inline _ForwardIterator
    next ( _ForwardIterator __x, typename
  iterator_traits < _ForwardIterator > :: difference_type __n = 1 )
    {
      std :: advance ( __x, __n );
      return __x;
    }
template < typename _BidirectionalIterator >
    inline _BidirectionalIterator
    prev ( _BidirectionalIterator __x, typename
  iterator_traits < _BidirectionalIterator > :: difference_type __n = 1 )
    {
      std :: advance ( __x, - __n );
      return __x;
    }
}
namespace std
{
class __undefined ;
template < typename _Tp >
    struct __get_first_arg
    { using type = __undefined; };
template < template < typename, typename ... > class _Template, typename _Tp,
           typename ... _Types >
    struct __get_first_arg < _Template < _Tp, _Types ... > >
    { using type = _Tp; };
template < typename _Tp >
    using __get_first_arg_t = typename __get_first_arg < _Tp > :: type;
template < typename _Tp, typename _Up >
    struct __replace_first_arg
    { using type = __undefined; };
template < template < typename, typename ... > class _Template, typename _Up,
           typename _Tp, typename ... _Types >
    struct __replace_first_arg < _Template < _Tp, _Types ... >, _Up >
    { using type = _Template < _Up, _Types ... >; };
template < typename _Tp, typename _Up >
    using __replace_first_arg_t = typename __replace_first_arg < _Tp, _Up > :: type;
template < typename _Tp >
    using __make_not_void
      = typename conditional < is_void < _Tp > :: value, __undefined, _Tp > :: type;
template < typename _Ptr >
    struct pointer_traits
    {
    private :
      template < typename _Tp >
 using __element_type = typename _Tp :: element_type;
      template < typename _Tp >
 using __difference_type = typename _Tp :: difference_type;
      template < typename _Tp, typename _Up >
 using __rebind = typename _Tp :: template rebind < _Up >;
    public :
      using pointer = _Ptr;
      using element_type
 = __detected_or_t_ < __get_first_arg_t, __element_type, _Ptr >;
      using difference_type
 = __detected_or_t < ptrdiff_t, __difference_type, _Ptr >;
      template < typename _Up >
        using rebind
   = __detected_or_t_ < __replace_first_arg_t, __rebind, _Ptr, _Up >;
      static _Ptr
      pointer_to ( __make_not_void < element_type > & __e )
      ;
      static_assert ( ! is_same < element_type, __undefined > :: value,
   "pointer type defines element_type or is like SomePointer<T, Args>" );
      static_assert ( ! is_same < rebind < element_type >, __undefined > :: value,
   "pointer type defines rebind<U> or is like SomePointer<T, Args>" );
    };
template < typename _Tp >
    struct pointer_traits < _Tp * >
    {
      typedef _Tp * pointer;
      typedef _Tp element_type;
      typedef ptrdiff_t difference_type;
      template < typename _Up >
        using rebind = _Up *;
      static pointer
      pointer_to ( __make_not_void < element_type > & __r ) noexcept
      ;
    };
template < typename _Ptr, typename _Tp >
    using __ptr_rebind = typename pointer_traits < _Ptr > :: template rebind < _Tp >;
}
namespace std
{
template < typename _Iterator >
    class reverse_iterator
    : public iterator < typename iterator_traits < _Iterator > :: iterator_category,
        typename iterator_traits < _Iterator > :: value_type,
        typename iterator_traits < _Iterator > :: difference_type,
        typename iterator_traits < _Iterator > :: pointer,
                      typename iterator_traits < _Iterator > :: reference >
    {
    protected :
      _Iterator current;
      typedef iterator_traits < _Iterator > __traits_type;
    public :
      typedef _Iterator iterator_type;
      typedef typename __traits_type :: difference_type difference_type;
      typedef typename __traits_type :: pointer pointer;
      typedef typename __traits_type :: reference reference;
      reverse_iterator ( );
      explicit
      reverse_iterator ( iterator_type __x );
      reverse_iterator ( const reverse_iterator & __x )
      ;
      template < typename _Iter >
        reverse_iterator ( const reverse_iterator < _Iter > & __x )
 : current ( __x . base ( ) ) { }
      iterator_type
      base ( ) const
      ;
      reference
      operator * ( ) const
      ;
      pointer
      operator -> ( ) const
      ;
      reverse_iterator &
      operator ++ ( )
      ;
      reverse_iterator
      operator ++ ( int )
      ;
      reverse_iterator &
      operator -- ( )
      ;
      reverse_iterator
      operator -- ( int )
      ;
      reverse_iterator
      operator + ( difference_type __n ) const
      ;
      reverse_iterator &
      operator += ( difference_type __n )
      ;
      reverse_iterator
      operator - ( difference_type __n ) const
      ;
      reverse_iterator &
      operator -= ( difference_type __n )
      ;
      reference
      operator [ ] ( difference_type __n ) const
      ;
    };
template < typename _Iterator >
    inline bool
    operator == ( const reverse_iterator < _Iterator > & __x,
        const reverse_iterator < _Iterator > & __y )
    { return __x . base ( ) == __y . base ( ); }
template < typename _Iterator >
    inline bool
    operator < ( const reverse_iterator < _Iterator > & __x,
       const reverse_iterator < _Iterator > & __y )
    { return __y . base ( ) < __x . base ( ); }
template < typename _Iterator >
    inline bool
    operator != ( const reverse_iterator < _Iterator > & __x,
        const reverse_iterator < _Iterator > & __y )
    { return ! ( __x == __y ); }
template < typename _Iterator >
    inline bool
    operator > ( const reverse_iterator < _Iterator > & __x,
       const reverse_iterator < _Iterator > & __y )
    { return __y < __x; }
template < typename _Iterator >
    inline bool
    operator <= ( const reverse_iterator < _Iterator > & __x,
        const reverse_iterator < _Iterator > & __y )
    { return ! ( __y < __x ); }
template < typename _Iterator >
    inline bool
    operator >= ( const reverse_iterator < _Iterator > & __x,
        const reverse_iterator < _Iterator > & __y )
    { return ! ( __x < __y ); }
template < typename _Iterator >
    inline typename reverse_iterator < _Iterator > :: difference_type
    operator - ( const reverse_iterator < _Iterator > & __x,
       const reverse_iterator < _Iterator > & __y )
    { return __y . base ( ) - __x . base ( ); }
template < typename _Iterator >
    inline reverse_iterator < _Iterator >
    operator + ( typename reverse_iterator < _Iterator > :: difference_type __n,
       const reverse_iterator < _Iterator > & __x )
    { return reverse_iterator < _Iterator > ( __x . base ( ) - __n ); }
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator == ( const reverse_iterator < _IteratorL > & __x,
        const reverse_iterator < _IteratorR > & __y )
    { return __x . base ( ) == __y . base ( ); }
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator < ( const reverse_iterator < _IteratorL > & __x,
       const reverse_iterator < _IteratorR > & __y )
    { return __y . base ( ) < __x . base ( ); }
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator != ( const reverse_iterator < _IteratorL > & __x,
        const reverse_iterator < _IteratorR > & __y )
    { return ! ( __x == __y ); }
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator > ( const reverse_iterator < _IteratorL > & __x,
       const reverse_iterator < _IteratorR > & __y )
    { return __y < __x; }
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator <= ( const reverse_iterator < _IteratorL > & __x,
        const reverse_iterator < _IteratorR > & __y )
    { return ! ( __y < __x ); }
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator >= ( const reverse_iterator < _IteratorL > & __x,
        const reverse_iterator < _IteratorR > & __y )
    { return ! ( __x < __y ); }
template < typename _IteratorL, typename _IteratorR >
    inline auto
    operator - ( const reverse_iterator < _IteratorL > & __x,
       const reverse_iterator < _IteratorR > & __y )
    -> decltype ( __y . base ( ) - __x . base ( ) )
    { return __y . base ( ) - __x . base ( ); }
template < typename _Iterator >
    inline reverse_iterator < _Iterator >
    __make_reverse_iterator ( _Iterator __i )
    { return reverse_iterator < _Iterator > ( __i ); }
template < typename _Iterator >
    inline reverse_iterator < _Iterator >
    make_reverse_iterator ( _Iterator __i )
    { return reverse_iterator < _Iterator > ( __i ); }
template < typename _Iterator >
    auto
    __niter_base ( reverse_iterator < _Iterator > __it )
    -> decltype ( __make_reverse_iterator ( __niter_base ( __it . base ( ) ) ) )
    { return __make_reverse_iterator ( __niter_base ( __it . base ( ) ) ); }
template < typename _Iterator >
    struct __is_move_iterator < reverse_iterator < _Iterator > >
      : __is_move_iterator < _Iterator >
    { };
template < typename _Iterator >
    auto
    __miter_base ( reverse_iterator < _Iterator > __it )
    -> decltype ( __make_reverse_iterator ( __miter_base ( __it . base ( ) ) ) )
    { return __make_reverse_iterator ( __miter_base ( __it . base ( ) ) ); }
template < typename _Container >
    class back_insert_iterator
    : public iterator < output_iterator_tag, void, void, void, void >
    {
    protected :
      _Container * container;
    public :
      typedef _Container container_type;
      explicit
      back_insert_iterator ( _Container & __x )
      ;
      back_insert_iterator &
      operator = ( const typename _Container :: value_type & __value )
      ;
      back_insert_iterator &
      operator = ( typename _Container :: value_type && __value )
      ;
      back_insert_iterator &
      operator * ( )
      ;
      back_insert_iterator &
      operator ++ ( )
      ;
      back_insert_iterator
      operator ++ ( int )
      ;
    };
template < typename _Container >
    inline back_insert_iterator < _Container >
    back_inserter ( _Container & __x )
    { return back_insert_iterator < _Container > ( __x ); }
template < typename _Container >
    class front_insert_iterator
    : public iterator < output_iterator_tag, void, void, void, void >
    {
    protected :
      _Container * container;
    public :
      typedef _Container container_type;
      explicit front_insert_iterator ( _Container & __x )
      ;
      front_insert_iterator &
      operator = ( const typename _Container :: value_type & __value )
      ;
      front_insert_iterator &
      operator = ( typename _Container :: value_type && __value )
      ;
      front_insert_iterator &
      operator * ( )
      ;
      front_insert_iterator &
      operator ++ ( )
      ;
      front_insert_iterator
      operator ++ ( int )
      ;
    };
template < typename _Container >
    inline front_insert_iterator < _Container >
    front_inserter ( _Container & __x )
    { return front_insert_iterator < _Container > ( __x ); }
template < typename _Container >
    class insert_iterator
    : public iterator < output_iterator_tag, void, void, void, void >
    {
    protected :
      _Container * container;
      typename _Container :: iterator iter;
    public :
      typedef _Container container_type;
      insert_iterator ( _Container & __x, typename _Container :: iterator __i )
      ;
      insert_iterator &
      operator = ( const typename _Container :: value_type & __value )
      ;
      insert_iterator &
      operator = ( typename _Container :: value_type && __value )
      ;
      insert_iterator &
      operator * ( )
      ;
      insert_iterator &
      operator ++ ( )
      ;
      insert_iterator &
      operator ++ ( int )
      ;
    };
template < typename _Container, typename _Iterator >
    inline insert_iterator < _Container >
    inserter ( _Container & __x, _Iterator __i )
    {
      return insert_iterator < _Container > ( __x,
      typename _Container :: iterator ( __i ) );
    }
}
namespace __gnu_cxx
{
using std::iterator_traits;
using std::iterator;
template < typename _Iterator, typename _Container >
    class __normal_iterator
    {
    protected :
      _Iterator _M_current;
      typedef iterator_traits < _Iterator > __traits_type;
    public :
      typedef _Iterator iterator_type;
      typedef typename __traits_type :: iterator_category iterator_category;
      typedef typename __traits_type :: value_type value_type;
      typedef typename __traits_type :: difference_type difference_type;
      typedef typename __traits_type :: reference reference;
      typedef typename __traits_type :: pointer pointer;
      constexpr __normal_iterator ( ) noexcept
      ;
      explicit
      __normal_iterator ( const _Iterator & __i ) noexcept
      ;
      template < typename _Iter >
        __normal_iterator ( const __normal_iterator < _Iter,
     typename __enable_if <
              ( std :: __are_same < _Iter, typename _Container :: pointer > :: __value ),
        _Container > :: __type > & __i ) noexcept
        : _M_current ( __i . base ( ) ) { }
      reference
      operator * ( ) const noexcept
      ;
      pointer
      operator -> ( ) const noexcept
      ;
      __normal_iterator &
      operator ++ ( ) noexcept
      ;
      __normal_iterator
      operator ++ ( int ) noexcept
      ;
      __normal_iterator &
      operator -- ( ) noexcept
      ;
      __normal_iterator
      operator -- ( int ) noexcept
      ;
      reference
      operator [ ] ( difference_type __n ) const noexcept
      ;
      __normal_iterator &
      operator += ( difference_type __n ) noexcept
      ;
      __normal_iterator
      operator + ( difference_type __n ) const noexcept
      ;
      __normal_iterator &
      operator -= ( difference_type __n ) noexcept
      ;
      __normal_iterator
      operator - ( difference_type __n ) const noexcept
      ;
      const _Iterator &
      base ( ) const noexcept
      ;
    };
template < typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool
    operator == ( const __normal_iterator < _IteratorL, _Container > & __lhs,
        const __normal_iterator < _IteratorR, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) == __rhs . base ( ); }
template < typename _Iterator, typename _Container >
    inline bool
    operator == ( const __normal_iterator < _Iterator, _Container > & __lhs,
        const __normal_iterator < _Iterator, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) == __rhs . base ( ); }
template < typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool
    operator != ( const __normal_iterator < _IteratorL, _Container > & __lhs,
        const __normal_iterator < _IteratorR, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) != __rhs . base ( ); }
template < typename _Iterator, typename _Container >
    inline bool
    operator != ( const __normal_iterator < _Iterator, _Container > & __lhs,
        const __normal_iterator < _Iterator, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) != __rhs . base ( ); }
template < typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool
    operator < ( const __normal_iterator < _IteratorL, _Container > & __lhs,
       const __normal_iterator < _IteratorR, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) < __rhs . base ( ); }
template < typename _Iterator, typename _Container >
    inline bool
    operator < ( const __normal_iterator < _Iterator, _Container > & __lhs,
       const __normal_iterator < _Iterator, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) < __rhs . base ( ); }
template < typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool
    operator > ( const __normal_iterator < _IteratorL, _Container > & __lhs,
       const __normal_iterator < _IteratorR, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) > __rhs . base ( ); }
template < typename _Iterator, typename _Container >
    inline bool
    operator > ( const __normal_iterator < _Iterator, _Container > & __lhs,
       const __normal_iterator < _Iterator, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) > __rhs . base ( ); }
template < typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool
    operator <= ( const __normal_iterator < _IteratorL, _Container > & __lhs,
        const __normal_iterator < _IteratorR, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) <= __rhs . base ( ); }
template < typename _Iterator, typename _Container >
    inline bool
    operator <= ( const __normal_iterator < _Iterator, _Container > & __lhs,
        const __normal_iterator < _Iterator, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) <= __rhs . base ( ); }
template < typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool
    operator >= ( const __normal_iterator < _IteratorL, _Container > & __lhs,
        const __normal_iterator < _IteratorR, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) >= __rhs . base ( ); }
template < typename _Iterator, typename _Container >
    inline bool
    operator >= ( const __normal_iterator < _Iterator, _Container > & __lhs,
        const __normal_iterator < _Iterator, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) >= __rhs . base ( ); }
template < typename _IteratorL, typename _IteratorR, typename _Container >
    inline auto
    operator - ( const __normal_iterator < _IteratorL, _Container > & __lhs,
       const __normal_iterator < _IteratorR, _Container > & __rhs ) noexcept
    -> decltype ( __lhs . base ( ) - __rhs . base ( ) )
    { return __lhs . base ( ) - __rhs . base ( ); }
template < typename _Iterator, typename _Container >
    inline typename __normal_iterator < _Iterator, _Container > :: difference_type
    operator - ( const __normal_iterator < _Iterator, _Container > & __lhs,
       const __normal_iterator < _Iterator, _Container > & __rhs )
    noexcept
    { return __lhs . base ( ) - __rhs . base ( ); }
template < typename _Iterator, typename _Container >
    inline __normal_iterator < _Iterator, _Container >
    operator + ( typename __normal_iterator < _Iterator, _Container > :: difference_type
       __n, const __normal_iterator < _Iterator, _Container > & __i )
    noexcept
    { return __normal_iterator < _Iterator, _Container > ( __i . base ( ) + __n ); }
}
namespace std
{
template < typename _Iterator, typename _Container >
    _Iterator
    __niter_base ( __gnu_cxx :: __normal_iterator < _Iterator, _Container > __it )
    { return __it . base ( ); }
}
namespace std
{
template < typename _Iterator >
    class move_iterator
    {
    protected :
      _Iterator _M_current;
      typedef iterator_traits < _Iterator > __traits_type;
      typedef typename __traits_type :: reference __base_ref;
    public :
      typedef _Iterator iterator_type;
      typedef typename __traits_type :: iterator_category iterator_category;
      typedef typename __traits_type :: value_type value_type;
      typedef typename __traits_type :: difference_type difference_type;
      typedef _Iterator pointer;
      typedef typename conditional < is_reference < __base_ref > :: value,
    typename remove_reference < __base_ref > :: type &&,
    __base_ref > :: type reference;
      move_iterator ( )
      ;
      explicit
      move_iterator ( iterator_type __i )
      ;
      template < typename _Iter >
 move_iterator ( const move_iterator < _Iter > & __i )
 : _M_current ( __i . base ( ) ) { }
      iterator_type
      base ( ) const
      ;
      reference
      operator * ( ) const
      ;
      pointer
      operator -> ( ) const
      ;
      move_iterator &
      operator ++ ( )
      ;
      move_iterator
      operator ++ ( int )
      ;
      move_iterator &
      operator -- ( )
      ;
      move_iterator
      operator -- ( int )
      ;
      move_iterator
      operator + ( difference_type __n ) const
      ;
      move_iterator &
      operator += ( difference_type __n )
      ;
      move_iterator
      operator - ( difference_type __n ) const
      ;
      move_iterator &
      operator -= ( difference_type __n )
      ;
      reference
      operator [ ] ( difference_type __n ) const
      ;
    };
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator == ( const move_iterator < _IteratorL > & __x,
        const move_iterator < _IteratorR > & __y )
    { return __x . base ( ) == __y . base ( ); }
template < typename _Iterator >
    inline bool
    operator == ( const move_iterator < _Iterator > & __x,
        const move_iterator < _Iterator > & __y )
    { return __x . base ( ) == __y . base ( ); }
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator != ( const move_iterator < _IteratorL > & __x,
        const move_iterator < _IteratorR > & __y )
    { return ! ( __x == __y ); }
template < typename _Iterator >
    inline bool
    operator != ( const move_iterator < _Iterator > & __x,
        const move_iterator < _Iterator > & __y )
    { return ! ( __x == __y ); }
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator < ( const move_iterator < _IteratorL > & __x,
       const move_iterator < _IteratorR > & __y )
    { return __x . base ( ) < __y . base ( ); }
template < typename _Iterator >
    inline bool
    operator < ( const move_iterator < _Iterator > & __x,
       const move_iterator < _Iterator > & __y )
    { return __x . base ( ) < __y . base ( ); }
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator <= ( const move_iterator < _IteratorL > & __x,
        const move_iterator < _IteratorR > & __y )
    { return ! ( __y < __x ); }
template < typename _Iterator >
    inline bool
    operator <= ( const move_iterator < _Iterator > & __x,
        const move_iterator < _Iterator > & __y )
    { return ! ( __y < __x ); }
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator > ( const move_iterator < _IteratorL > & __x,
       const move_iterator < _IteratorR > & __y )
    { return __y < __x; }
template < typename _Iterator >
    inline bool
    operator > ( const move_iterator < _Iterator > & __x,
       const move_iterator < _Iterator > & __y )
    { return __y < __x; }
template < typename _IteratorL, typename _IteratorR >
    inline bool
    operator >= ( const move_iterator < _IteratorL > & __x,
        const move_iterator < _IteratorR > & __y )
    { return ! ( __x < __y ); }
template < typename _Iterator >
    inline bool
    operator >= ( const move_iterator < _Iterator > & __x,
        const move_iterator < _Iterator > & __y )
    { return ! ( __x < __y ); }
template < typename _IteratorL, typename _IteratorR >
    inline auto
    operator - ( const move_iterator < _IteratorL > & __x,
       const move_iterator < _IteratorR > & __y )
    -> decltype ( __x . base ( ) - __y . base ( ) )
    { return __x . base ( ) - __y . base ( ); }
template < typename _Iterator >
    inline auto
    operator - ( const move_iterator < _Iterator > & __x,
       const move_iterator < _Iterator > & __y )
    -> decltype ( __x . base ( ) - __y . base ( ) )
    { return __x . base ( ) - __y . base ( ); }
template < typename _Iterator >
    inline move_iterator < _Iterator >
    operator + ( typename move_iterator < _Iterator > :: difference_type __n,
       const move_iterator < _Iterator > & __x )
    { return __x + __n; }
template < typename _Iterator >
    inline move_iterator < _Iterator >
    make_move_iterator ( _Iterator __i )
    { return move_iterator < _Iterator > ( __i ); }
template < typename _Iterator, typename _ReturnType
    = typename conditional < __move_if_noexcept_cond
      < typename iterator_traits < _Iterator > :: value_type > :: value,
                _Iterator, move_iterator < _Iterator > > :: type >
    inline _ReturnType
    __make_move_if_noexcept_iterator ( _Iterator __i )
    { return _ReturnType ( __i ); }
template < typename _Tp, typename _ReturnType
    = typename conditional < __move_if_noexcept_cond < _Tp > :: value,
      const _Tp *, move_iterator < _Tp * > > :: type >
    inline _ReturnType
    __make_move_if_noexcept_iterator ( _Tp * __i )
    { return _ReturnType ( __i ); }
template < typename _Iterator >
    auto
    __niter_base ( move_iterator < _Iterator > __it )
    -> decltype ( make_move_iterator ( __niter_base ( __it . base ( ) ) ) )
    { return make_move_iterator ( __niter_base ( __it . base ( ) ) ); }
template < typename _Iterator >
    struct __is_move_iterator < move_iterator < _Iterator > >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
template < typename _Iterator >
    auto
    __miter_base ( move_iterator < _Iterator > __it )
    -> decltype ( __miter_base ( __it . base ( ) ) )
    { return __miter_base ( __it . base ( ) ); }
}
namespace std
{
namespace __debug
{
}
}
namespace __gnu_debug
{
using namespace std::__debug;
}
namespace __gnu_cxx
{
namespace __ops
{

struct _Iter_less_iter 
{
template < typename _Iterator1, typename _Iterator2 >
      constexpr
      bool
      operator ( ) ( _Iterator1 __it1, _Iterator2 __it2 ) const
      { return * __it1 < * __it2; }
}
;

constexpr inline struct _Iter_less_iter __iter_less_iter()
{
return _Iter_less_iter ();
}

struct _Iter_less_val 
{
template < typename _Iterator, typename _Value >
      bool
      operator ( ) ( _Iterator __it, _Value & __val ) const
      { return * __it < __val; }
}
;

inline struct _Iter_less_val __iter_less_val()
{
return _Iter_less_val ();
}

inline struct _Iter_less_val __iter_comp_val(struct _Iter_less_iter )
{
return _Iter_less_val ();
}

struct _Val_less_iter 
{
template < typename _Value, typename _Iterator >
      bool
      operator ( ) ( _Value & __val, _Iterator __it ) const
      { return __val < * __it; }
}
;

inline struct _Val_less_iter __val_less_iter()
{
return _Val_less_iter ();
}

inline struct _Val_less_iter __val_comp_iter(struct _Iter_less_iter )
{
return _Val_less_iter ();
}

struct _Iter_equal_to_iter 
{
template < typename _Iterator1, typename _Iterator2 >
      bool
      operator ( ) ( _Iterator1 __it1, _Iterator2 __it2 ) const
      { return * __it1 == * __it2; }
}
;

inline struct _Iter_equal_to_iter __iter_equal_to_iter()
{
return _Iter_equal_to_iter ();
}

struct _Iter_equal_to_val 
{
template < typename _Iterator, typename _Value >
      bool
      operator ( ) ( _Iterator __it, _Value & __val ) const
      { return * __it == __val; }
}
;

inline struct _Iter_equal_to_val __iter_equal_to_val()
{
return _Iter_equal_to_val ();
}

inline struct _Iter_equal_to_val __iter_comp_val(struct _Iter_equal_to_iter )
{
return _Iter_equal_to_val ();
}
template < typename _Compare >
    struct _Iter_comp_iter
    {
      _Compare _M_comp;
      constexpr
      _Iter_comp_iter ( _Compare __comp )
 ;
      template < typename _Iterator1, typename _Iterator2 >
        constexpr
        bool
        operator ( ) ( _Iterator1 __it1, _Iterator2 __it2 )
        { return bool ( _M_comp ( * __it1, * __it2 ) ); }
    };
template < typename _Compare >
    constexpr
    inline _Iter_comp_iter < _Compare >
    __iter_comp_iter ( _Compare __comp )
    { return _Iter_comp_iter < _Compare > ( __comp ); }
template < typename _Compare >
    struct _Iter_comp_val
    {
      _Compare _M_comp;
      _Iter_comp_val ( _Compare __comp )
 ;
      template < typename _Iterator, typename _Value >
 bool
 operator ( ) ( _Iterator __it, _Value & __val )
 { return bool ( _M_comp ( * __it, __val ) ); }
    };
template < typename _Compare >
   inline _Iter_comp_val < _Compare >
    __iter_comp_val ( _Compare __comp )
    { return _Iter_comp_val < _Compare > ( __comp ); }
template < typename _Compare >
    inline _Iter_comp_val < _Compare >
    __iter_comp_val ( _Iter_comp_iter < _Compare > __comp )
    { return _Iter_comp_val < _Compare > ( __comp . _M_comp ); }
template < typename _Compare >
    struct _Val_comp_iter
    {
      _Compare _M_comp;
      _Val_comp_iter ( _Compare __comp )
 ;
      template < typename _Value, typename _Iterator >
 bool
 operator ( ) ( _Value & __val, _Iterator __it )
 { return bool ( _M_comp ( __val, * __it ) ); }
    };
template < typename _Compare >
    inline _Val_comp_iter < _Compare >
    __val_comp_iter ( _Compare __comp )
    { return _Val_comp_iter < _Compare > ( __comp ); }
template < typename _Compare >
    inline _Val_comp_iter < _Compare >
    __val_comp_iter ( _Iter_comp_iter < _Compare > __comp )
    { return _Val_comp_iter < _Compare > ( __comp . _M_comp ); }
template < typename _Value >
    struct _Iter_equals_val
    {
      _Value & _M_value;
      _Iter_equals_val ( _Value & __value )
 ;
      template < typename _Iterator >
 bool
 operator ( ) ( _Iterator __it )
 { return * __it == _M_value; }
    };
template < typename _Value >
    inline _Iter_equals_val < _Value >
    __iter_equals_val ( _Value & __val )
    { return _Iter_equals_val < _Value > ( __val ); }
template < typename _Iterator1 >
    struct _Iter_equals_iter
    {
      typename std :: iterator_traits < _Iterator1 > :: reference _M_ref;
      _Iter_equals_iter ( _Iterator1 __it1 )
 ;
      template < typename _Iterator2 >
 bool
 operator ( ) ( _Iterator2 __it2 )
 { return * __it2 == _M_ref; }
    };
template < typename _Iterator >
    inline _Iter_equals_iter < _Iterator >
    __iter_comp_iter ( _Iter_equal_to_iter, _Iterator __it )
    { return _Iter_equals_iter < _Iterator > ( __it ); }
template < typename _Predicate >
    struct _Iter_pred
    {
      _Predicate _M_pred;
      _Iter_pred ( _Predicate __pred )
 ;
      template < typename _Iterator >
 bool
 operator ( ) ( _Iterator __it )
 { return bool ( _M_pred ( * __it ) ); }
    };
template < typename _Predicate >
    inline _Iter_pred < _Predicate >
    __pred_iter ( _Predicate __pred )
    { return _Iter_pred < _Predicate > ( __pred ); }
template < typename _Compare, typename _Value >
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value & _M_value;
      _Iter_comp_to_val ( _Compare __comp, _Value & __value )
 ;
      template < typename _Iterator >
 bool
 operator ( ) ( _Iterator __it )
 { return bool ( _M_comp ( * __it, _M_value ) ); }
    };
template < typename _Compare, typename _Value >
    _Iter_comp_to_val < _Compare, _Value >
    __iter_comp_val ( _Compare __comp, _Value & __val )
    { return _Iter_comp_to_val < _Compare, _Value > ( __comp, __val ); }
template < typename _Compare, typename _Iterator1 >
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      typename std :: iterator_traits < _Iterator1 > :: reference _M_ref;
      _Iter_comp_to_iter ( _Compare __comp, _Iterator1 __it1 )
 ;
      template < typename _Iterator2 >
 bool
 operator ( ) ( _Iterator2 __it2 )
 { return bool ( _M_comp ( * __it2, _M_ref ) ); }
    };
template < typename _Compare, typename _Iterator >
    inline _Iter_comp_to_iter < _Compare, _Iterator >
    __iter_comp_iter ( _Iter_comp_iter < _Compare > __comp, _Iterator __it )
    { return _Iter_comp_to_iter < _Compare, _Iterator > ( __comp . _M_comp, __it ); }
template < typename _Predicate >
    struct _Iter_negate
    {
      _Predicate _M_pred;
      _Iter_negate ( _Predicate __pred )
 ;
      template < typename _Iterator >
 bool
 operator ( ) ( _Iterator __it )
 { return ! bool ( _M_pred ( * __it ) ); }
    };
template < typename _Predicate >
    inline _Iter_negate < _Predicate >
    __negate ( _Iter_pred < _Predicate > __pred )
    { return _Iter_negate < _Predicate > ( __pred . _M_pred ); }
}
}
namespace std
{
template < typename _ForwardIterator1, typename _ForwardIterator2 >
    inline void
    iter_swap ( _ForwardIterator1 __a, _ForwardIterator2 __b )
    {
      swap ( * __a, * __b );
    }
template < typename _ForwardIterator1, typename _ForwardIterator2 >
    _ForwardIterator2
    swap_ranges ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2 )
    {
      ;
      for (; __first1 != __last1; ++ __first1, ( void ) ++ __first2 )
 std :: iter_swap ( __first1, __first2 );
      return __first2;
    }
template < typename _Tp >
    constexpr
    inline const _Tp &
    min ( const _Tp & __a, const _Tp & __b )
    {
      if ( __b < __a )
 return __b;
      return __a;
    }
template < typename _Tp >
    constexpr
    inline const _Tp &
    max ( const _Tp & __a, const _Tp & __b )
    {
      if ( __a < __b )
 return __b;
      return __a;
    }
template < typename _Tp, typename _Compare >
    constexpr
    inline const _Tp &
    min ( const _Tp & __a, const _Tp & __b, _Compare __comp )
    {
      if ( __comp ( __b, __a ) )
 return __b;
      return __a;
    }
template < typename _Tp, typename _Compare >
    constexpr
    inline const _Tp &
    max ( const _Tp & __a, const _Tp & __b, _Compare __comp )
    {
      if ( __comp ( __a, __b ) )
 return __b;
      return __a;
    }
template < typename _Iterator >
    inline _Iterator
    __niter_base ( _Iterator __it )
    { return __it; }
template < bool, bool, typename >
    struct __copy_move
    {
      template < typename _II, typename _OI >
        static _OI
        __copy_m ( _II __first, _II __last, _OI __result )
        {
   for (; __first != __last; ++ __result, ( void ) ++ __first )
     * __result = * __first;
   return __result;
 }
    };
template < typename _Category >
    struct __copy_move < true, false, _Category >
    {
      template < typename _II, typename _OI >
        static _OI
        __copy_m ( _II __first, _II __last, _OI __result )
        {
   for (; __first != __last; ++ __result, ( void ) ++ __first )
     * __result = std :: move ( * __first );
   return __result;
 }
    };
template<> struct __copy_move< false , false , random_access_iterator_tag  > 
{
template < typename _II, typename _OI >
        static _OI
        __copy_m ( _II __first, _II __last, _OI __result )
        {
   typedef typename iterator_traits < _II > :: difference_type _Distance;
   for ( _Distance __n = __last - __first; __n > 0; -- __n )
     {
       * __result = * __first;
       ++ __first;
       ++ __result;
     }
   return __result;
 }
};
template<> struct __copy_move< true , false , random_access_iterator_tag  > 
{
template < typename _II, typename _OI >
        static _OI
        __copy_m ( _II __first, _II __last, _OI __result )
        {
   typedef typename iterator_traits < _II > :: difference_type _Distance;
   for ( _Distance __n = __last - __first; __n > 0; -- __n )
     {
       * __result = std :: move ( * __first );
       ++ __first;
       ++ __result;
     }
   return __result;
 }
};
template < bool _IsMove >
    struct __copy_move < _IsMove, true, random_access_iterator_tag >
    {
      template < typename _Tp >
        static _Tp *
        __copy_m ( const _Tp * __first, const _Tp * __last, _Tp * __result )
        {
   using __assignable = conditional < _IsMove,
        is_move_assignable < _Tp >,
        is_copy_assignable < _Tp >>;
   static_assert ( __assignable :: type :: value, "type is not assignable" );
   const ptrdiff_t _Num = __last - __first;
   if ( _Num )
     __builtin_memmove ( __result, __first, sizeof ( _Tp ) * _Num );
   return __result + _Num;
 }
    };
template < bool _IsMove, typename _II, typename _OI >
    inline _OI
    __copy_move_a ( _II __first, _II __last, _OI __result )
    {
      typedef typename iterator_traits < _II > :: value_type _ValueTypeI;
      typedef typename iterator_traits < _OI > :: value_type _ValueTypeO;
      typedef typename iterator_traits < _II > :: iterator_category _Category;
      const bool __simple = ( __is_trivial ( _ValueTypeI )
                      && __is_pointer < _II > :: __value
                      && __is_pointer < _OI > :: __value
        && __are_same < _ValueTypeI, _ValueTypeO > :: __value );
      return std :: __copy_move < _IsMove, __simple,
                       _Category > :: __copy_m ( __first, __last, __result );
    }
template < typename _CharT >
    struct char_traits;
template < typename _CharT, typename _Traits >
    class istreambuf_iterator;
template < typename _CharT, typename _Traits >
    class ostreambuf_iterator;
template < bool _IsMove, typename _CharT >
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,
      ostreambuf_iterator < _CharT, char_traits < _CharT > > > :: __type
    __copy_move_a2 ( _CharT *, _CharT *,
     ostreambuf_iterator < _CharT, char_traits < _CharT > > );
template < bool _IsMove, typename _CharT >
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,
      ostreambuf_iterator < _CharT, char_traits < _CharT > > > :: __type
    __copy_move_a2 ( const _CharT *, const _CharT *,
     ostreambuf_iterator < _CharT, char_traits < _CharT > > );
template < bool _IsMove, typename _CharT >
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,
        _CharT * > :: __type
    __copy_move_a2 ( istreambuf_iterator < _CharT, char_traits < _CharT > >,
     istreambuf_iterator < _CharT, char_traits < _CharT > >, _CharT * );
template < bool _IsMove, typename _II, typename _OI >
    inline _OI
    __copy_move_a2 ( _II __first, _II __last, _OI __result )
    {
      return _OI ( std :: __copy_move_a < _IsMove > ( std :: __niter_base ( __first ),
          std :: __niter_base ( __last ),
          std :: __niter_base ( __result ) ) );
    }
template < typename _II, typename _OI >
    inline _OI
    copy ( _II __first, _II __last, _OI __result )
    {
      ;
      return ( std :: __copy_move_a2 < __is_move_iterator < _II > :: __value >
       ( std :: __miter_base ( __first ), std :: __miter_base ( __last ),
        __result ) );
    }
template < typename _II, typename _OI >
    inline _OI
    move ( _II __first, _II __last, _OI __result )
    {
      ;
      return std :: __copy_move_a2 < true > ( std :: __miter_base ( __first ),
           std :: __miter_base ( __last ), __result );
    }
template < bool, bool, typename >
    struct __copy_move_backward
    {
      template < typename _BI1, typename _BI2 >
        static _BI2
        __copy_move_b ( _BI1 __first, _BI1 __last, _BI2 __result )
        {
   while ( __first != __last )
     * -- __result = * -- __last;
   return __result;
 }
    };
template < typename _Category >
    struct __copy_move_backward < true, false, _Category >
    {
      template < typename _BI1, typename _BI2 >
        static _BI2
        __copy_move_b ( _BI1 __first, _BI1 __last, _BI2 __result )
        {
   while ( __first != __last )
     * -- __result = std :: move ( * -- __last );
   return __result;
 }
    };
template<> struct __copy_move_backward< false , false , random_access_iterator_tag  > 
{
template < typename _BI1, typename _BI2 >
        static _BI2
        __copy_move_b ( _BI1 __first, _BI1 __last, _BI2 __result )
        {
   typename iterator_traits < _BI1 > :: difference_type __n;
   for ( __n = __last - __first; __n > 0; -- __n )
     * -- __result = * -- __last;
   return __result;
 }
};
template<> struct __copy_move_backward< true , false , random_access_iterator_tag  > 
{
template < typename _BI1, typename _BI2 >
        static _BI2
        __copy_move_b ( _BI1 __first, _BI1 __last, _BI2 __result )
        {
   typename iterator_traits < _BI1 > :: difference_type __n;
   for ( __n = __last - __first; __n > 0; -- __n )
     * -- __result = std :: move ( * -- __last );
   return __result;
 }
};
template < bool _IsMove >
    struct __copy_move_backward < _IsMove, true, random_access_iterator_tag >
    {
      template < typename _Tp >
        static _Tp *
        __copy_move_b ( const _Tp * __first, const _Tp * __last, _Tp * __result )
        {
   using __assignable = conditional < _IsMove,
        is_move_assignable < _Tp >,
        is_copy_assignable < _Tp >>;
   static_assert ( __assignable :: type :: value, "type is not assignable" );
   const ptrdiff_t _Num = __last - __first;
   if ( _Num )
     __builtin_memmove ( __result - _Num, __first, sizeof ( _Tp ) * _Num );
   return __result - _Num;
 }
    };
template < bool _IsMove, typename _BI1, typename _BI2 >
    inline _BI2
    __copy_move_backward_a ( _BI1 __first, _BI1 __last, _BI2 __result )
    {
      typedef typename iterator_traits < _BI1 > :: value_type _ValueType1;
      typedef typename iterator_traits < _BI2 > :: value_type _ValueType2;
      typedef typename iterator_traits < _BI1 > :: iterator_category _Category;
      const bool __simple = ( __is_trivial ( _ValueType1 )
                      && __is_pointer < _BI1 > :: __value
                      && __is_pointer < _BI2 > :: __value
        && __are_same < _ValueType1, _ValueType2 > :: __value );
      return std :: __copy_move_backward < _IsMove, __simple,
                                _Category > :: __copy_move_b ( __first,
         __last,
         __result );
    }
template < bool _IsMove, typename _BI1, typename _BI2 >
    inline _BI2
    __copy_move_backward_a2 ( _BI1 __first, _BI1 __last, _BI2 __result )
    {
      return _BI2 ( std :: __copy_move_backward_a < _IsMove >
    ( std :: __niter_base ( __first ), std :: __niter_base ( __last ),
     std :: __niter_base ( __result ) ) );
    }
template < typename _BI1, typename _BI2 >
    inline _BI2
    copy_backward ( _BI1 __first, _BI1 __last, _BI2 __result )
    {
      ;
      return ( std :: __copy_move_backward_a2 < __is_move_iterator < _BI1 > :: __value >
       ( std :: __miter_base ( __first ), std :: __miter_base ( __last ),
        __result ) );
    }
template < typename _BI1, typename _BI2 >
    inline _BI2
    move_backward ( _BI1 __first, _BI1 __last, _BI2 __result )
    {
      ;
      return std :: __copy_move_backward_a2 < true > ( std :: __miter_base ( __first ),
      std :: __miter_base ( __last ),
      __result );
    }
template < typename _ForwardIterator, typename _Tp >
    inline typename
    __gnu_cxx :: __enable_if < ! __is_scalar < _Tp > :: __value, void > :: __type
    __fill_a ( _ForwardIterator __first, _ForwardIterator __last,
       const _Tp & __value )
    {
      for (; __first != __last; ++ __first )
 * __first = __value;
    }
template < typename _ForwardIterator, typename _Tp >
    inline typename
    __gnu_cxx :: __enable_if < __is_scalar < _Tp > :: __value, void > :: __type
    __fill_a ( _ForwardIterator __first, _ForwardIterator __last,
      const _Tp & __value )
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++ __first )
 * __first = __tmp;
    }
template < typename _Tp >
    inline typename
    __gnu_cxx :: __enable_if < __is_byte < _Tp > :: __value, void > :: __type
    __fill_a ( _Tp * __first, _Tp * __last, const _Tp & __c )
    {
      const _Tp __tmp = __c;
      if ( const size_t __len = __last - __first )
 __builtin_memset ( __first, static_cast < unsigned char > ( __tmp ), __len );
    }
template < typename _ForwardIterator, typename _Tp >
    inline void
    fill ( _ForwardIterator __first, _ForwardIterator __last, const _Tp & __value )
    {
      ;
      std :: __fill_a ( std :: __niter_base ( __first ), std :: __niter_base ( __last ),
      __value );
    }
template < typename _OutputIterator, typename _Size, typename _Tp >
    inline typename
    __gnu_cxx :: __enable_if < ! __is_scalar < _Tp > :: __value, _OutputIterator > :: __type
    __fill_n_a ( _OutputIterator __first, _Size __n, const _Tp & __value )
    {
      for ( decltype ( __n + 0 ) __niter = __n;
    __niter > 0; -- __niter, ++ __first )
 * __first = __value;
      return __first;
    }
template < typename _OutputIterator, typename _Size, typename _Tp >
    inline typename
    __gnu_cxx :: __enable_if < __is_scalar < _Tp > :: __value, _OutputIterator > :: __type
    __fill_n_a ( _OutputIterator __first, _Size __n, const _Tp & __value )
    {
      const _Tp __tmp = __value;
      for ( decltype ( __n + 0 ) __niter = __n;
    __niter > 0; -- __niter, ++ __first )
 * __first = __tmp;
      return __first;
    }
template < typename _Size, typename _Tp >
    inline typename
    __gnu_cxx :: __enable_if < __is_byte < _Tp > :: __value, _Tp * > :: __type
    __fill_n_a ( _Tp * __first, _Size __n, const _Tp & __c )
    {
      std :: __fill_a ( __first, __first + __n, __c );
      return __first + __n;
    }
template < typename _OI, typename _Size, typename _Tp >
    inline _OI
    fill_n ( _OI __first, _Size __n, const _Tp & __value )
    {
      return _OI ( std :: __fill_n_a ( std :: __niter_base ( __first ), __n, __value ) );
    }
template < bool _BoolType >
    struct __equal
    {
      template < typename _II1, typename _II2 >
        static bool
        equal ( _II1 __first1, _II1 __last1, _II2 __first2 )
        {
   for (; __first1 != __last1; ++ __first1, ( void ) ++ __first2 )
     if ( ! ( * __first1 == * __first2 ) )
       return false;
   return true;
 }
    };
template<> struct __equal< true > 
{
template < typename _Tp >
        static bool
        equal ( const _Tp * __first1, const _Tp * __last1, const _Tp * __first2 )
        {
   if ( const size_t __len = ( __last1 - __first1 ) )
     return ! __builtin_memcmp ( __first1, __first2, sizeof ( _Tp ) * __len );
   return true;
 }
};
template < typename _II1, typename _II2 >
    inline bool
    __equal_aux ( _II1 __first1, _II1 __last1, _II2 __first2 )
    {
      typedef typename iterator_traits < _II1 > :: value_type _ValueType1;
      typedef typename iterator_traits < _II2 > :: value_type _ValueType2;
      const bool __simple = ( ( __is_integer < _ValueType1 > :: __value
         || __is_pointer < _ValueType1 > :: __value )
                      && __is_pointer < _II1 > :: __value
                      && __is_pointer < _II2 > :: __value
        && __are_same < _ValueType1, _ValueType2 > :: __value );
      return std :: __equal < __simple > :: equal ( __first1, __last1, __first2 );
    }
template < typename, typename >
    struct __lc_rai
    {
      template < typename _II1, typename _II2 >
        static _II1
        __newlast1 ( _II1, _II1 __last1, _II2, _II2 )
        { return __last1; }
      template < typename _II >
        static bool
        __cnd2 ( _II __first, _II __last )
        { return __first != __last; }
    };
template<> struct __lc_rai< random_access_iterator_tag  , random_access_iterator_tag  > 
{
template < typename _RAI1, typename _RAI2 >
        static _RAI1
        __newlast1 ( _RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2 )
        {
   const typename iterator_traits < _RAI1 > :: difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits < _RAI2 > :: difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }
template < typename _RAI >
        static bool
        __cnd2 ( _RAI, _RAI )
        { return true; }
};
template < typename _II1, typename _II2, typename _Compare >
    bool
    __lexicographical_compare_impl ( _II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp )
    {
      typedef typename iterator_traits < _II1 > :: iterator_category _Category1;
      typedef typename iterator_traits < _II2 > :: iterator_category _Category2;
      typedef std :: __lc_rai < _Category1, _Category2 > __rai_type;
      __last1 = __rai_type :: __newlast1 ( __first1, __last1, __first2, __last2 );
      for (; __first1 != __last1 && __rai_type :: __cnd2 ( __first2, __last2 );
    ++ __first1, ( void ) ++ __first2 )
 {
   if ( __comp ( __first1, __first2 ) )
     return true;
   if ( __comp ( __first2, __first1 ) )
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
template < bool _BoolType >
    struct __lexicographical_compare
    {
      template < typename _II1, typename _II2 >
        static bool __lc ( _II1, _II1, _II2, _II2 );
    };
template < bool _BoolType >
    template < typename _II1, typename _II2 >
      bool
      __lexicographical_compare < _BoolType > ::
      __lc ( _II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2 )
      {
 return std :: __lexicographical_compare_impl ( __first1, __last1,
         __first2, __last2,
     __gnu_cxx :: __ops :: __iter_less_iter ( ) );
      }
template<> struct __lexicographical_compare< true > 
{
template < typename _Tp, typename _Up >
        static bool
        __lc ( const _Tp * __first1, const _Tp * __last1,
      const _Up * __first2, const _Up * __last2 )
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if ( const size_t __len = std :: min ( __len1, __len2 ) )
     if ( int __result = __builtin_memcmp ( __first1, __first2, __len ) )
       return __result < 0;
   return __len1 < __len2;
 }
};
template < typename _II1, typename _II2 >
    inline bool
    __lexicographical_compare_aux ( _II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2 )
    {
      typedef typename iterator_traits < _II1 > :: value_type _ValueType1;
      typedef typename iterator_traits < _II2 > :: value_type _ValueType2;
      const bool __simple =
 ( __is_byte < _ValueType1 > :: __value && __is_byte < _ValueType2 > :: __value
  && ! __gnu_cxx :: __numeric_traits < _ValueType1 > :: __is_signed
  && ! __gnu_cxx :: __numeric_traits < _ValueType2 > :: __is_signed
  && __is_pointer < _II1 > :: __value
  && __is_pointer < _II2 > :: __value );
      return std :: __lexicographical_compare < __simple > :: __lc ( __first1, __last1,
           __first2, __last2 );
    }
template < typename _ForwardIterator, typename _Tp, typename _Compare >
    _ForwardIterator
    __lower_bound ( _ForwardIterator __first, _ForwardIterator __last,
    const _Tp & __val, _Compare __comp )
    {
      typedef typename iterator_traits < _ForwardIterator > :: difference_type
 _DistanceType;
      _DistanceType __len = std :: distance ( __first, __last );
      while ( __len > 0 )
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std :: advance ( __middle, __half );
   if ( __comp ( __middle, __val ) )
     {
       __first = __middle;
       ++ __first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
template < typename _ForwardIterator, typename _Tp >
    inline _ForwardIterator
    lower_bound ( _ForwardIterator __first, _ForwardIterator __last,
  const _Tp & __val )
    {
      ;
      ;
      return std :: __lower_bound ( __first, __last, __val,
    __gnu_cxx :: __ops :: __iter_less_val ( ) );
    }

constexpr inline int  __attribute__((visibility("default"))) __lg(int __n)
{
return (sizeof(int ) * 8 - 1 - (__builtin_clz(__n)));
}

constexpr inline unsigned int  __attribute__((visibility("default"))) __lg(unsigned int __n)
{
return (sizeof(int ) * 8 - 1 - (__builtin_clz(__n)));
}

constexpr inline long  __attribute__((visibility("default"))) __lg(long __n)
{
return (sizeof(long ) * 8 - 1 - (__builtin_clzl(__n)));
}

constexpr inline unsigned long  __attribute__((visibility("default"))) __lg(unsigned long __n)
{
return sizeof(long ) * 8 - 1 - (__builtin_clzl(__n));
}

constexpr inline long long  __attribute__((visibility("default"))) __lg(long long __n)
{
return (sizeof(long long ) * 8 - 1 - (__builtin_clzll(__n)));
}

constexpr inline unsigned long long  __attribute__((visibility("default"))) __lg(unsigned long long __n)
{
return (sizeof(long long ) * 8 - 1 - (__builtin_clzll(__n)));
}
template < typename _II1, typename _II2 >
    inline bool
    equal ( _II1 __first1, _II1 __last1, _II2 __first2 )
    {
      ;
      return std :: __equal_aux ( std :: __niter_base ( __first1 ),
         std :: __niter_base ( __last1 ),
         std :: __niter_base ( __first2 ) );
    }
template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
    inline bool
    equal ( _IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred )
    {
      ;
      for (; __first1 != __last1; ++ __first1, ( void ) ++ __first2 )
 if ( ! bool ( __binary_pred ( * __first1, * __first2 ) ) )
   return false;
      return true;
    }
template < typename _II1, typename _II2 >
    inline bool
    equal ( _II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2 )
    {
      ;
      ;
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits < _II1 > :: iterator_category;
      using _Cat2 = typename iterator_traits < _II2 > :: iterator_category;
      using _RAIters = __and_ < is_same < _Cat1, _RATag >, is_same < _Cat2, _RATag >>;
      if ( _RAIters ( ) )
 {
   auto __d1 = std :: distance ( __first1, __last1 );
   auto __d2 = std :: distance ( __first2, __last2 );
   if ( __d1 != __d2 )
     return false;
   return std :: equal ( __first1, __last1, __first2 );
 }
      for (; __first1 != __last1 && __first2 != __last2;
   ++ __first1, ( void ) ++ __first2 )
 if ( ! ( * __first1 == * __first2 ) )
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
    inline bool
    equal ( _IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred )
    {
      ;
      ;
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits < _IIter1 > :: iterator_category;
      using _Cat2 = typename iterator_traits < _IIter2 > :: iterator_category;
      using _RAIters = __and_ < is_same < _Cat1, _RATag >, is_same < _Cat2, _RATag >>;
      if ( _RAIters ( ) )
 {
   auto __d1 = std :: distance ( __first1, __last1 );
   auto __d2 = std :: distance ( __first2, __last2 );
   if ( __d1 != __d2 )
     return false;
   return std :: equal ( __first1, __last1, __first2,
           __binary_pred );
 }
      for (; __first1 != __last1 && __first2 != __last2;
   ++ __first1, ( void ) ++ __first2 )
 if ( ! bool ( __binary_pred ( * __first1, * __first2 ) ) )
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
template < typename _II1, typename _II2 >
    inline bool
    lexicographical_compare ( _II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2 )
    {
      ;
      ;
      ;
      ;
      return std :: __lexicographical_compare_aux ( std :: __niter_base ( __first1 ),
      std :: __niter_base ( __last1 ),
      std :: __niter_base ( __first2 ),
      std :: __niter_base ( __last2 ) );
    }
template < typename _II1, typename _II2, typename _Compare >
    inline bool
    lexicographical_compare ( _II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp )
    {
      ;
      ;
      ;
      ;
      return std :: __lexicographical_compare_impl
 ( __first1, __last1, __first2, __last2,
  __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate >
    pair < _InputIterator1, _InputIterator2 >
    __mismatch ( _InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred )
    {
      while ( __first1 != __last1 && __binary_pred ( __first1, __first2 ) )
        {
   ++ __first1;
   ++ __first2;
        }
      return pair < _InputIterator1, _InputIterator2 > ( __first1, __first2 );
    }
template < typename _InputIterator1, typename _InputIterator2 >
    inline pair < _InputIterator1, _InputIterator2 >
    mismatch ( _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2 )
    {
      ;
      return std :: __mismatch ( __first1, __last1, __first2,
        __gnu_cxx :: __ops :: __iter_equal_to_iter ( ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate >
    inline pair < _InputIterator1, _InputIterator2 >
    mismatch ( _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred )
    {
      ;
      return std :: __mismatch ( __first1, __last1, __first2,
 __gnu_cxx :: __ops :: __iter_comp_iter ( __binary_pred ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate >
    pair < _InputIterator1, _InputIterator2 >
    __mismatch ( _InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred )
    {
      while ( __first1 != __last1 && __first2 != __last2
      && __binary_pred ( __first1, __first2 ) )
        {
   ++ __first1;
   ++ __first2;
        }
      return pair < _InputIterator1, _InputIterator2 > ( __first1, __first2 );
    }
template < typename _InputIterator1, typename _InputIterator2 >
    inline pair < _InputIterator1, _InputIterator2 >
    mismatch ( _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2 )
    {
      ;
      ;
      return std :: __mismatch ( __first1, __last1, __first2, __last2,
        __gnu_cxx :: __ops :: __iter_equal_to_iter ( ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate >
    inline pair < _InputIterator1, _InputIterator2 >
    mismatch ( _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred )
    {
      ;
      ;
      return std :: __mismatch ( __first1, __last1, __first2, __last2,
        __gnu_cxx :: __ops :: __iter_comp_iter ( __binary_pred ) );
    }
}
namespace __gnu_cxx
{
template < typename _CharT >
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std :: streampos pos_type;
      typedef std :: streamoff off_type;
      typedef std :: mbstate_t state_type;
    };
template < typename _CharT >
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types < _CharT > :: int_type int_type;
      typedef typename _Char_types < _CharT > :: pos_type pos_type;
      typedef typename _Char_types < _CharT > :: off_type off_type;
      typedef typename _Char_types < _CharT > :: state_type state_type;
      static void
      assign ( char_type & __c1, const char_type & __c2 )
      ;
      static constexpr bool
      eq ( const char_type & __c1, const char_type & __c2 )
      ;
      static constexpr bool
      lt ( const char_type & __c1, const char_type & __c2 )
      ;
      static int
      compare ( const char_type * __s1, const char_type * __s2, std :: size_t __n );
      static std :: size_t
      length ( const char_type * __s );
      static const char_type *
      find ( const char_type * __s, std :: size_t __n, const char_type & __a );
      static char_type *
      move ( char_type * __s1, const char_type * __s2, std :: size_t __n );
      static char_type *
      copy ( char_type * __s1, const char_type * __s2, std :: size_t __n );
      static char_type *
      assign ( char_type * __s, std :: size_t __n, char_type __a );
      static constexpr char_type
      to_char_type ( const int_type & __c )
      ;
      static constexpr int_type
      to_int_type ( const char_type & __c )
      ;
      static constexpr bool
      eq_int_type ( const int_type & __c1, const int_type & __c2 )
      ;
      static constexpr int_type
      eof ( )
      ;
      static constexpr int_type
      not_eof ( const int_type & __c )
      ;
    };
template < typename _CharT >
    int
    char_traits < _CharT > ::
    compare ( const char_type * __s1, const char_type * __s2, std :: size_t __n )
    {
      for ( std :: size_t __i = 0; __i < __n; ++ __i )
 if ( lt ( __s1 [ __i ], __s2 [ __i ] ) )
   return - 1;
 else if ( lt ( __s2 [ __i ], __s1 [ __i ] ) )
   return 1;
      return 0;
    }
template < typename _CharT >
    std :: size_t
    char_traits < _CharT > ::
    length ( const char_type * __p )
    {
      std :: size_t __i = 0;
      while ( ! eq ( __p [ __i ], char_type ( ) ) )
        ++ __i;
      return __i;
    }
template < typename _CharT >
    const typename char_traits < _CharT > :: char_type *
    char_traits < _CharT > ::
    find ( const char_type * __s, std :: size_t __n, const char_type & __a )
    {
      for ( std :: size_t __i = 0; __i < __n; ++ __i )
        if ( eq ( __s [ __i ], __a ) )
          return __s + __i;
      return 0;
    }
template < typename _CharT >
    typename char_traits < _CharT > :: char_type *
    char_traits < _CharT > ::
    move ( char_type * __s1, const char_type * __s2, std :: size_t __n )
    {
      return static_cast < _CharT * > ( __builtin_memmove ( __s1, __s2,
          __n * sizeof ( char_type ) ) );
    }
template < typename _CharT >
    typename char_traits < _CharT > :: char_type *
    char_traits < _CharT > ::
    copy ( char_type * __s1, const char_type * __s2, std :: size_t __n )
    {
      std :: copy ( __s2, __s2 + __n, __s1 );
      return __s1;
    }
template < typename _CharT >
    typename char_traits < _CharT > :: char_type *
    char_traits < _CharT > ::
    assign ( char_type * __s, std :: size_t __n, char_type __a )
    {
      std :: fill_n ( __s, __n, __a );
      return __s;
    }
}
namespace std
{
template < class _CharT >
    struct char_traits : public __gnu_cxx :: char_traits < _CharT >
    { };
template<> struct char_traits< char  > 
{
typedef char char_type;
typedef int int_type;
typedef streampos pos_type;
typedef streamoff off_type;
typedef mbstate_t state_type;

inline static void assign(char_type &__c1,const char_type &__c2)
{
__c1 = __c2;
}

constexpr inline static bool eq(const char_type &__c1,const char_type &__c2)
{
return __c1 == __c2;
}

constexpr inline static bool lt(const char_type &__c1,const char_type &__c2)
{
return (static_cast < unsigned char  >  (__c1)) < (static_cast < unsigned char  >  (__c2));
}

inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n)
{
if (__n == 0) 
return 0;
return __builtin_memcmp(__s1,__s2,__n);
}

inline static size_t length(const char_type *__s)
{
return __builtin_strlen(__s);
}

inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a)
{
if (__n == 0) 
return 0;
return static_cast < const char_type * >  ((__builtin_memchr(__s,__a,__n)));
}

inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n)
{
if (__n == 0) 
return __s1;
return static_cast < char_type * >  ((__builtin_memmove(__s1,__s2,__n)));
}

inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n)
{
if (__n == 0) 
return __s1;
return static_cast < char_type * >  ((__builtin_memcpy(__s1,__s2,__n)));
}

inline static char_type *assign(char_type *__s,size_t __n,char_type __a)
{
if (__n == 0) 
return __s;
return static_cast < char_type * >  ((__builtin_memset(__s,__a,__n)));
}

constexpr inline static char_type to_char_type(const int_type &__c)
{
return static_cast < char_type  >  (__c);
}

constexpr inline static int_type to_int_type(const char_type &__c)
{
return static_cast < int_type  >  ((static_cast < unsigned char  >  (__c)));
}

constexpr inline static bool eq_int_type(const int_type &__c1,const int_type &__c2)
{
return __c1 == __c2;
}

constexpr inline static int_type eof()
{
return static_cast < int_type  >  ((- 1));
}

constexpr inline static int_type not_eof(const int_type &__c)
{
return __c == eof()?0 : __c;
}
};
template<> struct char_traits< wchar_t  > 
{
typedef wchar_t char_type;
typedef wint_t int_type;
typedef streamoff off_type;
typedef wstreampos pos_type;
typedef mbstate_t state_type;

inline static void assign(char_type &__c1,const char_type &__c2)
{
__c1 = __c2;
}

constexpr inline static bool eq(const char_type &__c1,const char_type &__c2)
{
return __c1 == __c2;
}

constexpr inline static bool lt(const char_type &__c1,const char_type &__c2)
{
return __c1 < __c2;
}

inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n)
{
if (__n == 0) 
return 0;
return wmemcmp(__s1,__s2,__n);
}

inline static size_t length(const char_type *__s)
{
return wcslen(__s);
}

inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a)
{
if (__n == 0) 
return 0;
return wmemchr(__s,__a,__n);
}

inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n)
{
if (__n == 0) 
return __s1;
return wmemmove(__s1,__s2,__n);
}

inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n)
{
if (__n == 0) 
return __s1;
return wmemcpy(__s1,__s2,__n);
}

inline static char_type *assign(char_type *__s,size_t __n,char_type __a)
{
if (__n == 0) 
return __s;
return wmemset(__s,__a,__n);
}

constexpr inline static char_type to_char_type(const int_type &__c)
{
return (char_type )__c;
}

constexpr inline static int_type to_int_type(const char_type &__c)
{
return (int_type )__c;
}

constexpr inline static bool eq_int_type(const int_type &__c1,const int_type &__c2)
{
return __c1 == __c2;
}

constexpr inline static int_type eof()
{
return static_cast < int_type  >  (0xffffffffu);
}

constexpr inline static int_type not_eof(const int_type &__c)
{
return eq_int_type(__c,(eof()))?0 : __c;
}
};
}
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long uint64_t;
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef int int_least32_t;
typedef long int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long uint_least64_t;
typedef signed char int_fast8_t;
typedef long int_fast16_t;
typedef long int_fast32_t;
typedef long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef unsigned long uint_fast64_t;
typedef long intptr_t;
typedef unsigned long uintptr_t;
typedef long intmax_t;
typedef unsigned long uintmax_t;
namespace std
{
using ::int8_t;
using ::int16_t;
using ::int32_t;
using ::int64_t;
using ::int_fast8_t;
using ::int_fast16_t;
using ::int_fast32_t;
using ::int_fast64_t;
using ::int_least8_t;
using ::int_least16_t;
using ::int_least32_t;
using ::int_least64_t;
using ::intmax_t;
using ::intptr_t;
using ::uint8_t;
using ::uint16_t;
using ::uint32_t;
using ::uint64_t;
using ::uint_fast8_t;
using ::uint_fast16_t;
using ::uint_fast32_t;
using ::uint_fast64_t;
using ::uint_least8_t;
using ::uint_least64_t;
using ::uintmax_t;
using ::uintptr_t;
}
namespace std
{
template<> struct char_traits< char16_t  > 
{
typedef char16_t char_type;
typedef uint_least16_t int_type;
typedef streamoff off_type;
typedef u16streampos pos_type;
typedef mbstate_t state_type;

inline static void assign(char_type &__c1,const char_type &__c2)
{
__c1 = __c2;
}

constexpr inline static bool eq(const char_type &__c1,const char_type &__c2)
{
return __c1 == __c2;
}

constexpr inline static bool lt(const char_type &__c1,const char_type &__c2)
{
return __c1 < __c2;
}

inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n)
{
for (size_t __i = 0; __i < __n; ++__i) 
if (lt(__s1[__i],__s2[__i])) 
return - 1;
 else if (lt(__s2[__i],__s1[__i])) 
return 1;
return 0;
}

inline static size_t length(const char_type *__s)
{
size_t __i = 0;
while(!eq(__s[__i],char16_t ()))
++__i;
return __i;
}

inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a)
{
for (size_t __i = 0; __i < __n; ++__i) 
if (eq(__s[__i],__a)) 
return __s + __i;
return 0;
}

inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n)
{
if (__n == 0) 
return __s1;
return static_cast < char_type * >  ((__builtin_memmove(__s1,__s2,__n * sizeof(char_type ))));
}

inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n)
{
if (__n == 0) 
return __s1;
return static_cast < char_type * >  ((__builtin_memcpy(__s1,__s2,__n * sizeof(char_type ))));
}

inline static char_type *assign(char_type *__s,size_t __n,char_type __a)
{
for (size_t __i = 0; __i < __n; ++__i) 
assign(__s[__i],__a);
return __s;
}

constexpr inline static char_type to_char_type(const int_type &__c)
{
return (char_type )__c;
}

constexpr inline static int_type to_int_type(const char_type &__c)
{
return (int_type )__c;
}

constexpr inline static bool eq_int_type(const int_type &__c1,const int_type &__c2)
{
return __c1 == __c2;
}

constexpr inline static int_type eof()
{
return static_cast < int_type  >  ((- 1));
}

constexpr inline static int_type not_eof(const int_type &__c)
{
return (eq_int_type(__c,(eof()))?0 : __c);
}
};
template<> struct char_traits< char32_t  > 
{
typedef char32_t char_type;
typedef uint_least32_t int_type;
typedef streamoff off_type;
typedef u32streampos pos_type;
typedef mbstate_t state_type;

inline static void assign(char_type &__c1,const char_type &__c2)
{
__c1 = __c2;
}

constexpr inline static bool eq(const char_type &__c1,const char_type &__c2)
{
return __c1 == __c2;
}

constexpr inline static bool lt(const char_type &__c1,const char_type &__c2)
{
return __c1 < __c2;
}

inline static int compare(const char_type *__s1,const char_type *__s2,size_t __n)
{
for (size_t __i = 0; __i < __n; ++__i) 
if (lt(__s1[__i],__s2[__i])) 
return - 1;
 else if (lt(__s2[__i],__s1[__i])) 
return 1;
return 0;
}

inline static size_t length(const char_type *__s)
{
size_t __i = 0;
while(!eq(__s[__i],char32_t ()))
++__i;
return __i;
}

inline static const char_type *find(const char_type *__s,size_t __n,const char_type &__a)
{
for (size_t __i = 0; __i < __n; ++__i) 
if (eq(__s[__i],__a)) 
return __s + __i;
return 0;
}

inline static char_type *move(char_type *__s1,const char_type *__s2,size_t __n)
{
if (__n == 0) 
return __s1;
return static_cast < char_type * >  ((__builtin_memmove(__s1,__s2,__n * sizeof(char_type ))));
}

inline static char_type *copy(char_type *__s1,const char_type *__s2,size_t __n)
{
if (__n == 0) 
return __s1;
return static_cast < char_type * >  ((__builtin_memcpy(__s1,__s2,__n * sizeof(char_type ))));
}

inline static char_type *assign(char_type *__s,size_t __n,char_type __a)
{
for (size_t __i = 0; __i < __n; ++__i) 
assign(__s[__i],__a);
return __s;
}

constexpr inline static char_type to_char_type(const int_type &__c)
{
return (char_type )__c;
}

constexpr inline static int_type to_int_type(const char_type &__c)
{
return (int_type )__c;
}

constexpr inline static bool eq_int_type(const int_type &__c1,const int_type &__c2)
{
return __c1 == __c2;
}

constexpr inline static int_type eof()
{
return static_cast < int_type  >  ((- 1));
}

constexpr inline static int_type not_eof(const int_type &__c)
{
return eq_int_type(__c,(eof()))?0 : __c;
}
};
}

struct lconv 
{
char *decimal_point;
char *thousands_sep;
char *grouping;
char *int_curr_symbol;
char *currency_symbol;
char *mon_decimal_point;
char *mon_thousands_sep;
char *mon_grouping;
char *positive_sign;
char *negative_sign;
char int_frac_digits;
char frac_digits;
char p_cs_precedes;
char p_sep_by_space;
char n_cs_precedes;
char n_sep_by_space;
char p_sign_posn;
char n_sign_posn;
char int_p_cs_precedes;
char int_p_sep_by_space;
char int_n_cs_precedes;
char int_n_sep_by_space;
char int_p_sign_posn;
char int_n_sign_posn;
}
;
extern "C" { char *setlocale(int __category,const char *__locale) throw() __attribute__((no_throw)) ; }
extern "C" { struct lconv *localeconv() throw() __attribute__((no_throw)) ; }
extern "C" { __locale_t newlocale(int __category_mask,const char *__locale,__locale_t __base) throw() __attribute__((no_throw)) ; }
extern "C" { __locale_t duplocale(__locale_t __dataset) throw() __attribute__((no_throw)) ; }
extern "C" { void freelocale(__locale_t __dataset) throw() __attribute__((no_throw)) ; }
extern "C" { __locale_t uselocale(__locale_t __dataset) throw() __attribute__((no_throw)) ; }
namespace std
{
using ::lconv;
using ::setlocale;
using ::localeconv;
}
namespace __gnu_cxx
{
__locale_t __uselocale(__locale_t __dataset) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
}
namespace std
{
typedef __locale_t __c_locale;

inline int  __attribute__((visibility("default"))) __convert_from_v(const __c_locale &__cloc,char *__out,const int __size,const char *__fmt,... )
{
__c_locale __old = __gnu_cxx::__uselocale(__cloc);
__builtin_va_list __args;
__builtin_va_start(__args,__fmt);
const int __ret = __builtin_vsnprintf(__out,__size,__fmt,__args);
__builtin_va_end(__args);
__gnu_cxx::__uselocale(__old);
return __ret;
}
}
enum __anonymous_0x25c1f20 {_ISupper=256,_ISlower=512,_ISalpha=1024,_ISdigit=2048,_ISxdigit=4096,_ISspace=8192,_ISprint=16384,_ISgraph=32768,_ISblank=1,_IScntrl=2,_ISpunct=4,_ISalnum=8} ;
extern "C" { const unsigned short **__ctype_b_loc() throw() __attribute__((no_throw)) ; }
extern "C" { const __int32_t **__ctype_tolower_loc() throw() __attribute__((no_throw)) ; }
extern "C" { const __int32_t **__ctype_toupper_loc() throw() __attribute__((no_throw)) ; }
extern "C" { int isalnum(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int isalpha(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int iscntrl(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int isdigit(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int islower(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int isgraph(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int isprint(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int ispunct(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int isspace(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int isupper(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int isxdigit(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int tolower(int __c) throw() __attribute__((no_throw)) ; }
extern "C" { int toupper(int __c) throw() __attribute__((no_throw)) ; }
extern "C" { int isblank(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int isctype(int __c,int __mask) throw() __attribute__((no_throw)) ; }
extern "C" { int isascii(int __c) throw() __attribute__((no_throw)) ; }
extern "C" { int toascii(int __c) throw() __attribute__((no_throw)) ; }
extern "C" { int _toupper(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int _tolower(int ) throw() __attribute__((no_throw)) ; }
extern "C" { int isalnum_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int isalpha_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int iscntrl_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int isdigit_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int islower_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int isgraph_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int isprint_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int ispunct_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int isspace_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int isupper_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int isxdigit_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int isblank_l(int ,__locale_t ) throw() __attribute__((no_throw)) ; }
extern "C" { int __tolower_l(int __c,__locale_t __l) throw() __attribute__((no_throw)) ; }
extern "C" { int tolower_l(int __c,__locale_t __l) throw() __attribute__((no_throw)) ; }
extern "C" { int __toupper_l(int __c,__locale_t __l) throw() __attribute__((no_throw)) ; }
extern "C" { int toupper_l(int __c,__locale_t __l) throw() __attribute__((no_throw)) ; }
namespace std
{
using ::isalnum;
using ::isalpha;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
}
namespace std
{
using ::isblank;
}
namespace std
{
class locale ;
template < typename _Facet >
    bool
    has_facet ( const locale & ) throw ( );
template < typename _Facet >
    const _Facet &
    use_facet ( const locale & );
template < typename _CharT >
    bool
    isspace ( _CharT, const locale & );
template < typename _CharT >
    bool
    isprint ( _CharT, const locale & );
template < typename _CharT >
    bool
    iscntrl ( _CharT, const locale & );
template < typename _CharT >
    bool
    isupper ( _CharT, const locale & );
template < typename _CharT >
    bool
    islower ( _CharT, const locale & );
template < typename _CharT >
    bool
    isalpha ( _CharT, const locale & );
template < typename _CharT >
    bool
    isdigit ( _CharT, const locale & );
template < typename _CharT >
    bool
    ispunct ( _CharT, const locale & );
template < typename _CharT >
    bool
    isxdigit ( _CharT, const locale & );
template < typename _CharT >
    bool
    isalnum ( _CharT, const locale & );
template < typename _CharT >
    bool
    isgraph ( _CharT, const locale & );
template < typename _CharT >
    bool
    isblank ( _CharT, const locale & );
template < typename _CharT >
    _CharT
    toupper ( _CharT, const locale & );
template < typename _CharT >
    _CharT
    tolower ( _CharT, const locale & );
struct ctype_base ;
template < typename _CharT >
    class ctype;
extern "C" {
extern "C" {
}
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
template<> class ctype< char  > ;
template<> class ctype< char  > ;
template<> class ctype< wchar_t  > ;
template<> class ctype< wchar_t  > ;
template < typename _CharT >
    class ctype_byname;
class codecvt_base ;
template < typename _InternT, typename _ExternT, typename _StateT >
    class codecvt;
template<> class codecvt< char  , char  , mbstate_t  > ;
template<> class codecvt< wchar_t  , char  , mbstate_t  > ;
template < typename _InternT, typename _ExternT, typename _StateT >
    class codecvt_byname;
template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >
    class num_get;
template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >
    class num_put;
namespace __cxx11
{
template < typename _CharT > class numpunct;
template < typename _CharT > class numpunct_byname;
}
namespace __cxx11
{
template < typename _CharT >
    class collate;
template < typename _CharT >
    class collate_byname;
}
class time_base ;
namespace __cxx11
{
template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >
    class time_get;
template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >
    class time_get_byname;
}
template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >
    class time_put;
template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >
    class time_put_byname;
class money_base ;
namespace __cxx11
{
template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >
    class money_get;
template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >
    class money_put;
}
namespace __cxx11
{
template < typename _CharT, bool _Intl = false >
    class moneypunct;
template < typename _CharT, bool _Intl = false >
    class moneypunct_byname;
}
class messages_base ;
namespace __cxx11
{
template < typename _CharT >
    class messages;
template < typename _CharT >
    class messages_byname;
}
}
#pragma GCC visibility push ( default )

struct sched_param 
{
int __sched_priority;
}
;
extern "C" { int clone(int (*__fn)(void *),void *__child_stack,int __flags,void *__arg,... ) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int unshare(int __flags) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int sched_getcpu() throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int setns(int __fd,int __nstype) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }

struct __sched_param 
{
int __sched_priority;
}
;
typedef unsigned long __cpu_mask;
typedef struct {
__cpu_mask __bits[16];}cpu_set_t;
extern "C" { int __sched_cpucount(size_t __setsize,const cpu_set_t *__setp) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { cpu_set_t *__sched_cpualloc(size_t __count) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { void __sched_cpufree(cpu_set_t *__set) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int sched_setparam(__pid_t __pid,const struct sched_param *__param) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int sched_getparam(__pid_t __pid,struct sched_param *__param) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int sched_setscheduler(__pid_t __pid,int __policy,const struct sched_param *__param) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int sched_getscheduler(__pid_t __pid) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int sched_yield() throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int sched_get_priority_max(int __algorithm) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int sched_get_priority_min(int __algorithm) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int sched_rr_get_interval(__pid_t __pid,struct timespec *__t) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int sched_setaffinity(__pid_t __pid,size_t __cpusetsize,const cpu_set_t *__cpuset) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int sched_getaffinity(__pid_t __pid,size_t __cpusetsize,cpu_set_t *__cpuset) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }

struct timex 
{
unsigned int modes;
__syscall_slong_t offset;
__syscall_slong_t freq;
__syscall_slong_t maxerror;
__syscall_slong_t esterror;
int status;
__syscall_slong_t constant;
__syscall_slong_t precision;
__syscall_slong_t tolerance;
struct timeval time;
__syscall_slong_t tick;
__syscall_slong_t ppsfreq;
__syscall_slong_t jitter;
int shift;
__syscall_slong_t stabil;
__syscall_slong_t jitcnt;
__syscall_slong_t calcnt;
__syscall_slong_t errcnt;
__syscall_slong_t stbcnt;
int tai;
int :32;
int :32;
int :32;
int :32;
int :32;
int :32;
int :32;
int :32;
int :32;
int :32;
int :32;
}
;
extern "C" { int clock_adjtime(__clockid_t __clock_id,struct timex *__utx) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }

struct tm 
{
int tm_sec;
int tm_min;
int tm_hour;
int tm_mday;
int tm_mon;
int tm_year;
int tm_wday;
int tm_yday;
int tm_isdst;
long tm_gmtoff;
const char *tm_zone;
}
;

struct itimerspec 
{
struct timespec it_interval;
struct timespec it_value;
}
;
struct sigevent ;
extern "C" { clock_t clock() throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { time_t time(time_t *__timer) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { double difftime(time_t __time1,time_t __time0) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { time_t mktime(struct tm *__tp) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { size_t strftime(char *__s,size_t __maxsize,const char *__format,const struct tm *__tp) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { char *strptime(const char *__s,const char *__fmt,struct tm *__tp) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { size_t strftime_l(char *__s,size_t __maxsize,const char *__format,const struct tm *__tp,__locale_t __loc) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { char *strptime_l(const char *__s,const char *__fmt,struct tm *__tp,__locale_t __loc) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { struct tm *gmtime(const time_t *__timer) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { struct tm *localtime(const time_t *__timer) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { struct tm *gmtime_r(const time_t *__timer,struct tm *__tp) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { struct tm *localtime_r(const time_t *__timer,struct tm *__tp) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { char *asctime(const struct tm *__tp) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { char *ctime(const time_t *__timer) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { char *asctime_r(const struct tm *__tp,char *__buf) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { char *ctime_r(const time_t *__timer,char *__buf) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern char *__tzname[2];
extern int __daylight;
extern long __timezone;
extern char *tzname[2];
extern "C" { void tzset() throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern int daylight;
extern long timezone;
extern "C" { int stime(const time_t *__when) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { time_t timegm(struct tm *__tp) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { time_t timelocal(struct tm *__tp) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int dysize(int __year) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int nanosleep(const struct timespec *__requested_time,struct timespec *__remaining) __attribute__((visibility("default"))) ; }
extern "C" { int clock_getres(clockid_t __clock_id,struct timespec *__res) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int clock_gettime(clockid_t __clock_id,struct timespec *__tp) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int clock_settime(clockid_t __clock_id,const struct timespec *__tp) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int clock_nanosleep(clockid_t __clock_id,int __flags,const struct timespec *__req,struct timespec *__rem) __attribute__((visibility("default"))) ; }
extern "C" { int clock_getcpuclockid(pid_t __pid,clockid_t *__clock_id) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int timer_create(clockid_t __clock_id,struct sigevent *__evp,timer_t *__timerid) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int timer_delete(timer_t __timerid) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int timer_settime(timer_t __timerid,int __flags,const struct itimerspec *__value,struct itimerspec *__ovalue) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int timer_gettime(timer_t __timerid,struct itimerspec *__value) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int timer_getoverrun(timer_t __timerid) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int timespec_get(struct timespec *__ts,int __base) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern int getdate_err;
extern "C" { struct tm *getdate(const char *__string) __attribute__((visibility("default"))) ; }
extern "C" { int getdate_r(const char *__string,struct tm *__resbufp) __attribute__((visibility("default"))) ; }
typedef long __jmp_buf[8];
enum __anonymous_0x2663630 {PTHREAD_CREATE_JOINABLE=0,PTHREAD_CREATE_DETACHED=1} ;
enum __anonymous_0x2663cf0 {PTHREAD_MUTEX_TIMED_NP=0,PTHREAD_MUTEX_RECURSIVE_NP=1,PTHREAD_MUTEX_ERRORCHECK_NP=2,PTHREAD_MUTEX_ADAPTIVE_NP=3,PTHREAD_MUTEX_NORMAL=0,PTHREAD_MUTEX_RECURSIVE=1,PTHREAD_MUTEX_ERRORCHECK=2,PTHREAD_MUTEX_DEFAULT=0,PTHREAD_MUTEX_FAST_NP=0} ;
enum __anonymous_0x2665850 {PTHREAD_MUTEX_STALLED=0,PTHREAD_MUTEX_STALLED_NP=0,PTHREAD_MUTEX_ROBUST=1,PTHREAD_MUTEX_ROBUST_NP=1} ;
enum __anonymous_0x26665a0 {PTHREAD_PRIO_NONE=0,PTHREAD_PRIO_INHERIT=1,PTHREAD_PRIO_PROTECT=2} ;
enum __anonymous_0x2666ef0 {PTHREAD_RWLOCK_PREFER_READER_NP=0,PTHREAD_RWLOCK_PREFER_WRITER_NP=1,PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP=2,PTHREAD_RWLOCK_DEFAULT_NP=0} ;
enum __anonymous_0x2667b80 {PTHREAD_INHERIT_SCHED=0,PTHREAD_EXPLICIT_SCHED=1} ;
enum __anonymous_0x2668270 {PTHREAD_SCOPE_SYSTEM=0,PTHREAD_SCOPE_PROCESS=1} ;
enum __anonymous_0x2668960 {PTHREAD_PROCESS_PRIVATE=0,PTHREAD_PROCESS_SHARED=1} ;

struct _pthread_cleanup_buffer 
{
void (*__routine)(void *);
void *__arg;
int __canceltype;
struct _pthread_cleanup_buffer *__prev;
}
;
enum __anonymous_0x267ac10 {PTHREAD_CANCEL_ENABLE=0,PTHREAD_CANCEL_DISABLE=1} ;
enum __anonymous_0x267b2d0 {PTHREAD_CANCEL_DEFERRED=0,PTHREAD_CANCEL_ASYNCHRONOUS=1} ;
extern "C" { int pthread_create(pthread_t *__newthread,const ::pthread_attr_t *__attr,void *(*__start_routine)(void *),void *__arg) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { void pthread_exit(void *__retval) __attribute__((visibility("default")))  __attribute__((noreturn)); }
extern "C" { int pthread_join(pthread_t __th,void **__thread_return) __attribute__((visibility("default"))) ; }
extern "C" { int pthread_tryjoin_np(pthread_t __th,void **__thread_return) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_timedjoin_np(pthread_t __th,void **__thread_return,const struct timespec *__abstime) __attribute__((visibility("default"))) ; }
extern "C" { int pthread_detach(pthread_t __th) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { pthread_t pthread_self() throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { inline int pthread_equal(pthread_t __thread1,pthread_t __thread2) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_init(::pthread_attr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_destroy(::pthread_attr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_getdetachstate(const ::pthread_attr_t *__attr,int *__detachstate) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_setdetachstate(::pthread_attr_t *__attr,int __detachstate) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_getguardsize(const ::pthread_attr_t *__attr,size_t *__guardsize) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_setguardsize(::pthread_attr_t *__attr,size_t __guardsize) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_getschedparam(const ::pthread_attr_t *__attr,struct sched_param *__param) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_setschedparam(::pthread_attr_t *__attr,const struct sched_param *__param) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_getschedpolicy(const ::pthread_attr_t *__attr,int *__policy) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_setschedpolicy(::pthread_attr_t *__attr,int __policy) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_getinheritsched(const ::pthread_attr_t *__attr,int *__inherit) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_setinheritsched(::pthread_attr_t *__attr,int __inherit) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_getscope(const ::pthread_attr_t *__attr,int *__scope) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_setscope(::pthread_attr_t *__attr,int __scope) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_getstackaddr(const ::pthread_attr_t *__attr,void **__stackaddr) throw() __attribute__((deprecated))  __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_setstackaddr(::pthread_attr_t *__attr,void *__stackaddr) throw() __attribute__((deprecated))  __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_getstacksize(const ::pthread_attr_t *__attr,size_t *__stacksize) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_setstacksize(::pthread_attr_t *__attr,size_t __stacksize) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_getstack(const ::pthread_attr_t *__attr,void **__stackaddr,size_t *__stacksize) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_setstack(::pthread_attr_t *__attr,void *__stackaddr,size_t __stacksize) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_setaffinity_np(::pthread_attr_t *__attr,size_t __cpusetsize,const cpu_set_t *__cpuset) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_attr_getaffinity_np(const ::pthread_attr_t *__attr,size_t __cpusetsize,cpu_set_t *__cpuset) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_getattr_np(pthread_t __th,::pthread_attr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_setschedparam(pthread_t __target_thread,int __policy,const struct sched_param *__param) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_getschedparam(pthread_t __target_thread,int *__policy,struct sched_param *__param) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_setschedprio(pthread_t __target_thread,int __prio) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_getname_np(pthread_t __target_thread,char *__buf,size_t __buflen) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_setname_np(pthread_t __target_thread,const char *__name) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_getconcurrency() throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_setconcurrency(int __level) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_yield() throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_setaffinity_np(pthread_t __th,size_t __cpusetsize,const cpu_set_t *__cpuset) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_getaffinity_np(pthread_t __th,size_t __cpusetsize,cpu_set_t *__cpuset) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_once(pthread_once_t *__once_control,void (*__init_routine)()) __attribute__((visibility("default"))) ; }
extern "C" { int pthread_setcancelstate(int __state,int *__oldstate) __attribute__((visibility("default"))) ; }
extern "C" { int pthread_setcanceltype(int __type,int *__oldtype) __attribute__((visibility("default"))) ; }
extern "C" { int pthread_cancel(pthread_t __th) __attribute__((visibility("default"))) ; }
extern "C" { void pthread_testcancel() __attribute__((visibility("default"))) ; }
typedef struct {
struct {
__jmp_buf __cancel_jmp_buf;
int __mask_was_saved;}__cancel_jmp_buf[1];
void *__pad[4];}__pthread_unwind_buf_t __attribute__((aligned(16))) __attribute__((aligned(16)));

struct __pthread_cleanup_frame 
{
void (*__cancel_routine)(void *);
void *__cancel_arg;
int __do_it;
int __cancel_type;
}
;

class __pthread_cleanup_class 
{
private: void (*__cancel_routine)(void *);
void *__cancel_arg;
int __do_it;
int __cancel_type;

public: inline __pthread_cleanup_class(void (*__fct)(void *),void *__arg) : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1)
{
}

inline ~__pthread_cleanup_class()
{
if (((this) -> __do_it)) 
((this) -> __cancel_routine)(((this) -> __cancel_arg));
}

inline void __setdoit(int __newval)
{
(this) -> __do_it = __newval;
}

inline void __defer()
{
pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED,&(this) -> __cancel_type);
}

inline void __restore() const
{
pthread_setcanceltype((this) -> __cancel_type,0);
}
}
;
struct __jmp_buf_tag ;
extern "C" { int __sigsetjmp(struct __jmp_buf_tag *__env,int __savemask) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutex_init(pthread_mutex_t *__mutex,const pthread_mutexattr_t *__mutexattr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutex_destroy(pthread_mutex_t *__mutex) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutex_trylock(pthread_mutex_t *__mutex) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutex_lock(pthread_mutex_t *__mutex) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutex_timedlock(pthread_mutex_t *__mutex,const struct timespec *__abstime) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutex_unlock(pthread_mutex_t *__mutex) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutex_getprioceiling(const pthread_mutex_t *__mutex,int *__prioceiling) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutex_setprioceiling(pthread_mutex_t *__mutex,int __prioceiling,int *__old_ceiling) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutex_consistent(pthread_mutex_t *__mutex) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutex_consistent_np(pthread_mutex_t *__mutex) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_init(pthread_mutexattr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__attr,int *__pshared) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr,int __pshared) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_gettype(const pthread_mutexattr_t *__attr,int *__kind) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_settype(pthread_mutexattr_t *__attr,int __kind) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__attr,int *__protocol) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr,int __protocol) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__attr,int *__prioceiling) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr,int __prioceiling) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr,int *__robustness) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t *__attr,int *__robustness) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr,int __robustness) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *__attr,int __robustness) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlock_init(pthread_rwlock_t *__rwlock,const pthread_rwlockattr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlock_timedrdlock(pthread_rwlock_t *__rwlock,const struct timespec *__abstime) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlock_timedwrlock(pthread_rwlock_t *__rwlock,const struct timespec *__abstime) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__attr,int *__pshared) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr,int __pshared) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__attr,int *__pref) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr,int __pref) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_cond_init(pthread_cond_t *__cond,const pthread_condattr_t *__cond_attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_cond_destroy(pthread_cond_t *__cond) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_cond_signal(pthread_cond_t *__cond) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_cond_broadcast(pthread_cond_t *__cond) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_cond_wait(pthread_cond_t *__cond,pthread_mutex_t *__mutex) __attribute__((visibility("default"))) ; }
extern "C" { int pthread_cond_timedwait(pthread_cond_t *__cond,pthread_mutex_t *__mutex,const struct timespec *__abstime) __attribute__((visibility("default"))) ; }
extern "C" { int pthread_condattr_init(pthread_condattr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_condattr_destroy(pthread_condattr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_condattr_getpshared(const pthread_condattr_t *__attr,int *__pshared) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_condattr_setpshared(pthread_condattr_t *__attr,int __pshared) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_condattr_getclock(const pthread_condattr_t *__attr,__clockid_t *__clock_id) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_condattr_setclock(pthread_condattr_t *__attr,__clockid_t __clock_id) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_spin_init(pthread_spinlock_t *__lock,int __pshared) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_spin_destroy(pthread_spinlock_t *__lock) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_spin_lock(pthread_spinlock_t *__lock) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_spin_trylock(pthread_spinlock_t *__lock) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_spin_unlock(pthread_spinlock_t *__lock) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_barrier_init(pthread_barrier_t *__barrier,const pthread_barrierattr_t *__attr,unsigned int __count) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_barrier_destroy(pthread_barrier_t *__barrier) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_barrier_wait(pthread_barrier_t *__barrier) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_barrierattr_init(pthread_barrierattr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__attr,int *__pshared) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr,int __pshared) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_key_create(pthread_key_t *__key,void (*__destr_function)(void *)) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_key_delete(pthread_key_t __key) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { void *pthread_getspecific(pthread_key_t __key) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_setspecific(pthread_key_t __key,const void *__pointer) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_getcpuclockid(pthread_t __thread_id,__clockid_t *__clock_id) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }
extern "C" { int pthread_atfork(void (*__prepare)(),void (*__parent)(),void (*__child)()) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ; }

inline int  __attribute__((no_throw))  __attribute__((visibility("default"))) pthread_equal(pthread_t __thread1,pthread_t __thread2) throw()
{
return (__thread1 == __thread2);
}
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
static int __gthrw_pthread_once(pthread_once_t *__once_control,void (*__init_routine)()) __attribute__((visibility("default"))) ;
static void *__gthrw_pthread_getspecific(pthread_key_t __key) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_setspecific(pthread_key_t __key,const void *__pointer) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_create(pthread_t *__newthread,const ::pthread_attr_t *__attr,void *(*__start_routine)(void *),void *__arg) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_join(pthread_t __th,void **__thread_return) __attribute__((visibility("default"))) ;
static int __gthrw_pthread_equal(pthread_t __thread1,pthread_t __thread2) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static pthread_t __gthrw_pthread_self() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_detach(pthread_t __th) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_cancel(pthread_t __th) __attribute__((visibility("default"))) ;
static int __gthrw_sched_yield() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_mutex_lock(pthread_mutex_t *__mutex) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_mutex_trylock(pthread_mutex_t *__mutex) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_mutex_timedlock(pthread_mutex_t *__mutex,const struct timespec *__abstime) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_mutex_unlock(pthread_mutex_t *__mutex) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_mutex_init(pthread_mutex_t *__mutex,const pthread_mutexattr_t *__mutexattr) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_mutex_destroy(pthread_mutex_t *__mutex) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_cond_init(pthread_cond_t *__cond,const pthread_condattr_t *__cond_attr) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_cond_broadcast(pthread_cond_t *__cond) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_cond_signal(pthread_cond_t *__cond) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_cond_wait(pthread_cond_t *__cond,pthread_mutex_t *__mutex) __attribute__((visibility("default"))) ;
static int __gthrw_pthread_cond_timedwait(pthread_cond_t *__cond,pthread_mutex_t *__mutex,const struct timespec *__abstime) __attribute__((visibility("default"))) ;
static int __gthrw_pthread_cond_destroy(pthread_cond_t *__cond) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_key_create(pthread_key_t *__key,void (*__destr_function)(void *)) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_key_delete(pthread_key_t __key) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_mutexattr_init(pthread_mutexattr_t *__attr) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_mutexattr_settype(pthread_mutexattr_t *__attr,int __kind) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw_pthread_mutexattr_destroy(pthread_mutexattr_t *__attr) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
static int __gthrw___pthread_key_create(pthread_key_t *__key,void (*__destr_function)(void *)) __attribute__((no_throw))  __attribute__((visibility("default"))) ;

inline static int  __attribute__((visibility("default"))) __gthread_active_p()
{
static void *const __gthread_active_ptr = (void *)(&__gthrw___pthread_key_create);
return (__gthread_active_ptr != 0);
}

inline static int  __attribute__((visibility("default"))) __gthread_create(__gthread_t *__threadid,void *(*__func)(void *),void *__args)
{
return __gthrw_pthread_create(__threadid,0L,__func,__args);
}

inline static int  __attribute__((visibility("default"))) __gthread_join(__gthread_t __threadid,void **__value_ptr)
{
return __gthrw_pthread_join(__threadid,__value_ptr);
}

inline static int  __attribute__((visibility("default"))) __gthread_detach(__gthread_t __threadid)
{
return __gthrw_pthread_detach(__threadid);
}

inline static int  __attribute__((visibility("default"))) __gthread_equal(__gthread_t __t1,__gthread_t __t2)
{
return __gthrw_pthread_equal(__t1,__t2);
}

inline static __gthread_t  __attribute__((visibility("default"))) __gthread_self()
{
return __gthrw_pthread_self();
}

inline static int  __attribute__((visibility("default"))) __gthread_yield()
{
return __gthrw_sched_yield();
}

inline static int  __attribute__((visibility("default"))) __gthread_once(__gthread_once_t *__once,void (*__func)())
{
if ((__gthread_active_p())) 
return __gthrw_pthread_once(__once,__func);
 else 
return - 1;
}

inline static int  __attribute__((visibility("default"))) __gthread_key_create(__gthread_key_t *__key,void (*__dtor)(void *))
{
return __gthrw_pthread_key_create(__key,__dtor);
}

inline static int  __attribute__((visibility("default"))) __gthread_key_delete(__gthread_key_t __key)
{
return __gthrw_pthread_key_delete(__key);
}

inline static void * __attribute__((visibility("default"))) __gthread_getspecific(__gthread_key_t __key)
{
return __gthrw_pthread_getspecific(__key);
}

inline static int  __attribute__((visibility("default"))) __gthread_setspecific(__gthread_key_t __key,const void *__ptr)
{
return __gthrw_pthread_setspecific(__key,__ptr);
}

inline static void  __attribute__((visibility("default"))) __gthread_mutex_init_function(__gthread_mutex_t *__mutex)
{
if ((__gthread_active_p())) 
__gthrw_pthread_mutex_init(__mutex,0L);
}

inline static int  __attribute__((visibility("default"))) __gthread_mutex_destroy(__gthread_mutex_t *__mutex)
{
if ((__gthread_active_p())) 
return __gthrw_pthread_mutex_destroy(__mutex);
 else 
return 0;
}

inline static int  __attribute__((visibility("default"))) __gthread_mutex_lock(__gthread_mutex_t *__mutex)
{
if ((__gthread_active_p())) 
return __gthrw_pthread_mutex_lock(__mutex);
 else 
return 0;
}

inline static int  __attribute__((visibility("default"))) __gthread_mutex_trylock(__gthread_mutex_t *__mutex)
{
if ((__gthread_active_p())) 
return __gthrw_pthread_mutex_trylock(__mutex);
 else 
return 0;
}

inline static int  __attribute__((visibility("default"))) __gthread_mutex_timedlock(__gthread_mutex_t *__mutex,const __gthread_time_t *__abs_timeout)
{
if ((__gthread_active_p())) 
return __gthrw_pthread_mutex_timedlock(__mutex,__abs_timeout);
 else 
return 0;
}

inline static int  __attribute__((visibility("default"))) __gthread_mutex_unlock(__gthread_mutex_t *__mutex)
{
if ((__gthread_active_p())) 
return __gthrw_pthread_mutex_unlock(__mutex);
 else 
return 0;
}

inline static int  __attribute__((visibility("default"))) __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex)
{
return __gthread_mutex_lock(__mutex);
}

inline static int  __attribute__((visibility("default"))) __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex)
{
return __gthread_mutex_trylock(__mutex);
}

inline static int  __attribute__((visibility("default"))) __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex,const __gthread_time_t *__abs_timeout)
{
return __gthread_mutex_timedlock(__mutex,__abs_timeout);
}

inline static int  __attribute__((visibility("default"))) __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex)
{
return __gthread_mutex_unlock(__mutex);
}

inline static int  __attribute__((visibility("default"))) __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex)
{
return __gthread_mutex_destroy(__mutex);
}

inline static int  __attribute__((visibility("default"))) __gthread_cond_broadcast(__gthread_cond_t *__cond)
{
return __gthrw_pthread_cond_broadcast(__cond);
}

inline static int  __attribute__((visibility("default"))) __gthread_cond_signal(__gthread_cond_t *__cond)
{
return __gthrw_pthread_cond_signal(__cond);
}

inline static int  __attribute__((visibility("default"))) __gthread_cond_wait(__gthread_cond_t *__cond,__gthread_mutex_t *__mutex)
{
return __gthrw_pthread_cond_wait(__cond,__mutex);
}

inline static int  __attribute__((visibility("default"))) __gthread_cond_timedwait(__gthread_cond_t *__cond,__gthread_mutex_t *__mutex,const __gthread_time_t *__abs_timeout)
{
return __gthrw_pthread_cond_timedwait(__cond,__mutex,__abs_timeout);
}

inline static int  __attribute__((visibility("default"))) __gthread_cond_wait_recursive(__gthread_cond_t *__cond,__gthread_recursive_mutex_t *__mutex)
{
return __gthread_cond_wait(__cond,__mutex);
}

inline static int  __attribute__((visibility("default"))) __gthread_cond_destroy(__gthread_cond_t *__cond)
{
return __gthrw_pthread_cond_destroy(__cond);
}
#pragma GCC visibility pop
typedef int _Atomic_word;
namespace __gnu_cxx
{

inline static _Atomic_word  __attribute__((visibility("default"))) __exchange_and_add(volatile _Atomic_word *__mem,int __val)
{
return  *__mem;
}

inline static void  __attribute__((visibility("default"))) __atomic_add(volatile _Atomic_word *__mem,int __val)
{
 *__mem;
}

inline static _Atomic_word  __attribute__((visibility("default"))) __exchange_and_add_single(_Atomic_word *__mem,int __val)
{
_Atomic_word __result =  *__mem;
 *__mem += __val;
return __result;
}

inline static void  __attribute__((visibility("default"))) __atomic_add_single(_Atomic_word *__mem,int __val)
{
 *__mem += __val;
}

inline static _Atomic_word  __attribute__((visibility("default"))) __exchange_and_add_dispatch(_Atomic_word *__mem,int __val)
{
if ((__gthread_active_p())) 
return __exchange_and_add(__mem,__val);
 else 
return __exchange_and_add_single(__mem,__val);
}

inline static void  __attribute__((visibility("default"))) __atomic_add_dispatch(_Atomic_word *__mem,int __val)
{
if ((__gthread_active_p())) 
__atomic_add(__mem,__val);
 else 
__atomic_add_single(__mem,__val);
}
}
#pragma GCC visibility push ( default )
namespace std
{

class bad_alloc : public exception
{

public: inline bad_alloc() throw()
{
}
virtual ~bad_alloc() throw();
virtual const char *what() const throw();
}
;

class bad_array_new_length : public bad_alloc
{

public: inline bad_array_new_length() throw()
{
}
virtual ~bad_array_new_length() throw();
virtual const char *what() const throw();
}
;

struct nothrow_t 
{
inline explicit nothrow_t() = default;
}
;
extern const struct nothrow_t nothrow;
typedef void (*new_handler)();
extern new_handler set_new_handler(new_handler ) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern new_handler get_new_handler() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
}
extern void *operator new(std::size_t ) __attribute__((visibility("default"))) ;
extern void *operator new[](std::size_t ) __attribute__((visibility("default"))) ;
extern void operator delete(void *) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void operator delete[](void *) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void operator delete(void *,std::size_t ) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void operator delete[](void *,std::size_t ) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void *operator new(std::size_t ,const struct std::nothrow_t &) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void *operator new[](std::size_t ,const struct std::nothrow_t &) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void operator delete(void *,const struct std::nothrow_t &) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void operator delete[](void *,const struct std::nothrow_t &) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void operator delete(void *,std::size_t ,const struct std::nothrow_t &) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
extern void operator delete[](void *,std::size_t ,const struct std::nothrow_t &) __attribute__((no_throw))  __attribute__((visibility("default"))) ;

inline void * __attribute__((no_throw))  __attribute__((visibility("default"))) operator new(std::size_t ,void *__p)
{
return __p;
}

inline void * __attribute__((no_throw))  __attribute__((visibility("default"))) operator new[](std::size_t ,void *__p)
{
return __p;
}

inline void  __attribute__((no_throw))  __attribute__((visibility("default"))) operator delete(void *,void *)
{
}

inline void  __attribute__((no_throw))  __attribute__((visibility("default"))) operator delete[](void *,void *)
{
}
#pragma GCC visibility pop
namespace __gnu_cxx
{
using std::size_t;
using std::ptrdiff_t;
template < typename _Tp >
    class new_allocator
    {
    public :
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp * pointer;
      typedef const _Tp * const_pointer;
      typedef _Tp & reference;
      typedef const _Tp & const_reference;
      typedef _Tp value_type;
      template < typename _Tp1 >
        struct rebind
        { typedef new_allocator < _Tp1 > other; };
      typedef std :: true_type propagate_on_container_move_assignment;
      new_allocator ( ) noexcept;
      new_allocator ( const new_allocator & ) noexcept;
      template < typename _Tp1 >
        new_allocator ( const new_allocator < _Tp1 > & ) noexcept { }
      ~ new_allocator ( ) noexcept;
      pointer
      address ( reference __x ) const noexcept
      ;
      const_pointer
      address ( const_reference __x ) const noexcept
      ;
      pointer
      allocate ( size_type __n, const void * = 0 )
      ;
      void
      deallocate ( pointer __p, size_type )
      ;
      size_type
      max_size ( ) const noexcept
      ;
      template < typename _Up, typename ... _Args >
        void
        construct ( _Up * __p, _Args && ... __args )
 { :: new ( ( void * ) __p ) _Up ( std :: forward < _Args > ( __args ) ... ); }
      template < typename _Up >
        void
        destroy ( _Up * __p ) { __p -> ~ _Up ( ); }
    };
template < typename _Tp >
    inline bool
    operator == ( const new_allocator < _Tp > &, const new_allocator < _Tp > & )
    { return true; }
template < typename _Tp >
    inline bool
    operator != ( const new_allocator < _Tp > &, const new_allocator < _Tp > & )
    { return false; }
}
namespace std
{
template < typename _Tp >
    using __allocator_base = __gnu_cxx :: new_allocator < _Tp >;
}
namespace std
{
template<> class allocator< void  > 
{
public: typedef size_t size_type;
typedef ptrdiff_t difference_type;
typedef void *pointer;
typedef const void *const_pointer;
typedef void value_type;
template < typename _Tp1 >
        struct rebind
        { typedef allocator < _Tp1 > other; };
typedef true_type propagate_on_container_move_assignment;
typedef true_type is_always_equal;
};
template < typename _Tp >
    class allocator : public __allocator_base < _Tp >
    {
   public :
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp * pointer;
      typedef const _Tp * const_pointer;
      typedef _Tp & reference;
      typedef const _Tp & const_reference;
      typedef _Tp value_type;
      template < typename _Tp1 >
        struct rebind
        { typedef allocator < _Tp1 > other; };
      typedef true_type propagate_on_container_move_assignment;
      allocator ( ) throw ( );
      allocator ( const allocator & __a ) throw ( )
      ;
      template < typename _Tp1 >
        allocator ( const allocator < _Tp1 > & ) throw ( ) { }
      ~ allocator ( ) throw ( );
    };
template < typename _T1, typename _T2 >
    inline bool
    operator == ( const allocator < _T1 > &, const allocator < _T2 > & )
    noexcept
    { return true; }
template < typename _Tp >
    inline bool
    operator == ( const allocator < _Tp > &, const allocator < _Tp > & )
    noexcept
    { return true; }
template < typename _T1, typename _T2 >
    inline bool
    operator != ( const allocator < _T1 > &, const allocator < _T2 > & )
    noexcept
    { return false; }
template < typename _Tp >
    inline bool
    operator != ( const allocator < _Tp > &, const allocator < _Tp > & )
    noexcept
    { return false; }
extern template class allocator< char  > ;
extern template class allocator< wchar_t  > ;
template < typename _Alloc, bool = __is_empty ( _Alloc ) >
    struct __alloc_swap
    { static void _S_do_it ( _Alloc &, _Alloc & ) noexcept; };
template < typename _Alloc >
    struct __alloc_swap < _Alloc, false >
    {
      static void
      _S_do_it ( _Alloc & __one, _Alloc & __two ) noexcept
      ;
    };
template < typename _Alloc, bool = __is_empty ( _Alloc ) >
    struct __alloc_neq
    {
      static bool
      _S_do_it ( const _Alloc &, const _Alloc & )
      ;
    };
template < typename _Alloc >
    struct __alloc_neq < _Alloc, false >
    {
      static bool
      _S_do_it ( const _Alloc & __one, const _Alloc & __two )
      ;
    };
template < typename _Tp, bool
    = __or_ < is_copy_constructible < typename _Tp :: value_type >,
            is_nothrow_move_constructible < typename _Tp :: value_type > > :: value >
    struct __shrink_to_fit_aux
    { static bool _S_do_it ( _Tp & ) noexcept; };
template < typename _Tp >
    struct __shrink_to_fit_aux < _Tp, true >
    {
      static bool
      _S_do_it ( _Tp & __c ) noexcept
      ;
    };
}
#pragma GCC visibility push ( default )
namespace __cxxabiv1
{

class __forced_unwind 
{
private: virtual ~__forced_unwind() throw();
virtual void __pure_dummy() = 0;
}
;
}
#pragma GCC visibility pop
namespace std
{
template < typename _CharT, typename _Traits >
    inline void
    __ostream_write ( basic_ostream < _CharT, _Traits > & __out,
      const _CharT * __s, streamsize __n )
    {
      typedef basic_ostream < _CharT, _Traits > __ostream_type;
      typedef typename __ostream_type :: ios_base __ios_base;
      const streamsize __put = __out . rdbuf ( ) -> sputn ( __s, __n );
      if ( __put != __n )
 __out . setstate ( __ios_base :: badbit );
    }
template < typename _CharT, typename _Traits >
    inline void
    __ostream_fill ( basic_ostream < _CharT, _Traits > & __out, streamsize __n )
    {
      typedef basic_ostream < _CharT, _Traits > __ostream_type;
      typedef typename __ostream_type :: ios_base __ios_base;
      const _CharT __c = __out . fill ( );
      for (; __n > 0; -- __n )
 {
   const typename _Traits :: int_type __put = __out . rdbuf ( ) -> sputc ( __c );
   if ( _Traits :: eq_int_type ( __put, _Traits :: eof ( ) ) )
     {
       __out . setstate ( __ios_base :: badbit );
       break;
     }
 }
    }
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    __ostream_insert ( basic_ostream < _CharT, _Traits > & __out,
       const _CharT * __s, streamsize __n )
    {
      typedef basic_ostream < _CharT, _Traits > __ostream_type;
      typedef typename __ostream_type :: ios_base __ios_base;
      typename __ostream_type :: sentry __cerb ( __out );
      if ( __cerb )
 {
   try
     {
       const streamsize __w = __out . width ( );
       if ( __w > __n )
  {
    const bool __left = ( ( __out . flags ( )
     & __ios_base :: adjustfield )
           == __ios_base :: left );
    if ( ! __left )
      __ostream_fill ( __out, __w - __n );
    if ( __out . good ( ) )
      __ostream_write ( __out, __s, __n );
    if ( __left && __out . good ( ) )
      __ostream_fill ( __out, __w - __n );
  }
       else
  __ostream_write ( __out, __s, __n );
       __out . width ( 0 );
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       __out . _M_setstate ( __ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { __out . _M_setstate ( __ios_base :: badbit ); }
 }
      return __out;
    }
extern template class basic_ostream< char  , char_traits< char  >  > &__ostream_insert(class basic_ostream< char  , char_traits< char  >  > &__out,const char *__s,streamsize __n);
extern template class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &__ostream_insert(class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &__out,const wchar_t *__s,streamsize __n);
}
namespace std
{
template < typename _Arg, typename _Result >
    struct unary_function
    {
      typedef _Arg argument_type;
      typedef _Result result_type;
    };
template < typename _Arg1, typename _Arg2, typename _Result >
    struct binary_function
    {
      typedef _Arg1 first_argument_type;
      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
struct __is_transparent ;
template < typename _Tp = void >
    struct plus;
template < typename _Tp = void >
    struct minus;
template < typename _Tp = void >
    struct multiplies;
template < typename _Tp = void >
    struct divides;
template < typename _Tp = void >
    struct modulus;
template < typename _Tp = void >
    struct negate;
template < typename _Tp >
    struct plus : public binary_function < _Tp, _Tp, _Tp >
    {
      constexpr
      _Tp
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct minus : public binary_function < _Tp, _Tp, _Tp >
    {
      constexpr
      _Tp
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct multiplies : public binary_function < _Tp, _Tp, _Tp >
    {
      constexpr
      _Tp
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct divides : public binary_function < _Tp, _Tp, _Tp >
    {
      constexpr
      _Tp
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct modulus : public binary_function < _Tp, _Tp, _Tp >
    {
      constexpr
      _Tp
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct negate : public unary_function < _Tp, _Tp >
    {
      constexpr
      _Tp
      operator ( ) ( const _Tp & __x ) const
      ;
    };
template<> struct plus< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) + std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) + std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) + std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct minus< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) - std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) - std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) - std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct multiplies< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) * std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) * std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) * std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct divides< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) / std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) / std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) / std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct modulus< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) % std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) % std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) % std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct negate< void  > 
{
template < typename _Tp >
 constexpr
 auto
 operator ( ) ( _Tp && __t ) const
 noexcept ( noexcept ( - std :: forward < _Tp > ( __t ) ) )
 -> decltype ( - std :: forward < _Tp > ( __t ) )
 { return - std :: forward < _Tp > ( __t ); }
typedef struct __is_transparent is_transparent;
};
template < typename _Tp = void >
    struct equal_to;
template < typename _Tp = void >
    struct not_equal_to;
template < typename _Tp = void >
    struct greater;
template < typename _Tp = void >
    struct less;
template < typename _Tp = void >
    struct greater_equal;
template < typename _Tp = void >
    struct less_equal;
template < typename _Tp >
    struct equal_to : public binary_function < _Tp, _Tp, bool >
    {
      constexpr
      bool
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct not_equal_to : public binary_function < _Tp, _Tp, bool >
    {
      constexpr
      bool
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct greater : public binary_function < _Tp, _Tp, bool >
    {
      constexpr
      bool
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct less : public binary_function < _Tp, _Tp, bool >
    {
      constexpr
      bool
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct greater_equal : public binary_function < _Tp, _Tp, bool >
    {
      constexpr
      bool
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct less_equal : public binary_function < _Tp, _Tp, bool >
    {
      constexpr
      bool
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template<> struct equal_to< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) == std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) == std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) == std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct not_equal_to< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) != std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) != std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) != std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct greater< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) > std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) > std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) > std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct less< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) < std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) < std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) < std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct greater_equal< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) >= std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) >= std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) >= std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct less_equal< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) <= std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) <= std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) <= std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template < typename _Tp = void >
    struct logical_and;
template < typename _Tp = void >
    struct logical_or;
template < typename _Tp = void >
    struct logical_not;
template < typename _Tp >
    struct logical_and : public binary_function < _Tp, _Tp, bool >
    {
      constexpr
      bool
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct logical_or : public binary_function < _Tp, _Tp, bool >
    {
      constexpr
      bool
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct logical_not : public unary_function < _Tp, bool >
    {
      constexpr
      bool
      operator ( ) ( const _Tp & __x ) const
      ;
    };
template<> struct logical_and< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) && std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) && std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) && std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct logical_or< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) || std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) || std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) || std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct logical_not< void  > 
{
template < typename _Tp >
 constexpr
 auto
 operator ( ) ( _Tp && __t ) const
 noexcept ( noexcept ( ! std :: forward < _Tp > ( __t ) ) )
 -> decltype ( ! std :: forward < _Tp > ( __t ) )
 { return ! std :: forward < _Tp > ( __t ); }
typedef struct __is_transparent is_transparent;
};
template < typename _Tp = void >
    struct bit_and;
template < typename _Tp = void >
    struct bit_or;
template < typename _Tp = void >
    struct bit_xor;
template < typename _Tp = void >
    struct bit_not;
template < typename _Tp >
    struct bit_and : public binary_function < _Tp, _Tp, _Tp >
    {
      constexpr
      _Tp
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct bit_or : public binary_function < _Tp, _Tp, _Tp >
    {
      constexpr
      _Tp
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct bit_xor : public binary_function < _Tp, _Tp, _Tp >
    {
      constexpr
      _Tp
      operator ( ) ( const _Tp & __x, const _Tp & __y ) const
      ;
    };
template < typename _Tp >
    struct bit_not : public unary_function < _Tp, _Tp >
    {
    constexpr
      _Tp
      operator ( ) ( const _Tp & __x ) const
      ;
    };
template<> struct bit_and< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) & std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) & std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) & std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct bit_or< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) | std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) | std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) | std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct bit_xor< void  > 
{
template < typename _Tp, typename _Up >
 constexpr
 auto
 operator ( ) ( _Tp && __t, _Up && __u ) const
 noexcept ( noexcept ( std :: forward < _Tp > ( __t ) ^ std :: forward < _Up > ( __u ) ) )
 -> decltype ( std :: forward < _Tp > ( __t ) ^ std :: forward < _Up > ( __u ) )
 { return std :: forward < _Tp > ( __t ) ^ std :: forward < _Up > ( __u ); }
typedef struct __is_transparent is_transparent;
};
template<> struct bit_not< void  > 
{
template < typename _Tp >
 constexpr
 auto
 operator ( ) ( _Tp && __t ) const
 noexcept ( noexcept ( ~ std :: forward < _Tp > ( __t ) ) )
 -> decltype ( ~ std :: forward < _Tp > ( __t ) )
 { return ~ std :: forward < _Tp > ( __t ); }
typedef struct __is_transparent is_transparent;
};
template < typename _Predicate >
    class unary_negate
    : public unary_function < typename _Predicate :: argument_type, bool >
    {
    protected :
      _Predicate _M_pred;
    public :
      constexpr
      explicit
      unary_negate ( const _Predicate & __x );
      constexpr
      bool
      operator ( ) ( const typename _Predicate :: argument_type & __x ) const
      ;
    };
template < typename _Predicate >
    constexpr
    inline unary_negate < _Predicate >
    not1 ( const _Predicate & __pred )
    { return unary_negate < _Predicate > ( __pred ); }
template < typename _Predicate >
    class binary_negate
    : public binary_function < typename _Predicate :: first_argument_type,
        typename _Predicate :: second_argument_type, bool >
    {
    protected :
      _Predicate _M_pred;
    public :
      constexpr
      explicit
      binary_negate ( const _Predicate & __x );
      constexpr
      bool
      operator ( ) ( const typename _Predicate :: first_argument_type & __x,
   const typename _Predicate :: second_argument_type & __y ) const
      ;
    };
template < typename _Predicate >
    constexpr
    inline binary_negate < _Predicate >
    not2 ( const _Predicate & __pred )
    { return binary_negate < _Predicate > ( __pred ); }
template < typename _Arg, typename _Result >
    class pointer_to_unary_function : public unary_function < _Arg, _Result >
    {
    protected :
      _Result ( * _M_ptr ) ( _Arg );
    public :
      pointer_to_unary_function ( );
      explicit
      pointer_to_unary_function ( _Result ( * __x ) ( _Arg ) )
      ;
      _Result
      operator ( ) ( _Arg __x ) const
      ;
    };
template < typename _Arg, typename _Result >
    inline pointer_to_unary_function < _Arg, _Result >
    ptr_fun ( _Result ( * __x ) ( _Arg ) )
    { return pointer_to_unary_function < _Arg, _Result > ( __x ); }
template < typename _Arg1, typename _Arg2, typename _Result >
    class pointer_to_binary_function
    : public binary_function < _Arg1, _Arg2, _Result >
    {
    protected :
      _Result ( * _M_ptr ) ( _Arg1, _Arg2 );
    public :
      pointer_to_binary_function ( );
      explicit
      pointer_to_binary_function ( _Result ( * __x ) ( _Arg1, _Arg2 ) )
      ;
      _Result
      operator ( ) ( _Arg1 __x, _Arg2 __y ) const
      ;
    };
template < typename _Arg1, typename _Arg2, typename _Result >
    inline pointer_to_binary_function < _Arg1, _Arg2, _Result >
    ptr_fun ( _Result ( * __x ) ( _Arg1, _Arg2 ) )
    { return pointer_to_binary_function < _Arg1, _Arg2, _Result > ( __x ); }
template < typename _Tp >
    struct _Identity
    : public unary_function < _Tp, _Tp >
    {
      _Tp &
      operator ( ) ( _Tp & __x ) const
      ;
      const _Tp &
      operator ( ) ( const _Tp & __x ) const
      ;
    };
template < typename _Pair >
    struct _Select1st
    : public unary_function < _Pair, typename _Pair :: first_type >
    {
      typename _Pair :: first_type &
      operator ( ) ( _Pair & __x ) const
      ;
      const typename _Pair :: first_type &
      operator ( ) ( const _Pair & __x ) const
      ;
      template < typename _Pair2 >
        typename _Pair2 :: first_type &
        operator ( ) ( _Pair2 & __x ) const
        { return __x . first; }
      template < typename _Pair2 >
        const typename _Pair2 :: first_type &
        operator ( ) ( const _Pair2 & __x ) const
        { return __x . first; }
    };
template < typename _Pair >
    struct _Select2nd
    : public unary_function < _Pair, typename _Pair :: second_type >
    {
      typename _Pair :: second_type &
      operator ( ) ( _Pair & __x ) const
      ;
      const typename _Pair :: second_type &
      operator ( ) ( const _Pair & __x ) const
      ;
    };
template < typename _Ret, typename _Tp >
    class mem_fun_t : public unary_function < _Tp *, _Ret >
    {
    public :
      explicit
      mem_fun_t ( _Ret ( _Tp :: * __pf ) ( ) )
      ;
      _Ret
      operator ( ) ( _Tp * __p ) const
      ;
    private :
      _Ret ( _Tp :: * _M_f ) ( );
    };
template < typename _Ret, typename _Tp >
    class const_mem_fun_t : public unary_function < const _Tp *, _Ret >
    {
    public :
      explicit
      const_mem_fun_t ( _Ret ( _Tp :: * __pf ) ( ) const )
      ;
      _Ret
      operator ( ) ( const _Tp * __p ) const
      ;
    private :
      _Ret ( _Tp :: * _M_f ) ( ) const;
    };
template < typename _Ret, typename _Tp >
    class mem_fun_ref_t : public unary_function < _Tp, _Ret >
    {
    public :
      explicit
      mem_fun_ref_t ( _Ret ( _Tp :: * __pf ) ( ) )
      ;
      _Ret
      operator ( ) ( _Tp & __r ) const
      ;
    private :
      _Ret ( _Tp :: * _M_f ) ( );
  };
template < typename _Ret, typename _Tp >
    class const_mem_fun_ref_t : public unary_function < _Tp, _Ret >
    {
    public :
      explicit
      const_mem_fun_ref_t ( _Ret ( _Tp :: * __pf ) ( ) const )
      ;
      _Ret
      operator ( ) ( const _Tp & __r ) const
      ;
    private :
      _Ret ( _Tp :: * _M_f ) ( ) const;
    };
template < typename _Ret, typename _Tp, typename _Arg >
    class mem_fun1_t : public binary_function < _Tp *, _Arg, _Ret >
    {
    public :
      explicit
      mem_fun1_t ( _Ret ( _Tp :: * __pf ) ( _Arg ) )
      ;
      _Ret
      operator ( ) ( _Tp * __p, _Arg __x ) const
      ;
    private :
      _Ret ( _Tp :: * _M_f ) ( _Arg );
    };
template < typename _Ret, typename _Tp, typename _Arg >
    class const_mem_fun1_t : public binary_function < const _Tp *, _Arg, _Ret >
    {
    public :
      explicit
      const_mem_fun1_t ( _Ret ( _Tp :: * __pf ) ( _Arg ) const )
      ;
      _Ret
      operator ( ) ( const _Tp * __p, _Arg __x ) const
      ;
    private :
      _Ret ( _Tp :: * _M_f ) ( _Arg ) const;
    };
template < typename _Ret, typename _Tp, typename _Arg >
    class mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >
    {
    public :
      explicit
      mem_fun1_ref_t ( _Ret ( _Tp :: * __pf ) ( _Arg ) )
      ;
      _Ret
      operator ( ) ( _Tp & __r, _Arg __x ) const
      ;
    private :
      _Ret ( _Tp :: * _M_f ) ( _Arg );
    };
template < typename _Ret, typename _Tp, typename _Arg >
    class const_mem_fun1_ref_t : public binary_function < _Tp, _Arg, _Ret >
    {
    public :
      explicit
      const_mem_fun1_ref_t ( _Ret ( _Tp :: * __pf ) ( _Arg ) const )
      ;
      _Ret
      operator ( ) ( const _Tp & __r, _Arg __x ) const
      ;
    private :
      _Ret ( _Tp :: * _M_f ) ( _Arg ) const;
    };
template < typename _Ret, typename _Tp >
    inline mem_fun_t < _Ret, _Tp >
    mem_fun ( _Ret ( _Tp :: * __f ) ( ) )
    { return mem_fun_t < _Ret, _Tp > ( __f ); }
template < typename _Ret, typename _Tp >
    inline const_mem_fun_t < _Ret, _Tp >
    mem_fun ( _Ret ( _Tp :: * __f ) ( ) const )
    { return const_mem_fun_t < _Ret, _Tp > ( __f ); }
template < typename _Ret, typename _Tp >
    inline mem_fun_ref_t < _Ret, _Tp >
    mem_fun_ref ( _Ret ( _Tp :: * __f ) ( ) )
    { return mem_fun_ref_t < _Ret, _Tp > ( __f ); }
template < typename _Ret, typename _Tp >
    inline const_mem_fun_ref_t < _Ret, _Tp >
    mem_fun_ref ( _Ret ( _Tp :: * __f ) ( ) const )
    { return const_mem_fun_ref_t < _Ret, _Tp > ( __f ); }
template < typename _Ret, typename _Tp, typename _Arg >
    inline mem_fun1_t < _Ret, _Tp, _Arg >
    mem_fun ( _Ret ( _Tp :: * __f ) ( _Arg ) )
    { return mem_fun1_t < _Ret, _Tp, _Arg > ( __f ); }
template < typename _Ret, typename _Tp, typename _Arg >
    inline const_mem_fun1_t < _Ret, _Tp, _Arg >
    mem_fun ( _Ret ( _Tp :: * __f ) ( _Arg ) const )
    { return const_mem_fun1_t < _Ret, _Tp, _Arg > ( __f ); }
template < typename _Ret, typename _Tp, typename _Arg >
    inline mem_fun1_ref_t < _Ret, _Tp, _Arg >
    mem_fun_ref ( _Ret ( _Tp :: * __f ) ( _Arg ) )
    { return mem_fun1_ref_t < _Ret, _Tp, _Arg > ( __f ); }
template < typename _Ret, typename _Tp, typename _Arg >
    inline const_mem_fun1_ref_t < _Ret, _Tp, _Arg >
    mem_fun_ref ( _Ret ( _Tp :: * __f ) ( _Arg ) const )
    { return const_mem_fun1_ref_t < _Ret, _Tp, _Arg > ( __f ); }
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
namespace std
{
template < typename _Operation >
    class binder1st
    : public unary_function < typename _Operation :: second_argument_type,
       typename _Operation :: result_type >
    {
    protected :
      _Operation op;
      typename _Operation :: first_argument_type value;
    public :
      binder1st ( const _Operation & __x,
  const typename _Operation :: first_argument_type & __y )
      ;
      typename _Operation :: result_type
      operator ( ) ( const typename _Operation :: second_argument_type & __x ) const
      ;
      typename _Operation :: result_type
      operator ( ) ( typename _Operation :: second_argument_type & __x ) const
      ;
    } __attribute__ ( ( __deprecated__ ) );
template < typename _Operation, typename _Tp >
    inline binder1st < _Operation >
    bind1st ( const _Operation & __fn, const _Tp & __x )
    {
      typedef typename _Operation :: first_argument_type _Arg1_type;
      return binder1st < _Operation > ( __fn, _Arg1_type ( __x ) );
    }
template < typename _Operation >
    class binder2nd
    : public unary_function < typename _Operation :: first_argument_type,
       typename _Operation :: result_type >
    {
    protected :
      _Operation op;
      typename _Operation :: second_argument_type value;
    public :
      binder2nd ( const _Operation & __x,
  const typename _Operation :: second_argument_type & __y )
      ;
      typename _Operation :: result_type
      operator ( ) ( const typename _Operation :: first_argument_type & __x ) const
      ;
      typename _Operation :: result_type
      operator ( ) ( typename _Operation :: first_argument_type & __x ) const
      ;
    } __attribute__ ( ( __deprecated__ ) );
template < typename _Operation, typename _Tp >
    inline binder2nd < _Operation >
    bind2nd ( const _Operation & __fn, const _Tp & __x )
    {
      typedef typename _Operation :: second_argument_type _Arg2_type;
      return binder2nd < _Operation > ( __fn, _Arg2_type ( __x ) );
    }
}
#pragma GCC diagnostic pop
#pragma GCC visibility push ( default )
namespace std
{
template < class _E >
    class initializer_list
    {
    public :
      typedef _E value_type;
      typedef const _E & reference;
      typedef const _E & const_reference;
      typedef size_t size_type;
      typedef const _E * iterator;
      typedef const _E * const_iterator;
    private :
      iterator _M_array;
      size_type _M_len;
      constexpr initializer_list ( const_iterator __a, size_type __l )
      : _M_array ( __a ), _M_len ( __l ) { }
    public :
      constexpr initializer_list ( ) noexcept
      : _M_array ( 0 ), _M_len ( 0 ) { }
      constexpr size_type
      size ( ) const noexcept { return _M_len; }
      constexpr const_iterator
      begin ( ) const noexcept { return _M_array; }
      constexpr const_iterator
      end ( ) const noexcept { return begin ( ) + size ( ); }
    };
template < class _Tp >
    constexpr const _Tp *
    begin ( initializer_list < _Tp > __ils ) noexcept
    { return __ils . begin ( ); }
template < class _Tp >
    constexpr const _Tp *
    end ( initializer_list < _Tp > __ils ) noexcept
    { return __ils . end ( ); }
}
#pragma GCC visibility pop
namespace std
{
template < typename _Container >
    inline auto
    begin ( _Container & __cont ) -> decltype ( __cont . begin ( ) )
    { return __cont . begin ( ); }
template < typename _Container >
    inline auto
    begin ( const _Container & __cont ) -> decltype ( __cont . begin ( ) )
    { return __cont . begin ( ); }
template < typename _Container >
    inline auto
    end ( _Container & __cont ) -> decltype ( __cont . end ( ) )
    { return __cont . end ( ); }
template < typename _Container >
    inline auto
    end ( const _Container & __cont ) -> decltype ( __cont . end ( ) )
    { return __cont . end ( ); }
template < typename _Tp, size_t _Nm >
    inline constexpr _Tp *
    begin ( _Tp ( & __arr ) [ _Nm ] )
    { return __arr; }
template < typename _Tp, size_t _Nm >
    inline constexpr _Tp *
    end ( _Tp ( & __arr ) [ _Nm ] )
    { return __arr + _Nm; }
template < typename _Tp > class valarray;
template < typename _Tp > _Tp * begin ( valarray < _Tp > & );
template < typename _Tp > const _Tp * begin ( const valarray < _Tp > & );
template < typename _Tp > _Tp * end ( valarray < _Tp > & );
template < typename _Tp > const _Tp * end ( const valarray < _Tp > & );
template < typename _Container >
    inline constexpr auto
    cbegin ( const _Container & __cont ) noexcept ( noexcept ( std :: begin ( __cont ) ) )
      -> decltype ( std :: begin ( __cont ) )
    { return std :: begin ( __cont ); }
template < typename _Container >
    inline constexpr auto
    cend ( const _Container & __cont ) noexcept ( noexcept ( std :: end ( __cont ) ) )
      -> decltype ( std :: end ( __cont ) )
    { return std :: end ( __cont ); }
template < typename _Container >
    inline auto
    rbegin ( _Container & __cont ) -> decltype ( __cont . rbegin ( ) )
    { return __cont . rbegin ( ); }
template < typename _Container >
    inline auto
    rbegin ( const _Container & __cont ) -> decltype ( __cont . rbegin ( ) )
    { return __cont . rbegin ( ); }
template < typename _Container >
    inline auto
    rend ( _Container & __cont ) -> decltype ( __cont . rend ( ) )
    { return __cont . rend ( ); }
template < typename _Container >
    inline auto
    rend ( const _Container & __cont ) -> decltype ( __cont . rend ( ) )
    { return __cont . rend ( ); }
template < typename _Tp, size_t _Nm >
    inline reverse_iterator < _Tp * >
    rbegin ( _Tp ( & __arr ) [ _Nm ] )
    { return reverse_iterator < _Tp * > ( __arr + _Nm ); }
template < typename _Tp, size_t _Nm >
    inline reverse_iterator < _Tp * >
    rend ( _Tp ( & __arr ) [ _Nm ] )
    { return reverse_iterator < _Tp * > ( __arr ); }
template < typename _Tp >
    inline reverse_iterator < const _Tp * >
    rbegin ( initializer_list < _Tp > __il )
    { return reverse_iterator < const _Tp * > ( __il . end ( ) ); }
template < typename _Tp >
    inline reverse_iterator < const _Tp * >
    rend ( initializer_list < _Tp > __il )
    { return reverse_iterator < const _Tp * > ( __il . begin ( ) ); }
template < typename _Container >
    inline auto
    crbegin ( const _Container & __cont ) -> decltype ( std :: rbegin ( __cont ) )
    { return std :: rbegin ( __cont ); }
template < typename _Container >
    inline auto
    crend ( const _Container & __cont ) -> decltype ( std :: rend ( __cont ) )
    { return std :: rend ( __cont ); }
}
namespace std
{

struct __allocator_traits_base 
{
template < typename _Alloc, typename _Up >
      using __rebind = typename _Alloc :: template rebind < _Up > :: other;
template < typename _Tp >
      using __pointer = typename _Tp :: pointer;
template < typename _Tp >
      using __c_pointer = typename _Tp :: const_pointer;
template < typename _Tp >
      using __v_pointer = typename _Tp :: void_pointer;
template < typename _Tp >
      using __cv_pointer = typename _Tp :: const_void_pointer;
template < typename _Tp >
      using __diff_type = typename _Tp :: difference_type;
template < typename _Tp >
      using __size_type = typename _Tp :: size_type;
template < typename _Tp >
      using __pocca = typename _Tp :: propagate_on_container_copy_assignment;
template < typename _Tp >
      using __pocma = typename _Tp :: propagate_on_container_move_assignment;
template < typename _Tp >
      using __pocs = typename _Tp :: propagate_on_container_swap;
template < typename _Tp >
      using __equal = typename _Tp :: is_always_equal;
}
;
template < typename _Alloc, typename _Up >
    using __alloc_rebind = __detected_or_t_ < __replace_first_arg_t,
         __allocator_traits_base :: __rebind,
         _Alloc, _Up >;
template < typename _Alloc >
    struct allocator_traits : __allocator_traits_base
    {
      typedef _Alloc allocator_type;
      typedef typename _Alloc :: value_type value_type;
      using pointer = __detected_or_t < value_type *, __pointer, _Alloc >;
      using const_pointer
 = __detected_or_t < __ptr_rebind < pointer, const value_type >,
     __c_pointer, _Alloc >;
      using void_pointer
 = __detected_or_t < __ptr_rebind < pointer, void >, __v_pointer, _Alloc >;
      using const_void_pointer
 = __detected_or_t < __ptr_rebind < pointer, const void >, __cv_pointer,
     _Alloc >;
      using difference_type
 = __detected_or_t < typename pointer_traits < pointer > :: difference_type,
     __diff_type, _Alloc >;
      using size_type
 = __detected_or_t < typename make_unsigned < difference_type > :: type,
     __size_type, _Alloc >;
      using propagate_on_container_copy_assignment
 = __detected_or_t < false_type, __pocca, _Alloc >;
      using propagate_on_container_move_assignment
 = __detected_or_t < false_type, __pocma, _Alloc >;
      using propagate_on_container_swap
 = __detected_or_t < false_type, __pocs, _Alloc >;
      using is_always_equal
 = __detected_or_t < typename is_empty < _Alloc > :: type, __equal, _Alloc >;
      template < typename _Tp >
 using rebind_alloc = __alloc_rebind < _Alloc, _Tp >;
      template < typename _Tp >
 using rebind_traits = allocator_traits < rebind_alloc < _Tp >>;
      static_assert ( ! is_same < rebind_alloc < value_type >, __undefined > :: value,
   "allocator defines rebind or is like Alloc<T, Args>" );
    private :
      template < typename _Alloc2 >
 static auto
 _S_allocate ( _Alloc2 & __a, size_type __n, const_void_pointer __hint, int )
 -> decltype ( __a . allocate ( __n, __hint ) )
 { return __a . allocate ( __n, __hint ); }
      template < typename _Alloc2 >
 static pointer
 _S_allocate ( _Alloc2 & __a, size_type __n, const_void_pointer, ... )
 { return __a . allocate ( __n ); }
      template < typename _Tp, typename ... _Args >
 struct __construct_helper
 {
   template < typename _Alloc2,
     typename = decltype ( std :: declval < _Alloc2 * > ( ) -> construct (
    std :: declval < _Tp * > ( ), std :: declval < _Args > ( ) ... ) ) >
     static true_type __test ( int );
   template < typename >
     static false_type __test ( ... );
   using type = decltype ( __test < _Alloc > ( 0 ) );
 };
      template < typename _Tp, typename ... _Args >
 using __has_construct
   = typename __construct_helper < _Tp, _Args ... > :: type;
      template < typename _Tp, typename ... _Args >
 static _Require < __has_construct < _Tp, _Args ... >>
 _S_construct ( _Alloc & __a, _Tp * __p, _Args && ... __args )
 { __a . construct ( __p, std :: forward < _Args > ( __args ) ... ); }
      template < typename _Tp, typename ... _Args >
 static
 _Require < __and_ < __not_ < __has_construct < _Tp, _Args ... >>,
          is_constructible < _Tp, _Args ... >>>
 _S_construct ( _Alloc &, _Tp * __p, _Args && ... __args )
 { :: new ( ( void * ) __p ) _Tp ( std :: forward < _Args > ( __args ) ... ); }
      template < typename _Alloc2, typename _Tp >
 static auto
 _S_destroy ( _Alloc2 & __a, _Tp * __p, int )
 -> decltype ( __a . destroy ( __p ) )
 { __a . destroy ( __p ); }
      template < typename _Alloc2, typename _Tp >
 static void
 _S_destroy ( _Alloc2 &, _Tp * __p, ... )
 { __p -> ~ _Tp ( ); }
      template < typename _Alloc2 >
 static auto
 _S_max_size ( _Alloc2 & __a, int )
 -> decltype ( __a . max_size ( ) )
 { return __a . max_size ( ); }
      template < typename _Alloc2 >
 static size_type
 _S_max_size ( _Alloc2 &, ... )
 {
   return __gnu_cxx :: __numeric_traits < size_type > :: __max
     / sizeof ( value_type );
 }
      template < typename _Alloc2 >
 static auto
 _S_select ( _Alloc2 & __a, int )
 -> decltype ( __a . select_on_container_copy_construction ( ) )
 { return __a . select_on_container_copy_construction ( ); }
      template < typename _Alloc2 >
 static _Alloc2
 _S_select ( _Alloc2 & __a, ... )
 { return __a; }
    public :
      static pointer
      allocate ( _Alloc & __a, size_type __n )
      ;
      static pointer
      allocate ( _Alloc & __a, size_type __n, const_void_pointer __hint )
      ;
      static void
      deallocate ( _Alloc & __a, pointer __p, size_type __n )
      ;
      template < typename _Tp, typename ... _Args >
 static auto construct ( _Alloc & __a, _Tp * __p, _Args && ... __args )
 -> decltype ( _S_construct ( __a, __p, std :: forward < _Args > ( __args ) ... ) )
 { _S_construct ( __a, __p, std :: forward < _Args > ( __args ) ... ); }
      template < typename _Tp >
 static void destroy ( _Alloc & __a, _Tp * __p )
 { _S_destroy ( __a, __p, 0 ); }
      static size_type max_size ( const _Alloc & __a ) noexcept
      ;
      static _Alloc
      select_on_container_copy_construction ( const _Alloc & __rhs )
      ;
    };
template < typename _Tp >
    struct allocator_traits < allocator < _Tp > >
    {
      using allocator_type = allocator < _Tp >;
      using value_type = _Tp;
      using pointer = _Tp *;
      using const_pointer = const _Tp *;
      using void_pointer = void *;
      using const_void_pointer = const void *;
      using difference_type = std :: ptrdiff_t;
      using size_type = std :: size_t;
      using propagate_on_container_copy_assignment = false_type;
      using propagate_on_container_move_assignment = true_type;
      using propagate_on_container_swap = false_type;
      using is_always_equal = true_type;
      template < typename _Up >
 using rebind_alloc = allocator < _Up >;
      template < typename _Up >
 using rebind_traits = allocator_traits < allocator < _Up >>;
      static pointer
      allocate ( allocator_type & __a, size_type __n )
      ;
      static pointer
      allocate ( allocator_type & __a, size_type __n, const_void_pointer __hint )
      ;
      static void
      deallocate ( allocator_type & __a, pointer __p, size_type __n )
      ;
      template < typename _Up, typename ... _Args >
 static void
 construct ( allocator_type & __a, _Up * __p, _Args && ... __args )
 { __a . construct ( __p, std :: forward < _Args > ( __args ) ... ); }
      template < typename _Up >
 static void
 destroy ( allocator_type & __a, _Up * __p )
 { __a . destroy ( __p ); }
      static size_type
      max_size ( const allocator_type & __a ) noexcept
      ;
      static allocator_type
      select_on_container_copy_construction ( const allocator_type & __rhs )
      ;
    };
template < typename _Alloc >
    inline void
    __do_alloc_on_copy ( _Alloc & __one, const _Alloc & __two, true_type )
    { __one = __two; }
template < typename _Alloc >
    inline void
    __do_alloc_on_copy ( _Alloc &, const _Alloc &, false_type )
    { }
template < typename _Alloc >
    inline void __alloc_on_copy ( _Alloc & __one, const _Alloc & __two )
    {
      typedef allocator_traits < _Alloc > __traits;
      typedef typename __traits :: propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy ( __one, __two, __pocca ( ) );
    }
template < typename _Alloc >
    inline _Alloc __alloc_on_copy ( const _Alloc & __a )
    {
      typedef allocator_traits < _Alloc > __traits;
      return __traits :: select_on_container_copy_construction ( __a );
    }
template < typename _Alloc >
    inline void __do_alloc_on_move ( _Alloc & __one, _Alloc & __two, true_type )
    { __one = std :: move ( __two ); }
template < typename _Alloc >
    inline void __do_alloc_on_move ( _Alloc &, _Alloc &, false_type )
    { }
template < typename _Alloc >
    inline void __alloc_on_move ( _Alloc & __one, _Alloc & __two )
    {
      typedef allocator_traits < _Alloc > __traits;
      typedef typename __traits :: propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move ( __one, __two, __pocma ( ) );
    }
template < typename _Alloc >
    inline void __do_alloc_on_swap ( _Alloc & __one, _Alloc & __two, true_type )
    {
      using std :: swap;
      swap ( __one, __two );
    }
template < typename _Alloc >
    inline void __do_alloc_on_swap ( _Alloc &, _Alloc &, false_type )
    { }
template < typename _Alloc >
    inline void __alloc_on_swap ( _Alloc & __one, _Alloc & __two )
    {
      typedef allocator_traits < _Alloc > __traits;
      typedef typename __traits :: propagate_on_container_swap __pocs;
      __do_alloc_on_swap ( __one, __two, __pocs ( ) );
    }
template < typename _Alloc >
    class __is_copy_insertable_impl
    {
      typedef allocator_traits < _Alloc > _Traits;
      template < typename _Up, typename
        = decltype ( _Traits :: construct ( std :: declval < _Alloc & > ( ),
          std :: declval < _Up * > ( ),
          std :: declval < const _Up & > ( ) ) ) >
 static true_type
 _M_select ( int );
      template < typename _Up >
 static false_type
 _M_select ( ... );
    public :
      typedef decltype ( _M_select < typename _Alloc :: value_type > ( 0 ) ) type;
    };
template < typename _Alloc >
    struct __is_copy_insertable
    : __is_copy_insertable_impl < _Alloc > :: type
    { };
template < typename _Tp >
    struct __is_copy_insertable < allocator < _Tp > >
    : is_copy_constructible < _Tp >
    { };
}
namespace __gnu_cxx
{
template < typename _Alloc >
  struct __alloc_traits
  : std :: allocator_traits < _Alloc >
  {
    typedef _Alloc allocator_type;
    typedef std :: allocator_traits < _Alloc > _Base_type;
    typedef typename _Base_type :: value_type value_type;
    typedef typename _Base_type :: pointer pointer;
    typedef typename _Base_type :: const_pointer const_pointer;
    typedef typename _Base_type :: size_type size_type;
    typedef typename _Base_type :: difference_type difference_type;
    typedef value_type & reference;
    typedef const value_type & const_reference;
    using _Base_type :: allocate;
    using _Base_type :: deallocate;
    using _Base_type :: construct;
    using _Base_type :: destroy;
    using _Base_type :: max_size;
  private :
    template < typename _Ptr >
      using __is_custom_pointer
 = std :: __and_ < std :: is_same < pointer, _Ptr >,
        std :: __not_ < std :: is_pointer < _Ptr >>>;
  public :
    template < typename _Ptr, typename ... _Args >
      static typename std :: enable_if < __is_custom_pointer < _Ptr > :: value > :: type
      construct ( _Alloc & __a, _Ptr __p, _Args && ... __args )
      {
 _Base_type :: construct ( __a, std :: addressof ( * __p ),
         std :: forward < _Args > ( __args ) ... );
      }
    template < typename _Ptr >
      static typename std :: enable_if < __is_custom_pointer < _Ptr > :: value > :: type
      destroy ( _Alloc & __a, _Ptr __p )
      { _Base_type :: destroy ( __a, std :: addressof ( * __p ) ); }
    static _Alloc _S_select_on_copy ( const _Alloc & __a )
    ;
    static void _S_on_swap ( _Alloc & __a, _Alloc & __b )
    ;
    static constexpr bool _S_propagate_on_copy_assign ( )
    ;
    static constexpr bool _S_propagate_on_move_assign ( )
    ;
    static constexpr bool _S_propagate_on_swap ( )
    ;
    static constexpr bool _S_always_equal ( )
    ;
    static constexpr bool _S_nothrow_move ( )
    ;
    template < typename _Tp >
      struct rebind
      { typedef typename _Base_type :: template rebind_alloc < _Tp > other; };
  };
}
namespace std
{
namespace __cxx11
{
template < typename _CharT, typename _Traits, typename _Alloc >
    class basic_string
    {
      typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template
 rebind < _CharT > :: other _Char_alloc_type;
      typedef __gnu_cxx :: __alloc_traits < _Char_alloc_type > _Alloc_traits;
    public :
      typedef _Traits traits_type;
      typedef typename _Traits :: char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits :: size_type size_type;
      typedef typename _Alloc_traits :: difference_type difference_type;
      typedef typename _Alloc_traits :: reference reference;
      typedef typename _Alloc_traits :: const_reference const_reference;
      typedef typename _Alloc_traits :: pointer pointer;
      typedef typename _Alloc_traits :: const_pointer const_pointer;
      typedef __gnu_cxx :: __normal_iterator < pointer, basic_string > iterator;
      typedef __gnu_cxx :: __normal_iterator < const_pointer, basic_string >
       const_iterator;
      typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;
      typedef std :: reverse_iterator < iterator > reverse_iterator;
      static const size_type npos = static_cast < size_type > ( - 1 );
    private :
      typedef const_iterator __const_iterator;
      struct _Alloc_hider : allocator_type
      {
 _Alloc_hider ( pointer __dat, const _Alloc & __a = _Alloc ( ) )
 ;
 pointer _M_p;
      };
      _Alloc_hider _M_dataplus;
      size_type _M_string_length;
      enum { _S_local_capacity = 15 / sizeof ( _CharT ) };
      union
      {
 _CharT _M_local_buf [ _S_local_capacity + 1 ];
 size_type _M_allocated_capacity;
      };
      void
      _M_data ( pointer __p )
      ;
      void
      _M_length ( size_type __length )
      ;
      pointer
      _M_data ( ) const
      ;
      pointer
      _M_local_data ( )
      ;
      const_pointer
      _M_local_data ( ) const
      ;
      void
      _M_capacity ( size_type __capacity )
      ;
      void
      _M_set_length ( size_type __n )
      ;
      bool
      _M_is_local ( ) const
      ;
      pointer
      _M_create ( size_type &, size_type );
      void
      _M_dispose ( )
      ;
      void
      _M_destroy ( size_type __size ) throw ( )
      ;
      template < typename _InIterator >
        void
        _M_construct_aux ( _InIterator __beg, _InIterator __end,
    std :: __false_type )
 {
          typedef typename iterator_traits < _InIterator > :: iterator_category _Tag;
          _M_construct ( __beg, __end, _Tag ( ) );
 }
      template < typename _Integer >
        void
        _M_construct_aux ( _Integer __beg, _Integer __end, std :: __true_type )
 { _M_construct_aux_2 ( static_cast < size_type > ( __beg ), __end ); }
      void
      _M_construct_aux_2 ( size_type __req, _CharT __c )
      ;
      template < typename _InIterator >
        void
        _M_construct ( _InIterator __beg, _InIterator __end )
 {
   typedef typename std :: __is_integer < _InIterator > :: __type _Integral;
   _M_construct_aux ( __beg, __end, _Integral ( ) );
        }
      template < typename _InIterator >
        void
        _M_construct ( _InIterator __beg, _InIterator __end,
       std :: input_iterator_tag );
      template < typename _FwdIterator >
        void
        _M_construct ( _FwdIterator __beg, _FwdIterator __end,
       std :: forward_iterator_tag );
      void
      _M_construct ( size_type __req, _CharT __c );
      allocator_type &
      _M_get_allocator ( )
      ;
      const allocator_type &
      _M_get_allocator ( ) const
      ;
    private :
      size_type
      _M_check ( size_type __pos, const char * __s ) const
      ;
      void
      _M_check_length ( size_type __n1, size_type __n2, const char * __s ) const
      ;
      size_type
      _M_limit ( size_type __pos, size_type __off ) const noexcept
      ;
      bool
      _M_disjunct ( const _CharT * __s ) const noexcept
      ;
      static void
      _S_copy ( _CharT * __d, const _CharT * __s, size_type __n )
      ;
      static void
      _S_move ( _CharT * __d, const _CharT * __s, size_type __n )
      ;
      static void
      _S_assign ( _CharT * __d, size_type __n, _CharT __c )
      ;
      template < class _Iterator >
        static void
        _S_copy_chars ( _CharT * __p, _Iterator __k1, _Iterator __k2 )
        {
   for (; __k1 != __k2; ++ __k1, ( void ) ++ __p )
     traits_type :: assign ( * __p, * __k1 );
 }
      static void
      _S_copy_chars ( _CharT * __p, iterator __k1, iterator __k2 ) noexcept
      ;
      static void
      _S_copy_chars ( _CharT * __p, const_iterator __k1, const_iterator __k2 )
      noexcept
      ;
      static void
      _S_copy_chars ( _CharT * __p, _CharT * __k1, _CharT * __k2 ) noexcept
      ;
      static void
      _S_copy_chars ( _CharT * __p, const _CharT * __k1, const _CharT * __k2 )
      noexcept
      ;
      static int
      _S_compare ( size_type __n1, size_type __n2 ) noexcept
      ;
      void
      _M_assign ( const basic_string & __rcs );
      void
      _M_mutate ( size_type __pos, size_type __len1, const _CharT * __s,
  size_type __len2 );
      void
      _M_erase ( size_type __pos, size_type __n );
    public :
      basic_string ( )
      noexcept ( is_nothrow_default_constructible < _Alloc > :: value )
      ;
      explicit
      basic_string ( const _Alloc & __a ) noexcept
      ;
      basic_string ( const basic_string & __str )
      ;
      basic_string ( const basic_string & __str, size_type __pos,
     size_type __n = npos )
      ;
      basic_string ( const basic_string & __str, size_type __pos,
     size_type __n, const _Alloc & __a )
      ;
      basic_string ( const _CharT * __s, size_type __n,
     const _Alloc & __a = _Alloc ( ) )
      ;
      basic_string ( const _CharT * __s, const _Alloc & __a = _Alloc ( ) )
      ;
      basic_string ( size_type __n, _CharT __c, const _Alloc & __a = _Alloc ( ) )
      ;
      basic_string ( basic_string && __str ) noexcept
      ;
      basic_string ( initializer_list < _CharT > __l, const _Alloc & __a = _Alloc ( ) )
      ;
      basic_string ( const basic_string & __str, const _Alloc & __a )
      ;
      basic_string ( basic_string && __str, const _Alloc & __a )
      noexcept ( _Alloc_traits :: _S_always_equal ( ) )
      ;
      template < typename _InputIterator,
        typename = std :: _RequireInputIter < _InputIterator >>
        basic_string ( _InputIterator __beg, _InputIterator __end,
       const _Alloc & __a = _Alloc ( ) )
 : _M_dataplus ( _M_local_data ( ), __a )
 { _M_construct ( __beg, __end ); }
      ~ basic_string ( )
      ;
      basic_string &
      operator = ( const basic_string & __str )
      ;
      basic_string &
      operator = ( const _CharT * __s )
      ;
      basic_string &
      operator = ( _CharT __c )
      ;
      basic_string &
      operator = ( basic_string && __str )
      noexcept ( _Alloc_traits :: _S_nothrow_move ( ) )
      ;
      basic_string &
      operator = ( initializer_list < _CharT > __l )
      ;
      iterator
      begin ( ) noexcept
      ;
      const_iterator
      begin ( ) const noexcept
      ;
      iterator
      end ( ) noexcept
      ;
      const_iterator
      end ( ) const noexcept
      ;
      reverse_iterator
      rbegin ( ) noexcept
      ;
      const_reverse_iterator
      rbegin ( ) const noexcept
      ;
      reverse_iterator
      rend ( ) noexcept
      ;
      const_reverse_iterator
      rend ( ) const noexcept
      ;
      const_iterator
      cbegin ( ) const noexcept
      ;
      const_iterator
      cend ( ) const noexcept
      ;
      const_reverse_iterator
      crbegin ( ) const noexcept
      ;
      const_reverse_iterator
      crend ( ) const noexcept
      ;
    public :
      size_type
      size ( ) const noexcept
      ;
      size_type
      length ( ) const noexcept
      ;
      size_type
      max_size ( ) const noexcept
      ;
      void
      resize ( size_type __n, _CharT __c );
      void
      resize ( size_type __n )
      ;
      void
      shrink_to_fit ( ) noexcept
      ;
      size_type
      capacity ( ) const noexcept
      ;
      void
      reserve ( size_type __res_arg = 0 );
      void
      clear ( ) noexcept
      ;
      bool
      empty ( ) const noexcept
      ;
      const_reference
      operator [ ] ( size_type __pos ) const noexcept
      ;
      reference
      operator [ ] ( size_type __pos )
      ;
      const_reference
      at ( size_type __n ) const
      ;
      reference
      at ( size_type __n )
      ;
      reference
      front ( ) noexcept
      ;
      const_reference
      front ( ) const noexcept
      ;
      reference
      back ( ) noexcept
      ;
      const_reference
      back ( ) const noexcept
      ;
      basic_string &
      operator += ( const basic_string & __str )
      ;
      basic_string &
      operator += ( const _CharT * __s )
      ;
      basic_string &
      operator += ( _CharT __c )
      ;
      basic_string &
      operator += ( initializer_list < _CharT > __l )
      ;
      basic_string &
      append ( const basic_string & __str )
      ;
      basic_string &
      append ( const basic_string & __str, size_type __pos, size_type __n )
      ;
      basic_string &
      append ( const _CharT * __s, size_type __n )
      ;
      basic_string &
      append ( const _CharT * __s )
      ;
      basic_string &
      append ( size_type __n, _CharT __c )
      ;
      basic_string &
      append ( initializer_list < _CharT > __l )
      ;
      template < class _InputIterator,
        typename = std :: _RequireInputIter < _InputIterator >>
        basic_string &
        append ( _InputIterator __first, _InputIterator __last )
        { return this -> replace ( end ( ), end ( ), __first, __last ); }
      void
      push_back ( _CharT __c )
      ;
      basic_string &
      assign ( const basic_string & __str )
      ;
      basic_string &
      assign ( basic_string && __str )
      noexcept ( _Alloc_traits :: _S_nothrow_move ( ) )
      ;
      basic_string &
      assign ( const basic_string & __str, size_type __pos, size_type __n )
      ;
      basic_string &
      assign ( const _CharT * __s, size_type __n )
      ;
      basic_string &
      assign ( const _CharT * __s )
      ;
      basic_string &
      assign ( size_type __n, _CharT __c )
      ;
      template < class _InputIterator,
        typename = std :: _RequireInputIter < _InputIterator >>
        basic_string &
        assign ( _InputIterator __first, _InputIterator __last )
        { return this -> replace ( begin ( ), end ( ), __first, __last ); }
      basic_string &
      assign ( initializer_list < _CharT > __l )
      ;
      iterator
      insert ( const_iterator __p, size_type __n, _CharT __c )
      ;
      template < class _InputIterator,
        typename = std :: _RequireInputIter < _InputIterator >>
 iterator
        insert ( const_iterator __p, _InputIterator __beg, _InputIterator __end )
        {
   ;
   const size_type __pos = __p - begin ( );
   this -> replace ( __p, __p, __beg, __end );
   return iterator ( this -> _M_data ( ) + __pos );
 }
      void
      insert ( iterator __p, initializer_list < _CharT > __l )
      ;
      basic_string &
      insert ( size_type __pos1, const basic_string & __str )
      ;
      basic_string &
      insert ( size_type __pos1, const basic_string & __str,
      size_type __pos2, size_type __n )
      ;
      basic_string &
      insert ( size_type __pos, const _CharT * __s, size_type __n )
      ;
      basic_string &
      insert ( size_type __pos, const _CharT * __s )
      ;
      basic_string &
      insert ( size_type __pos, size_type __n, _CharT __c )
      ;
      iterator
      insert ( __const_iterator __p, _CharT __c )
      ;
      basic_string &
      erase ( size_type __pos = 0, size_type __n = npos )
      ;
      iterator
      erase ( __const_iterator __position )
      ;
      iterator
      erase ( __const_iterator __first, __const_iterator __last )
      ;
      void
      pop_back ( ) noexcept
      ;
      basic_string &
      replace ( size_type __pos, size_type __n, const basic_string & __str )
      ;
      basic_string &
      replace ( size_type __pos1, size_type __n1, const basic_string & __str,
       size_type __pos2, size_type __n2 )
      ;
      basic_string &
      replace ( size_type __pos, size_type __n1, const _CharT * __s,
       size_type __n2 )
      ;
      basic_string &
      replace ( size_type __pos, size_type __n1, const _CharT * __s )
      ;
      basic_string &
      replace ( size_type __pos, size_type __n1, size_type __n2, _CharT __c )
      ;
      basic_string &
      replace ( __const_iterator __i1, __const_iterator __i2,
       const basic_string & __str )
      ;
      basic_string &
      replace ( __const_iterator __i1, __const_iterator __i2,
       const _CharT * __s, size_type __n )
      ;
      basic_string &
      replace ( __const_iterator __i1, __const_iterator __i2, const _CharT * __s )
      ;
      basic_string &
      replace ( __const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c )
      ;
      template < class _InputIterator,
        typename = std :: _RequireInputIter < _InputIterator >>
        basic_string &
        replace ( const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2 )
        {
                        ;
   ;
   return this -> _M_replace_dispatch ( __i1, __i2, __k1, __k2,
        std :: __false_type ( ) );
 }
      basic_string &
      replace ( __const_iterator __i1, __const_iterator __i2,
       _CharT * __k1, _CharT * __k2 )
      ;
      basic_string &
      replace ( __const_iterator __i1, __const_iterator __i2,
       const _CharT * __k1, const _CharT * __k2 )
      ;
      basic_string &
      replace ( __const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2 )
      ;
      basic_string &
      replace ( __const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2 )
      ;
      basic_string & replace ( const_iterator __i1, const_iterator __i2,
       initializer_list < _CharT > __l )
      ;
    private :
      template < class _Integer >
 basic_string &
 _M_replace_dispatch ( const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type )
        { return _M_replace_aux ( __i1 - begin ( ), __i2 - __i1, __n, __val ); }
      template < class _InputIterator >
 basic_string &
 _M_replace_dispatch ( const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type );
      basic_string &
      _M_replace_aux ( size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c );
      basic_string &
      _M_replace ( size_type __pos, size_type __len1, const _CharT * __s,
   const size_type __len2 );
      basic_string &
      _M_append ( const _CharT * __s, size_type __n );
    public :
      size_type
      copy ( _CharT * __s, size_type __n, size_type __pos = 0 ) const;
      void
      swap ( basic_string & __s ) noexcept;
      const _CharT *
      c_str ( ) const noexcept
      ;
      const _CharT *
      data ( ) const noexcept
      ;
      allocator_type
      get_allocator ( ) const noexcept
      ;
      size_type
      find ( const _CharT * __s, size_type __pos, size_type __n ) const;
      size_type
      find ( const basic_string & __str, size_type __pos = 0 ) const
 noexcept
      ;
      size_type
      find ( const _CharT * __s, size_type __pos = 0 ) const
      ;
      size_type
      find ( _CharT __c, size_type __pos = 0 ) const noexcept;
      size_type
      rfind ( const basic_string & __str, size_type __pos = npos ) const
 noexcept
      ;
      size_type
      rfind ( const _CharT * __s, size_type __pos, size_type __n ) const;
      size_type
      rfind ( const _CharT * __s, size_type __pos = npos ) const
      ;
      size_type
      rfind ( _CharT __c, size_type __pos = npos ) const noexcept;
      size_type
      find_first_of ( const basic_string & __str, size_type __pos = 0 ) const
 noexcept
      ;
      size_type
      find_first_of ( const _CharT * __s, size_type __pos, size_type __n ) const;
      size_type
      find_first_of ( const _CharT * __s, size_type __pos = 0 ) const
      ;
      size_type
      find_first_of ( _CharT __c, size_type __pos = 0 ) const noexcept
      ;
      size_type
      find_last_of ( const basic_string & __str, size_type __pos = npos ) const
 noexcept
      ;
      size_type
      find_last_of ( const _CharT * __s, size_type __pos, size_type __n ) const;
      size_type
      find_last_of ( const _CharT * __s, size_type __pos = npos ) const
      ;
      size_type
      find_last_of ( _CharT __c, size_type __pos = npos ) const noexcept
      ;
      size_type
      find_first_not_of ( const basic_string & __str, size_type __pos = 0 ) const
 noexcept
      ;
      size_type
      find_first_not_of ( const _CharT * __s, size_type __pos,
   size_type __n ) const;
      size_type
      find_first_not_of ( const _CharT * __s, size_type __pos = 0 ) const
      ;
      size_type
      find_first_not_of ( _CharT __c, size_type __pos = 0 ) const
 noexcept;
      size_type
      find_last_not_of ( const basic_string & __str, size_type __pos = npos ) const
 noexcept
      ;
      size_type
      find_last_not_of ( const _CharT * __s, size_type __pos,
         size_type __n ) const;
      size_type
      find_last_not_of ( const _CharT * __s, size_type __pos = npos ) const
      ;
      size_type
      find_last_not_of ( _CharT __c, size_type __pos = npos ) const
 noexcept;
      basic_string
      substr ( size_type __pos = 0, size_type __n = npos ) const
      ;
      int
      compare ( const basic_string & __str ) const
      ;
      int
      compare ( size_type __pos, size_type __n, const basic_string & __str ) const;
      int
      compare ( size_type __pos1, size_type __n1, const basic_string & __str,
       size_type __pos2, size_type __n2 ) const;
      int
      compare ( const _CharT * __s ) const;
      int
      compare ( size_type __pos, size_type __n1, const _CharT * __s ) const;
      int
      compare ( size_type __pos, size_type __n1, const _CharT * __s,
       size_type __n2 ) const;
  };
}
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_string < _CharT, _Traits, _Alloc >
    operator + ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
       const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    {
      basic_string < _CharT, _Traits, _Alloc > __str ( __lhs );
      __str . append ( __rhs );
      return __str;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_string < _CharT, _Traits, _Alloc >
    operator + ( const _CharT * __lhs,
       const basic_string < _CharT, _Traits, _Alloc > & __rhs );
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_string < _CharT, _Traits, _Alloc >
    operator + ( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs );
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string < _CharT, _Traits, _Alloc >
    operator + ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
       const _CharT * __rhs )
    {
      basic_string < _CharT, _Traits, _Alloc > __str ( __lhs );
      __str . append ( __rhs );
      return __str;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string < _CharT, _Traits, _Alloc >
    operator + ( const basic_string < _CharT, _Traits, _Alloc > & __lhs, _CharT __rhs )
    {
      typedef basic_string < _CharT, _Traits, _Alloc > __string_type;
      typedef typename __string_type :: size_type __size_type;
      __string_type __str ( __lhs );
      __str . append ( __size_type ( 1 ), __rhs );
      return __str;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string < _CharT, _Traits, _Alloc >
    operator + ( basic_string < _CharT, _Traits, _Alloc > && __lhs,
       const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    { return std :: move ( __lhs . append ( __rhs ) ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string < _CharT, _Traits, _Alloc >
    operator + ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
       basic_string < _CharT, _Traits, _Alloc > && __rhs )
    { return std :: move ( __rhs . insert ( 0, __lhs ) ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string < _CharT, _Traits, _Alloc >
    operator + ( basic_string < _CharT, _Traits, _Alloc > && __lhs,
       basic_string < _CharT, _Traits, _Alloc > && __rhs )
    {
      const auto __size = __lhs . size ( ) + __rhs . size ( );
      const bool __cond = ( __size > __lhs . capacity ( )
      && __size <= __rhs . capacity ( ) );
      return __cond ? std :: move ( __rhs . insert ( 0, __lhs ) )
             : std :: move ( __lhs . append ( __rhs ) );
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string < _CharT, _Traits, _Alloc >
    operator + ( const _CharT * __lhs,
       basic_string < _CharT, _Traits, _Alloc > && __rhs )
    { return std :: move ( __rhs . insert ( 0, __lhs ) ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string < _CharT, _Traits, _Alloc >
    operator + ( _CharT __lhs,
       basic_string < _CharT, _Traits, _Alloc > && __rhs )
    { return std :: move ( __rhs . insert ( 0, 1, __lhs ) ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string < _CharT, _Traits, _Alloc >
    operator + ( basic_string < _CharT, _Traits, _Alloc > && __lhs,
       const _CharT * __rhs )
    { return std :: move ( __lhs . append ( __rhs ) ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string < _CharT, _Traits, _Alloc >
    operator + ( basic_string < _CharT, _Traits, _Alloc > && __lhs,
       _CharT __rhs )
    { return std :: move ( __lhs . append ( 1, __rhs ) ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator == ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
        const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    noexcept
    { return __lhs . compare ( __rhs ) == 0; }
template < typename _CharT >
    inline
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value, bool > :: __type
    operator == ( const basic_string < _CharT > & __lhs,
        const basic_string < _CharT > & __rhs ) noexcept
    { return ( __lhs . size ( ) == __rhs . size ( )
       && ! std :: char_traits < _CharT > :: compare ( __lhs . data ( ), __rhs . data ( ),
          __lhs . size ( ) ) ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator == ( const _CharT * __lhs,
        const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    { return __rhs . compare ( __lhs ) == 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator == ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
        const _CharT * __rhs )
    { return __lhs . compare ( __rhs ) == 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator != ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
        const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    noexcept
    { return ! ( __lhs == __rhs ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator != ( const _CharT * __lhs,
        const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    { return ! ( __lhs == __rhs ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator != ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
        const _CharT * __rhs )
    { return ! ( __lhs == __rhs ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator < ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
       const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    noexcept
    { return __lhs . compare ( __rhs ) < 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator < ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
       const _CharT * __rhs )
    { return __lhs . compare ( __rhs ) < 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator < ( const _CharT * __lhs,
       const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    { return __rhs . compare ( __lhs ) > 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator > ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
       const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    noexcept
    { return __lhs . compare ( __rhs ) > 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator > ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
       const _CharT * __rhs )
    { return __lhs . compare ( __rhs ) > 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator > ( const _CharT * __lhs,
       const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    { return __rhs . compare ( __lhs ) < 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator <= ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
        const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    noexcept
    { return __lhs . compare ( __rhs ) <= 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator <= ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
        const _CharT * __rhs )
    { return __lhs . compare ( __rhs ) <= 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator <= ( const _CharT * __lhs,
        const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    { return __rhs . compare ( __lhs ) >= 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator >= ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
        const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    noexcept
    { return __lhs . compare ( __rhs ) >= 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator >= ( const basic_string < _CharT, _Traits, _Alloc > & __lhs,
        const _CharT * __rhs )
    { return __lhs . compare ( __rhs ) >= 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline bool
    operator >= ( const _CharT * __lhs,
      const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    { return __rhs . compare ( __lhs ) <= 0; }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline void
    swap ( basic_string < _CharT, _Traits, _Alloc > & __lhs,
  basic_string < _CharT, _Traits, _Alloc > & __rhs )
    noexcept ( noexcept ( __lhs . swap ( __rhs ) ) )
    { __lhs . swap ( __rhs ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_istream < _CharT, _Traits > &
    operator >> ( basic_istream < _CharT, _Traits > & __is,
        basic_string < _CharT, _Traits, _Alloc > & __str );
template<> class basic_istream< char  , char_traits< char  >  > &operator>>(class basic_istream< char  , char_traits< char  >  > &__is,class __cxx11::basic_string< char  , char_traits< char  >  , class std::allocator< char  >  > &__str);
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_ostream < _CharT, _Traits > &
    operator << ( basic_ostream < _CharT, _Traits > & __os,
        const basic_string < _CharT, _Traits, _Alloc > & __str )
    {
      return __ostream_insert ( __os, __str . data ( ), __str . size ( ) );
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_istream < _CharT, _Traits > &
    getline ( basic_istream < _CharT, _Traits > & __is,
     basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim );
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_istream < _CharT, _Traits > &
    getline ( basic_istream < _CharT, _Traits > & __is,
     basic_string < _CharT, _Traits, _Alloc > & __str )
    { return std :: getline ( __is, __str, __is . widen ( '\n' ) ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_istream < _CharT, _Traits > &
    getline ( basic_istream < _CharT, _Traits > && __is,
     basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim )
    { return std :: getline ( __is, __str, __delim ); }
template < typename _CharT, typename _Traits, typename _Alloc >
    inline basic_istream < _CharT, _Traits > &
    getline ( basic_istream < _CharT, _Traits > && __is,
     basic_string < _CharT, _Traits, _Alloc > & __str )
    { return std :: getline ( __is, __str ); }
template<> class basic_istream< char  , char_traits< char  >  > &getline(class basic_istream< char  , char_traits< char  >  > &__in,class __cxx11::basic_string< char  , char_traits< char  >  , class std::allocator< char  >  > &__str,char __delim);
template<> class basic_istream< wchar_t  , char_traits< wchar_t  >  > &getline(class basic_istream< wchar_t  , char_traits< wchar_t  >  > &__in,class __cxx11::basic_string< wchar_t  , char_traits< wchar_t  >  , class std::allocator< wchar_t  >  > &__str,wchar_t __delim);
}
typedef struct {
__off_t __pos;
__mbstate_t __state;}_G_fpos_t;
typedef struct {
__off64_t __pos;
__mbstate_t __state;}_G_fpos64_t;
struct _IO_jump_t ;
struct _IO_FILE ;
typedef void _IO_lock_t;

struct _IO_marker 
{
struct _IO_marker *_next;
struct _IO_FILE *_sbuf;
int _pos;
}
;
enum __codecvt_result {__codecvt_ok=0,__codecvt_partial=1,__codecvt_error=2,__codecvt_noconv=3} ;

struct _IO_FILE 
{
int _flags;
char *_IO_read_ptr;
char *_IO_read_end;
char *_IO_read_base;
char *_IO_write_base;
char *_IO_write_ptr;
char *_IO_write_end;
char *_IO_buf_base;
char *_IO_buf_end;
char *_IO_save_base;
char *_IO_backup_base;
char *_IO_save_end;
struct _IO_marker *_markers;
struct _IO_FILE *_chain;
int _fileno;
int _flags2;
__off_t _old_offset;
unsigned short _cur_column;
signed char _vtable_offset;
char _shortbuf[1];
_IO_lock_t *_lock;
__off64_t _offset;
void *__pad1;
void *__pad2;
void *__pad3;
void *__pad4;
size_t __pad5;
int _mode;
char _unused2[20];
}
;
struct _IO_FILE_plus ;
extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
typedef __ssize_t __io_read_fn(void *, char *, ::size_t);
typedef __ssize_t __io_write_fn(void *, const char *, ::size_t);
typedef int __io_seek_fn(void *, ::__off64_t*, int );
typedef int __io_close_fn(void *);
typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;
typedef struct {
__io_read_fn *read;
__io_write_fn *write;
__io_seek_fn *seek;
__io_close_fn *close;}_IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;
struct _IO_cookie_file ;
extern "C" { void _IO_cookie_init(struct _IO_cookie_file *__cfile,int __read_write,void *__cookie,_IO_cookie_io_functions_t __fns); }
extern "C" { int __underflow(struct _IO_FILE *); }
extern "C" { int __uflow(struct _IO_FILE *); }
extern "C" { int __overflow(struct _IO_FILE *,int ); }
extern "C" { int _IO_getc(struct _IO_FILE *__fp); }
extern "C" { int _IO_putc(int __c,struct _IO_FILE *__fp); }
extern "C" { int _IO_feof(struct _IO_FILE *__fp) throw() __attribute__((no_throw)) ; }
extern "C" { int _IO_ferror(struct _IO_FILE *__fp) throw() __attribute__((no_throw)) ; }
extern "C" { int _IO_peekc_locked(struct _IO_FILE *__fp); }
extern "C" { void _IO_flockfile(struct _IO_FILE *) throw() __attribute__((no_throw)) ; }
extern "C" { void _IO_funlockfile(struct _IO_FILE *) throw() __attribute__((no_throw)) ; }
extern "C" { int _IO_ftrylockfile(struct _IO_FILE *) throw() __attribute__((no_throw)) ; }
extern "C" { int _IO_vfscanf(struct _IO_FILE *,const char *,__gnuc_va_list ,int *); }
extern "C" { int _IO_vfprintf(struct _IO_FILE *,const char *,__gnuc_va_list ); }
extern "C" { __ssize_t _IO_padn(struct _IO_FILE *,int ,__ssize_t ); }
extern "C" { size_t _IO_sgetn(struct _IO_FILE *,void *,size_t ); }
extern "C" { __off64_t _IO_seekoff(struct _IO_FILE *,__off64_t ,int ,int ); }
extern "C" { __off64_t _IO_seekpos(struct _IO_FILE *,__off64_t ,int ); }
extern "C" { void _IO_free_backup_area(struct _IO_FILE *) throw() __attribute__((no_throw)) ; }
typedef __gnuc_va_list va_list;
typedef _G_fpos_t fpos_t;
typedef _G_fpos64_t fpos64_t;
extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;
extern "C" { int remove(const char *__filename) throw() __attribute__((no_throw)) ; }
extern "C" { int rename(const char *__old,const char *__new) throw() __attribute__((no_throw)) ; }
extern "C" { int renameat(int __oldfd,const char *__old,int __newfd,const char *__new) throw() __attribute__((no_throw)) ; }
extern "C" { FILE *tmpfile(); }
extern "C" { FILE *tmpfile64(); }
extern "C" { char *tmpnam(char *__s) throw() __attribute__((no_throw)) ; }
extern "C" { char *tmpnam_r(char *__s) throw() __attribute__((no_throw)) ; }
extern "C" { char *tempnam(const char *__dir,const char *__pfx) throw() __attribute__((malloc))  __attribute__((no_throw)) ; }
extern "C" { int fclose(FILE *__stream); }
extern "C" { int fflush(FILE *__stream); }
extern "C" { int fflush_unlocked(FILE *__stream); }
extern "C" { int fcloseall(); }
extern "C" { FILE *fopen(const char *__filename,const char *__modes); }
extern "C" { FILE *freopen(const char *__filename,const char *__modes,FILE *__stream); }
extern "C" { FILE *fopen64(const char *__filename,const char *__modes); }
extern "C" { FILE *freopen64(const char *__filename,const char *__modes,FILE *__stream); }
extern "C" { FILE *fdopen(int __fd,const char *__modes) throw() __attribute__((no_throw)) ; }
extern "C" { FILE *fopencookie(void *__magic_cookie,const char *__modes,_IO_cookie_io_functions_t __io_funcs) throw() __attribute__((no_throw)) ; }
extern "C" { FILE *fmemopen(void *__s,size_t __len,const char *__modes) throw() __attribute__((no_throw)) ; }
extern "C" { FILE *open_memstream(char **__bufloc,size_t *__sizeloc) throw() __attribute__((no_throw)) ; }
extern "C" { void setbuf(FILE *__stream,char *__buf) throw() __attribute__((no_throw)) ; }
extern "C" { int setvbuf(FILE *__stream,char *__buf,int __modes,size_t __n) throw() __attribute__((no_throw)) ; }
extern "C" { void setbuffer(FILE *__stream,char *__buf,size_t __size) throw() __attribute__((no_throw)) ; }
extern "C" { void setlinebuf(FILE *__stream) throw() __attribute__((no_throw)) ; }
extern "C" { int fprintf(FILE *__stream,const char *__format,... ); }
extern "C" { int printf(const char *__format,... ); }
extern "C" { int sprintf(char *__s,const char *__format,... ) throw() __attribute__((no_throw)) ; }
extern "C" { int vfprintf(FILE *__s,const char *__format,__gnuc_va_list __arg); }
extern "C" { inline int vprintf(const char *__format,__gnuc_va_list __arg); }
extern "C" { int vsprintf(char *__s,const char *__format,__gnuc_va_list __arg) throw() __attribute__((no_throw)) ; }
extern "C" { int snprintf(char *__s,size_t __maxlen,const char *__format,... ) throw() __attribute__((no_throw)) ; }
extern "C" { int vsnprintf(char *__s,size_t __maxlen,const char *__format,__gnuc_va_list __arg) throw() __attribute__((no_throw)) ; }
extern "C" { int vasprintf(char **__ptr,const char *__f,__gnuc_va_list __arg) throw() __attribute__((no_throw)) ; }
extern "C" { int __asprintf(char **__ptr,const char *__fmt,... ) throw() __attribute__((no_throw)) ; }
extern "C" { int asprintf(char **__ptr,const char *__fmt,... ) throw() __attribute__((no_throw)) ; }
extern "C" { int vdprintf(int __fd,const char *__fmt,__gnuc_va_list __arg); }
extern "C" { int dprintf(int __fd,const char *__fmt,... ); }
extern "C" { int fscanf(FILE *__stream,const char *__format,... ); }
extern "C" { int scanf(const char *__format,... ); }
extern "C" { int sscanf(const char *__s,const char *__format,... ) throw() __attribute__((no_throw)) ; }
extern "C" { int vfscanf(FILE *__s,const char *__format,__gnuc_va_list __arg); }
extern "C" { int vscanf(const char *__format,__gnuc_va_list __arg); }
extern "C" { int vsscanf(const char *__s,const char *__format,__gnuc_va_list __arg) throw() __attribute__((no_throw)) ; }
extern "C" { int fgetc(FILE *__stream); }
extern "C" { int getc(FILE *__stream); }
extern "C" { inline int getchar(); }
extern "C" { inline int getc_unlocked(FILE *__stream); }
extern "C" { inline int getchar_unlocked(); }
extern "C" { inline int fgetc_unlocked(FILE *__stream); }
extern "C" { int fputc(int __c,FILE *__stream); }
extern "C" { int putc(int __c,FILE *__stream); }
extern "C" { inline int putchar(int __c); }
extern "C" { inline int fputc_unlocked(int __c,FILE *__stream); }
extern "C" { inline int putc_unlocked(int __c,FILE *__stream); }
extern "C" { inline int putchar_unlocked(int __c); }
extern "C" { int getw(FILE *__stream); }
extern "C" { int putw(int __w,FILE *__stream); }
extern "C" { char *fgets(char *__s,int __n,FILE *__stream); }
extern "C" { char *fgets_unlocked(char *__s,int __n,FILE *__stream); }
extern "C" { __ssize_t __getdelim(char **__lineptr,size_t *__n,int __delimiter,FILE *__stream); }
extern "C" { __ssize_t getdelim(char **__lineptr,size_t *__n,int __delimiter,FILE *__stream); }
extern "C" { inline __ssize_t getline(char **__lineptr,size_t *__n,FILE *__stream); }
extern "C" { int fputs(const char *__s,FILE *__stream); }
extern "C" { int puts(const char *__s); }
extern "C" { int ungetc(int __c,FILE *__stream); }
extern "C" { size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream); }
extern "C" { size_t fwrite(const void *__ptr,size_t __size,size_t __n,FILE *__s); }
extern "C" { int fputs_unlocked(const char *__s,FILE *__stream); }
extern "C" { size_t fread_unlocked(void *__ptr,size_t __size,size_t __n,FILE *__stream); }
extern "C" { size_t fwrite_unlocked(const void *__ptr,size_t __size,size_t __n,FILE *__stream); }
extern "C" { int fseek(FILE *__stream,long __off,int __whence); }
extern "C" { long ftell(FILE *__stream); }
extern "C" { void rewind(FILE *__stream); }
extern "C" { int fseeko(FILE *__stream,__off_t __off,int __whence); }
extern "C" { __off_t ftello(FILE *__stream); }
extern "C" { int fgetpos(FILE *__stream,fpos_t *__pos); }
extern "C" { int fsetpos(FILE *__stream,const fpos_t *__pos); }
extern "C" { int fseeko64(FILE *__stream,__off64_t __off,int __whence); }
extern "C" { __off64_t ftello64(FILE *__stream); }
extern "C" { int fgetpos64(FILE *__stream,fpos64_t *__pos); }
extern "C" { int fsetpos64(FILE *__stream,const fpos64_t *__pos); }
extern "C" { void clearerr(FILE *__stream) throw() __attribute__((no_throw)) ; }
extern "C" { int feof(FILE *__stream) throw() __attribute__((no_throw)) ; }
extern "C" { int ferror(FILE *__stream) throw() __attribute__((no_throw)) ; }
extern "C" { void clearerr_unlocked(FILE *__stream) throw() __attribute__((no_throw)) ; }
extern "C" { inline int feof_unlocked(FILE *__stream) throw() __attribute__((no_throw)) ; }
extern "C" { inline int ferror_unlocked(FILE *__stream) throw() __attribute__((no_throw)) ; }
extern "C" { void perror(const char *__s); }
extern int sys_nerr;
extern const char *const sys_errlist[];
extern int _sys_nerr;
extern const char *const _sys_errlist[];
extern "C" { int fileno(FILE *__stream) throw() __attribute__((no_throw)) ; }
extern "C" { int fileno_unlocked(FILE *__stream) throw() __attribute__((no_throw)) ; }
extern "C" { FILE *popen(const char *__command,const char *__modes); }
extern "C" { int pclose(FILE *__stream); }
extern "C" { char *ctermid(char *__s) throw() __attribute__((no_throw)) ; }
extern "C" { char *cuserid(char *__s); }
struct obstack ;
extern "C" { int obstack_printf(struct obstack *__obstack,const char *__format,... ) throw() __attribute__((no_throw)) ; }
extern "C" { int obstack_vprintf(struct obstack *__obstack,const char *__format,__gnuc_va_list __args) throw() __attribute__((no_throw)) ; }
extern "C" { void flockfile(FILE *__stream) throw() __attribute__((no_throw)) ; }
extern "C" { int ftrylockfile(FILE *__stream) throw() __attribute__((no_throw)) ; }
extern "C" { void funlockfile(FILE *__stream) throw() __attribute__((no_throw)) ; }

inline int vprintf(const char *__fmt,__gnuc_va_list __arg)
{
return vfprintf(stdout,__fmt,__arg);
}

inline int getchar()
{
return _IO_getc(stdin);
}

inline int fgetc_unlocked(FILE *__fp)
{
return (__builtin_expect((__fp -> _IO_read_ptr >= __fp -> _IO_read_end),0))?__uflow(__fp) : ( *((unsigned char *)(__fp -> _IO_read_ptr++)));
}

inline int getc_unlocked(FILE *__fp)
{
return (__builtin_expect((__fp -> _IO_read_ptr >= __fp -> _IO_read_end),0))?__uflow(__fp) : ( *((unsigned char *)(__fp -> _IO_read_ptr++)));
}

inline int getchar_unlocked()
{
return (__builtin_expect((stdin -> _IO_read_ptr >= stdin -> _IO_read_end),0))?__uflow(stdin) : ( *((unsigned char *)(stdin -> _IO_read_ptr++)));
}

inline int putchar(int __c)
{
return _IO_putc(__c,stdout);
}

inline int fputc_unlocked(int __c,FILE *__stream)
{
return (__builtin_expect((__stream -> _IO_write_ptr >= __stream -> _IO_write_end),0))?__overflow(__stream,((unsigned char )__c)) : ((unsigned char )( *(__stream -> _IO_write_ptr++) = __c));
}

inline int putc_unlocked(int __c,FILE *__stream)
{
return (__builtin_expect((__stream -> _IO_write_ptr >= __stream -> _IO_write_end),0))?__overflow(__stream,((unsigned char )__c)) : ((unsigned char )( *(__stream -> _IO_write_ptr++) = __c));
}

inline int putchar_unlocked(int __c)
{
return (__builtin_expect((stdout -> _IO_write_ptr >= stdout -> _IO_write_end),0))?__overflow(stdout,((unsigned char )__c)) : ((unsigned char )( *(stdout -> _IO_write_ptr++) = __c));
}

inline __ssize_t getline(char **__lineptr,size_t *__n,FILE *__stream)
{
return __getdelim(__lineptr,__n,'\n',__stream);
}

inline int  __attribute__((no_throw)) feof_unlocked(FILE *__stream) throw()
{
return ((__stream -> _flags & 0x10) != 0);
}

inline int  __attribute__((no_throw)) ferror_unlocked(FILE *__stream) throw()
{
return ((__stream -> _flags & 0x20) != 0);
}
extern "C" { char *gets(char *__s) __attribute__((deprecated)) ; }
namespace std
{
using ::FILE;
using ::fpos_t;
using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;
using ::getc;
using ::getchar;
using ::perror;
using ::printf;
using ::putc;
using ::putchar;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;
}
namespace __gnu_cxx
{
using ::snprintf;
using ::vfscanf;
using ::vscanf;
using ::vsnprintf;
using ::vsscanf;
}
namespace std
{
using ::snprintf;
using ::vfscanf;
using ::vscanf;
using ::vsnprintf;
using ::vsscanf;
}
extern "C" { int *__errno_location() throw() __attribute__((no_throw)) ; }
extern char *program_invocation_name;
extern char *program_invocation_short_name;
typedef int error_t;
namespace __gnu_cxx
{
template < typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename ... _Base >
    _Ret
    __stoa ( _TRet ( * __convf ) ( const _CharT *, _CharT * *, _Base ... ),
    const char * __name, const _CharT * __str, std :: size_t * __idx,
    _Base ... __base )
    {
      _Ret __ret;
      _CharT * __endptr;
      struct _Save_errno {
 _Save_errno ( ) : _M_errno ( ( * __errno_location ( ) ) ) { ( * __errno_location ( ) ) = 0; }
 ~ _Save_errno ( ) { if ( ( * __errno_location ( ) ) == 0 ) ( * __errno_location ( ) ) = _M_errno; }
 int _M_errno;
      } const __save_errno;
      const _TRet __tmp = __convf ( __str, & __endptr, __base ... );
      if ( __endptr == __str )
 std :: __throw_invalid_argument ( __name );
      else if ( ( * __errno_location ( ) ) == 34
        || ( std :: __are_same < _Ret, int > :: __value
     && ( __tmp < __numeric_traits < int > :: __min
         || __tmp > __numeric_traits < int > :: __max ) ) )
 std :: __throw_out_of_range ( __name );
      else
 __ret = __tmp;
      if ( __idx )
 * __idx = __endptr - __str;
      return __ret;
    }
template < typename _String, typename _CharT = typename _String :: value_type >
    _String
    __to_xstring ( int ( * __convf ) ( _CharT *, std :: size_t, const _CharT *,
     __builtin_va_list ), std :: size_t __n,
   const _CharT * __fmt, ... )
    {
      _CharT * __s = static_cast < _CharT * > ( __builtin_alloca ( sizeof ( _CharT )
         * __n ) );
      __builtin_va_list __args;
      __builtin_va_start ( __args, __fmt );
      const int __len = __convf ( __s, __n, __fmt, __args );
      __builtin_va_end ( __args );
      return _String ( __s, __s + __len );
    }
}
namespace std
{
namespace __cxx11
{

inline int  __attribute__((visibility("default"))) stoi(const string &__str,size_t *__idx = 0,int __base = 10)
{
return __gnu_cxx::__stoa< long  , int  , char  > (&strtol,"stoi",(__str . c_str()),__idx,__base);
}

inline long  __attribute__((visibility("default"))) stol(const string &__str,size_t *__idx = 0,int __base = 10)
{
return __gnu_cxx::__stoa(&strtol,"stol",(__str . c_str()),__idx,__base);
}

inline unsigned long  __attribute__((visibility("default"))) stoul(const string &__str,size_t *__idx = 0,int __base = 10)
{
return __gnu_cxx::__stoa(&strtoul,"stoul",(__str . c_str()),__idx,__base);
}

inline long long  __attribute__((visibility("default"))) stoll(const string &__str,size_t *__idx = 0,int __base = 10)
{
return __gnu_cxx::__stoa(&strtoll,"stoll",(__str . c_str()),__idx,__base);
}

inline unsigned long long  __attribute__((visibility("default"))) stoull(const string &__str,size_t *__idx = 0,int __base = 10)
{
return __gnu_cxx::__stoa(&strtoull,"stoull",(__str . c_str()),__idx,__base);
}

inline float  __attribute__((visibility("default"))) stof(const string &__str,size_t *__idx = 0)
{
return __gnu_cxx::__stoa(&strtof,"stof",(__str . c_str()),__idx);
}

inline double  __attribute__((visibility("default"))) stod(const string &__str,size_t *__idx = 0)
{
return __gnu_cxx::__stoa(&strtod,"stod",(__str . c_str()),__idx);
}

inline long double  __attribute__((visibility("default"))) stold(const string &__str,size_t *__idx = 0)
{
return __gnu_cxx::__stoa(&strtold,"stold",(__str . c_str()),__idx);
}

inline string  __attribute__((visibility("default"))) to_string(int __val)
{
return __gnu_cxx::__to_xstring< string  , char  > (&vsnprintf,4 * sizeof(int ),"%d",__val);
}

inline string  __attribute__((visibility("default"))) to_string(unsigned int __val)
{
return __gnu_cxx::__to_xstring< string  , char  > (&vsnprintf,4 * sizeof(unsigned int ),"%u",__val);
}

inline string  __attribute__((visibility("default"))) to_string(long __val)
{
return __gnu_cxx::__to_xstring< string  , char  > (&vsnprintf,4 * sizeof(long ),"%ld",__val);
}

inline string  __attribute__((visibility("default"))) to_string(unsigned long __val)
{
return __gnu_cxx::__to_xstring< string  , char  > (&vsnprintf,4 * sizeof(unsigned long ),"%lu",__val);
}

inline string  __attribute__((visibility("default"))) to_string(long long __val)
{
return __gnu_cxx::__to_xstring< string  , char  > (&vsnprintf,4 * sizeof(long long ),"%lld",__val);
}

inline string  __attribute__((visibility("default"))) to_string(unsigned long long __val)
{
return __gnu_cxx::__to_xstring< string  , char  > (&vsnprintf,4 * sizeof(unsigned long long ),"%llu",__val);
}

inline string  __attribute__((visibility("default"))) to_string(float __val)
{
const int __n = __gnu_cxx::__numeric_traits_floating< float > ::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring< string  , char  > (&vsnprintf,__n,"%f",__val);
}

inline string  __attribute__((visibility("default"))) to_string(double __val)
{
const int __n = __gnu_cxx::__numeric_traits_floating< double > ::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring< string  , char  > (&vsnprintf,__n,"%f",__val);
}

inline string  __attribute__((visibility("default"))) to_string(long double __val)
{
const int __n = __gnu_cxx::__numeric_traits_floating< long double > ::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring< string  , char  > (&vsnprintf,__n,"%Lf",__val);
}

inline int  __attribute__((visibility("default"))) stoi(const wstring &__str,size_t *__idx = 0,int __base = 10)
{
return __gnu_cxx::__stoa< long  , int  , wchar_t  > (&wcstol,"stoi",(__str . c_str()),__idx,__base);
}

inline long  __attribute__((visibility("default"))) stol(const wstring &__str,size_t *__idx = 0,int __base = 10)
{
return __gnu_cxx::__stoa(&wcstol,"stol",(__str . c_str()),__idx,__base);
}

inline unsigned long  __attribute__((visibility("default"))) stoul(const wstring &__str,size_t *__idx = 0,int __base = 10)
{
return __gnu_cxx::__stoa(&wcstoul,"stoul",(__str . c_str()),__idx,__base);
}

inline long long  __attribute__((visibility("default"))) stoll(const wstring &__str,size_t *__idx = 0,int __base = 10)
{
return __gnu_cxx::__stoa(&wcstoll,"stoll",(__str . c_str()),__idx,__base);
}

inline unsigned long long  __attribute__((visibility("default"))) stoull(const wstring &__str,size_t *__idx = 0,int __base = 10)
{
return __gnu_cxx::__stoa(&wcstoull,"stoull",(__str . c_str()),__idx,__base);
}

inline float  __attribute__((visibility("default"))) stof(const wstring &__str,size_t *__idx = 0)
{
return __gnu_cxx::__stoa(&wcstof,"stof",(__str . c_str()),__idx);
}

inline double  __attribute__((visibility("default"))) stod(const wstring &__str,size_t *__idx = 0)
{
return __gnu_cxx::__stoa(&wcstod,"stod",(__str . c_str()),__idx);
}

inline long double  __attribute__((visibility("default"))) stold(const wstring &__str,size_t *__idx = 0)
{
return __gnu_cxx::__stoa(&wcstold,"stold",(__str . c_str()),__idx);
}

inline wstring  __attribute__((visibility("default"))) to_wstring(int __val)
{
return __gnu_cxx::__to_xstring< wstring  , wchar_t  > (&vswprintf,4 * sizeof(int ),L"%\000\000\000d\000\000\000\000\000\000",__val);
}

inline wstring  __attribute__((visibility("default"))) to_wstring(unsigned int __val)
{
return __gnu_cxx::__to_xstring< wstring  , wchar_t  > (&vswprintf,4 * sizeof(unsigned int ),L"%\000\000\000u\000\000\000\000\000\000",__val);
}

inline wstring  __attribute__((visibility("default"))) to_wstring(long __val)
{
return __gnu_cxx::__to_xstring< wstring  , wchar_t  > (&vswprintf,4 * sizeof(long ),L"%\000\000\000l\000\000\000d\000\000\000\000\000\000",__val);
}

inline wstring  __attribute__((visibility("default"))) to_wstring(unsigned long __val)
{
return __gnu_cxx::__to_xstring< wstring  , wchar_t  > (&vswprintf,4 * sizeof(unsigned long ),L"%\000\000\000l\000\000\000u\000\000\000\000\000\000",__val);
}

inline wstring  __attribute__((visibility("default"))) to_wstring(long long __val)
{
return __gnu_cxx::__to_xstring< wstring  , wchar_t  > (&vswprintf,4 * sizeof(long long ),L"%\000\000\000l\000\000\000l\000\000\000d\000\000\000\000\000\000",__val);
}

inline wstring  __attribute__((visibility("default"))) to_wstring(unsigned long long __val)
{
return __gnu_cxx::__to_xstring< wstring  , wchar_t  > (&vswprintf,4 * sizeof(unsigned long long ),L"%\000\000\000l\000\000\000l\000\000\000u\000\000\000\000\000\000",__val);
}

inline wstring  __attribute__((visibility("default"))) to_wstring(float __val)
{
const int __n = __gnu_cxx::__numeric_traits_floating< float > ::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring< wstring  , wchar_t  > (&vswprintf,__n,L"%\000\000\000f\000\000\000\000\000\000",__val);
}

inline wstring  __attribute__((visibility("default"))) to_wstring(double __val)
{
const int __n = __gnu_cxx::__numeric_traits_floating< double > ::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring< wstring  , wchar_t  > (&vswprintf,__n,L"%\000\000\000f\000\000\000\000\000\000",__val);
}

inline wstring  __attribute__((visibility("default"))) to_wstring(long double __val)
{
const int __n = __gnu_cxx::__numeric_traits_floating< long double > ::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring< wstring  , wchar_t  > (&vswprintf,__n,L"%\000\000\000L\000\000\000f\000\000\000\000\000\000",__val);
}
}
}
namespace std
{
size_t _Hash_bytes(const void *__ptr,size_t __len,size_t __seed);
size_t _Fnv_hash_bytes(const void *__ptr,size_t __len,size_t __seed);
}
namespace std
{
template < typename _Result, typename _Arg >
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };
template < typename _Tp >
    struct hash;
template < typename _Tp, bool = is_enum < _Tp > :: value >
    struct __hash_enum
    {
    private :
      __hash_enum ( __hash_enum && );
      ~ __hash_enum ( );
    };
template < typename _Tp >
    struct __hash_enum < _Tp, true > : public __hash_base < size_t, _Tp >
    {
      size_t
      operator ( ) ( _Tp __val ) const noexcept
      ;
    };
template < typename _Tp >
    struct hash : __hash_enum < _Tp >
    { };
template < typename _Tp >
    struct hash < _Tp * > : public __hash_base < size_t, _Tp * >
    {
      size_t
      operator ( ) ( _Tp * __p ) const noexcept
      ;
    };
template<> struct hash< bool  > ;
template<> struct hash< bool  > : public __hash_base< size_t  , bool  > 
{

inline size_t operator()(bool __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< char  > ;
template<> struct hash< char  > : public __hash_base< size_t  , char  > 
{

inline size_t operator()(char __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< signed char  > ;
template<> struct hash< signed char  > : public __hash_base< size_t  , signed char  > 
{

inline size_t operator()(signed char __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< unsigned char  > ;
template<> struct hash< unsigned char  > : public __hash_base< size_t  , unsigned char  > 
{

inline size_t operator()(unsigned char __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< wchar_t  > ;
template<> struct hash< wchar_t  > : public __hash_base< size_t  , wchar_t  > 
{

inline size_t operator()(wchar_t __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< char16_t  > ;
template<> struct hash< char16_t  > : public __hash_base< size_t  , char16_t  > 
{

inline size_t operator()(char16_t __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< char32_t  > ;
template<> struct hash< char32_t  > : public __hash_base< size_t  , char32_t  > 
{

inline size_t operator()(char32_t __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< short  > ;
template<> struct hash< short  > : public __hash_base< size_t  , short  > 
{

inline size_t operator()(short __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< int  > ;
template<> struct hash< int  > : public __hash_base< size_t  , int  > 
{

inline size_t operator()(int __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< long  > ;
template<> struct hash< long  > : public __hash_base< size_t  , long  > 
{

inline size_t operator()(long __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< long long  > ;
template<> struct hash< long long  > : public __hash_base< size_t  , long long  > 
{

inline size_t operator()(long long __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< unsigned short  > ;
template<> struct hash< unsigned short  > : public __hash_base< size_t  , unsigned short  > 
{

inline size_t operator()(unsigned short __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< unsigned int  > ;
template<> struct hash< unsigned int  > : public __hash_base< size_t  , unsigned int  > 
{

inline size_t operator()(unsigned int __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< unsigned long  > ;
template<> struct hash< unsigned long  > : public __hash_base< size_t  , unsigned long  > 
{

inline size_t operator()(unsigned long __val) const
{
return static_cast < size_t  >  (__val);
}
};
template<> struct hash< unsigned long long  > ;
template<> struct hash< unsigned long long  > : public __hash_base< size_t  , unsigned long long  > 
{

inline size_t operator()(unsigned long long __val) const
{
return static_cast < size_t  >  (__val);
}
};

struct _Hash_impl 
{

inline static size_t hash(const void *__ptr,size_t __clength,size_t __seed = static_cast < size_t  >  (0xc70f6907UL))
{
return _Hash_bytes(__ptr,__clength,__seed);
}
template < typename _Tp >
      static size_t
      hash ( const _Tp & __val )
      { return hash ( & __val, sizeof ( __val ) ); }
template < typename _Tp >
      static size_t
      __hash_combine ( const _Tp & __val, size_t __hash )
      { return hash ( & __val, sizeof ( __val ), __hash ); }
}
;

struct _Fnv_hash_impl 
{

inline static size_t hash(const void *__ptr,size_t __clength,size_t __seed = static_cast < size_t  >  (2166136261UL))
{
return _Fnv_hash_bytes(__ptr,__clength,__seed);
}
template < typename _Tp >
      static size_t
      hash ( const _Tp & __val )
      { return hash ( & __val, sizeof ( __val ) ); }
template < typename _Tp >
      static size_t
      __hash_combine ( const _Tp & __val, size_t __hash )
      { return hash ( & __val, sizeof ( __val ), __hash ); }
}
;
template<> struct hash< float  > ;
template<> struct hash< float  > : public __hash_base< size_t  , float  > 
{

inline size_t operator()(float __val) const
{
return __val != 0.0f?_Hash_impl::hash(__val) : 0;
}
};
template<> struct hash< double  > ;
template<> struct hash< double  > : public __hash_base< size_t  , double  > 
{

inline size_t operator()(double __val) const
{
return __val != 0.0?_Hash_impl::hash(__val) : 0;
}
};
template<> struct hash< long double  > ;
template<> struct hash< long double  > : public __hash_base< size_t  , long double  > 
{
size_t operator()(long double __val) const;
};
template < typename _Hash >
    struct __is_fast_hash : public std :: true_type
    { };
template<> struct __is_fast_hash< hash< long double  >  > : public integral_constant< bool  , false > 
{
};
}
namespace std
{
template<> struct hash< __cxx11::string  > ;
template<> struct hash< __cxx11::string  > : public __hash_base< size_t  , __cxx11::string  > 
{

inline size_t operator()(const __cxx11::string &__s) const
{
return _Hash_impl::hash((__s . data()),(__s . length()));
}
};
template<> struct __is_fast_hash< hash< __cxx11::string  >  > : public integral_constant< bool  , false > 
{
};
template<> struct hash< __cxx11::wstring  > ;
template<> struct hash< __cxx11::wstring  > : public __hash_base< size_t  , __cxx11::wstring  > 
{

inline size_t operator()(const __cxx11::wstring &__s) const
{
return _Hash_impl::hash((__s . data()),__s . length() * sizeof(wchar_t ));
}
};
template<> struct __is_fast_hash< hash< __cxx11::wstring  >  > : public integral_constant< bool  , false > 
{
};
template<> struct hash< __cxx11::u16string  > ;
template<> struct hash< __cxx11::u16string  > : public __hash_base< size_t  , __cxx11::u16string  > 
{

inline size_t operator()(const __cxx11::u16string &__s) const
{
return _Hash_impl::hash((__s . data()),__s . length() * sizeof(char16_t ));
}
};
template<> struct __is_fast_hash< hash< __cxx11::u16string  >  > : public integral_constant< bool  , false > 
{
};
template<> struct hash< __cxx11::u32string  > ;
template<> struct hash< __cxx11::u32string  > : public __hash_base< size_t  , __cxx11::u32string  > 
{

inline size_t operator()(const __cxx11::u32string &__s) const
{
return _Hash_impl::hash((__s . data()),__s . length() * sizeof(char32_t ));
}
};
template<> struct __is_fast_hash< hash< __cxx11::u32string  >  > : public integral_constant< bool  , false > 
{
};
inline namespace literals
{
inline namespace string_literals
{

inline class __cxx11::basic_string< char  , char_traits< char  >  , allocator< char  >  >  __attribute__((visibility("default"))) operator "" s(const char *__str,size_t __len)
{
return __cxx11::basic_string< char ,char_traits< char  > ,allocator< char  > > (__str,__len);
}

inline class __cxx11::basic_string< wchar_t  , char_traits< wchar_t  >  , allocator< wchar_t  >  >  __attribute__((visibility("default"))) operator "" s(const wchar_t *__str,size_t __len)
{
return __cxx11::basic_string< wchar_t ,char_traits< wchar_t  > ,allocator< wchar_t  > > (__str,__len);
}

inline class __cxx11::basic_string< char16_t  , char_traits< char16_t  >  , allocator< char16_t  >  >  __attribute__((visibility("default"))) operator "" s(const char16_t *__str,size_t __len)
{
return __cxx11::basic_string< char16_t ,char_traits< char16_t  > ,allocator< char16_t  > > (__str,__len);
}

inline class __cxx11::basic_string< char32_t  , char_traits< char32_t  >  , allocator< char32_t  >  >  __attribute__((visibility("default"))) operator "" s(const char32_t *__str,size_t __len)
{
return __cxx11::basic_string< char32_t ,char_traits< char32_t  > ,allocator< char32_t  > > (__str,__len);
}
}
}
}
namespace std
{
template < typename _CharT, typename _Traits, typename _Alloc >
    const typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > :: npos;
template < typename _CharT, typename _Traits, typename _Alloc >
    void
    basic_string < _CharT, _Traits, _Alloc > ::
    swap ( basic_string & __s ) noexcept
    {
      if ( this == & __s )
 return;
      _Alloc_traits :: _S_on_swap ( _M_get_allocator ( ), __s . _M_get_allocator ( ) );
      if ( _M_is_local ( ) )
 if ( __s . _M_is_local ( ) )
   {
     if ( length ( ) && __s . length ( ) )
       {
  _CharT __tmp_data [ _S_local_capacity + 1 ];
  traits_type :: copy ( __tmp_data, __s . _M_local_buf,
      _S_local_capacity + 1 );
  traits_type :: copy ( __s . _M_local_buf, _M_local_buf,
      _S_local_capacity + 1 );
  traits_type :: copy ( _M_local_buf, __tmp_data,
      _S_local_capacity + 1 );
       }
     else if ( __s . length ( ) )
       {
  traits_type :: copy ( _M_local_buf, __s . _M_local_buf,
      _S_local_capacity + 1 );
  _M_length ( __s . length ( ) );
  __s . _M_set_length ( 0 );
  return;
       }
     else if ( length ( ) )
       {
  traits_type :: copy ( __s . _M_local_buf, _M_local_buf,
      _S_local_capacity + 1 );
  __s . _M_length ( length ( ) );
  _M_set_length ( 0 );
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s . _M_allocated_capacity;
     traits_type :: copy ( __s . _M_local_buf, _M_local_buf,
         _S_local_capacity + 1 );
     _M_data ( __s . _M_data ( ) );
     __s . _M_data ( __s . _M_local_buf );
     _M_capacity ( __tmp_capacity );
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if ( __s . _M_is_local ( ) )
     {
       traits_type :: copy ( _M_local_buf, __s . _M_local_buf,
    _S_local_capacity + 1 );
       __s . _M_data ( _M_data ( ) );
       _M_data ( _M_local_buf );
     }
   else
     {
       pointer __tmp_ptr = _M_data ( );
       _M_data ( __s . _M_data ( ) );
       __s . _M_data ( __tmp_ptr );
       _M_capacity ( __s . _M_allocated_capacity );
     }
   __s . _M_capacity ( __tmp_capacity );
 }
      const size_type __tmp_length = length ( );
      _M_length ( __s . length ( ) );
      __s . _M_length ( __tmp_length );
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: pointer
    basic_string < _CharT, _Traits, _Alloc > ::
    _M_create ( size_type & __capacity, size_type __old_capacity )
    {
      if ( __capacity > max_size ( ) )
 std :: __throw_length_error ( ( "basic_string::_M_create" ) );
      if ( __capacity > __old_capacity && __capacity < 2 * __old_capacity )
 {
   __capacity = 2 * __old_capacity;
   if ( __capacity > max_size ( ) )
     __capacity = max_size ( );
 }
      return _Alloc_traits :: allocate ( _M_get_allocator ( ), __capacity + 1 );
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    template < typename _InIterator >
      void
      basic_string < _CharT, _Traits, _Alloc > ::
      _M_construct ( _InIterator __beg, _InIterator __end,
     std :: input_iterator_tag )
      {
 size_type __len = 0;
 size_type __capacity = size_type ( _S_local_capacity );
 while ( __beg != __end && __len < __capacity )
   {
     _M_data ( ) [ __len ++ ] = * __beg;
     ++ __beg;
   }
 try
   {
     while ( __beg != __end )
       {
  if ( __len == __capacity )
    {
      __capacity = __len + 1;
      pointer __another = _M_create ( __capacity, __len );
      this -> _S_copy ( __another, _M_data ( ), __len );
      _M_dispose ( );
      _M_data ( __another );
      _M_capacity ( __capacity );
    }
  _M_data ( ) [ __len ++ ] = * __beg;
  ++ __beg;
       }
   }
 catch ( ... )
   {
     _M_dispose ( );
     throw;
   }
 _M_set_length ( __len );
      }
template < typename _CharT, typename _Traits, typename _Alloc >
    template < typename _InIterator >
      void
      basic_string < _CharT, _Traits, _Alloc > ::
      _M_construct ( _InIterator __beg, _InIterator __end,
     std :: forward_iterator_tag )
      {
 if ( __gnu_cxx :: __is_null_pointer ( __beg ) && __beg != __end )
   std :: __throw_logic_error ( ( "basic_string::_M_construct null not valid" )
                                         );
 size_type __dnew = static_cast < size_type > ( std :: distance ( __beg, __end ) );
 if ( __dnew > size_type ( _S_local_capacity ) )
   {
     _M_data ( _M_create ( __dnew, size_type ( 0 ) ) );
     _M_capacity ( __dnew );
   }
 try
   { this -> _S_copy_chars ( _M_data ( ), __beg, __end ); }
 catch ( ... )
   {
     _M_dispose ( );
     throw;
   }
 _M_set_length ( __dnew );
      }
template < typename _CharT, typename _Traits, typename _Alloc >
    void
    basic_string < _CharT, _Traits, _Alloc > ::
    _M_construct ( size_type __n, _CharT __c )
    {
      if ( __n > size_type ( _S_local_capacity ) )
 {
   _M_data ( _M_create ( __n, size_type ( 0 ) ) );
   _M_capacity ( __n );
 }
      if ( __n )
 this -> _S_assign ( _M_data ( ), __n, __c );
      _M_set_length ( __n );
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    void
    basic_string < _CharT, _Traits, _Alloc > ::
    _M_assign ( const basic_string & __str )
    {
      if ( this != & __str )
 {
   const size_type __rsize = __str . length ( );
   const size_type __capacity = capacity ( );
   if ( __rsize > __capacity )
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create ( __new_capacity, __capacity );
       _M_dispose ( );
       _M_data ( __tmp );
       _M_capacity ( __new_capacity );
     }
   if ( __rsize )
     this -> _S_copy ( _M_data ( ), __str . _M_data ( ), __rsize );
   _M_set_length ( __rsize );
 }
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    void
    basic_string < _CharT, _Traits, _Alloc > ::
    reserve ( size_type __res )
    {
      if ( __res < length ( ) )
 __res = length ( );
      const size_type __capacity = capacity ( );
      if ( __res != __capacity )
 {
   if ( __res > __capacity
       || __res > size_type ( _S_local_capacity ) )
     {
       pointer __tmp = _M_create ( __res, __capacity );
       this -> _S_copy ( __tmp, _M_data ( ), length ( ) + 1 );
       _M_dispose ( );
       _M_data ( __tmp );
       _M_capacity ( __res );
     }
   else if ( ! _M_is_local ( ) )
     {
       this -> _S_copy ( _M_local_data ( ), _M_data ( ), length ( ) + 1 );
       _M_destroy ( __capacity );
       _M_data ( _M_local_data ( ) );
     }
 }
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    void
    basic_string < _CharT, _Traits, _Alloc > ::
    _M_mutate ( size_type __pos, size_type __len1, const _CharT * __s,
       size_type __len2 )
    {
      const size_type __how_much = length ( ) - __pos - __len1;
      size_type __new_capacity = length ( ) + __len2 - __len1;
      pointer __r = _M_create ( __new_capacity, capacity ( ) );
      if ( __pos )
 this -> _S_copy ( __r, _M_data ( ), __pos );
      if ( __s && __len2 )
 this -> _S_copy ( __r + __pos, __s, __len2 );
      if ( __how_much )
 this -> _S_copy ( __r + __pos + __len2,
        _M_data ( ) + __pos + __len1, __how_much );
      _M_dispose ( );
      _M_data ( __r );
      _M_capacity ( __new_capacity );
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    void
    basic_string < _CharT, _Traits, _Alloc > ::
    _M_erase ( size_type __pos, size_type __n )
    {
      const size_type __how_much = length ( ) - __pos - __n;
      if ( __how_much && __n )
 this -> _S_move ( _M_data ( ) + __pos, _M_data ( ) + __pos + __n, __how_much );
      _M_set_length ( length ( ) - __n );
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    void
    basic_string < _CharT, _Traits, _Alloc > ::
    resize ( size_type __n, _CharT __c )
    {
      const size_type __size = this -> size ( );
      if ( __size < __n )
 this -> append ( __n - __size, __c );
      else if ( __n < __size )
 this -> _M_erase ( __n, __size - __n );
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_string < _CharT, _Traits, _Alloc > &
    basic_string < _CharT, _Traits, _Alloc > ::
    _M_append ( const _CharT * __s, size_type __n )
    {
      const size_type __len = __n + this -> size ( );
      if ( __len <= this -> capacity ( ) )
 {
   if ( __n )
     this -> _S_copy ( this -> _M_data ( ) + this -> size ( ), __s, __n );
 }
      else
 this -> _M_mutate ( this -> size ( ), size_type ( 0 ), __s, __n );
      this -> _M_set_length ( __len );
      return * this;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    template < typename _InputIterator >
      basic_string < _CharT, _Traits, _Alloc > &
      basic_string < _CharT, _Traits, _Alloc > ::
      _M_replace_dispatch ( const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std :: __false_type )
      {
 const basic_string __s ( __k1, __k2 );
 const size_type __n1 = __i2 - __i1;
 return _M_replace ( __i1 - begin ( ), __n1, __s . _M_data ( ),
     __s . size ( ) );
      }
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_string < _CharT, _Traits, _Alloc > &
    basic_string < _CharT, _Traits, _Alloc > ::
    _M_replace_aux ( size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c )
    {
      _M_check_length ( __n1, __n2, "basic_string::_M_replace_aux" );
      const size_type __old_size = this -> size ( );
      const size_type __new_size = __old_size + __n2 - __n1;
      if ( __new_size <= this -> capacity ( ) )
 {
   pointer __p = this -> _M_data ( ) + __pos1;
   const size_type __how_much = __old_size - __pos1 - __n1;
   if ( __how_much && __n1 != __n2 )
     this -> _S_move ( __p + __n2, __p + __n1, __how_much );
 }
      else
 this -> _M_mutate ( __pos1, __n1, 0, __n2 );
      if ( __n2 )
 this -> _S_assign ( this -> _M_data ( ) + __pos1, __n2, __c );
      this -> _M_set_length ( __new_size );
      return * this;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_string < _CharT, _Traits, _Alloc > &
    basic_string < _CharT, _Traits, _Alloc > ::
    _M_replace ( size_type __pos, size_type __len1, const _CharT * __s,
        const size_type __len2 )
    {
      _M_check_length ( __len1, __len2, "basic_string::_M_replace" );
      const size_type __old_size = this -> size ( );
      const size_type __new_size = __old_size + __len2 - __len1;
      if ( __new_size <= this -> capacity ( ) )
 {
   pointer __p = this -> _M_data ( ) + __pos;
   const size_type __how_much = __old_size - __pos - __len1;
   if ( _M_disjunct ( __s ) )
     {
       if ( __how_much && __len1 != __len2 )
  this -> _S_move ( __p + __len2, __p + __len1, __how_much );
       if ( __len2 )
  this -> _S_copy ( __p, __s, __len2 );
     }
   else
     {
       if ( __len2 && __len2 <= __len1 )
  this -> _S_move ( __p, __s, __len2 );
       if ( __how_much && __len1 != __len2 )
  this -> _S_move ( __p + __len2, __p + __len1, __how_much );
       if ( __len2 > __len1 )
  {
    if ( __s + __len2 <= __p + __len1 )
      this -> _S_move ( __p, __s, __len2 );
    else if ( __s >= __p + __len1 )
      this -> _S_copy ( __p, __s + __len2 - __len1, __len2 );
    else
      {
        const size_type __nleft = ( __p + __len1 ) - __s;
        this -> _S_move ( __p, __s, __nleft );
        this -> _S_copy ( __p + __nleft, __p + __len2,
        __len2 - __nleft );
      }
  }
     }
 }
      else
 this -> _M_mutate ( __pos, __len1, __s, __len2 );
      this -> _M_set_length ( __new_size );
      return * this;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > ::
    copy ( _CharT * __s, size_type __n, size_type __pos ) const
    {
      _M_check ( __pos, "basic_string::copy" );
      __n = _M_limit ( __pos, __n );
      ;
      if ( __n )
 _S_copy ( __s, _M_data ( ) + __pos, __n );
      return __n;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_string < _CharT, _Traits, _Alloc >
    operator + ( const _CharT * __lhs,
       const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    {
      ;
      typedef basic_string < _CharT, _Traits, _Alloc > __string_type;
      typedef typename __string_type :: size_type __size_type;
      const __size_type __len = _Traits :: length ( __lhs );
      __string_type __str;
      __str . reserve ( __len + __rhs . size ( ) );
      __str . append ( __lhs, __len );
      __str . append ( __rhs );
      return __str;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_string < _CharT, _Traits, _Alloc >
    operator + ( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs )
    {
      typedef basic_string < _CharT, _Traits, _Alloc > __string_type;
      typedef typename __string_type :: size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs . size ( );
      __str . reserve ( __len + 1 );
      __str . append ( __size_type ( 1 ), __lhs );
      __str . append ( __rhs );
      return __str;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > ::
    find ( const _CharT * __s, size_type __pos, size_type __n ) const
    {
      ;
      const size_type __size = this -> size ( );
      const _CharT * __data = _M_data ( );
      if ( __n == 0 )
 return __pos <= __size ? __pos : npos;
      if ( __n <= __size )
 {
   for (; __pos <= __size - __n; ++ __pos )
     if ( traits_type :: eq ( __data [ __pos ], __s [ 0 ] )
  && traits_type :: compare ( __data + __pos + 1,
     __s + 1, __n - 1 ) == 0 )
       return __pos;
 }
      return npos;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > ::
    find ( _CharT __c, size_type __pos ) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this -> size ( );
      if ( __pos < __size )
 {
   const _CharT * __data = _M_data ( );
   const size_type __n = __size - __pos;
   const _CharT * __p = traits_type :: find ( __data + __pos, __n, __c );
   if ( __p )
     __ret = __p - __data;
 }
      return __ret;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > ::
    rfind ( const _CharT * __s, size_type __pos, size_type __n ) const
    {
      ;
      const size_type __size = this -> size ( );
      if ( __n <= __size )
 {
   __pos = std :: min ( size_type ( __size - __n ), __pos );
   const _CharT * __data = _M_data ( );
   do
     {
       if ( traits_type :: compare ( __data + __pos, __s, __n ) == 0 )
  return __pos;
     }
   while ( __pos -- > 0 );
 }
      return npos;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > ::
    rfind ( _CharT __c, size_type __pos ) const noexcept
    {
      size_type __size = this -> size ( );
      if ( __size )
 {
   if ( -- __size > __pos )
     __size = __pos;
   for ( ++ __size; __size -- > 0; )
     if ( traits_type :: eq ( _M_data ( ) [ __size ], __c ) )
       return __size;
 }
      return npos;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > ::
    find_first_of ( const _CharT * __s, size_type __pos, size_type __n ) const
    {
      ;
      for (; __n && __pos < this -> size ( ); ++ __pos )
 {
   const _CharT * __p = traits_type :: find ( __s, __n, _M_data ( ) [ __pos ] );
   if ( __p )
     return __pos;
 }
      return npos;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > ::
    find_last_of ( const _CharT * __s, size_type __pos, size_type __n ) const
    {
      ;
      size_type __size = this -> size ( );
      if ( __size && __n )
 {
   if ( -- __size > __pos )
     __size = __pos;
   do
     {
       if ( traits_type :: find ( __s, __n, _M_data ( ) [ __size ] ) )
  return __size;
     }
   while ( __size -- != 0 );
 }
      return npos;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > ::
    find_first_not_of ( const _CharT * __s, size_type __pos, size_type __n ) const
    {
      ;
      for (; __pos < this -> size ( ); ++ __pos )
 if ( ! traits_type :: find ( __s, __n, _M_data ( ) [ __pos ] ) )
   return __pos;
      return npos;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > ::
    find_first_not_of ( _CharT __c, size_type __pos ) const noexcept
    {
      for (; __pos < this -> size ( ); ++ __pos )
 if ( ! traits_type :: eq ( _M_data ( ) [ __pos ], __c ) )
   return __pos;
      return npos;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > ::
    find_last_not_of ( const _CharT * __s, size_type __pos, size_type __n ) const
    {
      ;
      size_type __size = this -> size ( );
      if ( __size )
 {
   if ( -- __size > __pos )
     __size = __pos;
   do
     {
       if ( ! traits_type :: find ( __s, __n, _M_data ( ) [ __size ] ) )
  return __size;
     }
   while ( __size -- );
 }
      return npos;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > ::
    find_last_not_of ( _CharT __c, size_type __pos ) const noexcept
    {
      size_type __size = this -> size ( );
      if ( __size )
 {
   if ( -- __size > __pos )
     __size = __pos;
   do
     {
       if ( ! traits_type :: eq ( _M_data ( ) [ __size ], __c ) )
  return __size;
     }
   while ( __size -- );
 }
      return npos;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    int
    basic_string < _CharT, _Traits, _Alloc > ::
    compare ( size_type __pos, size_type __n, const basic_string & __str ) const
    {
      _M_check ( __pos, "basic_string::compare" );
      __n = _M_limit ( __pos, __n );
      const size_type __osize = __str . size ( );
      const size_type __len = std :: min ( __n, __osize );
      int __r = traits_type :: compare ( _M_data ( ) + __pos, __str . data ( ), __len );
      if ( ! __r )
 __r = _S_compare ( __n, __osize );
      return __r;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    int
    basic_string < _CharT, _Traits, _Alloc > ::
    compare ( size_type __pos1, size_type __n1, const basic_string & __str,
     size_type __pos2, size_type __n2 ) const
    {
      _M_check ( __pos1, "basic_string::compare" );
      __str . _M_check ( __pos2, "basic_string::compare" );
      __n1 = _M_limit ( __pos1, __n1 );
      __n2 = __str . _M_limit ( __pos2, __n2 );
      const size_type __len = std :: min ( __n1, __n2 );
      int __r = traits_type :: compare ( _M_data ( ) + __pos1,
         __str . data ( ) + __pos2, __len );
      if ( ! __r )
 __r = _S_compare ( __n1, __n2 );
      return __r;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    int
    basic_string < _CharT, _Traits, _Alloc > ::
    compare ( const _CharT * __s ) const
    {
      ;
      const size_type __size = this -> size ( );
      const size_type __osize = traits_type :: length ( __s );
      const size_type __len = std :: min ( __size, __osize );
      int __r = traits_type :: compare ( _M_data ( ), __s, __len );
      if ( ! __r )
 __r = _S_compare ( __size, __osize );
      return __r;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    int
    basic_string < _CharT, _Traits, _Alloc > ::
    compare ( size_type __pos, size_type __n1, const _CharT * __s ) const
    {
      ;
      _M_check ( __pos, "basic_string::compare" );
      __n1 = _M_limit ( __pos, __n1 );
      const size_type __osize = traits_type :: length ( __s );
      const size_type __len = std :: min ( __n1, __osize );
      int __r = traits_type :: compare ( _M_data ( ) + __pos, __s, __len );
      if ( ! __r )
 __r = _S_compare ( __n1, __osize );
      return __r;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    int
    basic_string < _CharT, _Traits, _Alloc > ::
    compare ( size_type __pos, size_type __n1, const _CharT * __s,
     size_type __n2 ) const
    {
      ;
      _M_check ( __pos, "basic_string::compare" );
      __n1 = _M_limit ( __pos, __n1 );
      const size_type __len = std :: min ( __n1, __n2 );
      int __r = traits_type :: compare ( _M_data ( ) + __pos, __s, __len );
      if ( ! __r )
 __r = _S_compare ( __n1, __n2 );
      return __r;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_istream < _CharT, _Traits > &
    operator >> ( basic_istream < _CharT, _Traits > & __in,
        basic_string < _CharT, _Traits, _Alloc > & __str )
    {
      typedef basic_istream < _CharT, _Traits > __istream_type;
      typedef basic_string < _CharT, _Traits, _Alloc > __string_type;
      typedef typename __istream_type :: ios_base __ios_base;
      typedef typename __istream_type :: int_type __int_type;
      typedef typename __string_type :: size_type __size_type;
      typedef ctype < _CharT > __ctype_type;
      typedef typename __ctype_type :: ctype_base __ctype_base;
      __size_type __extracted = 0;
      typename __ios_base :: iostate __err = __ios_base :: goodbit;
      typename __istream_type :: sentry __cerb ( __in, false );
      if ( __cerb )
 {
   try
     {
       __str . erase ( );
       _CharT __buf [ 128 ];
       __size_type __len = 0;
       const streamsize __w = __in . width ( );
       const __size_type __n = __w > 0 ? static_cast < __size_type > ( __w )
                                : __str . max_size ( );
       const __ctype_type & __ct = use_facet < __ctype_type > ( __in . getloc ( ) );
       const __int_type __eof = _Traits :: eof ( );
       __int_type __c = __in . rdbuf ( ) -> sgetc ( );
       while ( __extracted < __n
       && ! _Traits :: eq_int_type ( __c, __eof )
       && ! __ct . is ( __ctype_base :: space,
     _Traits :: to_char_type ( __c ) ) )
  {
    if ( __len == sizeof ( __buf ) / sizeof ( _CharT ) )
      {
        __str . append ( __buf, sizeof ( __buf ) / sizeof ( _CharT ) );
        __len = 0;
      }
    __buf [ __len ++ ] = _Traits :: to_char_type ( __c );
    ++ __extracted;
    __c = __in . rdbuf ( ) -> snextc ( );
  }
       __str . append ( __buf, __len );
       if ( _Traits :: eq_int_type ( __c, __eof ) )
  __err |= __ios_base :: eofbit;
       __in . width ( 0 );
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       __in . _M_setstate ( __ios_base :: badbit );
       throw;
     }
   catch ( ... )
     {
       __in . _M_setstate ( __ios_base :: badbit );
     }
 }
      if ( ! __extracted )
 __err |= __ios_base :: failbit;
      if ( __err )
 __in . setstate ( __err );
      return __in;
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_istream < _CharT, _Traits > &
    getline ( basic_istream < _CharT, _Traits > & __in,
     basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim )
    {
      typedef basic_istream < _CharT, _Traits > __istream_type;
      typedef basic_string < _CharT, _Traits, _Alloc > __string_type;
      typedef typename __istream_type :: ios_base __ios_base;
      typedef typename __istream_type :: int_type __int_type;
      typedef typename __string_type :: size_type __size_type;
      __size_type __extracted = 0;
      const __size_type __n = __str . max_size ( );
      typename __ios_base :: iostate __err = __ios_base :: goodbit;
      typename __istream_type :: sentry __cerb ( __in, true );
      if ( __cerb )
 {
   try
     {
       __str . erase ( );
       const __int_type __idelim = _Traits :: to_int_type ( __delim );
       const __int_type __eof = _Traits :: eof ( );
       __int_type __c = __in . rdbuf ( ) -> sgetc ( );
       while ( __extracted < __n
       && ! _Traits :: eq_int_type ( __c, __eof )
       && ! _Traits :: eq_int_type ( __c, __idelim ) )
  {
    __str += _Traits :: to_char_type ( __c );
    ++ __extracted;
    __c = __in . rdbuf ( ) -> snextc ( );
  }
       if ( _Traits :: eq_int_type ( __c, __eof ) )
  __err |= __ios_base :: eofbit;
       else if ( _Traits :: eq_int_type ( __c, __idelim ) )
  {
    ++ __extracted;
    __in . rdbuf ( ) -> sbumpc ( );
  }
       else
  __err |= __ios_base :: failbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       __in . _M_setstate ( __ios_base :: badbit );
       throw;
     }
   catch ( ... )
     {
       __in . _M_setstate ( __ios_base :: badbit );
     }
 }
      if ( ! __extracted )
 __err |= __ios_base :: failbit;
      if ( __err )
 __in . setstate ( __err );
      return __in;
    }
extern template class __cxx11::basic_string< char  , char_traits< char  >  , class std::allocator< char  >  > ;
extern template class basic_istream< char  , char_traits< char  >  > &operator>>(class basic_istream< char  , char_traits< char  >  > &__is,class __cxx11::basic_string< char  , char_traits< char  >  , class std::allocator< char  >  > &__str);
extern template class basic_ostream< char  , char_traits< char  >  > &operator<<(class basic_ostream< char  , char_traits< char  >  > &__os,const class __cxx11::basic_string< char  , char_traits< char  >  , class std::allocator< char  >  > &__str);
extern template class basic_istream< char  , char_traits< char  >  > &getline(class basic_istream< char  , char_traits< char  >  > &__is,class __cxx11::basic_string< char  , char_traits< char  >  , class std::allocator< char  >  > &__str,char __delim);
extern template class basic_istream< char  , char_traits< char  >  > &getline(class basic_istream< char  , char_traits< char  >  > &__is,class __cxx11::basic_string< char  , char_traits< char  >  , class std::allocator< char  >  > &__str);
extern template class __cxx11::basic_string< wchar_t  , char_traits< wchar_t  >  , class std::allocator< wchar_t  >  > ;
extern template class basic_istream< wchar_t  , char_traits< wchar_t  >  > &operator>>(class basic_istream< wchar_t  , char_traits< wchar_t  >  > &__is,class __cxx11::basic_string< wchar_t  , char_traits< wchar_t  >  , class std::allocator< wchar_t  >  > &__str);
extern template class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &operator<<(class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &__os,const class __cxx11::basic_string< wchar_t  , char_traits< wchar_t  >  , class std::allocator< wchar_t  >  > &__str);
extern template class basic_istream< wchar_t  , char_traits< wchar_t  >  > &getline(class basic_istream< wchar_t  , char_traits< wchar_t  >  > &__is,class __cxx11::basic_string< wchar_t  , char_traits< wchar_t  >  , class std::allocator< wchar_t  >  > &__str,wchar_t __delim);
extern template class basic_istream< wchar_t  , char_traits< wchar_t  >  > &getline(class basic_istream< wchar_t  , char_traits< wchar_t  >  > &__is,class __cxx11::basic_string< wchar_t  , char_traits< wchar_t  >  , class std::allocator< wchar_t  >  > &__str);
}
namespace std
{

class locale 
{
public: typedef int category;
class facet ;
class id ;
class _Impl ;
friend class facet ;
friend class _Impl ;
template < typename _Facet >
      friend bool
      has_facet ( const locale & ) throw ( );
template < typename _Facet >
      friend const _Facet &
      use_facet ( const locale & );
template < typename _Cache >
      friend struct __use_cache;
static const category none = 0;
static const category ctype = (1L << 0);
static const category numeric = (1L << 1);
static const category collate = (1L << 2);
static const category time = (1L << 3);
static const category monetary = (1L << 4);
static const category messages = (1L << 5);
static const category all = ctype | numeric | collate | time | monetary | messages;
locale() throw();
locale(const class locale &__other) throw();
explicit locale(const char *__s);
locale(const class locale &__base,const char *__s,category __cat);

inline explicit locale(const __cxx11::string &__s) : locale(__s . c_str())
{
}

inline locale(const class locale &__base,const __cxx11::string &__s,category __cat) : locale(__base,__s . c_str(),__cat)
{
}
locale(const class locale &__base,const class locale &__add,category __cat);
template < typename _Facet >
      locale ( const locale & __other, _Facet * __f );
~locale() throw();
const locale &operator=(const class locale &__other) throw();
template < typename _Facet >
      locale
      combine ( const locale & __other ) const;
__cxx11::string name() const;
bool operator==(const class locale &__other) const throw();

inline bool operator!=(const class locale &__other) const throw()
{
return !((this) ->  operator== (__other));
}
template < typename _Char, typename _Traits, typename _Alloc >
      bool
      operator ( ) ( const basic_string < _Char, _Traits, _Alloc > & __s1,
   const basic_string < _Char, _Traits, _Alloc > & __s2 ) const;
static locale global(const class locale &__loc);
static const locale &classic();
private: class _Impl *_M_impl;
static class _Impl *_S_classic;
static class _Impl *_S_global;
static const char *const *const _S_categories;
enum __anonymous_0x3729800 {_S_categories_size=12} ;
static __gthread_once_t _S_once;
explicit locale(class _Impl *) throw();
static void _S_initialize();
static void _S_initialize_once() throw();
static category _S_normalize_category(category );
void _M_coalesce(const class locale &__base,const class locale &__add,category __cat);
static const class id *const _S_twinned_facets[];
}
;

class locale::facet 
{
public: friend class locale ;
friend class _Impl ;
private: mutable _Atomic_word _M_refcount;
static __c_locale _S_c_locale;
static const char _S_c_name[2];
static __gthread_once_t _S_once;
static void _S_initialize_once();

protected: inline explicit facet(size_t __refs = 0) throw() : _M_refcount(__refs?1 : 0)
{
}
virtual ~facet();
static void _S_create_c_locale(__c_locale &__cloc,const char *__s,__c_locale __old = 0);
static __c_locale _S_clone_c_locale(__c_locale &__cloc) throw();
static void _S_destroy_c_locale(__c_locale &__cloc);
static __c_locale _S_lc_ctype_c_locale(__c_locale __cloc,const char *__s);
static __c_locale _S_get_c_locale();
static const char *_S_get_c_name() throw();
inline facet(const class facet &) = delete;

inline facet &operator=(const class facet &)
{
}

private: inline void _M_add_reference() const throw()
{
__gnu_cxx::__atomic_add_dispatch(&(this) -> _M_refcount,1);
}

inline void _M_remove_reference() const throw()
{
;
if (__gnu_cxx::__exchange_and_add_dispatch(&(this) -> _M_refcount,- 1) == 1) {
;
try 
{
delete (this);
}
catch (
... )
{
}
}
}
class __shim ;
const facet *_M_sso_shim(const class id *) const;
const facet *_M_cow_shim(const class id *) const;
}
;

class locale::id 
{
public: friend class locale ;
friend class _Impl ;
template < typename _Facet >
      friend const _Facet &
      use_facet ( const locale & );
template < typename _Facet >
      friend bool
      has_facet ( const locale & ) throw ( );
private: mutable size_t _M_index;
static _Atomic_word _S_refcount;
void operator=(const class id &);
id(const class id &);

public: inline id()
{
}
size_t _M_id() const throw();
}
;

class locale::_Impl 
{
public: friend class locale ;
friend class facet ;
template < typename _Facet >
      friend bool
      has_facet ( const locale & ) throw ( );
template < typename _Facet >
      friend const _Facet &
      use_facet ( const locale & );
template < typename _Cache >
      friend struct __use_cache;
private: _Atomic_word _M_refcount;
const class facet **_M_facets;
size_t _M_facets_size;
const class facet **_M_caches;
char **_M_names;
static const class id *const _S_id_ctype[];
static const class id *const _S_id_numeric[];
static const class id *const _S_id_collate[];
static const class id *const _S_id_time[];
static const class id *const _S_id_monetary[];
static const class id *const _S_id_messages[];
static const class id *const *const _S_facet_categories[];

inline void _M_add_reference() throw()
{
__gnu_cxx::__atomic_add_dispatch(&(this) -> _M_refcount,1);
}

inline void _M_remove_reference() throw()
{
;
if (__gnu_cxx::__exchange_and_add_dispatch(&(this) -> _M_refcount,- 1) == 1) {
;
try 
{
delete (this);
}
catch (
... )
{
}
}
}
_Impl(const class _Impl &,size_t );
_Impl(const char *,size_t );
_Impl(size_t ) throw();
~_Impl() throw();
_Impl(const class _Impl &);
void operator=(const class _Impl &);

inline bool _M_check_same_name()
{
bool __ret = true;
if ((this) -> _M_names[1]) 
for (size_t __i = 0; __ret && __i < (_S_categories_size - 1); ++__i) 
__ret = __builtin_strcmp((this) -> _M_names[__i],(this) -> _M_names[__i + 1]) == 0;
return __ret;
}
void _M_replace_categories(const class _Impl *,category );
void _M_replace_category(const class _Impl *,const class id *const *);
void _M_replace_facet(const class _Impl *,const class id *);
void _M_install_facet(const class id *,const class facet *);
template < typename _Facet >
      void
      _M_init_facet ( _Facet * __facet )
      { _M_install_facet ( & _Facet :: id, __facet ); }
template < typename _Facet >
      void
      _M_init_facet_unchecked ( _Facet * __facet )
      {
 __facet -> _M_add_reference ( );
 _M_facets [ _Facet :: id . _M_id ( ) ] = __facet;
      }
void _M_install_cache(const class facet *,size_t );
void _M_init_extra(class facet **);
void _M_init_extra(void *,void *,const char *,const char *);
}
;
template < typename _CharT >
    class __cxx11 :: collate : public locale :: facet
    {
    public :
      typedef _CharT char_type;
      typedef basic_string < _CharT > string_type;
    protected :
      __c_locale _M_c_locale_collate;
    public :
      static locale :: id id;
      explicit
      collate ( size_t __refs = 0 )
      ;
      explicit
      collate ( __c_locale __cloc, size_t __refs = 0 )
      ;
      int
      compare ( const _CharT * __lo1, const _CharT * __hi1,
       const _CharT * __lo2, const _CharT * __hi2 ) const
      ;
      string_type
      transform ( const _CharT * __lo, const _CharT * __hi ) const
      ;
      long
      hash ( const _CharT * __lo, const _CharT * __hi ) const
      ;
      int
      _M_compare ( const _CharT *, const _CharT * ) const throw ( );
      size_t
      _M_transform ( _CharT *, const _CharT *, size_t ) const throw ( );
  protected :
      virtual
      ~ collate ( )
      ;
      virtual int
      do_compare ( const _CharT * __lo1, const _CharT * __hi1,
   const _CharT * __lo2, const _CharT * __hi2 ) const;
      virtual string_type
      do_transform ( const _CharT * __lo, const _CharT * __hi ) const;
      virtual long
      do_hash ( const _CharT * __lo, const _CharT * __hi ) const;
    };
template < typename _CharT >
    locale :: id collate < _CharT > :: id;
template<> int __cxx11::collate< char > ::_M_compare(const char *,const char *) const throw();
template<> size_t __cxx11::collate< char > ::_M_transform(char *,const char *,size_t ) const throw();
template<> int __cxx11::collate< wchar_t > ::_M_compare(const wchar_t *,const wchar_t *) const throw();
template<> size_t __cxx11::collate< wchar_t > ::_M_transform(wchar_t *,const wchar_t *,size_t ) const throw();
template < typename _CharT >
    class __cxx11 :: collate_byname : public collate < _CharT >
    {
    public :
      typedef _CharT char_type;
      typedef basic_string < _CharT > string_type;
      explicit
      collate_byname ( const char * __s, size_t __refs = 0 )
      ;
      explicit
      collate_byname ( const string & __s, size_t __refs = 0 )
      ;
    protected :
      virtual
      ~ collate_byname ( );
    };
}
namespace std
{
template < typename _Facet >
    locale ::
    locale ( const locale & __other, _Facet * __f )
    {
      _M_impl = new _Impl ( * __other . _M_impl, 1 );
      try
 { _M_impl -> _M_install_facet ( & _Facet :: id, __f ); }
      catch ( ... )
 {
   _M_impl -> _M_remove_reference ( );
   throw;
 }
      delete [ ] _M_impl -> _M_names [ 0 ];
      _M_impl -> _M_names [ 0 ] = 0;
    }
template < typename _Facet >
    locale
    locale ::
    combine ( const locale & __other ) const
    {
      _Impl * __tmp = new _Impl ( * _M_impl, 1 );
      try
 {
   __tmp -> _M_replace_facet ( __other . _M_impl, & _Facet :: id );
 }
      catch ( ... )
 {
   __tmp -> _M_remove_reference ( );
   throw;
 }
      return locale ( __tmp );
    }
template < typename _CharT, typename _Traits, typename _Alloc >
    bool
    locale ::
    operator ( ) ( const basic_string < _CharT, _Traits, _Alloc > & __s1,
        const basic_string < _CharT, _Traits, _Alloc > & __s2 ) const
    {
      typedef std :: collate < _CharT > __collate_type;
      const __collate_type & __collate = use_facet < __collate_type > ( * this );
      return ( __collate . compare ( __s1 . data ( ), __s1 . data ( ) + __s1 . length ( ),
    __s2 . data ( ), __s2 . data ( ) + __s2 . length ( ) ) < 0 );
    }
template < typename _Facet >
    bool
    has_facet ( const locale & __loc ) throw ( )
    {
      const size_t __i = _Facet :: id . _M_id ( );
      const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;
      return ( __i < __loc . _M_impl -> _M_facets_size
       && dynamic_cast < const _Facet * > ( __facets [ __i ] ) );
    }
template < typename _Facet >
    const _Facet &
    use_facet ( const locale & __loc )
    {
      const size_t __i = _Facet :: id . _M_id ( );
      const locale :: facet * * __facets = __loc . _M_impl -> _M_facets;
      if ( __i >= __loc . _M_impl -> _M_facets_size || ! __facets [ __i ] )
        __throw_bad_cast ( );
      return dynamic_cast < const _Facet & > ( * __facets [ __i ] );
    }
template < typename _CharT >
    int
    collate < _CharT > :: _M_compare ( const _CharT *, const _CharT * ) const throw ( )
    { return 0; }
template < typename _CharT >
    size_t
    collate < _CharT > :: _M_transform ( _CharT *, const _CharT *, size_t ) const throw ( )
    { return 0; }
template < typename _CharT >
    int
    collate < _CharT > ::
    do_compare ( const _CharT * __lo1, const _CharT * __hi1,
        const _CharT * __lo2, const _CharT * __hi2 ) const
    {
      const string_type __one ( __lo1, __hi1 );
      const string_type __two ( __lo2, __hi2 );
      const _CharT * __p = __one . c_str ( );
      const _CharT * __pend = __one . data ( ) + __one . length ( );
      const _CharT * __q = __two . c_str ( );
      const _CharT * __qend = __two . data ( ) + __two . length ( );
      for (;; )
 {
   const int __res = _M_compare ( __p, __q );
   if ( __res )
     return __res;
   __p += char_traits < _CharT > :: length ( __p );
   __q += char_traits < _CharT > :: length ( __q );
   if ( __p == __pend && __q == __qend )
     return 0;
   else if ( __p == __pend )
     return - 1;
   else if ( __q == __qend )
     return 1;
   __p ++;
   __q ++;
 }
    }
template < typename _CharT >
    typename collate < _CharT > :: string_type
    collate < _CharT > ::
    do_transform ( const _CharT * __lo, const _CharT * __hi ) const
    {
      string_type __ret;
      const string_type __str ( __lo, __hi );
      const _CharT * __p = __str . c_str ( );
      const _CharT * __pend = __str . data ( ) + __str . length ( );
      size_t __len = ( __hi - __lo ) * 2;
      _CharT * __c = new _CharT [ __len ];
      try
 {
   for (;; )
     {
       size_t __res = _M_transform ( __c, __p, __len );
       if ( __res >= __len )
  {
    __len = __res + 1;
    delete [ ] __c, __c = 0;
    __c = new _CharT [ __len ];
    __res = _M_transform ( __c, __p, __len );
  }
       __ret . append ( __c, __res );
       __p += char_traits < _CharT > :: length ( __p );
       if ( __p == __pend )
  break;
       __p ++;
       __ret . push_back ( _CharT ( ) );
     }
 }
      catch ( ... )
 {
   delete [ ] __c;
   throw;
 }
      delete [ ] __c;
      return __ret;
    }
template < typename _CharT >
    long
    collate < _CharT > ::
    do_hash ( const _CharT * __lo, const _CharT * __hi ) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++ __lo )
 __val =
   * __lo + ( ( __val << 7 )
     | ( __val >> ( __gnu_cxx :: __numeric_traits < unsigned long > ::
    __digits - 7 ) ) );
      return static_cast < long > ( __val );
    }
extern template class __cxx11::collate< char  > ;
extern template class __cxx11::collate_byname< char  > ;
extern template const class __cxx11::collate< char  > &use_facet< class __cxx11::collate< char  >  > (const class locale &);
extern template bool has_facet< class __cxx11::collate< char  >  > (const class locale &) throw() __attribute__((no_throw)) ;
extern template class __cxx11::collate< wchar_t  > ;
extern template class __cxx11::collate_byname< wchar_t  > ;
extern template const class __cxx11::collate< wchar_t  > &use_facet< class __cxx11::collate< wchar_t  >  > (const class locale &);
extern template bool has_facet< class __cxx11::collate< wchar_t  >  > (const class locale &) throw() __attribute__((no_throw)) ;
}
namespace std
{
enum class errc {address_family_not_supported=97,address_in_use=98,address_not_available=99,already_connected=106,argument_list_too_long=7,argument_out_of_domain=33,bad_address=14,bad_file_descriptor=9,bad_message=74,broken_pipe=32,connection_aborted=103,connection_already_in_progress=114,connection_refused=111,connection_reset=104,cross_device_link=18,destination_address_required=89,device_or_resource_busy=16,directory_not_empty=39,executable_format_error=8,file_exists=17,file_too_large=27,filename_too_long=36,function_not_supported=38,host_unreachable=113,identifier_removed=43,illegal_byte_sequence=84,inappropriate_io_control_operation=25,interrupted=4,invalid_argument=22,invalid_seek=29,io_error=5,is_a_directory=21,message_size=90,network_down=100,network_reset=102,network_unreachable=101,no_buffer_space=105,no_child_process=10,no_link=67,no_lock_available=37,no_message_available=61,no_message=42,no_protocol_option=92,no_space_on_device=28,no_stream_resources=63,no_such_device_or_address=6,no_such_device=19,no_such_file_or_directory=2,no_such_process=3,not_a_directory=20,not_a_socket=88,not_a_stream=60,not_connected=107,not_enough_memory=12,not_supported=95,operation_canceled=125,operation_in_progress=115,operation_not_permitted=1,operation_not_supported=95,operation_would_block=11,owner_dead=130,permission_denied=13,protocol_error=71,protocol_not_supported=93,read_only_file_system=30,resource_deadlock_would_occur=35,resource_unavailable_try_again=11,result_out_of_range=34,state_not_recoverable=131,stream_timeout=62,text_file_busy=26,timed_out=110,too_many_files_open_in_system=23,too_many_files_open=24,too_many_links=31,too_many_symbolic_link_levels=40,value_too_large=75,wrong_protocol_type=91} ;
}
namespace std
{

struct __cow_string 
{

union 
{
const char *_M_p;
char _M_bytes[8];
}
;
__cow_string();
__cow_string(const __cxx11::string &);
__cow_string(const char *,size_t );
__cow_string(const struct __cow_string &);
__cow_string &operator=(const struct __cow_string &);
~__cow_string();
__cow_string(struct __cow_string &&);
__cow_string &operator=(struct __cow_string &&);
}
;
typedef class __cxx11::basic_string< char  , char_traits< char  >  , class std::allocator< char  >  > __sso_string;

class logic_error : public exception
{
private: struct __cow_string _M_msg;
public: explicit logic_error(const __cxx11::string &__arg);
explicit logic_error(const char *);
logic_error(const class logic_error &);
logic_error &operator=(const class logic_error &);
virtual ~logic_error();
virtual const char *what() const;
}
;

class domain_error : public logic_error
{
public: explicit domain_error(const __cxx11::string &__arg);
explicit domain_error(const char *);
virtual ~domain_error();
}
;

class invalid_argument : public logic_error
{
public: explicit invalid_argument(const __cxx11::string &__arg);
explicit invalid_argument(const char *);
virtual ~invalid_argument();
}
;

class length_error : public logic_error
{
public: explicit length_error(const __cxx11::string &__arg);
explicit length_error(const char *);
virtual ~length_error();
}
;

class out_of_range : public logic_error
{
public: explicit out_of_range(const __cxx11::string &__arg);
explicit out_of_range(const char *);
virtual ~out_of_range();
}
;

class runtime_error : public exception
{
private: struct __cow_string _M_msg;
public: explicit runtime_error(const __cxx11::string &__arg);
explicit runtime_error(const char *);
runtime_error(const class runtime_error &);
runtime_error &operator=(const class runtime_error &);
virtual ~runtime_error();
virtual const char *what() const;
}
;

class range_error : public runtime_error
{
public: explicit range_error(const __cxx11::string &__arg);
explicit range_error(const char *);
virtual ~range_error();
}
;

class overflow_error : public runtime_error
{
public: explicit overflow_error(const __cxx11::string &__arg);
explicit overflow_error(const char *);
virtual ~overflow_error();
}
;

class underflow_error : public runtime_error
{
public: explicit underflow_error(const __cxx11::string &__arg);
explicit underflow_error(const char *);
virtual ~underflow_error();
}
;
}
namespace std
{
struct error_code ;
struct error_condition ;
class system_error ;
template < typename _Tp >
    struct is_error_code_enum : public false_type { };
template < typename _Tp >
    struct is_error_condition_enum : public false_type { };
template<> struct is_error_condition_enum< errc  > : public integral_constant< bool  , true > 
{
};
inline namespace _V2
{

class error_category 
{
public: constexpr inline error_category() = default;
virtual ~error_category();
inline error_category(const class error_category &) = delete;

inline error_category &operator=(const class error_category &)
{
}
virtual const char *name() const = 0;
private: virtual __cow_string _M_message(int ) const;
public: virtual __cxx11::string message(int ) const = 0;
virtual error_condition default_error_condition(int __i) const;
virtual bool equivalent(int __i,const struct error_condition &__cond) const;
virtual bool equivalent(const struct error_code &__code,int __i) const;

inline bool operator<(const class error_category &__other) const
{
return less< const error_category * > ()((this),(&__other));
}

inline bool operator==(const class error_category &__other) const
{
return (this) == &__other;
}

inline bool operator!=(const class error_category &__other) const
{
return (this) != &__other;
}
}
;
const class error_category &system_category() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
const class error_category &generic_category() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
}
inline struct error_code make_error_code(enum class errc ) __attribute__((no_throw))  __attribute__((visibility("default"))) ;
template < typename _Tp >
    struct hash;

struct error_code 
{

inline error_code() : _M_value(0), _M_cat(&_V2::system_category())
{
}

inline error_code(int __v,const class _V2::error_category &__cat) : _M_value(__v), _M_cat(&__cat)
{
}
template < typename _ErrorCodeEnum, typename = typename
      enable_if < is_error_code_enum < _ErrorCodeEnum > :: value > :: type >
      error_code ( _ErrorCodeEnum __e ) noexcept
      { * this = make_error_code ( __e ); }

inline void assign(int __v,const class _V2::error_category &__cat)
{
(this) -> _M_value = __v;
(this) -> _M_cat = &__cat;
}

inline void clear()
{
(this) ->  assign (0,(_V2::system_category()));
}
template < typename _ErrorCodeEnum >
      typename enable_if < is_error_code_enum < _ErrorCodeEnum > :: value,
    error_code & > :: type
      operator = ( _ErrorCodeEnum __e ) noexcept
      { return * this = make_error_code ( __e ); }

inline int value() const
{
return (this) -> _M_value;
}

inline const _V2::error_category &category() const
{
return  *(this) -> _M_cat;
}
error_condition default_error_condition() const;

inline __cxx11::string message() const
{
return (this) ->  category () .  message (((this) ->  value ()));
}

inline explicit operator bool() const
{
return (this) -> _M_value != 0;
}
friend struct hash< error_code  > ;
int _M_value;
const class _V2::error_category *_M_cat;
}
;

inline struct error_code  __attribute__((no_throw))  __attribute__((visibility("default"))) make_error_code(enum class errc __e)
{
return error_code((static_cast < int  >  (__e)),_V2::generic_category());
}

inline bool  __attribute__((no_throw))  __attribute__((visibility("default"))) operator<(const struct error_code &__lhs,const struct error_code &__rhs)
{
return __lhs .  category () < __rhs .  category () || __lhs .  category () == __rhs .  category () && __lhs .  value () < __rhs .  value ();
}
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    operator << ( basic_ostream < _CharT, _Traits > & __os, const error_code & __e )
    { return ( __os << __e . category ( ) . name ( ) << ':' << __e . value ( ) ); }
inline struct error_condition make_error_condition(enum class errc ) __attribute__((no_throw))  __attribute__((visibility("default"))) ;

struct error_condition 
{

inline error_condition() : _M_value(0), _M_cat(&_V2::generic_category())
{
}

inline error_condition(int __v,const class _V2::error_category &__cat) : _M_value(__v), _M_cat(&__cat)
{
}
template < typename _ErrorConditionEnum, typename = typename
  enable_if < is_error_condition_enum < _ErrorConditionEnum > :: value > :: type >
      error_condition ( _ErrorConditionEnum __e ) noexcept
      { * this = make_error_condition ( __e ); }

inline void assign(int __v,const class _V2::error_category &__cat)
{
(this) -> _M_value = __v;
(this) -> _M_cat = &__cat;
}
template < typename _ErrorConditionEnum >
      typename enable_if < is_error_condition_enum
    < _ErrorConditionEnum > :: value, error_condition & > :: type
      operator = ( _ErrorConditionEnum __e ) noexcept
      { return * this = make_error_condition ( __e ); }

inline void clear()
{
(this) ->  assign (0,(_V2::generic_category()));
}

inline int value() const
{
return (this) -> _M_value;
}

inline const _V2::error_category &category() const
{
return  *(this) -> _M_cat;
}

inline __cxx11::string message() const
{
return (this) ->  category () .  message (((this) ->  value ()));
}

inline explicit operator bool() const
{
return (this) -> _M_value != 0;
}
int _M_value;
const class _V2::error_category *_M_cat;
}
;

inline struct error_condition  __attribute__((no_throw))  __attribute__((visibility("default"))) make_error_condition(enum class errc __e)
{
return error_condition((static_cast < int  >  (__e)),_V2::generic_category());
}

inline bool  __attribute__((no_throw))  __attribute__((visibility("default"))) operator<(const struct error_condition &__lhs,const struct error_condition &__rhs)
{
return __lhs .  category () < __rhs .  category () || __lhs .  category () == __rhs .  category () && __lhs .  value () < __rhs .  value ();
}

inline bool  __attribute__((no_throw))  __attribute__((visibility("default"))) operator==(const struct error_code &__lhs,const struct error_code &__rhs)
{
return __lhs .  category () == __rhs .  category () && __lhs .  value () == __rhs .  value ();
}

inline bool  __attribute__((no_throw))  __attribute__((visibility("default"))) operator==(const struct error_code &__lhs,const struct error_condition &__rhs)
{
return __lhs .  category () .  equivalent ((__lhs .  value ()),__rhs) || __rhs .  category () .  equivalent (__lhs,(__rhs .  value ()));
}

inline bool  __attribute__((no_throw))  __attribute__((visibility("default"))) operator==(const struct error_condition &__lhs,const struct error_code &__rhs)
{
return __rhs .  category () .  equivalent ((__rhs .  value ()),__lhs) || __lhs .  category () .  equivalent (__rhs,(__lhs .  value ()));
}

inline bool  __attribute__((no_throw))  __attribute__((visibility("default"))) operator==(const struct error_condition &__lhs,const struct error_condition &__rhs)
{
return __lhs .  category () == __rhs .  category () && __lhs .  value () == __rhs .  value ();
}

inline bool  __attribute__((no_throw))  __attribute__((visibility("default"))) operator!=(const struct error_code &__lhs,const struct error_code &__rhs)
{
return !(__lhs==__rhs);
}

inline bool  __attribute__((no_throw))  __attribute__((visibility("default"))) operator!=(const struct error_code &__lhs,const struct error_condition &__rhs)
{
return !(__lhs==__rhs);
}

inline bool  __attribute__((no_throw))  __attribute__((visibility("default"))) operator!=(const struct error_condition &__lhs,const struct error_code &__rhs)
{
return !(__lhs==__rhs);
}

inline bool  __attribute__((no_throw))  __attribute__((visibility("default"))) operator!=(const struct error_condition &__lhs,const struct error_condition &__rhs)
{
return !(__lhs==__rhs);
}

class system_error : public runtime_error
{
private: struct error_code _M_code;

public: inline system_error(struct error_code __ec = error_code()) : runtime_error(__ec .  message ()), _M_code(__ec)
{
}

inline system_error(struct error_code __ec,const __cxx11::string &__what) : runtime_error((__what+": ")+__ec .  message ()), _M_code(__ec)
{
}

inline system_error(struct error_code __ec,const char *__what) : runtime_error(__what+(": "+__ec .  message ())), _M_code(__ec)
{
}

inline system_error(int __v,const class _V2::error_category &__ecat,const char *__what) : system_error(error_code(__v,__ecat),__what)
{
}

inline system_error(int __v,const class _V2::error_category &__ecat) : runtime_error(error_code(__v,__ecat) .  message ()), _M_code(__v,__ecat)
{
}

inline system_error(int __v,const class _V2::error_category &__ecat,const __cxx11::string &__what) : runtime_error((__what+": ")+error_code(__v,__ecat) .  message ()), _M_code(__v,__ecat)
{
}
virtual ~system_error();

inline const error_code &code() const
{
return (this) -> _M_code;
}
}
;
}
namespace std
{
template<> struct hash< error_code  > : public __hash_base< size_t  , error_code  > 
{

inline size_t operator()(const struct error_code &__e) const
{
const size_t __tmp = _Hash_impl::hash(__e . _M_value);
return _Hash_impl::__hash_combine(__e . _M_cat,__tmp);
}
};
}
namespace std
{
enum _Ios_Fmtflags {_S_boolalpha=1,_S_dec=2,_S_fixed=4,_S_hex=8,_S_internal=16,_S_left=32,_S_oct=64,_S_right=128,_S_scientific=256,_S_showbase=512,_S_showpoint=1024,_S_showpos=2048,_S_skipws=4096,_S_unitbuf=8192,_S_uppercase=16384,_S_adjustfield=176,_S_basefield=74,_S_floatfield=260,_S_ios_fmtflags_end=65536,_S_ios_fmtflags_max=2147483647,_S_ios_fmtflags_min=-2147483648} ;

constexpr inline enum _Ios_Fmtflags  __attribute__((visibility("default"))) operator&(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b)
{
return (enum _Ios_Fmtflags )((static_cast < int  >  (__a)) & (static_cast < int  >  (__b)));
}

constexpr inline enum _Ios_Fmtflags  __attribute__((visibility("default"))) operator|(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b)
{
return (enum _Ios_Fmtflags )((static_cast < int  >  (__a)) | (static_cast < int  >  (__b)));
}

constexpr inline enum _Ios_Fmtflags  __attribute__((visibility("default"))) operator^(enum _Ios_Fmtflags __a,enum _Ios_Fmtflags __b)
{
return (enum _Ios_Fmtflags )((static_cast < int  >  (__a)) ^ (static_cast < int  >  (__b)));
}

constexpr inline enum _Ios_Fmtflags  __attribute__((visibility("default"))) operator~(enum _Ios_Fmtflags __a)
{
return (enum _Ios_Fmtflags )(~(static_cast < int  >  (__a)));
}

inline const enum _Ios_Fmtflags & __attribute__((visibility("default"))) operator|=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b)
{
return __a = __a|__b;
}

inline const enum _Ios_Fmtflags & __attribute__((visibility("default"))) operator&=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b)
{
return __a = __a&__b;
}

inline const enum _Ios_Fmtflags & __attribute__((visibility("default"))) operator^=(enum _Ios_Fmtflags &__a,enum _Ios_Fmtflags __b)
{
return __a = __a^__b;
}
enum _Ios_Openmode {_S_app=1,_S_ate=2,_S_bin=4,_S_in=8,_S_out=16,_S_trunc=32,_S_ios_openmode_end=65536,_S_ios_openmode_max=2147483647,_S_ios_openmode_min=-2147483648} ;

constexpr inline enum _Ios_Openmode  __attribute__((visibility("default"))) operator&(enum _Ios_Openmode __a,enum _Ios_Openmode __b)
{
return (enum _Ios_Openmode )((static_cast < int  >  (__a)) & (static_cast < int  >  (__b)));
}

constexpr inline enum _Ios_Openmode  __attribute__((visibility("default"))) operator|(enum _Ios_Openmode __a,enum _Ios_Openmode __b)
{
return (enum _Ios_Openmode )((static_cast < int  >  (__a)) | (static_cast < int  >  (__b)));
}

constexpr inline enum _Ios_Openmode  __attribute__((visibility("default"))) operator^(enum _Ios_Openmode __a,enum _Ios_Openmode __b)
{
return (enum _Ios_Openmode )((static_cast < int  >  (__a)) ^ (static_cast < int  >  (__b)));
}

constexpr inline enum _Ios_Openmode  __attribute__((visibility("default"))) operator~(enum _Ios_Openmode __a)
{
return (enum _Ios_Openmode )(~(static_cast < int  >  (__a)));
}

inline const enum _Ios_Openmode & __attribute__((visibility("default"))) operator|=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b)
{
return __a = __a|__b;
}

inline const enum _Ios_Openmode & __attribute__((visibility("default"))) operator&=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b)
{
return __a = __a&__b;
}

inline const enum _Ios_Openmode & __attribute__((visibility("default"))) operator^=(enum _Ios_Openmode &__a,enum _Ios_Openmode __b)
{
return __a = __a^__b;
}
enum _Ios_Iostate {_S_goodbit=0,_S_badbit=1,_S_eofbit=2,_S_failbit=4,_S_ios_iostate_end=65536,_S_ios_iostate_max=2147483647,_S_ios_iostate_min=-2147483648} ;

constexpr inline enum _Ios_Iostate  __attribute__((visibility("default"))) operator&(enum _Ios_Iostate __a,enum _Ios_Iostate __b)
{
return (enum _Ios_Iostate )((static_cast < int  >  (__a)) & (static_cast < int  >  (__b)));
}

constexpr inline enum _Ios_Iostate  __attribute__((visibility("default"))) operator|(enum _Ios_Iostate __a,enum _Ios_Iostate __b)
{
return (enum _Ios_Iostate )((static_cast < int  >  (__a)) | (static_cast < int  >  (__b)));
}

constexpr inline enum _Ios_Iostate  __attribute__((visibility("default"))) operator^(enum _Ios_Iostate __a,enum _Ios_Iostate __b)
{
return (enum _Ios_Iostate )((static_cast < int  >  (__a)) ^ (static_cast < int  >  (__b)));
}

constexpr inline enum _Ios_Iostate  __attribute__((visibility("default"))) operator~(enum _Ios_Iostate __a)
{
return (enum _Ios_Iostate )(~(static_cast < int  >  (__a)));
}

inline const enum _Ios_Iostate & __attribute__((visibility("default"))) operator|=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b)
{
return __a = __a|__b;
}

inline const enum _Ios_Iostate & __attribute__((visibility("default"))) operator&=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b)
{
return __a = __a&__b;
}

inline const enum _Ios_Iostate & __attribute__((visibility("default"))) operator^=(enum _Ios_Iostate &__a,enum _Ios_Iostate __b)
{
return __a = __a^__b;
}
enum _Ios_Seekdir {_S_beg=0,_S_cur=1,_S_end=2,_S_ios_seekdir_end=65536} ;
enum class io_errc {stream=1} ;
template<> struct is_error_code_enum< io_errc  > : public integral_constant< bool  , true > 
{
};
const class _V2::error_category &iostream_category() __attribute__((no_throw))  __attribute__((visibility("default"))) ;

inline struct error_code  __attribute__((no_throw))  __attribute__((visibility("default"))) make_error_code(enum class io_errc e)
{
return error_code((static_cast < int  >  (e)),iostream_category());
}

inline struct error_condition  __attribute__((no_throw))  __attribute__((visibility("default"))) make_error_condition(enum class io_errc e)
{
return error_condition((static_cast < int  >  (e)),iostream_category());
}

class ios_base 
{

public: class failure : public system_error
{
public: explicit failure(const __cxx11::string &__str);
explicit failure(const __cxx11::string &,const struct error_code &);
explicit failure(const char *,const struct error_code & = (io_errc(1)));
virtual ~failure() throw();
virtual const char *what() const throw();
}
;
public: typedef enum _Ios_Fmtflags fmtflags;
static const fmtflags boolalpha = _S_boolalpha;
static const fmtflags dec = _S_dec;
static const fmtflags fixed = _S_fixed;
static const fmtflags hex = _S_hex;
static const fmtflags internal = _S_internal;
static const fmtflags left = _S_left;
static const fmtflags oct = _S_oct;
static const fmtflags right = _S_right;
static const fmtflags scientific = _S_scientific;
static const fmtflags showbase = _S_showbase;
static const fmtflags showpoint = _S_showpoint;
static const fmtflags showpos = _S_showpos;
static const fmtflags skipws = _S_skipws;
static const fmtflags unitbuf = _S_unitbuf;
static const fmtflags uppercase = _S_uppercase;
static const fmtflags adjustfield = _S_adjustfield;
static const fmtflags basefield = _S_basefield;
static const fmtflags floatfield = _S_floatfield;
typedef enum _Ios_Iostate iostate;
static const iostate badbit = _S_badbit;
static const iostate eofbit = _S_eofbit;
static const iostate failbit = _S_failbit;
static const iostate goodbit = _S_goodbit;
typedef enum _Ios_Openmode openmode;
static const openmode app = _S_app;
static const openmode ate = _S_ate;
static const openmode binary = _S_bin;
static const openmode in = _S_in;
static const openmode out = _S_out;
static const openmode trunc = _S_trunc;
typedef enum _Ios_Seekdir seekdir;
static const seekdir beg = _S_beg;
static const seekdir cur = _S_cur;
static const seekdir end = _S_end;
typedef int io_state;
typedef int open_mode;
typedef int seek_dir;
typedef std::streampos streampos;
typedef std::streamoff streamoff;
enum event {erase_event=0,imbue_event=1,copyfmt_event=2} ;
typedef void (*event_callback)(::std::ios_base::event, class ::std::ios_base&, int );
void register_callback(event_callback __fn,int __index);
protected: streamsize _M_precision;
streamsize _M_width;
fmtflags _M_flags;
iostate _M_exception;
iostate _M_streambuf_state;

struct _Callback_list 
{
struct _Callback_list *_M_next;
event_callback _M_fn;
int _M_index;
_Atomic_word _M_refcount;

inline _Callback_list(event_callback __fn,int __index,struct _Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0)
{
}

inline void _M_add_reference()
{
__gnu_cxx::__atomic_add_dispatch(&(this) -> _M_refcount,1);
}

inline int _M_remove_reference()
{
;
int __res = __gnu_cxx::__exchange_and_add_dispatch(&(this) -> _M_refcount,- 1);
if (__res == 0) {
;
}
return __res;
}
}
;
struct _Callback_list *_M_callbacks;
void _M_call_callbacks(enum event __ev) throw();
void _M_dispose_callbacks() throw();

struct _Words 
{
void *_M_pword;
long _M_iword;

inline _Words() : _M_pword(0), _M_iword(0)
{
}
}
;
struct _Words _M_word_zero;
enum __anonymous_0x3948ff0 {_S_local_word_size=8} ;
struct _Words _M_local_word[8];
int _M_word_size;
struct _Words *_M_word;
_Words &_M_grow_words(int __index,bool __iword);
class locale _M_ios_locale;
void _M_init() throw();

public: class Init 
{
public: friend class ios_base ;
Init();
~Init();
private: static _Atomic_word _S_refcount;
static bool _S_synced_with_stdio;
}
;

public: inline fmtflags flags() const
{
return (this) -> _M_flags;
}

inline fmtflags flags(fmtflags __fmtfl)
{
fmtflags __old = (this) -> _M_flags;
(this) -> _M_flags = __fmtfl;
return __old;
}

inline fmtflags setf(fmtflags __fmtfl)
{
fmtflags __old = (this) -> _M_flags;
(this) -> _M_flags|=__fmtfl;
return __old;
}

inline fmtflags setf(fmtflags __fmtfl,fmtflags __mask)
{
fmtflags __old = (this) -> _M_flags;
(this) -> _M_flags&=~(__mask);
(this) -> _M_flags|=__fmtfl&__mask;
return __old;
}

inline void unsetf(fmtflags __mask)
{
(this) -> _M_flags&=~(__mask);
}

inline streamsize precision() const
{
return (this) -> _M_precision;
}

inline streamsize precision(streamsize __prec)
{
streamsize __old = (this) -> _M_precision;
(this) -> _M_precision = __prec;
return __old;
}

inline streamsize width() const
{
return (this) -> _M_width;
}

inline streamsize width(streamsize __wide)
{
streamsize __old = (this) -> _M_width;
(this) -> _M_width = __wide;
return __old;
}
static bool sync_with_stdio(bool __sync = true);
locale imbue(const class locale &__loc) throw();

inline locale getloc() const
{
return ((this) -> _M_ios_locale);
}

inline const locale &_M_getloc() const
{
return (this) -> _M_ios_locale;
}
static int xalloc() throw();

inline long &iword(int __ix)
{
struct _Words &__word = __ix < (this) -> _M_word_size?(this) -> _M_word[__ix] : (this) ->  _M_grow_words (__ix,true);
return __word . _M_iword;
}

inline void *&pword(int __ix)
{
struct _Words &__word = __ix < (this) -> _M_word_size?(this) -> _M_word[__ix] : (this) ->  _M_grow_words (__ix,false);
return __word . _M_pword;
}
virtual ~ios_base();
protected: ios_base() throw();
public: inline ios_base(const class ios_base &) = delete;

inline ios_base &operator=(const class ios_base &)
{
}
protected: void _M_move(class ios_base &);
void _M_swap(class ios_base &__rhs);
}
;

inline class ios_base & __attribute__((visibility("default"))) boolalpha(class ios_base &__base)
{
__base .  setf (_S_boolalpha);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) noboolalpha(class ios_base &__base)
{
__base .  unsetf (_S_boolalpha);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) showbase(class ios_base &__base)
{
__base .  setf (_S_showbase);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) noshowbase(class ios_base &__base)
{
__base .  unsetf (_S_showbase);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) showpoint(class ios_base &__base)
{
__base .  setf (_S_showpoint);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) noshowpoint(class ios_base &__base)
{
__base .  unsetf (_S_showpoint);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) showpos(class ios_base &__base)
{
__base .  setf (_S_showpos);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) noshowpos(class ios_base &__base)
{
__base .  unsetf (_S_showpos);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) skipws(class ios_base &__base)
{
__base .  setf (_S_skipws);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) noskipws(class ios_base &__base)
{
__base .  unsetf (_S_skipws);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) uppercase(class ios_base &__base)
{
__base .  setf (_S_uppercase);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) nouppercase(class ios_base &__base)
{
__base .  unsetf (_S_uppercase);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) unitbuf(class ios_base &__base)
{
__base .  setf (_S_unitbuf);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) nounitbuf(class ios_base &__base)
{
__base .  unsetf (_S_unitbuf);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) internal(class ios_base &__base)
{
__base .  setf (_S_internal,_S_adjustfield);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) left(class ios_base &__base)
{
__base .  setf (_S_left,_S_adjustfield);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) right(class ios_base &__base)
{
__base .  setf (_S_right,_S_adjustfield);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) dec(class ios_base &__base)
{
__base .  setf (_S_dec,_S_basefield);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) hex(class ios_base &__base)
{
__base .  setf (_S_hex,_S_basefield);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) oct(class ios_base &__base)
{
__base .  setf (_S_oct,_S_basefield);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) fixed(class ios_base &__base)
{
__base .  setf (_S_fixed,_S_floatfield);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) scientific(class ios_base &__base)
{
__base .  setf (_S_scientific,_S_floatfield);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) hexfloat(class ios_base &__base)
{
__base .  setf (_S_floatfield,_S_floatfield);
return __base;
}

inline class ios_base & __attribute__((visibility("default"))) defaultfloat(class ios_base &__base)
{
__base .  unsetf (_S_floatfield);
return __base;
}
}
namespace std
{
template < typename _CharT, typename _Traits >
    streamsize
    __copy_streambufs_eof ( basic_streambuf < _CharT, _Traits > *,
     basic_streambuf < _CharT, _Traits > *, bool & );
template < typename _CharT, typename _Traits >
    class basic_streambuf
    {
    public :
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type :: int_type int_type;
      typedef typename traits_type :: pos_type pos_type;
      typedef typename traits_type :: off_type off_type;
      typedef basic_streambuf < char_type, traits_type > __streambuf_type;
      friend class basic_ios < char_type, traits_type >;
      friend class basic_istream < char_type, traits_type >;
      friend class basic_ostream < char_type, traits_type >;
      friend class istreambuf_iterator < char_type, traits_type >;
      friend class ostreambuf_iterator < char_type, traits_type >;
      friend streamsize
      __copy_streambufs_eof < > ( basic_streambuf *, basic_streambuf *, bool & );
      template < bool _IsMove, typename _CharT2 >
        friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,
            _CharT2 * > :: __type
        __copy_move_a2 ( istreambuf_iterator < _CharT2 >,
         istreambuf_iterator < _CharT2 >, _CharT2 * );
      template < typename _CharT2 >
        friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,
      istreambuf_iterator < _CharT2 > > :: __type
        find ( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,
      const _CharT2 & );
      template < typename _CharT2, typename _Traits2 >
        friend basic_istream < _CharT2, _Traits2 > &
        operator >> ( basic_istream < _CharT2, _Traits2 > &, _CharT2 * );
      template < typename _CharT2, typename _Traits2, typename _Alloc >
        friend basic_istream < _CharT2, _Traits2 > &
        operator >> ( basic_istream < _CharT2, _Traits2 > &,
     basic_string < _CharT2, _Traits2, _Alloc > & );
      template < typename _CharT2, typename _Traits2, typename _Alloc >
        friend basic_istream < _CharT2, _Traits2 > &
        getline ( basic_istream < _CharT2, _Traits2 > &,
  basic_string < _CharT2, _Traits2, _Alloc > &, _CharT2 );
    protected :
      char_type * _M_in_beg;
      char_type * _M_in_cur;
      char_type * _M_in_end;
      char_type * _M_out_beg;
      char_type * _M_out_cur;
      char_type * _M_out_end;
      locale _M_buf_locale;
  public :
      virtual
      ~ basic_streambuf ( )
      ;
      locale
      pubimbue ( const locale & __loc )
      ;
      locale
      getloc ( ) const
      ;
      basic_streambuf *
      pubsetbuf ( char_type * __s, streamsize __n )
      ;
      pos_type
      pubseekoff ( off_type __off, ios_base :: seekdir __way,
   ios_base :: openmode __mode = ios_base :: in | ios_base :: out )
      ;
      pos_type
      pubseekpos ( pos_type __sp,
   ios_base :: openmode __mode = ios_base :: in | ios_base :: out )
      ;
      int
      pubsync ( );
      streamsize
      in_avail ( )
      ;
      int_type
      snextc ( )
      ;
      int_type
      sbumpc ( )
      ;
      int_type
      sgetc ( )
      ;
      streamsize
      sgetn ( char_type * __s, streamsize __n )
      ;
      int_type
      sputbackc ( char_type __c )
      ;
      int_type
      sungetc ( )
      ;
      int_type
      sputc ( char_type __c )
      ;
      streamsize
      sputn ( const char_type * __s, streamsize __n )
      ;
    protected :
      basic_streambuf ( )
      ;
      char_type *
      eback ( ) const;
      char_type *
      gptr ( ) const;
      char_type *
      egptr ( ) const;
      void
      gbump ( int __n );
      void
      setg ( char_type * __gbeg, char_type * __gnext, char_type * __gend )
      ;
      char_type *
      pbase ( ) const;
      char_type *
      pptr ( ) const;
      char_type *
      epptr ( ) const;
      void
      pbump ( int __n );
      void
      setp ( char_type * __pbeg, char_type * __pend )
      ;
      virtual void
      imbue ( const locale & __loc )
      ;
      virtual basic_streambuf < char_type, _Traits > *
      setbuf ( char_type *, streamsize )
      ;
      virtual pos_type
      seekoff ( off_type, ios_base :: seekdir,
       ios_base :: openmode = ios_base :: in | ios_base :: out )
      ;
      virtual pos_type
      seekpos ( pos_type,
       ios_base :: openmode = ios_base :: in | ios_base :: out )
      ;
      virtual int
      sync ( );
      virtual streamsize
      showmanyc ( );
      virtual streamsize
      xsgetn ( char_type * __s, streamsize __n );
      virtual int_type
      underflow ( )
      ;
      virtual int_type
      uflow ( )
      ;
      virtual int_type
      pbackfail ( int_type __c = traits_type :: eof ( ) )
      ;
      virtual streamsize
      xsputn ( const char_type * __s, streamsize __n );
      virtual int_type
      overflow ( int_type __c = traits_type :: eof ( ) )
      ;
    public :
      void
      stossc ( )
      ;
      void
      __safe_gbump ( streamsize __n );
      void
      __safe_pbump ( streamsize __n );
    protected :
      basic_streambuf ( const basic_streambuf & );
      basic_streambuf &
      operator = ( const basic_streambuf & );
      void
      swap ( basic_streambuf & __sb )
      ;
    };
template < typename _CharT, typename _Traits >
    std :: basic_streambuf < _CharT, _Traits > ::
    basic_streambuf ( const basic_streambuf & ) = default;
template < typename _CharT, typename _Traits >
    std :: basic_streambuf < _CharT, _Traits > &
    std :: basic_streambuf < _CharT, _Traits > ::
    operator = ( const basic_streambuf & ) = default;
template<> streamsize __copy_streambufs_eof< char  , char_traits< char  >  > (class basic_streambuf< char  , char_traits< char  >  > *__sbin,class basic_streambuf< char  , char_traits< char  >  > *__sbout,bool &__ineof) __attribute__((visibility("default"))) ;
template<> streamsize __copy_streambufs_eof< wchar_t  , char_traits< wchar_t  >  > (class basic_streambuf< wchar_t  , char_traits< wchar_t  >  > *__sbin,class basic_streambuf< wchar_t  , char_traits< wchar_t  >  > *__sbout,bool &__ineof) __attribute__((visibility("default"))) ;
}
namespace std
{
template < typename _CharT, typename _Traits >
    streamsize
    basic_streambuf < _CharT, _Traits > ::
    xsgetn ( char_type * __s, streamsize __n )
    {
      streamsize __ret = 0;
      while ( __ret < __n )
 {
   const streamsize __buf_len = this -> egptr ( ) - this -> gptr ( );
   if ( __buf_len )
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std :: min ( __buf_len, __remaining );
       traits_type :: copy ( __s, this -> gptr ( ), __len );
       __ret += __len;
       __s += __len;
       this -> __safe_gbump ( __len );
     }
   if ( __ret < __n )
     {
       const int_type __c = this -> uflow ( );
       if ( ! traits_type :: eq_int_type ( __c, traits_type :: eof ( ) ) )
  {
    traits_type :: assign ( * __s ++, traits_type :: to_char_type ( __c ) );
    ++ __ret;
  }
       else
  break;
     }
 }
      return __ret;
    }
template < typename _CharT, typename _Traits >
    streamsize
    basic_streambuf < _CharT, _Traits > ::
    xsputn ( const char_type * __s, streamsize __n )
    {
      streamsize __ret = 0;
      while ( __ret < __n )
 {
   const streamsize __buf_len = this -> epptr ( ) - this -> pptr ( );
   if ( __buf_len )
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std :: min ( __buf_len, __remaining );
       traits_type :: copy ( this -> pptr ( ), __s, __len );
       __ret += __len;
       __s += __len;
       this -> __safe_pbump ( __len );
     }
   if ( __ret < __n )
     {
       int_type __c = this -> overflow ( traits_type :: to_int_type ( * __s ) );
       if ( ! traits_type :: eq_int_type ( __c, traits_type :: eof ( ) ) )
  {
    ++ __ret;
    ++ __s;
  }
       else
  break;
     }
 }
      return __ret;
    }
template < typename _CharT, typename _Traits >
    streamsize
    __copy_streambufs_eof ( basic_streambuf < _CharT, _Traits > * __sbin,
     basic_streambuf < _CharT, _Traits > * __sbout,
     bool & __ineof )
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits :: int_type __c = __sbin -> sgetc ( );
      while ( ! _Traits :: eq_int_type ( __c, _Traits :: eof ( ) ) )
 {
   __c = __sbout -> sputc ( _Traits :: to_char_type ( __c ) );
   if ( _Traits :: eq_int_type ( __c, _Traits :: eof ( ) ) )
     {
       __ineof = false;
       break;
     }
   ++ __ret;
   __c = __sbin -> snextc ( );
 }
      return __ret;
    }
template < typename _CharT, typename _Traits >
    inline streamsize
    __copy_streambufs ( basic_streambuf < _CharT, _Traits > * __sbin,
        basic_streambuf < _CharT, _Traits > * __sbout )
    {
      bool __ineof;
      return __copy_streambufs_eof ( __sbin, __sbout, __ineof );
    }
extern template class basic_streambuf< char  , char_traits< char  >  > ;
extern template streamsize __copy_streambufs(class basic_streambuf< char  , char_traits< char  >  > *__sbin,class basic_streambuf< char  , char_traits< char  >  > *__sbout);
extern template streamsize __copy_streambufs_eof< char  , char_traits< char  >  > (class basic_streambuf< char  , char_traits< char  >  > *,class basic_streambuf< char  , char_traits< char  >  > *,bool &) __attribute__((visibility("default"))) ;
extern template class basic_streambuf< wchar_t  , char_traits< wchar_t  >  > ;
extern template streamsize __copy_streambufs(class basic_streambuf< wchar_t  , char_traits< wchar_t  >  > *__sbin,class basic_streambuf< wchar_t  , char_traits< wchar_t  >  > *__sbout);
extern template streamsize __copy_streambufs_eof< wchar_t  , char_traits< wchar_t  >  > (class basic_streambuf< wchar_t  , char_traits< wchar_t  >  > *,class basic_streambuf< wchar_t  , char_traits< wchar_t  >  > *,bool &) __attribute__((visibility("default"))) ;
}
typedef unsigned long wctype_t;
enum __anonymous_0x3afa590 {__ISwupper=0,__ISwlower=1,__ISwalpha=2,__ISwdigit=3,__ISwxdigit=4,__ISwspace=5,__ISwprint=6,__ISwgraph=7,__ISwblank=8,__ISwcntrl=9,__ISwpunct=10,__ISwalnum=11,_ISwupper=16777216,_ISwlower=33554432,_ISwalpha=67108864,_ISwdigit=134217728,_ISwxdigit=268435456,_ISwspace=536870912,_ISwprint=1073741824,_ISwgraph=-2147483648,_ISwblank=65536,_ISwcntrl=131072,_ISwpunct=262144,_ISwalnum=524288} ;
extern "C" { int iswalnum(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswalpha(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswcntrl(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswdigit(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswgraph(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswlower(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswprint(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswpunct(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswspace(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswupper(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswxdigit(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswblank(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { wctype_t wctype(const char *__property) throw() __attribute__((no_throw)) ; }
extern "C" { int iswctype(wint_t __wc,wctype_t __desc) throw() __attribute__((no_throw)) ; }
typedef const __int32_t *wctrans_t;
extern "C" { wint_t towlower(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { wint_t towupper(wint_t __wc) throw() __attribute__((no_throw)) ; }
extern "C" { wctrans_t wctrans(const char *__property) throw() __attribute__((no_throw)) ; }
extern "C" { wint_t towctrans(wint_t __wc,wctrans_t __desc) throw() __attribute__((no_throw)) ; }
extern "C" { int iswalnum_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswalpha_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswcntrl_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswdigit_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswgraph_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswlower_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswprint_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswpunct_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswspace_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswupper_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswxdigit_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswblank_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { wctype_t wctype_l(const char *__property,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { int iswctype_l(wint_t __wc,wctype_t __desc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { wint_t towlower_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { wint_t towupper_l(wint_t __wc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { wctrans_t wctrans_l(const char *__property,__locale_t __locale) throw() __attribute__((no_throw)) ; }
extern "C" { wint_t towctrans_l(wint_t __wc,wctrans_t __desc,__locale_t __locale) throw() __attribute__((no_throw)) ; }
namespace std
{
using ::wctrans_t;
using ::wctype_t;
using ::iswalnum;
using ::iswalpha;
using ::iswblank;
using ::iswcntrl;
using ::iswctype;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::towctrans;
using ::towlower;
using ::towupper;
using ::wctrans;
using ::wctype;
}
namespace std
{

struct ctype_base 
{
typedef const int *__to_type;
typedef unsigned short mask;
static const mask upper = _ISupper;
static const mask lower = _ISlower;
static const mask alpha = _ISalpha;
static const mask digit = _ISdigit;
static const mask xdigit = _ISxdigit;
static const mask space = _ISspace;
static const mask print = _ISprint;
static const mask graph = (_ISalpha | _ISdigit | _ISpunct);
static const mask cntrl = _IScntrl;
static const mask punct = _ISpunct;
static const mask alnum = (_ISalpha | _ISdigit);
static const mask blank = _ISblank;
}
;
}
namespace std
{
template < typename _CharT, typename _Traits >
    class istreambuf_iterator
    : public iterator < input_iterator_tag, _CharT, typename _Traits :: off_type,
                      _CharT *,
        _CharT >
    {
    public :
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits :: int_type int_type;
      typedef basic_streambuf < _CharT, _Traits > streambuf_type;
      typedef basic_istream < _CharT, _Traits > istream_type;
      template < typename _CharT2 >
 friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,
                      ostreambuf_iterator < _CharT2 > > :: __type
 copy ( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,
      ostreambuf_iterator < _CharT2 > );
      template < bool _IsMove, typename _CharT2 >
 friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,
            _CharT2 * > :: __type
 __copy_move_a2 ( istreambuf_iterator < _CharT2 >,
         istreambuf_iterator < _CharT2 >, _CharT2 * );
      template < typename _CharT2 >
 friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,
               istreambuf_iterator < _CharT2 > > :: __type
 find ( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,
      const _CharT2 & );
    private :
      mutable streambuf_type * _M_sbuf;
      mutable int_type _M_c;
    public :
      constexpr istreambuf_iterator ( ) noexcept
      ;
      istreambuf_iterator ( const istreambuf_iterator & ) noexcept = default;
      ~ istreambuf_iterator ( ) = default;
      istreambuf_iterator ( istream_type & __s ) noexcept
      ;
      istreambuf_iterator ( streambuf_type * __s ) noexcept
      ;
      char_type
      operator * ( ) const
      ;
      istreambuf_iterator &
      operator ++ ( )
      ;
      istreambuf_iterator
      operator ++ ( int )
      ;
      bool
      equal ( const istreambuf_iterator & __b ) const
      ;
    private :
      int_type
      _M_get ( ) const
      ;
      bool
      _M_at_eof ( ) const
      ;
    };
template < typename _CharT, typename _Traits >
    inline bool
    operator == ( const istreambuf_iterator < _CharT, _Traits > & __a,
        const istreambuf_iterator < _CharT, _Traits > & __b )
    { return __a . equal ( __b ); }
template < typename _CharT, typename _Traits >
    inline bool
    operator != ( const istreambuf_iterator < _CharT, _Traits > & __a,
        const istreambuf_iterator < _CharT, _Traits > & __b )
    { return ! __a . equal ( __b ); }
template < typename _CharT, typename _Traits >
    class ostreambuf_iterator
    : public iterator < output_iterator_tag, void, void, void, void >
    {
    public :
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf < _CharT, _Traits > streambuf_type;
      typedef basic_ostream < _CharT, _Traits > ostream_type;
      template < typename _CharT2 >
 friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value,
                      ostreambuf_iterator < _CharT2 > > :: __type
 copy ( istreambuf_iterator < _CharT2 >, istreambuf_iterator < _CharT2 >,
      ostreambuf_iterator < _CharT2 > );
    private :
      streambuf_type * _M_sbuf;
      bool _M_failed;
    public :
      ostreambuf_iterator ( ostream_type & __s ) noexcept
      ;
      ostreambuf_iterator ( streambuf_type * __s ) noexcept
      ;
      ostreambuf_iterator &
      operator = ( _CharT __c )
      ;
      ostreambuf_iterator &
      operator * ( )
      ;
      ostreambuf_iterator &
      operator ++ ( int )
      ;
      ostreambuf_iterator &
      operator ++ ( )
      ;
      bool
      failed ( ) const noexcept
      ;
      ostreambuf_iterator &
      _M_put ( const _CharT * __ws, streamsize __len )
      ;
    };
template < typename _CharT >
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,
                           ostreambuf_iterator < _CharT > > :: __type
    copy ( istreambuf_iterator < _CharT > __first,
  istreambuf_iterator < _CharT > __last,
  ostreambuf_iterator < _CharT > __result )
    {
      if ( __first . _M_sbuf && ! __last . _M_sbuf && ! __result . _M_failed )
 {
   bool __ineof;
   __copy_streambufs_eof ( __first . _M_sbuf, __result . _M_sbuf, __ineof );
   if ( ! __ineof )
     __result . _M_failed = true;
 }
      return __result;
    }
template < bool _IsMove, typename _CharT >
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,
            ostreambuf_iterator < _CharT > > :: __type
    __copy_move_a2 ( _CharT * __first, _CharT * __last,
     ostreambuf_iterator < _CharT > __result )
    {
      const streamsize __num = __last - __first;
      if ( __num > 0 )
 __result . _M_put ( __first, __num );
      return __result;
    }
template < bool _IsMove, typename _CharT >
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,
        ostreambuf_iterator < _CharT > > :: __type
    __copy_move_a2 ( const _CharT * __first, const _CharT * __last,
     ostreambuf_iterator < _CharT > __result )
    {
      const streamsize __num = __last - __first;
      if ( __num > 0 )
 __result . _M_put ( __first, __num );
      return __result;
    }
template < bool _IsMove, typename _CharT >
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,
            _CharT * > :: __type
    __copy_move_a2 ( istreambuf_iterator < _CharT > __first,
     istreambuf_iterator < _CharT > __last, _CharT * __result )
    {
      typedef istreambuf_iterator < _CharT > __is_iterator_type;
      typedef typename __is_iterator_type :: traits_type traits_type;
      typedef typename __is_iterator_type :: streambuf_type streambuf_type;
      typedef typename traits_type :: int_type int_type;
      if ( __first . _M_sbuf && ! __last . _M_sbuf )
 {
   streambuf_type * __sb = __first . _M_sbuf;
   int_type __c = __sb -> sgetc ( );
   while ( ! traits_type :: eq_int_type ( __c, traits_type :: eof ( ) ) )
     {
       const streamsize __n = __sb -> egptr ( ) - __sb -> gptr ( );
       if ( __n > 1 )
  {
    traits_type :: copy ( __result, __sb -> gptr ( ), __n );
    __sb -> __safe_gbump ( __n );
    __result += __n;
    __c = __sb -> underflow ( );
  }
       else
  {
    * __result ++ = traits_type :: to_char_type ( __c );
    __c = __sb -> snextc ( );
  }
     }
 }
      return __result;
    }
template < typename _CharT >
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,
          istreambuf_iterator < _CharT > > :: __type
    find ( istreambuf_iterator < _CharT > __first,
  istreambuf_iterator < _CharT > __last, const _CharT & __val )
    {
      typedef istreambuf_iterator < _CharT > __is_iterator_type;
      typedef typename __is_iterator_type :: traits_type traits_type;
      typedef typename __is_iterator_type :: streambuf_type streambuf_type;
      typedef typename traits_type :: int_type int_type;
      if ( __first . _M_sbuf && ! __last . _M_sbuf )
 {
   const int_type __ival = traits_type :: to_int_type ( __val );
   streambuf_type * __sb = __first . _M_sbuf;
   int_type __c = __sb -> sgetc ( );
   while ( ! traits_type :: eq_int_type ( __c, traits_type :: eof ( ) )
   && ! traits_type :: eq_int_type ( __c, __ival ) )
     {
       streamsize __n = __sb -> egptr ( ) - __sb -> gptr ( );
       if ( __n > 1 )
  {
    const _CharT * __p = traits_type :: find ( __sb -> gptr ( ),
       __n, __val );
    if ( __p )
      __n = __p - __sb -> gptr ( );
    __sb -> __safe_gbump ( __n );
    __c = __sb -> sgetc ( );
  }
       else
  __c = __sb -> snextc ( );
     }
   if ( ! traits_type :: eq_int_type ( __c, traits_type :: eof ( ) ) )
     __first . _M_c = __c;
   else
     __first . _M_sbuf = 0;
 }
      return __first;
    }
}
namespace std
{
template < typename _Tp >
    void
    __convert_to_v ( const char *, _Tp &, ios_base :: iostate &,
     const __c_locale & ) throw ( );
template<> void __convert_to_v(const char *,float &,ios_base::iostate &,const __c_locale &) throw() __attribute__((no_throw)) ;
template<> void __convert_to_v(const char *,double &,ios_base::iostate &,const __c_locale &) throw() __attribute__((no_throw)) ;
template<> void __convert_to_v(const char *,long double &,ios_base::iostate &,const __c_locale &) throw() __attribute__((no_throw)) ;
template < typename _CharT, typename _Traits >
    struct __pad
    {
      static void
      _S_pad ( ios_base & __io, _CharT __fill, _CharT * __news,
      const _CharT * __olds, streamsize __newlen, streamsize __oldlen );
    };
template < typename _CharT >
    _CharT *
    __add_grouping ( _CharT * __s, _CharT __sep,
     const char * __gbeg, size_t __gsize,
     const _CharT * __first, const _CharT * __last );
template < typename _CharT >
    inline
    ostreambuf_iterator < _CharT >
    __write ( ostreambuf_iterator < _CharT > __s, const _CharT * __ws, int __len )
    {
      __s . _M_put ( __ws, __len );
      return __s;
    }
template < typename _CharT, typename _OutIter >
    inline
    _OutIter
    __write ( _OutIter __s, const _CharT * __ws, int __len )
    {
      for ( int __j = 0; __j < __len; __j ++, ++ __s )
 * __s = __ws [ __j ];
      return __s;
    }
template < typename _CharT >
    class __ctype_abstract_base : public locale :: facet, public ctype_base
    {
    public :
      typedef _CharT char_type;
      bool
      is ( mask __m, char_type __c ) const
      ;
      const char_type *
      is ( const char_type * __lo, const char_type * __hi, mask * __vec ) const
      ;
      const char_type *
      scan_is ( mask __m, const char_type * __lo, const char_type * __hi ) const
      ;
      const char_type *
      scan_not ( mask __m, const char_type * __lo, const char_type * __hi ) const
      ;
      char_type
      toupper ( char_type __c ) const
      ;
      const char_type *
      toupper ( char_type * __lo, const char_type * __hi ) const
      ;
      char_type
      tolower ( char_type __c ) const
      ;
      const char_type *
      tolower ( char_type * __lo, const char_type * __hi ) const
      ;
      char_type
      widen ( char __c ) const
      ;
      const char *
      widen ( const char * __lo, const char * __hi, char_type * __to ) const
      ;
      char
      narrow ( char_type __c, char __dfault ) const
      ;
      const char_type *
      narrow ( const char_type * __lo, const char_type * __hi,
       char __dfault, char * __to ) const
      ;
    protected :
      explicit
      __ctype_abstract_base ( size_t __refs = 0 );
      virtual
      ~ __ctype_abstract_base ( );
      virtual bool
      do_is ( mask __m, char_type __c ) const = 0;
      virtual const char_type *
      do_is ( const char_type * __lo, const char_type * __hi,
     mask * __vec ) const = 0;
      virtual const char_type *
      do_scan_is ( mask __m, const char_type * __lo,
   const char_type * __hi ) const = 0;
      virtual const char_type *
      do_scan_not ( mask __m, const char_type * __lo,
    const char_type * __hi ) const = 0;
      virtual char_type
      do_toupper ( char_type __c ) const = 0;
      virtual const char_type *
      do_toupper ( char_type * __lo, const char_type * __hi ) const = 0;
      virtual char_type
      do_tolower ( char_type __c ) const = 0;
      virtual const char_type *
      do_tolower ( char_type * __lo, const char_type * __hi ) const = 0;
      virtual char_type
      do_widen ( char __c ) const = 0;
      virtual const char *
      do_widen ( const char * __lo, const char * __hi, char_type * __to ) const = 0;
      virtual char
      do_narrow ( char_type __c, char __dfault ) const = 0;
      virtual const char_type *
      do_narrow ( const char_type * __lo, const char_type * __hi,
  char __dfault, char * __to ) const = 0;
    };
template < typename _CharT >
    class ctype : public __ctype_abstract_base < _CharT >
    {
    public :
      typedef _CharT char_type;
      typedef typename __ctype_abstract_base < _CharT > :: mask mask;
      static locale :: id id;
      explicit
      ctype ( size_t __refs = 0 );
   protected :
      virtual
      ~ ctype ( );
      virtual bool
      do_is ( mask __m, char_type __c ) const;
      virtual const char_type *
      do_is ( const char_type * __lo, const char_type * __hi, mask * __vec ) const;
      virtual const char_type *
      do_scan_is ( mask __m, const char_type * __lo, const char_type * __hi ) const;
      virtual const char_type *
      do_scan_not ( mask __m, const char_type * __lo,
    const char_type * __hi ) const;
      virtual char_type
      do_toupper ( char_type __c ) const;
      virtual const char_type *
      do_toupper ( char_type * __lo, const char_type * __hi ) const;
      virtual char_type
      do_tolower ( char_type __c ) const;
      virtual const char_type *
      do_tolower ( char_type * __lo, const char_type * __hi ) const;
      virtual char_type
      do_widen ( char __c ) const;
      virtual const char *
      do_widen ( const char * __lo, const char * __hi, char_type * __dest ) const;
      virtual char
      do_narrow ( char_type, char __dfault ) const;
      virtual const char_type *
      do_narrow ( const char_type * __lo, const char_type * __hi,
  char __dfault, char * __to ) const;
    };
template < typename _CharT >
    locale :: id ctype < _CharT > :: id;
template<> class ctype< char  > : public locale::facet,public ctype_base
{
public: typedef char char_type;
protected: __c_locale _M_c_locale_ctype;
bool _M_del;
__to_type _M_toupper;
__to_type _M_tolower;
const mask *_M_table;
mutable char _M_widen_ok;
mutable char _M_widen[256];
mutable char _M_narrow[256];
mutable char _M_narrow_ok;
public: static class locale::id id;
static const size_t table_size = (1 + (static_cast < unsigned char  >  ((- 1))));
explicit ctype(const ctype_base::mask *__table = 0,bool __del = false,size_t __refs = 0);
explicit ctype(__c_locale __cloc,const ctype_base::mask *__table = 0,bool __del = false,size_t __refs = 0);
inline bool is(ctype_base::mask __m,char __c) const;
inline const char *is(const char *__lo,const char *__hi,ctype_base::mask *__vec) const;
inline const char *scan_is(ctype_base::mask __m,const char *__lo,const char *__hi) const;
inline const char *scan_not(ctype_base::mask __m,const char *__lo,const char *__hi) const;

inline char_type toupper(char_type __c) const
{
return (this) ->  do_toupper (__c);
}

inline const char_type *toupper(char_type *__lo,const char_type *__hi) const
{
return (this) ->  do_toupper (__lo,__hi);
}

inline char_type tolower(char_type __c) const
{
return (this) ->  do_tolower (__c);
}

inline const char_type *tolower(char_type *__lo,const char_type *__hi) const
{
return (this) ->  do_tolower (__lo,__hi);
}

inline char_type widen(char __c) const
{
if (((this) -> _M_widen_ok)) 
return (this) -> _M_widen[static_cast < unsigned char  >  (__c)];
(this) ->  _M_widen_init ();
return (this) ->  do_widen (__c);
}

inline const char *widen(const char *__lo,const char *__hi,char_type *__to) const
{
if (((this) -> _M_widen_ok) == 1) {
__builtin_memcpy(__to,__lo,(__hi - __lo));
return __hi;
}
if (!((this) -> _M_widen_ok)) 
(this) ->  _M_widen_init ();
return (this) ->  do_widen (__lo,__hi,__to);
}

inline char narrow(char_type __c,char __dfault) const
{
if ((this) -> _M_narrow[static_cast < unsigned char  >  (__c)]) 
return (this) -> _M_narrow[static_cast < unsigned char  >  (__c)];
const char __t = (this) ->  do_narrow (__c,__dfault);
if (__t != __dfault) 
(this) -> _M_narrow[static_cast < unsigned char  >  (__c)] = __t;
return __t;
}

inline const char_type *narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__to) const
{
if ((__builtin_expect((((this) -> _M_narrow_ok) == 1),true))) {
__builtin_memcpy(__to,__lo,(__hi - __lo));
return __hi;
}
if (!((this) -> _M_narrow_ok)) 
(this) ->  _M_narrow_init ();
return (this) ->  do_narrow (__lo,__hi,__dfault,__to);
}

inline const ctype_base::mask *table() const throw()
{
return (this) -> _M_table;
}
static const ctype_base::mask *classic_table() throw();
protected: virtual ~ctype();
virtual char_type do_toupper(char_type __c) const;
virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;
virtual char_type do_tolower(char_type __c) const;
virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;

virtual inline char_type do_widen(char __c) const
{
return __c;
}

virtual inline const char *do_widen(const char *__lo,const char *__hi,char_type *__to) const
{
__builtin_memcpy(__to,__lo,(__hi - __lo));
return __hi;
}

virtual inline char do_narrow(char_type __c,char __dfault) const
{
return __c;
}

virtual inline const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__to) const
{
__builtin_memcpy(__to,__lo,(__hi - __lo));
return __hi;
}
private: void _M_narrow_init() const;
void _M_widen_init() const;
};
template<> class ctype< wchar_t  > : public __ctype_abstract_base< wchar_t  > 
{
public: typedef wchar_t char_type;
typedef wctype_t __wmask_type;
protected: __c_locale _M_c_locale_ctype;
bool _M_narrow_ok;
char _M_narrow[128];
wint_t _M_widen[256];
ctype_base::mask _M_bit[16];
__wmask_type _M_wmask[16];
public: static class locale::id id;
explicit ctype(size_t __refs = 0);
explicit ctype(__c_locale __cloc,size_t __refs = 0);
protected: __wmask_type _M_convert_to_wmask(const ctype_base::mask __m) const throw();
virtual ~ctype();
virtual bool do_is(ctype_base::mask __m,char_type __c) const;
virtual const char_type *do_is(const char_type *__lo,const char_type *__hi,ctype_base::mask *__vec) const;
virtual const char_type *do_scan_is(ctype_base::mask __m,const char_type *__lo,const char_type *__hi) const;
virtual const char_type *do_scan_not(ctype_base::mask __m,const char_type *__lo,const char_type *__hi) const;
virtual char_type do_toupper(char_type __c) const;
virtual const char_type *do_toupper(char_type *__lo,const char_type *__hi) const;
virtual char_type do_tolower(char_type __c) const;
virtual const char_type *do_tolower(char_type *__lo,const char_type *__hi) const;
virtual char_type do_widen(char __c) const;
virtual const char *do_widen(const char *__lo,const char *__hi,char_type *__to) const;
virtual char do_narrow(char_type __c,char __dfault) const;
virtual const char_type *do_narrow(const char_type *__lo,const char_type *__hi,char __dfault,char *__to) const;
void _M_initialize_ctype() throw();
};
template < typename _CharT >
    class ctype_byname : public ctype < _CharT >
    {
    public :
      typedef typename ctype < _CharT > :: mask mask;
      explicit
      ctype_byname ( const char * __s, size_t __refs = 0 );
      explicit
      ctype_byname ( const string & __s, size_t __refs = 0 )
      ;
    protected :
      virtual
      ~ ctype_byname ( );
    };
template<> class ctype_byname< char  > : public ctype< char  > 
{
public: explicit ctype_byname(const char *__s,size_t __refs = 0);
explicit ctype_byname(const __cxx11::string &__s,size_t __refs = 0);
protected: virtual ~ctype_byname();
};
template<> class ctype_byname< wchar_t  > : public ctype< wchar_t  > 
{
public: explicit ctype_byname(const char *__s,size_t __refs = 0);
explicit ctype_byname(const __cxx11::string &__s,size_t __refs = 0);
protected: virtual ~ctype_byname();
};
}
namespace std
{

inline bool ctype< char > ::is(ctype_base::mask __m,char __c) const
{
return ((this) -> _M_table[static_cast < unsigned char  >  (__c)] & __m);
}

inline const char *ctype< char > ::is(const char *__low,const char *__high,ctype_base::mask *__vec) const
{
while(__low < __high)
 *(__vec++) = (this) -> _M_table[static_cast < unsigned char  >  (( *(__low++)))];
return __high;
}

inline const char *ctype< char > ::scan_is(ctype_base::mask __m,const char *__low,const char *__high) const
{
while(__low < __high && !((this) -> _M_table[static_cast < unsigned char  >  (( *__low))] & __m))
++__low;
return __low;
}

inline const char *ctype< char > ::scan_not(ctype_base::mask __m,const char *__low,const char *__high) const
{
while(__low < __high && ((this) -> _M_table[static_cast < unsigned char  >  (( *__low))] & __m) != 0)
++__low;
return __low;
}
}
namespace std
{

class __num_base 
{
public: enum __anonymous_0x3ce8910 {_S_ominus=0,_S_oplus=1,_S_ox=2,_S_oX=3,_S_odigits=4,_S_odigits_end=20,_S_oudigits=20,_S_oudigits_end=36,_S_oe=18,_S_oE=34,_S_oend=36} ;
static const char *_S_atoms_out;
static const char *_S_atoms_in;
enum __anonymous_0x3cebf10 {_S_iminus=0,_S_iplus=1,_S_ix=2,_S_iX=3,_S_izero=4,_S_ie=18,_S_iE=24,_S_iend=26} ;
static void _S_format_float(const class ios_base &__io,char *__fptr,char __mod) throw();
}
;
template < typename _CharT >
    struct __numpunct_cache : public locale :: facet
    {
      const char * _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT * _M_truename;
      size_t _M_truename_size;
      const _CharT * _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      _CharT _M_atoms_out [ __num_base :: _S_oend ];
      _CharT _M_atoms_in [ __num_base :: _S_iend ];
      bool _M_allocated;
      __numpunct_cache ( size_t __refs = 0 )
      ;
      ~ __numpunct_cache ( );
      void
      _M_cache ( const locale & __loc );
    private :
      __numpunct_cache &
      operator = ( const __numpunct_cache & );
      explicit
      __numpunct_cache ( const __numpunct_cache & );
    };
template < typename _CharT >
    __numpunct_cache < _CharT > :: ~ __numpunct_cache ( )
    {
      if ( _M_allocated )
 {
   delete [ ] _M_grouping;
   delete [ ] _M_truename;
   delete [ ] _M_falsename;
 }
    }
namespace __cxx11
{
template < typename _CharT >
    class numpunct : public locale :: facet
    {
    public :
      typedef _CharT char_type;
      typedef basic_string < _CharT > string_type;
      typedef __numpunct_cache < _CharT > __cache_type;
    protected :
      __cache_type * _M_data;
    public :
      static locale :: id id;
      explicit
      numpunct ( size_t __refs = 0 )
      ;
      explicit
      numpunct ( __cache_type * __cache, size_t __refs = 0 )
      ;
      explicit
      numpunct ( __c_locale __cloc, size_t __refs = 0 )
      ;
      char_type
      decimal_point ( ) const
      ;
      char_type
      thousands_sep ( ) const
      ;
      string
      grouping ( ) const
      ;
      string_type
      truename ( ) const
      ;
      string_type
      falsename ( ) const
      ;
    protected :
      virtual
      ~ numpunct ( );
      virtual char_type
      do_decimal_point ( ) const
      ;
      virtual char_type
      do_thousands_sep ( ) const
      ;
      virtual string
      do_grouping ( ) const
      ;
      virtual string_type
      do_truename ( ) const
      ;
      virtual string_type
      do_falsename ( ) const
      ;
      void
      _M_initialize_numpunct ( __c_locale __cloc = 0 );
    };
template < typename _CharT >
    locale :: id numpunct < _CharT > :: id;
template<> numpunct< char > ::~numpunct();
template<> void numpunct< char > ::_M_initialize_numpunct(__c_locale __cloc);
template<> numpunct< wchar_t > ::~numpunct();
template<> void numpunct< wchar_t > ::_M_initialize_numpunct(__c_locale __cloc);
template < typename _CharT >
    class numpunct_byname : public numpunct < _CharT >
    {
    public :
      typedef _CharT char_type;
      typedef basic_string < _CharT > string_type;
      explicit
      numpunct_byname ( const char * __s, size_t __refs = 0 )
      ;
      explicit
      numpunct_byname ( const string & __s, size_t __refs = 0 )
      ;
    protected :
      virtual
      ~ numpunct_byname ( );
    };
}
template < typename _CharT, typename _InIter >
    class num_get : public locale :: facet
    {
    public :
      typedef _CharT char_type;
      typedef _InIter iter_type;
      static locale :: id id;
      explicit
      num_get ( size_t __refs = 0 );
      iter_type
      get ( iter_type __in, iter_type __end, ios_base & __io,
   ios_base :: iostate & __err, bool & __v ) const
      ;
      iter_type
      get ( iter_type __in, iter_type __end, ios_base & __io,
   ios_base :: iostate & __err, long & __v ) const
      ;
      iter_type
      get ( iter_type __in, iter_type __end, ios_base & __io,
   ios_base :: iostate & __err, unsigned short & __v ) const
      ;
      iter_type
      get ( iter_type __in, iter_type __end, ios_base & __io,
   ios_base :: iostate & __err, unsigned int & __v ) const
      ;
      iter_type
      get ( iter_type __in, iter_type __end, ios_base & __io,
   ios_base :: iostate & __err, unsigned long & __v ) const
      ;
      iter_type
      get ( iter_type __in, iter_type __end, ios_base & __io,
   ios_base :: iostate & __err, long long & __v ) const
      ;
      iter_type
      get ( iter_type __in, iter_type __end, ios_base & __io,
   ios_base :: iostate & __err, unsigned long long & __v ) const
      ;
      iter_type
      get ( iter_type __in, iter_type __end, ios_base & __io,
   ios_base :: iostate & __err, float & __v ) const
      ;
      iter_type
      get ( iter_type __in, iter_type __end, ios_base & __io,
   ios_base :: iostate & __err, double & __v ) const
      ;
      iter_type
      get ( iter_type __in, iter_type __end, ios_base & __io,
   ios_base :: iostate & __err, long double & __v ) const
      ;
      iter_type
      get ( iter_type __in, iter_type __end, ios_base & __io,
   ios_base :: iostate & __err, void * & __v ) const
      ;
    protected :
      virtual ~ num_get ( );
      __attribute__ ( ( __abi_tag__ ( "cxx11" ) ) )
      iter_type
      _M_extract_float ( iter_type, iter_type, ios_base &, ios_base :: iostate &,
         string & ) const;
      template < typename _ValueT >
 __attribute__ ( ( __abi_tag__ ( "cxx11" ) ) )
 iter_type
 _M_extract_int ( iter_type, iter_type, ios_base &, ios_base :: iostate &,
         _ValueT & ) const;
      template < typename _CharT2 >
      typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value, int > :: __type
 _M_find ( const _CharT2 *, size_t __len, _CharT2 __c ) const
 {
   int __ret = - 1;
   if ( __len <= 10 )
     {
       if ( __c >= _CharT2 ( '0' ) && __c < _CharT2 ( _CharT2 ( '0' ) + __len ) )
  __ret = __c - _CharT2 ( '0' );
     }
   else
     {
       if ( __c >= _CharT2 ( '0' ) && __c <= _CharT2 ( '9' ) )
  __ret = __c - _CharT2 ( '0' );
       else if ( __c >= _CharT2 ( 'a' ) && __c <= _CharT2 ( 'f' ) )
  __ret = 10 + ( __c - _CharT2 ( 'a' ) );
       else if ( __c >= _CharT2 ( 'A' ) && __c <= _CharT2 ( 'F' ) )
  __ret = 10 + ( __c - _CharT2 ( 'A' ) );
     }
   return __ret;
 }
      template < typename _CharT2 >
      typename __gnu_cxx :: __enable_if < ! __is_char < _CharT2 > :: __value,
          int > :: __type
 _M_find ( const _CharT2 * __zero, size_t __len, _CharT2 __c ) const
 {
   int __ret = - 1;
   const char_type * __q = char_traits < _CharT2 > :: find ( __zero, __len, __c );
   if ( __q )
     {
       __ret = __q - __zero;
       if ( __ret > 15 )
  __ret -= 6;
     }
   return __ret;
 }
      virtual iter_type
      do_get ( iter_type, iter_type, ios_base &, ios_base :: iostate &, bool & ) const;
      virtual iter_type
      do_get ( iter_type __beg, iter_type __end, ios_base & __io,
      ios_base :: iostate & __err, long & __v ) const
      ;
      virtual iter_type
      do_get ( iter_type __beg, iter_type __end, ios_base & __io,
      ios_base :: iostate & __err, unsigned short & __v ) const
      ;
      virtual iter_type
      do_get ( iter_type __beg, iter_type __end, ios_base & __io,
      ios_base :: iostate & __err, unsigned int & __v ) const
      ;
      virtual iter_type
      do_get ( iter_type __beg, iter_type __end, ios_base & __io,
      ios_base :: iostate & __err, unsigned long & __v ) const
      ;
      virtual iter_type
      do_get ( iter_type __beg, iter_type __end, ios_base & __io,
      ios_base :: iostate & __err, long long & __v ) const
      ;
      virtual iter_type
      do_get ( iter_type __beg, iter_type __end, ios_base & __io,
      ios_base :: iostate & __err, unsigned long long & __v ) const
      ;
      virtual iter_type
      do_get ( iter_type, iter_type, ios_base &, ios_base :: iostate &, float & ) const;
      virtual iter_type
      do_get ( iter_type, iter_type, ios_base &, ios_base :: iostate &,
      double & ) const;
      virtual iter_type
      do_get ( iter_type, iter_type, ios_base &, ios_base :: iostate &,
      long double & ) const;
      virtual iter_type
      do_get ( iter_type, iter_type, ios_base &, ios_base :: iostate &, void * & ) const;
    };
template < typename _CharT, typename _InIter >
    locale :: id num_get < _CharT, _InIter > :: id;
template < typename _CharT, typename _OutIter >
    class num_put : public locale :: facet
    {
    public :
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static locale :: id id;
      explicit
      num_put ( size_t __refs = 0 );
      iter_type
      put ( iter_type __s, ios_base & __io, char_type __fill, bool __v ) const
      ;
      iter_type
      put ( iter_type __s, ios_base & __io, char_type __fill, long __v ) const
      ;
      iter_type
      put ( iter_type __s, ios_base & __io, char_type __fill,
   unsigned long __v ) const
      ;
      iter_type
      put ( iter_type __s, ios_base & __io, char_type __fill, long long __v ) const
      ;
      iter_type
      put ( iter_type __s, ios_base & __io, char_type __fill,
   unsigned long long __v ) const
      ;
      iter_type
      put ( iter_type __s, ios_base & __io, char_type __fill, double __v ) const
      ;
      iter_type
      put ( iter_type __s, ios_base & __io, char_type __fill,
   long double __v ) const
      ;
      iter_type
      put ( iter_type __s, ios_base & __io, char_type __fill,
   const void * __v ) const
      ;
    protected :
      template < typename _ValueT >
 iter_type
 _M_insert_float ( iter_type, ios_base & __io, char_type __fill,
   char __mod, _ValueT __v ) const;
      void
      _M_group_float ( const char * __grouping, size_t __grouping_size,
       char_type __sep, const char_type * __p, char_type * __new,
       char_type * __cs, int & __len ) const;
      template < typename _ValueT >
 iter_type
 _M_insert_int ( iter_type, ios_base & __io, char_type __fill,
        _ValueT __v ) const;
      void
      _M_group_int ( const char * __grouping, size_t __grouping_size,
     char_type __sep, ios_base & __io, char_type * __new,
     char_type * __cs, int & __len ) const;
      void
      _M_pad ( char_type __fill, streamsize __w, ios_base & __io,
      char_type * __new, const char_type * __cs, int & __len ) const;
      virtual
      ~ num_put ( );
      virtual iter_type
      do_put ( iter_type __s, ios_base & __io, char_type __fill, bool __v ) const;
      virtual iter_type
      do_put ( iter_type __s, ios_base & __io, char_type __fill, long __v ) const
      ;
      virtual iter_type
      do_put ( iter_type __s, ios_base & __io, char_type __fill,
      unsigned long __v ) const
      ;
      virtual iter_type
      do_put ( iter_type __s, ios_base & __io, char_type __fill,
      long long __v ) const
      ;
      virtual iter_type
      do_put ( iter_type __s, ios_base & __io, char_type __fill,
      unsigned long long __v ) const
      ;
      virtual iter_type
      do_put ( iter_type, ios_base &, char_type, double ) const;
      virtual iter_type
      do_put ( iter_type, ios_base &, char_type, long double ) const;
      virtual iter_type
      do_put ( iter_type, ios_base &, char_type, const void * ) const;
    };
template < typename _CharT, typename _OutIter >
    locale :: id num_put < _CharT, _OutIter > :: id;
template < typename _CharT >
    inline bool
    isspace ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: space, __c ); }
template < typename _CharT >
    inline bool
    isprint ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: print, __c ); }
template < typename _CharT >
    inline bool
    iscntrl ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: cntrl, __c ); }
template < typename _CharT >
    inline bool
    isupper ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: upper, __c ); }
template < typename _CharT >
    inline bool
    islower ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: lower, __c ); }
template < typename _CharT >
    inline bool
    isalpha ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: alpha, __c ); }
template < typename _CharT >
    inline bool
    isdigit ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: digit, __c ); }
template < typename _CharT >
    inline bool
    ispunct ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: punct, __c ); }
template < typename _CharT >
    inline bool
    isxdigit ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: xdigit, __c ); }
template < typename _CharT >
    inline bool
    isalnum ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: alnum, __c ); }
template < typename _CharT >
    inline bool
    isgraph ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: graph, __c ); }
template < typename _CharT >
    inline bool
    isblank ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . is ( ctype_base :: blank, __c ); }
template < typename _CharT >
    inline _CharT
    toupper ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . toupper ( __c ); }
template < typename _CharT >
    inline _CharT
    tolower ( _CharT __c, const locale & __loc )
    { return use_facet < ctype < _CharT > > ( __loc ) . tolower ( __c ); }
}
namespace std
{
template < typename _Facet >
    struct __use_cache
    {
      const _Facet *
      operator ( ) ( const locale & __loc ) const;
    };
template < typename _CharT >
    struct __use_cache < __numpunct_cache < _CharT > >
    {
      const __numpunct_cache < _CharT > *
      operator ( ) ( const locale & __loc ) const
      ;
    };
template < typename _CharT >
    void
    __numpunct_cache < _CharT > :: _M_cache ( const locale & __loc )
    {
      const numpunct < _CharT > & __np = use_facet < numpunct < _CharT > > ( __loc );
      char * __grouping = 0;
      _CharT * __truename = 0;
      _CharT * __falsename = 0;
      try
 {
   const string & __g = __np . grouping ( );
   _M_grouping_size = __g . size ( );
   __grouping = new char [ _M_grouping_size ];
   __g . copy ( __grouping, _M_grouping_size );
   _M_use_grouping = ( _M_grouping_size
        && static_cast < signed char > ( __grouping [ 0 ] ) > 0
        && ( __grouping [ 0 ]
     != __gnu_cxx :: __numeric_traits < char > :: __max ) );
   const basic_string < _CharT > & __tn = __np . truename ( );
   _M_truename_size = __tn . size ( );
   __truename = new _CharT [ _M_truename_size ];
   __tn . copy ( __truename, _M_truename_size );
   const basic_string < _CharT > & __fn = __np . falsename ( );
   _M_falsename_size = __fn . size ( );
   __falsename = new _CharT [ _M_falsename_size ];
   __fn . copy ( __falsename, _M_falsename_size );
   _M_decimal_point = __np . decimal_point ( );
   _M_thousands_sep = __np . thousands_sep ( );
   const ctype < _CharT > & __ct = use_facet < ctype < _CharT > > ( __loc );
   __ct . widen ( __num_base :: _S_atoms_out,
       __num_base :: _S_atoms_out
       + __num_base :: _S_oend, _M_atoms_out );
   __ct . widen ( __num_base :: _S_atoms_in,
       __num_base :: _S_atoms_in
       + __num_base :: _S_iend, _M_atoms_in );
   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch ( ... )
 {
   delete [ ] __grouping;
   delete [ ] __truename;
   delete [ ] __falsename;
   throw;
 }
    }
bool __verify_grouping(const char *__grouping,size_t __grouping_size,const __cxx11::string &__grouping_tmp) throw() __attribute__((pure))  __attribute__((no_throw))  __attribute__((visibility("default"))) ;
template < typename _CharT, typename _InIter >
    __attribute__ ( ( __abi_tag__ ( "cxx11" ) ) )
    _InIter
    num_get < _CharT, _InIter > ::
    _M_extract_float ( _InIter __beg, _InIter __end, ios_base & __io,
       ios_base :: iostate & __err, string & __xtrc ) const
    {
      typedef char_traits < _CharT > __traits_type;
      typedef __numpunct_cache < _CharT > __cache_type;
      __use_cache < __cache_type > __uc;
      const locale & __loc = __io . _M_getloc ( );
      const __cache_type * __lc = __uc ( __loc );
      const _CharT * __lit = __lc -> _M_atoms_in;
      char_type __c = char_type ( );
      bool __testeof = __beg == __end;
      if ( ! __testeof )
 {
   __c = * __beg;
   const bool __plus = __c == __lit [ __num_base :: _S_iplus ];
   if ( ( __plus || __c == __lit [ __num_base :: _S_iminus ] )
       && ! ( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )
       && ! ( __c == __lc -> _M_decimal_point ) )
     {
       __xtrc += __plus ? '+' : '-';
       if ( ++ __beg != __end )
  __c = * __beg;
       else
  __testeof = true;
     }
 }
      bool __found_mantissa = false;
      int __sep_pos = 0;
      while ( ! __testeof )
 {
   if ( ( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )
       || __c == __lc -> _M_decimal_point )
     break;
   else if ( __c == __lit [ __num_base :: _S_izero ] )
     {
       if ( ! __found_mantissa )
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++ __sep_pos;
       if ( ++ __beg != __end )
  __c = * __beg;
       else
  __testeof = true;
     }
   else
     break;
 }
      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if ( __lc -> _M_use_grouping )
 __found_grouping . reserve ( 32 );
      const char_type * __lit_zero = __lit + __num_base :: _S_izero;
      if ( ! __lc -> _M_allocated )
 while ( ! __testeof )
   {
     const int __digit = _M_find ( __lit_zero, 10, __c );
     if ( __digit != - 1 )
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if ( __c == __lc -> _M_decimal_point
       && ! __found_dec && ! __found_sci )
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ( ( __c == __lit [ __num_base :: _S_ie ]
        || __c == __lit [ __num_base :: _S_iE ] )
       && ! __found_sci && __found_mantissa )
       {
  __xtrc += 'e';
  __found_sci = true;
  if ( ++ __beg != __end )
    {
      __c = * __beg;
      const bool __plus = __c == __lit [ __num_base :: _S_iplus ];
      if ( __plus || __c == __lit [ __num_base :: _S_iminus ] )
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;
     if ( ++ __beg != __end )
       __c = * __beg;
     else
       __testeof = true;
   }
      else
 while ( ! __testeof )
   {
     if ( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )
       {
  if ( ! __found_dec && ! __found_sci )
    {
      if ( __sep_pos )
        {
   __found_grouping += static_cast < char > ( __sep_pos );
   __sep_pos = 0;
        }
      else
        {
   __xtrc . clear ( );
   break;
        }
    }
  else
    break;
       }
     else if ( __c == __lc -> _M_decimal_point )
       {
  if ( ! __found_dec && ! __found_sci )
    {
      if ( __found_grouping . size ( ) )
        __found_grouping += static_cast < char > ( __sep_pos );
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type * __q =
    __traits_type :: find ( __lit_zero, 10, __c );
  if ( __q )
    {
      __xtrc += '0' + ( __q - __lit_zero );
      __found_mantissa = true;
      ++ __sep_pos;
    }
  else if ( ( __c == __lit [ __num_base :: _S_ie ]
     || __c == __lit [ __num_base :: _S_iE ] )
    && ! __found_sci && __found_mantissa )
    {
      if ( __found_grouping . size ( ) && ! __found_dec )
        __found_grouping += static_cast < char > ( __sep_pos );
      __xtrc += 'e';
      __found_sci = true;
      if ( ++ __beg != __end )
        {
   __c = * __beg;
   const bool __plus = __c == __lit [ __num_base :: _S_iplus ];
   if ( ( __plus || __c == __lit [ __num_base :: _S_iminus ] )
       && ! ( __lc -> _M_use_grouping
     && __c == __lc -> _M_thousands_sep )
       && ! ( __c == __lc -> _M_decimal_point ) )
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }
     if ( ++ __beg != __end )
       __c = * __beg;
     else
       __testeof = true;
   }
      if ( __found_grouping . size ( ) )
        {
   if ( ! __found_dec && ! __found_sci )
     __found_grouping += static_cast < char > ( __sep_pos );
          if ( ! std :: __verify_grouping ( __lc -> _M_grouping,
          __lc -> _M_grouping_size,
          __found_grouping ) )
     __err = ios_base :: failbit;
        }
      return __beg;
    }
template < typename _CharT, typename _InIter >
    template < typename _ValueT >
      __attribute__ ( ( __abi_tag__ ( "cxx11" ) ) )
      _InIter
      num_get < _CharT, _InIter > ::
      _M_extract_int ( _InIter __beg, _InIter __end, ios_base & __io,
       ios_base :: iostate & __err, _ValueT & __v ) const
      {
        typedef char_traits < _CharT > __traits_type;
 using __gnu_cxx :: __add_unsigned;
 typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;
 typedef __numpunct_cache < _CharT > __cache_type;
 __use_cache < __cache_type > __uc;
 const locale & __loc = __io . _M_getloc ( );
 const __cache_type * __lc = __uc ( __loc );
 const _CharT * __lit = __lc -> _M_atoms_in;
 char_type __c = char_type ( );
 const ios_base :: fmtflags __basefield = __io . flags ( )
                                        & ios_base :: basefield;
 const bool __oct = __basefield == ios_base :: oct;
 int __base = __oct ? 8 : ( __basefield == ios_base :: hex ? 16 : 10 );
 bool __testeof = __beg == __end;
 bool __negative = false;
 if ( ! __testeof )
   {
     __c = * __beg;
     __negative = __c == __lit [ __num_base :: _S_iminus ];
     if ( ( __negative || __c == __lit [ __num_base :: _S_iplus ] )
  && ! ( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )
  && ! ( __c == __lc -> _M_decimal_point ) )
       {
  if ( ++ __beg != __end )
    __c = * __beg;
  else
    __testeof = true;
       }
   }
 bool __found_zero = false;
 int __sep_pos = 0;
 while ( ! __testeof )
   {
     if ( ( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )
  || __c == __lc -> _M_decimal_point )
       break;
     else if ( __c == __lit [ __num_base :: _S_izero ]
       && ( ! __found_zero || __base == 10 ) )
       {
  __found_zero = true;
  ++ __sep_pos;
  if ( __basefield == 0 )
    __base = 8;
  if ( __base == 8 )
    __sep_pos = 0;
       }
     else if ( __found_zero
       && ( __c == __lit [ __num_base :: _S_ix ]
    || __c == __lit [ __num_base :: _S_iX ] ) )
       {
  if ( __basefield == 0 )
    __base = 16;
  if ( __base == 16 )
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;
     if ( ++ __beg != __end )
       {
  __c = * __beg;
  if ( ! __found_zero )
    break;
       }
     else
       __testeof = true;
   }
 const size_t __len = ( __base == 16 ? __num_base :: _S_iend
         - __num_base :: _S_izero : __base );
 string __found_grouping;
 if ( __lc -> _M_use_grouping )
   __found_grouping . reserve ( 32 );
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   ( __negative && __gnu_cxx :: __numeric_traits < _ValueT > :: __is_signed )
   ? - __gnu_cxx :: __numeric_traits < _ValueT > :: __min
   : __gnu_cxx :: __numeric_traits < _ValueT > :: __max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type * __lit_zero = __lit + __num_base :: _S_izero;
 if ( ! __lc -> _M_allocated )
   while ( ! __testeof )
     {
       __digit = _M_find ( __lit_zero, __len, __c );
       if ( __digit == - 1 )
  break;
       if ( __result > __smax )
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++ __sep_pos;
  }
       if ( ++ __beg != __end )
  __c = * __beg;
       else
  __testeof = true;
     }
 else
   while ( ! __testeof )
     {
       if ( __lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep )
  {
    if ( __sep_pos )
      {
        __found_grouping += static_cast < char > ( __sep_pos );
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if ( __c == __lc -> _M_decimal_point )
  break;
       else
  {
    const char_type * __q =
      __traits_type :: find ( __lit_zero, __len, __c );
    if ( ! __q )
      break;
    __digit = __q - __lit_zero;
    if ( __digit > 15 )
      __digit -= 6;
    if ( __result > __smax )
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++ __sep_pos;
      }
  }
       if ( ++ __beg != __end )
  __c = * __beg;
       else
  __testeof = true;
     }
 if ( __found_grouping . size ( ) )
   {
     __found_grouping += static_cast < char > ( __sep_pos );
     if ( ! std :: __verify_grouping ( __lc -> _M_grouping,
     __lc -> _M_grouping_size,
     __found_grouping ) )
       __err = ios_base :: failbit;
   }
 if ( ( ! __sep_pos && ! __found_zero && ! __found_grouping . size ( ) )
     || __testfail )
   {
     __v = 0;
     __err = ios_base :: failbit;
   }
 else if ( __testoverflow )
   {
     if ( __negative
  && __gnu_cxx :: __numeric_traits < _ValueT > :: __is_signed )
       __v = __gnu_cxx :: __numeric_traits < _ValueT > :: __min;
     else
       __v = __gnu_cxx :: __numeric_traits < _ValueT > :: __max;
     __err = ios_base :: failbit;
   }
 else
   __v = __negative ? - __result : __result;
 if ( __testeof )
   __err |= ios_base :: eofbit;
 return __beg;
      }
template < typename _CharT, typename _InIter >
    _InIter
    num_get < _CharT, _InIter > ::
    do_get ( iter_type __beg, iter_type __end, ios_base & __io,
           ios_base :: iostate & __err, bool & __v ) const
    {
      if ( ! ( __io . flags ( ) & ios_base :: boolalpha ) )
        {
   long __l = - 1;
          __beg = _M_extract_int ( __beg, __end, __io, __err, __l );
   if ( __l == 0 || __l == 1 )
     __v = bool ( __l );
   else
     {
       __v = true;
       __err = ios_base :: failbit;
       if ( __beg == __end )
  __err |= ios_base :: eofbit;
     }
        }
      else
        {
   typedef __numpunct_cache < _CharT > __cache_type;
   __use_cache < __cache_type > __uc;
   const locale & __loc = __io . _M_getloc ( );
   const __cache_type * __lc = __uc ( __loc );
   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc -> _M_falsename_size == 0;
   bool __donet = __lc -> _M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while ( ! __donef || ! __donet )
     {
       if ( __beg == __end )
  {
    __testeof = true;
    break;
  }
       const char_type __c = * __beg;
       if ( ! __donef )
  __testf = __c == __lc -> _M_falsename [ __n ];
       if ( ! __testf && __donet )
  break;
       if ( ! __donet )
  __testt = __c == __lc -> _M_truename [ __n ];
       if ( ! __testt && __donef )
  break;
       if ( ! __testt && ! __testf )
  break;
       ++ __n;
       ++ __beg;
       __donef = ! __testf || __n >= __lc -> _M_falsename_size;
       __donet = ! __testt || __n >= __lc -> _M_truename_size;
     }
   if ( __testf && __n == __lc -> _M_falsename_size && __n )
     {
       __v = false;
       if ( __testt && __n == __lc -> _M_truename_size )
  __err = ios_base :: failbit;
       else
  __err = __testeof ? ios_base :: eofbit : ios_base :: goodbit;
     }
   else if ( __testt && __n == __lc -> _M_truename_size && __n )
     {
       __v = true;
       __err = __testeof ? ios_base :: eofbit : ios_base :: goodbit;
     }
   else
     {
       __v = false;
       __err = ios_base :: failbit;
       if ( __testeof )
  __err |= ios_base :: eofbit;
     }
 }
      return __beg;
    }
template < typename _CharT, typename _InIter >
    _InIter
    num_get < _CharT, _InIter > ::
    do_get ( iter_type __beg, iter_type __end, ios_base & __io,
    ios_base :: iostate & __err, float & __v ) const
    {
      string __xtrc;
      __xtrc . reserve ( 32 );
      __beg = _M_extract_float ( __beg, __end, __io, __err, __xtrc );
      std :: __convert_to_v ( __xtrc . c_str ( ), __v, __err, _S_get_c_locale ( ) );
      if ( __beg == __end )
 __err |= ios_base :: eofbit;
      return __beg;
    }
template < typename _CharT, typename _InIter >
    _InIter
    num_get < _CharT, _InIter > ::
    do_get ( iter_type __beg, iter_type __end, ios_base & __io,
           ios_base :: iostate & __err, double & __v ) const
    {
      string __xtrc;
      __xtrc . reserve ( 32 );
      __beg = _M_extract_float ( __beg, __end, __io, __err, __xtrc );
      std :: __convert_to_v ( __xtrc . c_str ( ), __v, __err, _S_get_c_locale ( ) );
      if ( __beg == __end )
 __err |= ios_base :: eofbit;
      return __beg;
    }
template < typename _CharT, typename _InIter >
    _InIter
    num_get < _CharT, _InIter > ::
    do_get ( iter_type __beg, iter_type __end, ios_base & __io,
           ios_base :: iostate & __err, long double & __v ) const
    {
      string __xtrc;
      __xtrc . reserve ( 32 );
      __beg = _M_extract_float ( __beg, __end, __io, __err, __xtrc );
      std :: __convert_to_v ( __xtrc . c_str ( ), __v, __err, _S_get_c_locale ( ) );
      if ( __beg == __end )
 __err |= ios_base :: eofbit;
      return __beg;
    }
template < typename _CharT, typename _InIter >
    _InIter
    num_get < _CharT, _InIter > ::
    do_get ( iter_type __beg, iter_type __end, ios_base & __io,
           ios_base :: iostate & __err, void * & __v ) const
    {
      typedef ios_base :: fmtflags fmtflags;
      const fmtflags __fmt = __io . flags ( );
      __io . flags ( ( __fmt & ~ ios_base :: basefield ) | ios_base :: hex );
      typedef __gnu_cxx :: __conditional_type < ( sizeof ( void * )
          <= sizeof ( unsigned long ) ),
 unsigned long, unsigned long long > :: __type _UIntPtrType;
      _UIntPtrType __ul;
      __beg = _M_extract_int ( __beg, __end, __io, __err, __ul );
      __io . flags ( __fmt );
      __v = reinterpret_cast < void * > ( __ul );
      return __beg;
    }
template < typename _CharT, typename _OutIter >
    void
    num_put < _CharT, _OutIter > ::
    _M_pad ( _CharT __fill, streamsize __w, ios_base & __io,
    _CharT * __new, const _CharT * __cs, int & __len ) const
    {
      __pad < _CharT, char_traits < _CharT > > :: _S_pad ( __io, __fill, __new,
        __cs, __w, __len );
      __len = static_cast < int > ( __w );
    }
template < typename _CharT, typename _ValueT >
    int
    __int_to_char ( _CharT * __bufend, _ValueT __v, const _CharT * __lit,
    ios_base :: fmtflags __flags, bool __dec )
    {
      _CharT * __buf = __bufend;
      if ( __builtin_expect ( __dec, true ) )
 {
   do
     {
       * -- __buf = __lit [ ( __v % 10 ) + __num_base :: _S_odigits ];
       __v /= 10;
     }
   while ( __v != 0 );
 }
      else if ( ( __flags & ios_base :: basefield ) == ios_base :: oct )
 {
   do
     {
       * -- __buf = __lit [ ( __v & 0x7 ) + __num_base :: _S_odigits ];
       __v >>= 3;
     }
   while ( __v != 0 );
 }
      else
 {
   const bool __uppercase = __flags & ios_base :: uppercase;
   const int __case_offset = __uppercase ? __num_base :: _S_oudigits
                                         : __num_base :: _S_odigits;
   do
     {
       * -- __buf = __lit [ ( __v & 0xf ) + __case_offset ];
       __v >>= 4;
     }
   while ( __v != 0 );
 }
      return __bufend - __buf;
    }
template < typename _CharT, typename _OutIter >
    void
    num_put < _CharT, _OutIter > ::
    _M_group_int ( const char * __grouping, size_t __grouping_size, _CharT __sep,
   ios_base &, _CharT * __new, _CharT * __cs, int & __len ) const
    {
      _CharT * __p = std :: __add_grouping ( __new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len );
      __len = __p - __new;
    }
template < typename _CharT, typename _OutIter >
    template < typename _ValueT >
      _OutIter
      num_put < _CharT, _OutIter > ::
      _M_insert_int ( _OutIter __s, ios_base & __io, _CharT __fill,
      _ValueT __v ) const
      {
 using __gnu_cxx :: __add_unsigned;
 typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type;
 typedef __numpunct_cache < _CharT > __cache_type;
 __use_cache < __cache_type > __uc;
 const locale & __loc = __io . _M_getloc ( );
 const __cache_type * __lc = __uc ( __loc );
 const _CharT * __lit = __lc -> _M_atoms_out;
 const ios_base :: fmtflags __flags = __io . flags ( );
 const int __ilen = 5 * sizeof ( _ValueT );
 _CharT * __cs = static_cast < _CharT * > ( __builtin_alloca ( sizeof ( _CharT )
            * __ilen ) );
 const ios_base :: fmtflags __basefield = __flags & ios_base :: basefield;
 const bool __dec = ( __basefield != ios_base :: oct
       && __basefield != ios_base :: hex );
 const __unsigned_type __u = ( ( __v > 0 || ! __dec )
         ? __unsigned_type ( __v )
         : - __unsigned_type ( __v ) );
  int __len = __int_to_char ( __cs + __ilen, __u, __lit, __flags, __dec );
 __cs += __ilen - __len;
 if ( __lc -> _M_use_grouping )
   {
     _CharT * __cs2 = static_cast < _CharT * > ( __builtin_alloca ( sizeof ( _CharT )
          * ( __len + 1 )
          * 2 ) );
     _M_group_int ( __lc -> _M_grouping, __lc -> _M_grouping_size,
    __lc -> _M_thousands_sep, __io, __cs2 + 2, __cs, __len );
     __cs = __cs2 + 2;
   }
 if ( __builtin_expect ( __dec, true ) )
   {
     if ( __v >= 0 )
       {
  if ( bool ( __flags & ios_base :: showpos )
      && __gnu_cxx :: __numeric_traits < _ValueT > :: __is_signed )
    * -- __cs = __lit [ __num_base :: _S_oplus ], ++ __len;
       }
     else
       * -- __cs = __lit [ __num_base :: _S_ominus ], ++ __len;
   }
 else if ( bool ( __flags & ios_base :: showbase ) && __v )
   {
     if ( __basefield == ios_base :: oct )
       * -- __cs = __lit [ __num_base :: _S_odigits ], ++ __len;
     else
       {
  const bool __uppercase = __flags & ios_base :: uppercase;
  * -- __cs = __lit [ __num_base :: _S_ox + __uppercase ];
  * -- __cs = __lit [ __num_base :: _S_odigits ];
  __len += 2;
       }
   }
 const streamsize __w = __io . width ( );
 if ( __w > static_cast < streamsize > ( __len ) )
   {
     _CharT * __cs3 = static_cast < _CharT * > ( __builtin_alloca ( sizeof ( _CharT )
          * __w ) );
     _M_pad ( __fill, __w, __io, __cs3, __cs, __len );
     __cs = __cs3;
   }
 __io . width ( 0 );
 return std :: __write ( __s, __cs, __len );
      }
template < typename _CharT, typename _OutIter >
    void
    num_put < _CharT, _OutIter > ::
    _M_group_float ( const char * __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT * __p, _CharT * __new,
     _CharT * __cs, int & __len ) const
    {
      const int __declen = __p ? __p - __cs : __len;
      _CharT * __p2 = std :: __add_grouping ( __new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen );
      int __newlen = __p2 - __new;
      if ( __p )
 {
   char_traits < _CharT > :: copy ( __p2, __p, __len - __declen );
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
template < typename _CharT, typename _OutIter >
    template < typename _ValueT >
      _OutIter
      num_put < _CharT, _OutIter > ::
      _M_insert_float ( _OutIter __s, ios_base & __io, _CharT __fill, char __mod,
         _ValueT __v ) const
      {
 typedef __numpunct_cache < _CharT > __cache_type;
 __use_cache < __cache_type > __uc;
 const locale & __loc = __io . _M_getloc ( );
 const __cache_type * __lc = __uc ( __loc );
 const streamsize __prec = __io . precision ( ) < 0 ? 6 : __io . precision ( );
 const int __max_digits =
   __gnu_cxx :: __numeric_traits < _ValueT > :: __digits10;
 int __len;
 char __fbuf [ 16 ];
 __num_base :: _S_format_float ( __io, __fbuf, __mod );
 const bool __use_prec =
   ( __io . flags ( ) & ios_base :: floatfield ) != ios_base :: floatfield;
 int __cs_size = __max_digits * 3;
 char * __cs = static_cast < char * > ( __builtin_alloca ( __cs_size ) );
 if ( __use_prec )
   __len = std :: __convert_from_v ( _S_get_c_locale ( ), __cs, __cs_size,
     __fbuf, __prec, __v );
 else
   __len = std :: __convert_from_v ( _S_get_c_locale ( ), __cs, __cs_size,
     __fbuf, __v );
 if ( __len >= __cs_size )
   {
     __cs_size = __len + 1;
     __cs = static_cast < char * > ( __builtin_alloca ( __cs_size ) );
     if ( __use_prec )
       __len = std :: __convert_from_v ( _S_get_c_locale ( ), __cs, __cs_size,
         __fbuf, __prec, __v );
     else
       __len = std :: __convert_from_v ( _S_get_c_locale ( ), __cs, __cs_size,
         __fbuf, __v );
   }
 const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > ( __loc );
 _CharT * __ws = static_cast < _CharT * > ( __builtin_alloca ( sizeof ( _CharT )
            * __len ) );
 __ctype . widen ( __cs, __cs + __len, __ws );
 _CharT * __wp = 0;
 const char * __p = char_traits < char > :: find ( __cs, __len, '.' );
 if ( __p )
   {
     __wp = __ws + ( __p - __cs );
     * __wp = __lc -> _M_decimal_point;
   }
 if ( __lc -> _M_use_grouping
     && ( __wp || __len < 3 || ( __cs [ 1 ] <= '9' && __cs [ 2 ] <= '9'
          && __cs [ 1 ] >= '0' && __cs [ 2 ] >= '0' ) ) )
   {
     _CharT * __ws2 = static_cast < _CharT * > ( __builtin_alloca ( sizeof ( _CharT )
          * __len * 2 ) );
     streamsize __off = 0;
     if ( __cs [ 0 ] == '-' || __cs [ 0 ] == '+' )
       {
  __off = 1;
  __ws2 [ 0 ] = __ws [ 0 ];
  __len -= 1;
       }
     _M_group_float ( __lc -> _M_grouping, __lc -> _M_grouping_size,
      __lc -> _M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len );
     __len += __off;
     __ws = __ws2;
   }
 const streamsize __w = __io . width ( );
 if ( __w > static_cast < streamsize > ( __len ) )
   {
     _CharT * __ws3 = static_cast < _CharT * > ( __builtin_alloca ( sizeof ( _CharT )
          * __w ) );
     _M_pad ( __fill, __w, __io, __ws3, __ws, __len );
     __ws = __ws3;
   }
 __io . width ( 0 );
 return std :: __write ( __s, __ws, __len );
      }
template < typename _CharT, typename _OutIter >
    _OutIter
    num_put < _CharT, _OutIter > ::
    do_put ( iter_type __s, ios_base & __io, char_type __fill, bool __v ) const
    {
      const ios_base :: fmtflags __flags = __io . flags ( );
      if ( ( __flags & ios_base :: boolalpha ) == 0 )
        {
          const long __l = __v;
          __s = _M_insert_int ( __s, __io, __fill, __l );
        }
      else
        {
   typedef __numpunct_cache < _CharT > __cache_type;
   __use_cache < __cache_type > __uc;
   const locale & __loc = __io . _M_getloc ( );
   const __cache_type * __lc = __uc ( __loc );
   const _CharT * __name = __v ? __lc -> _M_truename
                              : __lc -> _M_falsename;
   int __len = __v ? __lc -> _M_truename_size
                   : __lc -> _M_falsename_size;
   const streamsize __w = __io . width ( );
   if ( __w > static_cast < streamsize > ( __len ) )
     {
       const streamsize __plen = __w - __len;
       _CharT * __ps
  = static_cast < _CharT * > ( __builtin_alloca ( sizeof ( _CharT )
       * __plen ) );
       char_traits < _CharT > :: assign ( __ps, __plen, __fill );
       __io . width ( 0 );
       if ( ( __flags & ios_base :: adjustfield ) == ios_base :: left )
  {
    __s = std :: __write ( __s, __name, __len );
    __s = std :: __write ( __s, __ps, __plen );
  }
       else
  {
    __s = std :: __write ( __s, __ps, __plen );
    __s = std :: __write ( __s, __name, __len );
  }
       return __s;
     }
   __io . width ( 0 );
   __s = std :: __write ( __s, __name, __len );
 }
      return __s;
    }
template < typename _CharT, typename _OutIter >
    _OutIter
    num_put < _CharT, _OutIter > ::
    do_put ( iter_type __s, ios_base & __io, char_type __fill, double __v ) const
    { return _M_insert_float ( __s, __io, __fill, char ( ), __v ); }
template < typename _CharT, typename _OutIter >
    _OutIter
    num_put < _CharT, _OutIter > ::
    do_put ( iter_type __s, ios_base & __io, char_type __fill,
    long double __v ) const
    { return _M_insert_float ( __s, __io, __fill, 'L', __v ); }
template < typename _CharT, typename _OutIter >
    _OutIter
    num_put < _CharT, _OutIter > ::
    do_put ( iter_type __s, ios_base & __io, char_type __fill,
           const void * __v ) const
    {
      const ios_base :: fmtflags __flags = __io . flags ( );
      const ios_base :: fmtflags __fmt = ~ ( ios_base :: basefield
      | ios_base :: uppercase );
      __io . flags ( ( __flags & __fmt ) | ( ios_base :: hex | ios_base :: showbase ) );
      typedef __gnu_cxx :: __conditional_type < ( sizeof ( const void * )
          <= sizeof ( unsigned long ) ),
 unsigned long, unsigned long long > :: __type _UIntPtrType;
      __s = _M_insert_int ( __s, __io, __fill,
     reinterpret_cast < _UIntPtrType > ( __v ) );
      __io . flags ( __flags );
      return __s;
    }
template < typename _CharT, typename _Traits >
    void
    __pad < _CharT, _Traits > :: _S_pad ( ios_base & __io, _CharT __fill,
       _CharT * __news, const _CharT * __olds,
       streamsize __newlen, streamsize __oldlen )
    {
      const size_t __plen = static_cast < size_t > ( __newlen - __oldlen );
      const ios_base :: fmtflags __adjust = __io . flags ( ) & ios_base :: adjustfield;
      if ( __adjust == ios_base :: left )
 {
   _Traits :: copy ( __news, __olds, __oldlen );
   _Traits :: assign ( __news + __oldlen, __plen, __fill );
   return;
 }
      size_t __mod = 0;
      if ( __adjust == ios_base :: internal )
 {
          const locale & __loc = __io . _M_getloc ( );
   const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > ( __loc );
   if ( __ctype . widen ( '-' ) == __olds [ 0 ]
       || __ctype . widen ( '+' ) == __olds [ 0 ] )
     {
       __news [ 0 ] = __olds [ 0 ];
       __mod = 1;
       ++ __news;
     }
   else if ( __ctype . widen ( '0' ) == __olds [ 0 ]
     && __oldlen > 1
     && ( __ctype . widen ( 'x' ) == __olds [ 1 ]
         || __ctype . widen ( 'X' ) == __olds [ 1 ] ) )
     {
       __news [ 0 ] = __olds [ 0 ];
       __news [ 1 ] = __olds [ 1 ];
       __mod = 2;
       __news += 2;
     }
 }
      _Traits :: assign ( __news, __plen, __fill );
      _Traits :: copy ( __news + __plen, __olds + __mod, __oldlen - __mod );
    }
template < typename _CharT >
    _CharT *
    __add_grouping ( _CharT * __s, _CharT __sep,
     const char * __gbeg, size_t __gsize,
     const _CharT * __first, const _CharT * __last )
    {
      size_t __idx = 0;
      size_t __ctr = 0;
      while ( __last - __first > __gbeg [ __idx ]
      && static_cast < signed char > ( __gbeg [ __idx ] ) > 0
      && __gbeg [ __idx ] != __gnu_cxx :: __numeric_traits < char > :: __max )
 {
   __last -= __gbeg [ __idx ];
   __idx < __gsize - 1 ? ++ __idx : ++ __ctr;
 }
      while ( __first != __last )
 * __s ++ = * __first ++;
      while ( __ctr -- )
 {
   * __s ++ = __sep;
   for ( char __i = __gbeg [ __idx ]; __i > 0; -- __i )
     * __s ++ = * __first ++;
 }
      while ( __idx -- )
 {
   * __s ++ = __sep;
   for ( char __i = __gbeg [ __idx ]; __i > 0; -- __i )
     * __s ++ = * __first ++;
 }
      return __s;
    }
extern template class __cxx11::numpunct< char  > ;
extern template class __cxx11::numpunct_byname< char  > ;
extern template class num_get< char  , istreambuf_iterator< basic_streambuf< char ,char_traits< char  > > ::char_type  , basic_streambuf< char ,char_traits< char  > > ::traits_type  >  > ;
extern template class num_put< char  , ostreambuf_iterator< basic_streambuf< char ,char_traits< char  > > ::char_type  , basic_streambuf< char ,char_traits< char  > > ::traits_type  >  > ;
extern template const class ctype< char  > &use_facet< ctype< char  >  > (const class locale &);
extern template const class __cxx11::numpunct< char  > &use_facet< class __cxx11::numpunct< char  >  > (const class locale &);
extern template const class num_put< char  , ostreambuf_iterator< basic_streambuf< char ,char_traits< char  > > ::char_type  , basic_streambuf< char ,char_traits< char  > > ::traits_type  >  > &use_facet< num_put< char  , ostreambuf_iterator< basic_streambuf< char ,char_traits< char  > > ::char_type  , basic_streambuf< char ,char_traits< char  > > ::traits_type  >  >  > (const class locale &);
extern template const class num_get< char  , istreambuf_iterator< basic_streambuf< char ,char_traits< char  > > ::char_type  , basic_streambuf< char ,char_traits< char  > > ::traits_type  >  > &use_facet< num_get< char  , istreambuf_iterator< basic_streambuf< char ,char_traits< char  > > ::char_type  , basic_streambuf< char ,char_traits< char  > > ::traits_type  >  >  > (const class locale &);
extern template bool has_facet< ctype< char  >  > (const class locale &) throw() __attribute__((no_throw)) ;
extern template bool has_facet< class __cxx11::numpunct< char  >  > (const class locale &) throw() __attribute__((no_throw)) ;
extern template bool has_facet< num_put< char  , ostreambuf_iterator< basic_streambuf< char ,char_traits< char  > > ::char_type  , basic_streambuf< char ,char_traits< char  > > ::traits_type  >  >  > (const class locale &) throw() __attribute__((no_throw)) ;
extern template bool has_facet< num_get< char  , istreambuf_iterator< basic_streambuf< char ,char_traits< char  > > ::char_type  , basic_streambuf< char ,char_traits< char  > > ::traits_type  >  >  > (const class locale &) throw() __attribute__((no_throw)) ;
extern template class __cxx11::numpunct< wchar_t  > ;
extern template class __cxx11::numpunct_byname< wchar_t  > ;
extern template class num_get< wchar_t  , istreambuf_iterator< basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::char_type  , basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::traits_type  >  > ;
extern template class num_put< wchar_t  , ostreambuf_iterator< basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::char_type  , basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::traits_type  >  > ;
extern template const class ctype< wchar_t  > &use_facet< ctype< wchar_t  >  > (const class locale &);
extern template const class __cxx11::numpunct< wchar_t  > &use_facet< class __cxx11::numpunct< wchar_t  >  > (const class locale &);
extern template const class num_put< wchar_t  , ostreambuf_iterator< basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::char_type  , basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::traits_type  >  > &use_facet< num_put< wchar_t  , ostreambuf_iterator< basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::char_type  , basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::traits_type  >  >  > (const class locale &);
extern template const class num_get< wchar_t  , istreambuf_iterator< basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::char_type  , basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::traits_type  >  > &use_facet< num_get< wchar_t  , istreambuf_iterator< basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::char_type  , basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::traits_type  >  >  > (const class locale &);
extern template bool has_facet< ctype< wchar_t  >  > (const class locale &) throw() __attribute__((no_throw)) ;
extern template bool has_facet< class __cxx11::numpunct< wchar_t  >  > (const class locale &) throw() __attribute__((no_throw)) ;
extern template bool has_facet< num_put< wchar_t  , ostreambuf_iterator< basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::char_type  , basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::traits_type  >  >  > (const class locale &) throw() __attribute__((no_throw)) ;
extern template bool has_facet< num_get< wchar_t  , istreambuf_iterator< basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::char_type  , basic_streambuf< wchar_t ,char_traits< wchar_t  > > ::traits_type  >  >  > (const class locale &) throw() __attribute__((no_throw)) ;
}
namespace std
{
template < typename _Facet >
    inline const _Facet &
    __check_facet ( const _Facet * __f )
    {
      if ( ! __f )
 __throw_bad_cast ( );
      return * __f;
    }
template < typename _CharT, typename _Traits >
    class basic_ios : public ios_base
    {
    public :
      typedef _CharT char_type;
      typedef typename _Traits :: int_type int_type;
      typedef typename _Traits :: pos_type pos_type;
      typedef typename _Traits :: off_type off_type;
      typedef _Traits traits_type;
      typedef ctype < _CharT > __ctype_type;
      typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >
           __num_put_type;
      typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >
           __num_get_type;
    protected :
      basic_ostream < _CharT, _Traits > * _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf < _CharT, _Traits > * _M_streambuf;
      const __ctype_type * _M_ctype;
      const __num_put_type * _M_num_put;
      const __num_get_type * _M_num_get;
    public :
      explicit operator bool ( ) const
      ;
      bool
      operator ! ( ) const
      ;
      iostate
      rdstate ( ) const
      ;
      void
      clear ( iostate __state = goodbit );
      void
      setstate ( iostate __state )
      ;
      void
      _M_setstate ( iostate __state )
      ;
      bool
      good ( ) const
      ;
      bool
      eof ( ) const
      ;
      bool
      fail ( ) const
      ;
      bool
      bad ( ) const
      ;
      iostate
      exceptions ( ) const
      ;
      void
      exceptions ( iostate __except )
      ;
      explicit
      basic_ios ( basic_streambuf < _CharT, _Traits > * __sb )
      ;
      virtual
      ~ basic_ios ( );
      basic_ostream < _CharT, _Traits > *
      tie ( ) const
      ;
      basic_ostream < _CharT, _Traits > *
      tie ( basic_ostream < _CharT, _Traits > * __tiestr )
      ;
      basic_streambuf < _CharT, _Traits > *
      rdbuf ( ) const
      ;
      basic_streambuf < _CharT, _Traits > *
      rdbuf ( basic_streambuf < _CharT, _Traits > * __sb );
      basic_ios &
      copyfmt ( const basic_ios & __rhs );
      char_type
      fill ( ) const
      ;
      char_type
      fill ( char_type __ch )
      ;
      locale
      imbue ( const locale & __loc );
      char
      narrow ( char_type __c, char __dfault ) const
      ;
      char_type
      widen ( char __c ) const
      ;
    protected :
      basic_ios ( )
      ;
      void
      init ( basic_streambuf < _CharT, _Traits > * __sb );
      basic_ios ( const basic_ios & ) = delete;
      basic_ios & operator = ( const basic_ios & ) = delete;
      void
      move ( basic_ios & __rhs )
      ;
      void
      move ( basic_ios && __rhs )
      ;
      void
      swap ( basic_ios & __rhs ) noexcept
      ;
      void
      set_rdbuf ( basic_streambuf < _CharT, _Traits > * __sb )
      ;
      void
      _M_cache_locale ( const locale & __loc );
    };
}
namespace std
{
template < typename _CharT, typename _Traits >
    void
    basic_ios < _CharT, _Traits > :: clear ( iostate __state )
    {
      if ( this -> rdbuf ( ) )
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if ( this -> exceptions ( ) & this -> rdstate ( ) )
 __throw_ios_failure ( ( "basic_ios::clear" ) );
    }
template < typename _CharT, typename _Traits >
    basic_streambuf < _CharT, _Traits > *
    basic_ios < _CharT, _Traits > :: rdbuf ( basic_streambuf < _CharT, _Traits > * __sb )
    {
      basic_streambuf < _CharT, _Traits > * __old = _M_streambuf;
      _M_streambuf = __sb;
      this -> clear ( );
      return __old;
    }
template < typename _CharT, typename _Traits >
    basic_ios < _CharT, _Traits > &
    basic_ios < _CharT, _Traits > :: copyfmt ( const basic_ios & __rhs )
    {
      if ( this != & __rhs )
 {
   _Words * __words = ( __rhs . _M_word_size <= _S_local_word_size ) ?
                      _M_local_word : new _Words [ __rhs . _M_word_size ];
   _Callback_list * __cb = __rhs . _M_callbacks;
   if ( __cb )
     __cb -> _M_add_reference ( );
   _M_call_callbacks ( erase_event );
   if ( _M_word != _M_local_word )
     {
       delete [ ] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks ( );
   _M_callbacks = __cb;
   for ( int __i = 0; __i < __rhs . _M_word_size; ++ __i )
     __words [ __i ] = __rhs . _M_word [ __i ];
   _M_word = __words;
   _M_word_size = __rhs . _M_word_size;
   this -> flags ( __rhs . flags ( ) );
   this -> width ( __rhs . width ( ) );
   this -> precision ( __rhs . precision ( ) );
   this -> tie ( __rhs . tie ( ) );
   this -> fill ( __rhs . fill ( ) );
   _M_ios_locale = __rhs . getloc ( );
   _M_cache_locale ( _M_ios_locale );
   _M_call_callbacks ( copyfmt_event );
   this -> exceptions ( __rhs . exceptions ( ) );
 }
      return * this;
    }
template < typename _CharT, typename _Traits >
    locale
    basic_ios < _CharT, _Traits > :: imbue ( const locale & __loc )
    {
      locale __old ( this -> getloc ( ) );
      ios_base :: imbue ( __loc );
      _M_cache_locale ( __loc );
      if ( this -> rdbuf ( ) != 0 )
 this -> rdbuf ( ) -> pubimbue ( __loc );
      return __old;
    }
template < typename _CharT, typename _Traits >
    void
    basic_ios < _CharT, _Traits > :: init ( basic_streambuf < _CharT, _Traits > * __sb )
    {
      ios_base :: _M_init ( );
      _M_cache_locale ( _M_ios_locale );
      _M_fill = _CharT ( );
      _M_fill_init = false;
      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }
template < typename _CharT, typename _Traits >
    void
    basic_ios < _CharT, _Traits > :: _M_cache_locale ( const locale & __loc )
    {
      if ( __builtin_expect ( has_facet < __ctype_type > ( __loc ), true ) )
 _M_ctype = & use_facet < __ctype_type > ( __loc );
      else
 _M_ctype = 0;
      if ( __builtin_expect ( has_facet < __num_put_type > ( __loc ), true ) )
 _M_num_put = & use_facet < __num_put_type > ( __loc );
      else
 _M_num_put = 0;
      if ( __builtin_expect ( has_facet < __num_get_type > ( __loc ), true ) )
 _M_num_get = & use_facet < __num_get_type > ( __loc );
      else
 _M_num_get = 0;
    }
extern template class basic_ios< char  , char_traits< char  >  > ;
extern template class basic_ios< wchar_t  , char_traits< wchar_t  >  > ;
}
namespace std
{
template < typename _CharT, typename _Traits >
    class basic_ostream : virtual public basic_ios < _CharT, _Traits >
    {
    public :
      typedef _CharT char_type;
      typedef typename _Traits :: int_type int_type;
      typedef typename _Traits :: pos_type pos_type;
      typedef typename _Traits :: off_type off_type;
      typedef _Traits traits_type;
      typedef basic_streambuf < _CharT, _Traits > __streambuf_type;
      typedef basic_ios < _CharT, _Traits > __ios_type;
      typedef basic_ostream < _CharT, _Traits > __ostream_type;
      typedef num_put < _CharT, ostreambuf_iterator < _CharT, _Traits > >
             __num_put_type;
      typedef ctype < _CharT > __ctype_type;
      explicit
      basic_ostream ( __streambuf_type * __sb )
      ;
      virtual
      ~ basic_ostream ( );
      class sentry;
      friend class sentry;
      __ostream_type &
      operator << ( __ostream_type & ( * __pf ) ( __ostream_type & ) )
      ;
      __ostream_type &
      operator << ( __ios_type & ( * __pf ) ( __ios_type & ) )
      ;
      __ostream_type &
      operator << ( ios_base & ( * __pf ) ( ios_base & ) )
      ;
      __ostream_type &
      operator << ( long __n )
      ;
      __ostream_type &
      operator << ( unsigned long __n )
      ;
      __ostream_type &
      operator << ( bool __n )
      ;
      __ostream_type &
      operator << ( short __n );
      __ostream_type &
      operator << ( unsigned short __n )
      ;
      __ostream_type &
      operator << ( int __n );
      __ostream_type &
      operator << ( unsigned int __n )
      ;
      __ostream_type &
      operator << ( long long __n )
      ;
      __ostream_type &
      operator << ( unsigned long long __n )
      ;
      __ostream_type &
      operator << ( double __f )
      ;
      __ostream_type &
      operator << ( float __f )
      ;
      __ostream_type &
      operator << ( long double __f )
      ;
      __ostream_type &
      operator << ( const void * __p )
      ;
      __ostream_type &
      operator << ( __streambuf_type * __sb );
      __ostream_type &
      put ( char_type __c );
      void
      _M_write ( const char_type * __s, streamsize __n )
      ;
      __ostream_type &
      write ( const char_type * __s, streamsize __n );
      __ostream_type &
      flush ( );
      pos_type
      tellp ( );
      __ostream_type &
      seekp ( pos_type );
       __ostream_type &
      seekp ( off_type, ios_base :: seekdir );
    protected :
      basic_ostream ( )
      ;
      basic_ostream ( basic_iostream < _CharT, _Traits > & );
      basic_ostream ( const basic_ostream & ) = delete;
      basic_ostream ( basic_ostream && __rhs )
      ;
      basic_ostream & operator = ( const basic_ostream & ) = delete;
      basic_ostream &
      operator = ( basic_ostream && __rhs )
      ;
      void
      swap ( basic_ostream & __rhs )
      ;
      template < typename _ValueT >
 __ostream_type &
 _M_insert ( _ValueT __v );
    };
template < typename _CharT, typename _Traits >
    class basic_ostream < _CharT, _Traits > :: sentry
    {
      bool _M_ok;
      basic_ostream < _CharT, _Traits > & _M_os;
    public :
      explicit
      sentry ( basic_ostream < _CharT, _Traits > & __os );
      ~ sentry ( )
      ;
      explicit
      operator bool ( ) const
      ;
    };
template < typename _CharT, typename _Traits >
    inline basic_ostream < _CharT, _Traits > &
    operator << ( basic_ostream < _CharT, _Traits > & __out, _CharT __c )
    { return __ostream_insert ( __out, & __c, 1 ); }
template < typename _CharT, typename _Traits >
    inline basic_ostream < _CharT, _Traits > &
    operator << ( basic_ostream < _CharT, _Traits > & __out, char __c )
    { return ( __out << __out . widen ( __c ) ); }
template < class _Traits >
    inline basic_ostream < char, _Traits > &
    operator << ( basic_ostream < char, _Traits > & __out, char __c )
    { return __ostream_insert ( __out, & __c, 1 ); }
template < class _Traits >
    inline basic_ostream < char, _Traits > &
    operator << ( basic_ostream < char, _Traits > & __out, signed char __c )
    { return ( __out << static_cast < char > ( __c ) ); }
template < class _Traits >
    inline basic_ostream < char, _Traits > &
    operator << ( basic_ostream < char, _Traits > & __out, unsigned char __c )
    { return ( __out << static_cast < char > ( __c ) ); }
template < typename _CharT, typename _Traits >
    inline basic_ostream < _CharT, _Traits > &
    operator << ( basic_ostream < _CharT, _Traits > & __out, const _CharT * __s )
    {
      if ( ! __s )
 __out . setstate ( ios_base :: badbit );
      else
 __ostream_insert ( __out, __s,
    static_cast < streamsize > ( _Traits :: length ( __s ) ) );
      return __out;
    }
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    operator << ( basic_ostream < _CharT, _Traits > & __out, const char * __s );
template < class _Traits >
    inline basic_ostream < char, _Traits > &
    operator << ( basic_ostream < char, _Traits > & __out, const char * __s )
    {
      if ( ! __s )
 __out . setstate ( ios_base :: badbit );
      else
 __ostream_insert ( __out, __s,
    static_cast < streamsize > ( _Traits :: length ( __s ) ) );
      return __out;
    }
template < class _Traits >
    inline basic_ostream < char, _Traits > &
    operator << ( basic_ostream < char, _Traits > & __out, const signed char * __s )
    { return ( __out << reinterpret_cast < const char * > ( __s ) ); }
template < class _Traits >
    inline basic_ostream < char, _Traits > &
    operator << ( basic_ostream < char, _Traits > & __out, const unsigned char * __s )
    { return ( __out << reinterpret_cast < const char * > ( __s ) ); }
template < typename _CharT, typename _Traits >
    inline basic_ostream < _CharT, _Traits > &
    endl ( basic_ostream < _CharT, _Traits > & __os )
    { return flush ( __os . put ( __os . widen ( '\n' ) ) ); }
template < typename _CharT, typename _Traits >
    inline basic_ostream < _CharT, _Traits > &
    ends ( basic_ostream < _CharT, _Traits > & __os )
    { return __os . put ( _CharT ( ) ); }
template < typename _CharT, typename _Traits >
    inline basic_ostream < _CharT, _Traits > &
    flush ( basic_ostream < _CharT, _Traits > & __os )
    { return __os . flush ( ); }
template < typename _CharT, typename _Traits, typename _Tp >
    inline basic_ostream < _CharT, _Traits > &
    operator << ( basic_ostream < _CharT, _Traits > && __os, const _Tp & __x )
    {
      __os << __x;
      return __os;
    }
}
namespace std
{
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > :: sentry ::
    sentry ( basic_ostream < _CharT, _Traits > & __os )
    : _M_ok ( false ), _M_os ( __os )
    {
      if ( __os . tie ( ) && __os . good ( ) )
 __os . tie ( ) -> flush ( );
      if ( __os . good ( ) )
 _M_ok = true;
      else
 __os . setstate ( ios_base :: failbit );
    }
template < typename _CharT, typename _Traits >
    template < typename _ValueT >
      basic_ostream < _CharT, _Traits > &
      basic_ostream < _CharT, _Traits > ::
      _M_insert ( _ValueT __v )
      {
 sentry __cerb ( * this );
 if ( __cerb )
   {
     ios_base :: iostate __err = ios_base :: goodbit;
     try
       {
  const __num_put_type & __np = __check_facet ( this -> _M_num_put );
  if ( __np . put ( * this, * this, this -> fill ( ), __v ) . failed ( ) )
    __err |= ios_base :: badbit;
       }
     catch ( __cxxabiv1 :: __forced_unwind & )
       {
  this -> _M_setstate ( ios_base :: badbit );
  throw;
       }
     catch ( ... )
       { this -> _M_setstate ( ios_base :: badbit ); }
     if ( __err )
       this -> setstate ( __err );
   }
 return * this;
      }
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    basic_ostream < _CharT, _Traits > ::
    operator << ( short __n )
    {
      const ios_base :: fmtflags __fmt = this -> flags ( ) & ios_base :: basefield;
      if ( __fmt == ios_base :: oct || __fmt == ios_base :: hex )
 return _M_insert ( static_cast < long > ( static_cast < unsigned short > ( __n ) ) );
      else
 return _M_insert ( static_cast < long > ( __n ) );
    }
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    basic_ostream < _CharT, _Traits > ::
    operator << ( int __n )
    {
      const ios_base :: fmtflags __fmt = this -> flags ( ) & ios_base :: basefield;
      if ( __fmt == ios_base :: oct || __fmt == ios_base :: hex )
 return _M_insert ( static_cast < long > ( static_cast < unsigned int > ( __n ) ) );
      else
 return _M_insert ( static_cast < long > ( __n ) );
    }
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    basic_ostream < _CharT, _Traits > ::
    operator << ( __streambuf_type * __sbin )
    {
      ios_base :: iostate __err = ios_base :: goodbit;
      sentry __cerb ( * this );
      if ( __cerb && __sbin )
 {
   try
     {
       if ( ! __copy_streambufs ( __sbin, this -> rdbuf ( ) ) )
  __err |= ios_base :: failbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: failbit ); }
 }
      else if ( ! __sbin )
 __err |= ios_base :: badbit;
      if ( __err )
 this -> setstate ( __err );
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    basic_ostream < _CharT, _Traits > ::
    put ( char_type __c )
    {
      sentry __cerb ( * this );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       const int_type __put = this -> rdbuf ( ) -> sputc ( __c );
       if ( traits_type :: eq_int_type ( __put, traits_type :: eof ( ) ) )
  __err |= ios_base :: badbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    basic_ostream < _CharT, _Traits > ::
    write ( const _CharT * __s, streamsize __n )
    {
      sentry __cerb ( * this );
      if ( __cerb )
 {
   try
     { _M_write ( __s, __n ); }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
 }
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    basic_ostream < _CharT, _Traits > ::
    flush ( )
    {
      ios_base :: iostate __err = ios_base :: goodbit;
      try
 {
   if ( this -> rdbuf ( ) && this -> rdbuf ( ) -> pubsync ( ) == - 1 )
     __err |= ios_base :: badbit;
 }
      catch ( __cxxabiv1 :: __forced_unwind & )
 {
   this -> _M_setstate ( ios_base :: badbit );
   throw;
 }
      catch ( ... )
 { this -> _M_setstate ( ios_base :: badbit ); }
      if ( __err )
 this -> setstate ( __err );
      return * this;
    }
template < typename _CharT, typename _Traits >
    typename basic_ostream < _CharT, _Traits > :: pos_type
    basic_ostream < _CharT, _Traits > ::
    tellp ( )
    {
      pos_type __ret = pos_type ( - 1 );
      try
 {
   if ( ! this -> fail ( ) )
     __ret = this -> rdbuf ( ) -> pubseekoff ( 0, ios_base :: cur, ios_base :: out );
 }
      catch ( __cxxabiv1 :: __forced_unwind & )
 {
   this -> _M_setstate ( ios_base :: badbit );
   throw;
 }
      catch ( ... )
 { this -> _M_setstate ( ios_base :: badbit ); }
      return __ret;
    }
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    basic_ostream < _CharT, _Traits > ::
    seekp ( pos_type __pos )
    {
      ios_base :: iostate __err = ios_base :: goodbit;
      try
 {
   if ( ! this -> fail ( ) )
     {
       const pos_type __p = this -> rdbuf ( ) -> pubseekpos ( __pos,
            ios_base :: out );
       if ( __p == pos_type ( off_type ( - 1 ) ) )
  __err |= ios_base :: failbit;
     }
 }
      catch ( __cxxabiv1 :: __forced_unwind & )
 {
   this -> _M_setstate ( ios_base :: badbit );
   throw;
 }
      catch ( ... )
 { this -> _M_setstate ( ios_base :: badbit ); }
      if ( __err )
 this -> setstate ( __err );
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    basic_ostream < _CharT, _Traits > ::
    seekp ( off_type __off, ios_base :: seekdir __dir )
    {
      ios_base :: iostate __err = ios_base :: goodbit;
      try
 {
   if ( ! this -> fail ( ) )
     {
       const pos_type __p = this -> rdbuf ( ) -> pubseekoff ( __off, __dir,
            ios_base :: out );
       if ( __p == pos_type ( off_type ( - 1 ) ) )
  __err |= ios_base :: failbit;
     }
 }
      catch ( __cxxabiv1 :: __forced_unwind & )
 {
   this -> _M_setstate ( ios_base :: badbit );
   throw;
 }
      catch ( ... )
 { this -> _M_setstate ( ios_base :: badbit ); }
      if ( __err )
 this -> setstate ( __err );
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    operator << ( basic_ostream < _CharT, _Traits > & __out, const char * __s )
    {
      if ( ! __s )
 __out . setstate ( ios_base :: badbit );
      else
 {
   const size_t __clen = char_traits < char > :: length ( __s );
   try
     {
       struct __ptr_guard
       {
  _CharT * __p;
  __ptr_guard ( _CharT * __ip ) : __p ( __ip ) { }
  ~ __ptr_guard ( ) { delete [ ] __p; }
  _CharT * __get ( ) { return __p; }
       } __pg ( new _CharT [ __clen ] );
       _CharT * __ws = __pg . __get ( );
       for ( size_t __i = 0; __i < __clen; ++ __i )
  __ws [ __i ] = __out . widen ( __s [ __i ] );
       __ostream_insert ( __out, __ws, __clen );
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       __out . _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { __out . _M_setstate ( ios_base :: badbit ); }
 }
      return __out;
    }
extern template class basic_ostream< char  , char_traits< char  >  > ;
extern template class basic_ostream< char  , char_traits< char  >  > &endl(class basic_ostream< char  , char_traits< char  >  > &__os);
extern template class basic_ostream< char  , char_traits< char  >  > &ends(class basic_ostream< char  , char_traits< char  >  > &__os);
extern template class basic_ostream< char  , char_traits< char  >  > &flush(class basic_ostream< char  , char_traits< char  >  > &__os);
extern template class basic_ostream< char  , char_traits< char  >  > &operator<<(class basic_ostream< char  , char_traits< char  >  > &__out,char __c);
extern template class basic_ostream< char  , char_traits< char  >  > &operator<<(class basic_ostream< char  , char_traits< char  >  > &__out,unsigned char __c);
extern template class basic_ostream< char  , char_traits< char  >  > &operator<<(class basic_ostream< char  , char_traits< char  >  > &__out,signed char __c);
extern template class basic_ostream< char  , char_traits< char  >  > &operator<<(class basic_ostream< char  , char_traits< char  >  > &__out,const char *__s);
extern template class basic_ostream< char  , char_traits< char  >  > &operator<<(class basic_ostream< char  , char_traits< char  >  > &__out,const unsigned char *__s);
extern template class basic_ostream< char  , char_traits< char  >  > &operator<<(class basic_ostream< char  , char_traits< char  >  > &__out,const signed char *__s);
extern template basic_ostream< char ,char_traits< char  > > ::__ostream_type &basic_ostream< char ,char_traits< char  > > ::_M_insert(long __v);
extern template basic_ostream< char ,char_traits< char  > > ::__ostream_type &basic_ostream< char ,char_traits< char  > > ::_M_insert(unsigned long __v);
extern template basic_ostream< char ,char_traits< char  > > ::__ostream_type &basic_ostream< char ,char_traits< char  > > ::_M_insert(bool __v);
extern template basic_ostream< char ,char_traits< char  > > ::__ostream_type &basic_ostream< char ,char_traits< char  > > ::_M_insert(long long __v);
extern template basic_ostream< char ,char_traits< char  > > ::__ostream_type &basic_ostream< char ,char_traits< char  > > ::_M_insert(unsigned long long __v);
extern template basic_ostream< char ,char_traits< char  > > ::__ostream_type &basic_ostream< char ,char_traits< char  > > ::_M_insert(double __v);
extern template basic_ostream< char ,char_traits< char  > > ::__ostream_type &basic_ostream< char ,char_traits< char  > > ::_M_insert(long double __v);
extern template basic_ostream< char ,char_traits< char  > > ::__ostream_type &basic_ostream< char ,char_traits< char  > > ::_M_insert(const void *__v);
extern template class basic_ostream< wchar_t  , char_traits< wchar_t  >  > ;
extern template class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &endl(class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &__os);
extern template class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &ends(class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &__os);
extern template class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &flush(class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &__os);
extern template class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &operator<<(class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &__out,wchar_t __c);
extern template class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &operator<<(class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &__out,char __c);
extern template class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &operator<<(class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &__out,const wchar_t *__s);
extern template class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &operator<<(class basic_ostream< wchar_t  , char_traits< wchar_t  >  > &__out,const char *__s);
extern template basic_ostream< wchar_t ,char_traits< wchar_t  > > ::__ostream_type &basic_ostream< wchar_t ,char_traits< wchar_t  > > ::_M_insert(long __v);
extern template basic_ostream< wchar_t ,char_traits< wchar_t  > > ::__ostream_type &basic_ostream< wchar_t ,char_traits< wchar_t  > > ::_M_insert(unsigned long __v);
extern template basic_ostream< wchar_t ,char_traits< wchar_t  > > ::__ostream_type &basic_ostream< wchar_t ,char_traits< wchar_t  > > ::_M_insert(bool __v);
extern template basic_ostream< wchar_t ,char_traits< wchar_t  > > ::__ostream_type &basic_ostream< wchar_t ,char_traits< wchar_t  > > ::_M_insert(long long __v);
extern template basic_ostream< wchar_t ,char_traits< wchar_t  > > ::__ostream_type &basic_ostream< wchar_t ,char_traits< wchar_t  > > ::_M_insert(unsigned long long __v);
extern template basic_ostream< wchar_t ,char_traits< wchar_t  > > ::__ostream_type &basic_ostream< wchar_t ,char_traits< wchar_t  > > ::_M_insert(double __v);
extern template basic_ostream< wchar_t ,char_traits< wchar_t  > > ::__ostream_type &basic_ostream< wchar_t ,char_traits< wchar_t  > > ::_M_insert(long double __v);
extern template basic_ostream< wchar_t ,char_traits< wchar_t  > > ::__ostream_type &basic_ostream< wchar_t ,char_traits< wchar_t  > > ::_M_insert(const void *__v);
}
namespace std
{
template < typename _CharT, typename _Traits >
    class basic_istream : virtual public basic_ios < _CharT, _Traits >
    {
    public :
      typedef _CharT char_type;
      typedef typename _Traits :: int_type int_type;
      typedef typename _Traits :: pos_type pos_type;
      typedef typename _Traits :: off_type off_type;
      typedef _Traits traits_type;
      typedef basic_streambuf < _CharT, _Traits > __streambuf_type;
      typedef basic_ios < _CharT, _Traits > __ios_type;
      typedef basic_istream < _CharT, _Traits > __istream_type;
      typedef num_get < _CharT, istreambuf_iterator < _CharT, _Traits > >
        __num_get_type;
      typedef ctype < _CharT > __ctype_type;
    protected :
      streamsize _M_gcount;
    public :
      explicit
      basic_istream ( __streambuf_type * __sb )
      ;
      virtual
      ~ basic_istream ( )
      ;
      class sentry;
      friend class sentry;
      __istream_type &
      operator >> ( __istream_type & ( * __pf ) ( __istream_type & ) )
      ;
      __istream_type &
      operator >> ( __ios_type & ( * __pf ) ( __ios_type & ) )
      ;
      __istream_type &
      operator >> ( ios_base & ( * __pf ) ( ios_base & ) )
      ;
      __istream_type &
      operator >> ( bool & __n )
      ;
      __istream_type &
      operator >> ( short & __n );
      __istream_type &
      operator >> ( unsigned short & __n )
      ;
      __istream_type &
      operator >> ( int & __n );
      __istream_type &
      operator >> ( unsigned int & __n )
      ;
      __istream_type &
      operator >> ( long & __n )
      ;
      __istream_type &
      operator >> ( unsigned long & __n )
      ;
      __istream_type &
      operator >> ( long long & __n )
      ;
      __istream_type &
      operator >> ( unsigned long long & __n )
      ;
      __istream_type &
      operator >> ( float & __f )
      ;
      __istream_type &
      operator >> ( double & __f )
      ;
      __istream_type &
      operator >> ( long double & __f )
      ;
      __istream_type &
      operator >> ( void * & __p )
      ;
      __istream_type &
      operator >> ( __streambuf_type * __sb );
      streamsize
      gcount ( ) const
      ;
      int_type
      get ( );
      __istream_type &
      get ( char_type & __c );
      __istream_type &
      get ( char_type * __s, streamsize __n, char_type __delim );
      __istream_type &
      get ( char_type * __s, streamsize __n )
      ;
      __istream_type &
      get ( __streambuf_type & __sb, char_type __delim );
      __istream_type &
      get ( __streambuf_type & __sb )
      ;
      __istream_type &
      getline ( char_type * __s, streamsize __n, char_type __delim );
      __istream_type &
      getline ( char_type * __s, streamsize __n )
      ;
      __istream_type &
      ignore ( streamsize __n, int_type __delim );
      __istream_type &
      ignore ( streamsize __n );
      __istream_type &
      ignore ( );
      int_type
      peek ( );
      __istream_type &
      read ( char_type * __s, streamsize __n );
      streamsize
      readsome ( char_type * __s, streamsize __n );
      __istream_type &
      putback ( char_type __c );
      __istream_type &
      unget ( );
      int
      sync ( );
      pos_type
      tellg ( );
      __istream_type &
      seekg ( pos_type );
      __istream_type &
      seekg ( off_type, ios_base :: seekdir );
    protected :
      basic_istream ( )
      ;
      basic_istream ( const basic_istream & ) = delete;
      basic_istream ( basic_istream && __rhs )
      ;
      basic_istream & operator = ( const basic_istream & ) = delete;
      basic_istream &
      operator = ( basic_istream && __rhs )
      ;
      void
      swap ( basic_istream & __rhs )
      ;
      template < typename _ValueT >
 __istream_type &
 _M_extract ( _ValueT & __v );
    };
template<> basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::getline(char_type *__s,streamsize __n,char_type __delim);
template<> basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::ignore(streamsize __n);
template<> basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::ignore(streamsize __n,int_type __delim);
template<> basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::getline(char_type *__s,streamsize __n,char_type __delim);
template<> basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::ignore(streamsize __n);
template<> basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::ignore(streamsize __n,int_type __delim);
template < typename _CharT, typename _Traits >
    class basic_istream < _CharT, _Traits > :: sentry
    {
      bool _M_ok;
    public :
      typedef _Traits traits_type;
      typedef basic_streambuf < _CharT, _Traits > __streambuf_type;
      typedef basic_istream < _CharT, _Traits > __istream_type;
      typedef typename __istream_type :: __ctype_type __ctype_type;
      typedef typename _Traits :: int_type __int_type;
      explicit
      sentry ( basic_istream < _CharT, _Traits > & __is, bool __noskipws = false );
      explicit
      operator bool ( ) const
      ;
    };
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    operator >> ( basic_istream < _CharT, _Traits > & __in, _CharT & __c );
template < class _Traits >
    inline basic_istream < char, _Traits > &
    operator >> ( basic_istream < char, _Traits > & __in, unsigned char & __c )
    { return ( __in >> reinterpret_cast < char & > ( __c ) ); }
template < class _Traits >
    inline basic_istream < char, _Traits > &
    operator >> ( basic_istream < char, _Traits > & __in, signed char & __c )
    { return ( __in >> reinterpret_cast < char & > ( __c ) ); }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    operator >> ( basic_istream < _CharT, _Traits > & __in, _CharT * __s );
template<> class basic_istream< char  , char_traits< char  >  > &operator>>(class basic_istream< char  , char_traits< char  >  > &__in,char *__s);
template < class _Traits >
    inline basic_istream < char, _Traits > &
    operator >> ( basic_istream < char, _Traits > & __in, unsigned char * __s )
    { return ( __in >> reinterpret_cast < char * > ( __s ) ); }
template < class _Traits >
    inline basic_istream < char, _Traits > &
    operator >> ( basic_istream < char, _Traits > & __in, signed char * __s )
    { return ( __in >> reinterpret_cast < char * > ( __s ) ); }
template < typename _CharT, typename _Traits >
    class basic_iostream
    : public basic_istream < _CharT, _Traits >,
      public basic_ostream < _CharT, _Traits >
    {
    public :
      typedef _CharT char_type;
      typedef typename _Traits :: int_type int_type;
      typedef typename _Traits :: pos_type pos_type;
      typedef typename _Traits :: off_type off_type;
      typedef _Traits traits_type;
      typedef basic_istream < _CharT, _Traits > __istream_type;
      typedef basic_ostream < _CharT, _Traits > __ostream_type;
      explicit
      basic_iostream ( basic_streambuf < _CharT, _Traits > * __sb )
      ;
      virtual
      ~ basic_iostream ( );
    protected :
      basic_iostream ( )
      ;
      basic_iostream ( const basic_iostream & ) = delete;
      basic_iostream ( basic_iostream && __rhs )
      ;
      basic_iostream & operator = ( const basic_iostream & ) = delete;
      basic_iostream &
      operator = ( basic_iostream && __rhs )
      ;
      void
      swap ( basic_iostream & __rhs )
      ;
    };
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    ws ( basic_istream < _CharT, _Traits > & __is );
template < typename _CharT, typename _Traits, typename _Tp >
    inline basic_istream < _CharT, _Traits > &
    operator >> ( basic_istream < _CharT, _Traits > && __is, _Tp & __x )
    {
      __is >> __x;
      return __is;
    }
}
namespace std
{
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > :: sentry ::
    sentry ( basic_istream < _CharT, _Traits > & __in, bool __noskip ) : _M_ok ( false )
    {
      ios_base :: iostate __err = ios_base :: goodbit;
      if ( __in . good ( ) )
 {
   if ( __in . tie ( ) )
     __in . tie ( ) -> flush ( );
   if ( ! __noskip && bool ( __in . flags ( ) & ios_base :: skipws ) )
     {
       const __int_type __eof = traits_type :: eof ( );
       __streambuf_type * __sb = __in . rdbuf ( );
       __int_type __c = __sb -> sgetc ( );
       const __ctype_type & __ct = __check_facet ( __in . _M_ctype );
       while ( ! traits_type :: eq_int_type ( __c, __eof )
       && __ct . is ( ctype_base :: space,
    traits_type :: to_char_type ( __c ) ) )
  __c = __sb -> snextc ( );
       if ( traits_type :: eq_int_type ( __c, __eof ) )
  __err |= ios_base :: eofbit;
     }
 }
      if ( __in . good ( ) && __err == ios_base :: goodbit )
 _M_ok = true;
      else
 {
   __err |= ios_base :: failbit;
   __in . setstate ( __err );
 }
    }
template < typename _CharT, typename _Traits >
    template < typename _ValueT >
      basic_istream < _CharT, _Traits > &
      basic_istream < _CharT, _Traits > ::
      _M_extract ( _ValueT & __v )
      {
 sentry __cerb ( * this, false );
 if ( __cerb )
   {
     ios_base :: iostate __err = ios_base :: goodbit;
     try
       {
  const __num_get_type & __ng = __check_facet ( this -> _M_num_get );
  __ng . get ( * this, 0, * this, __err, __v );
       }
     catch ( __cxxabiv1 :: __forced_unwind & )
       {
  this -> _M_setstate ( ios_base :: badbit );
  throw;
       }
     catch ( ... )
       { this -> _M_setstate ( ios_base :: badbit ); }
     if ( __err )
       this -> setstate ( __err );
   }
 return * this;
      }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    operator >> ( short & __n )
    {
      sentry __cerb ( * this, false );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       long __l;
       const __num_get_type & __ng = __check_facet ( this -> _M_num_get );
       __ng . get ( * this, 0, * this, __err, __l );
       if ( __l < __gnu_cxx :: __numeric_traits < short > :: __min )
  {
    __err |= ios_base :: failbit;
    __n = __gnu_cxx :: __numeric_traits < short > :: __min;
  }
       else if ( __l > __gnu_cxx :: __numeric_traits < short > :: __max )
  {
    __err |= ios_base :: failbit;
    __n = __gnu_cxx :: __numeric_traits < short > :: __max;
  }
       else
  __n = short ( __l );
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    operator >> ( int & __n )
    {
      sentry __cerb ( * this, false );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       long __l;
       const __num_get_type & __ng = __check_facet ( this -> _M_num_get );
       __ng . get ( * this, 0, * this, __err, __l );
       if ( __l < __gnu_cxx :: __numeric_traits < int > :: __min )
  {
    __err |= ios_base :: failbit;
    __n = __gnu_cxx :: __numeric_traits < int > :: __min;
  }
       else if ( __l > __gnu_cxx :: __numeric_traits < int > :: __max )
  {
    __err |= ios_base :: failbit;
    __n = __gnu_cxx :: __numeric_traits < int > :: __max;
  }
       else
  __n = int ( __l );
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    operator >> ( __streambuf_type * __sbout )
    {
      ios_base :: iostate __err = ios_base :: goodbit;
      sentry __cerb ( * this, false );
      if ( __cerb && __sbout )
 {
   try
     {
       bool __ineof;
       if ( ! __copy_streambufs_eof ( this -> rdbuf ( ), __sbout, __ineof ) )
  __err |= ios_base :: failbit;
       if ( __ineof )
  __err |= ios_base :: eofbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: failbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: failbit ); }
 }
      else if ( ! __sbout )
 __err |= ios_base :: failbit;
      if ( __err )
 this -> setstate ( __err );
      return * this;
    }
template < typename _CharT, typename _Traits >
    typename basic_istream < _CharT, _Traits > :: int_type
    basic_istream < _CharT, _Traits > ::
    get ( void )
    {
      const int_type __eof = traits_type :: eof ( );
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base :: iostate __err = ios_base :: goodbit;
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   try
     {
       __c = this -> rdbuf ( ) -> sbumpc ( );
       if ( ! traits_type :: eq_int_type ( __c, __eof ) )
  _M_gcount = 1;
       else
  __err |= ios_base :: eofbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
 }
      if ( ! _M_gcount )
 __err |= ios_base :: failbit;
      if ( __err )
 this -> setstate ( __err );
      return __c;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    get ( char_type & __c )
    {
      _M_gcount = 0;
      ios_base :: iostate __err = ios_base :: goodbit;
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   try
     {
       const int_type __cb = this -> rdbuf ( ) -> sbumpc ( );
       if ( ! traits_type :: eq_int_type ( __cb, traits_type :: eof ( ) ) )
  {
    _M_gcount = 1;
    __c = traits_type :: to_char_type ( __cb );
  }
       else
  __err |= ios_base :: eofbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
 }
      if ( ! _M_gcount )
 __err |= ios_base :: failbit;
      if ( __err )
 this -> setstate ( __err );
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    get ( char_type * __s, streamsize __n, char_type __delim )
    {
      _M_gcount = 0;
      ios_base :: iostate __err = ios_base :: goodbit;
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   try
     {
       const int_type __idelim = traits_type :: to_int_type ( __delim );
       const int_type __eof = traits_type :: eof ( );
       __streambuf_type * __sb = this -> rdbuf ( );
       int_type __c = __sb -> sgetc ( );
       while ( _M_gcount + 1 < __n
       && ! traits_type :: eq_int_type ( __c, __eof )
       && ! traits_type :: eq_int_type ( __c, __idelim ) )
  {
    * __s ++ = traits_type :: to_char_type ( __c );
    ++ _M_gcount;
    __c = __sb -> snextc ( );
  }
       if ( traits_type :: eq_int_type ( __c, __eof ) )
  __err |= ios_base :: eofbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
 }
      if ( __n > 0 )
 * __s = char_type ( );
      if ( ! _M_gcount )
 __err |= ios_base :: failbit;
      if ( __err )
 this -> setstate ( __err );
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    get ( __streambuf_type & __sb, char_type __delim )
    {
      _M_gcount = 0;
      ios_base :: iostate __err = ios_base :: goodbit;
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   try
     {
       const int_type __idelim = traits_type :: to_int_type ( __delim );
       const int_type __eof = traits_type :: eof ( );
       __streambuf_type * __this_sb = this -> rdbuf ( );
       int_type __c = __this_sb -> sgetc ( );
       char_type __c2 = traits_type :: to_char_type ( __c );
       while ( ! traits_type :: eq_int_type ( __c, __eof )
       && ! traits_type :: eq_int_type ( __c, __idelim )
       && ! traits_type :: eq_int_type ( __sb . sputc ( __c2 ), __eof ) )
  {
    ++ _M_gcount;
    __c = __this_sb -> snextc ( );
    __c2 = traits_type :: to_char_type ( __c );
  }
       if ( traits_type :: eq_int_type ( __c, __eof ) )
  __err |= ios_base :: eofbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
 }
      if ( ! _M_gcount )
 __err |= ios_base :: failbit;
      if ( __err )
 this -> setstate ( __err );
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    getline ( char_type * __s, streamsize __n, char_type __delim )
    {
      _M_gcount = 0;
      ios_base :: iostate __err = ios_base :: goodbit;
      sentry __cerb ( * this, true );
      if ( __cerb )
        {
          try
            {
              const int_type __idelim = traits_type :: to_int_type ( __delim );
              const int_type __eof = traits_type :: eof ( );
              __streambuf_type * __sb = this -> rdbuf ( );
              int_type __c = __sb -> sgetc ( );
              while ( _M_gcount + 1 < __n
                     && ! traits_type :: eq_int_type ( __c, __eof )
                     && ! traits_type :: eq_int_type ( __c, __idelim ) )
                {
                  * __s ++ = traits_type :: to_char_type ( __c );
                  __c = __sb -> snextc ( );
                  ++ _M_gcount;
                }
              if ( traits_type :: eq_int_type ( __c, __eof ) )
                __err |= ios_base :: eofbit;
              else
                {
                  if ( traits_type :: eq_int_type ( __c, __idelim ) )
                    {
                      __sb -> sbumpc ( );
                      ++ _M_gcount;
                    }
                  else
                    __err |= ios_base :: failbit;
                }
            }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
          catch ( ... )
            { this -> _M_setstate ( ios_base :: badbit ); }
        }
      if ( __n > 0 )
 * __s = char_type ( );
      if ( ! _M_gcount )
        __err |= ios_base :: failbit;
      if ( __err )
        this -> setstate ( __err );
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    ignore ( void )
    {
      _M_gcount = 0;
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       const int_type __eof = traits_type :: eof ( );
       __streambuf_type * __sb = this -> rdbuf ( );
       if ( traits_type :: eq_int_type ( __sb -> sbumpc ( ), __eof ) )
  __err |= ios_base :: eofbit;
       else
  _M_gcount = 1;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    ignore ( streamsize __n )
    {
      _M_gcount = 0;
      sentry __cerb ( * this, true );
      if ( __cerb && __n > 0 )
        {
          ios_base :: iostate __err = ios_base :: goodbit;
          try
            {
              const int_type __eof = traits_type :: eof ( );
              __streambuf_type * __sb = this -> rdbuf ( );
              int_type __c = __sb -> sgetc ( );
       bool __large_ignore = false;
       while ( true )
  {
    while ( _M_gcount < __n
    && ! traits_type :: eq_int_type ( __c, __eof ) )
      {
        ++ _M_gcount;
        __c = __sb -> snextc ( );
      }
    if ( __n == __gnu_cxx :: __numeric_traits < streamsize > :: __max
        && ! traits_type :: eq_int_type ( __c, __eof ) )
      {
        _M_gcount =
   __gnu_cxx :: __numeric_traits < streamsize > :: __min;
        __large_ignore = true;
      }
    else
      break;
  }
       if ( __large_ignore )
  _M_gcount = __gnu_cxx :: __numeric_traits < streamsize > :: __max;
       if ( traits_type :: eq_int_type ( __c, __eof ) )
                __err |= ios_base :: eofbit;
            }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
          catch ( ... )
            { this -> _M_setstate ( ios_base :: badbit ); }
          if ( __err )
            this -> setstate ( __err );
        }
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    ignore ( streamsize __n, int_type __delim )
    {
      _M_gcount = 0;
      sentry __cerb ( * this, true );
      if ( __cerb && __n > 0 )
        {
          ios_base :: iostate __err = ios_base :: goodbit;
          try
            {
              const int_type __eof = traits_type :: eof ( );
              __streambuf_type * __sb = this -> rdbuf ( );
              int_type __c = __sb -> sgetc ( );
       bool __large_ignore = false;
       while ( true )
  {
    while ( _M_gcount < __n
    && ! traits_type :: eq_int_type ( __c, __eof )
    && ! traits_type :: eq_int_type ( __c, __delim ) )
      {
        ++ _M_gcount;
        __c = __sb -> snextc ( );
      }
    if ( __n == __gnu_cxx :: __numeric_traits < streamsize > :: __max
        && ! traits_type :: eq_int_type ( __c, __eof )
        && ! traits_type :: eq_int_type ( __c, __delim ) )
      {
        _M_gcount =
   __gnu_cxx :: __numeric_traits < streamsize > :: __min;
        __large_ignore = true;
      }
    else
      break;
  }
       if ( __large_ignore )
  _M_gcount = __gnu_cxx :: __numeric_traits < streamsize > :: __max;
              if ( traits_type :: eq_int_type ( __c, __eof ) )
                __err |= ios_base :: eofbit;
       else if ( traits_type :: eq_int_type ( __c, __delim ) )
  {
    if ( _M_gcount
        < __gnu_cxx :: __numeric_traits < streamsize > :: __max )
      ++ _M_gcount;
    __sb -> sbumpc ( );
  }
            }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
          catch ( ... )
            { this -> _M_setstate ( ios_base :: badbit ); }
          if ( __err )
            this -> setstate ( __err );
        }
      return * this;
    }
template < typename _CharT, typename _Traits >
    typename basic_istream < _CharT, _Traits > :: int_type
    basic_istream < _CharT, _Traits > ::
    peek ( void )
    {
      int_type __c = traits_type :: eof ( );
      _M_gcount = 0;
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       __c = this -> rdbuf ( ) -> sgetc ( );
       if ( traits_type :: eq_int_type ( __c, traits_type :: eof ( ) ) )
  __err |= ios_base :: eofbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return __c;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    read ( char_type * __s, streamsize __n )
    {
      _M_gcount = 0;
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       _M_gcount = this -> rdbuf ( ) -> sgetn ( __s, __n );
       if ( _M_gcount != __n )
  __err |= ( ios_base :: eofbit | ios_base :: failbit );
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return * this;
    }
template < typename _CharT, typename _Traits >
    streamsize
    basic_istream < _CharT, _Traits > ::
    readsome ( char_type * __s, streamsize __n )
    {
      _M_gcount = 0;
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       const streamsize __num = this -> rdbuf ( ) -> in_avail ( );
       if ( __num > 0 )
  _M_gcount = this -> rdbuf ( ) -> sgetn ( __s, std :: min ( __num, __n ) );
       else if ( __num == - 1 )
  __err |= ios_base :: eofbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return _M_gcount;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    putback ( char_type __c )
    {
      _M_gcount = 0;
      this -> clear ( this -> rdstate ( ) & ~ ios_base :: eofbit );
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       const int_type __eof = traits_type :: eof ( );
       __streambuf_type * __sb = this -> rdbuf ( );
       if ( ! __sb
    || traits_type :: eq_int_type ( __sb -> sputbackc ( __c ), __eof ) )
  __err |= ios_base :: badbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    unget ( void )
    {
      _M_gcount = 0;
      this -> clear ( this -> rdstate ( ) & ~ ios_base :: eofbit );
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       const int_type __eof = traits_type :: eof ( );
       __streambuf_type * __sb = this -> rdbuf ( );
       if ( ! __sb
    || traits_type :: eq_int_type ( __sb -> sungetc ( ), __eof ) )
  __err |= ios_base :: badbit;
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return * this;
    }
template < typename _CharT, typename _Traits >
    int
    basic_istream < _CharT, _Traits > ::
    sync ( void )
    {
      int __ret = - 1;
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       __streambuf_type * __sb = this -> rdbuf ( );
       if ( __sb )
  {
    if ( __sb -> pubsync ( ) == - 1 )
      __err |= ios_base :: badbit;
    else
      __ret = 0;
  }
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return __ret;
    }
template < typename _CharT, typename _Traits >
    typename basic_istream < _CharT, _Traits > :: pos_type
    basic_istream < _CharT, _Traits > ::
    tellg ( void )
    {
      pos_type __ret = pos_type ( - 1 );
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   try
     {
       if ( ! this -> fail ( ) )
  __ret = this -> rdbuf ( ) -> pubseekoff ( 0, ios_base :: cur,
        ios_base :: in );
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
 }
      return __ret;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    seekg ( pos_type __pos )
    {
      this -> clear ( this -> rdstate ( ) & ~ ios_base :: eofbit );
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       if ( ! this -> fail ( ) )
  {
    const pos_type __p = this -> rdbuf ( ) -> pubseekpos ( __pos,
         ios_base :: in );
    if ( __p == pos_type ( off_type ( - 1 ) ) )
      __err |= ios_base :: failbit;
  }
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    basic_istream < _CharT, _Traits > ::
    seekg ( off_type __off, ios_base :: seekdir __dir )
    {
      this -> clear ( this -> rdstate ( ) & ~ ios_base :: eofbit );
      sentry __cerb ( * this, true );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       if ( ! this -> fail ( ) )
  {
    const pos_type __p = this -> rdbuf ( ) -> pubseekoff ( __off, __dir,
         ios_base :: in );
    if ( __p == pos_type ( off_type ( - 1 ) ) )
      __err |= ios_base :: failbit;
  }
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       this -> _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { this -> _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     this -> setstate ( __err );
 }
      return * this;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    operator >> ( basic_istream < _CharT, _Traits > & __in, _CharT & __c )
    {
      typedef basic_istream < _CharT, _Traits > __istream_type;
      typedef typename __istream_type :: int_type __int_type;
      typename __istream_type :: sentry __cerb ( __in, false );
      if ( __cerb )
 {
   ios_base :: iostate __err = ios_base :: goodbit;
   try
     {
       const __int_type __cb = __in . rdbuf ( ) -> sbumpc ( );
       if ( ! _Traits :: eq_int_type ( __cb, _Traits :: eof ( ) ) )
  __c = _Traits :: to_char_type ( __cb );
       else
  __err |= ( ios_base :: eofbit | ios_base :: failbit );
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       __in . _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { __in . _M_setstate ( ios_base :: badbit ); }
   if ( __err )
     __in . setstate ( __err );
 }
      return __in;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    operator >> ( basic_istream < _CharT, _Traits > & __in, _CharT * __s )
    {
      typedef basic_istream < _CharT, _Traits > __istream_type;
      typedef basic_streambuf < _CharT, _Traits > __streambuf_type;
      typedef typename _Traits :: int_type int_type;
      typedef _CharT char_type;
      typedef ctype < _CharT > __ctype_type;
      streamsize __extracted = 0;
      ios_base :: iostate __err = ios_base :: goodbit;
      typename __istream_type :: sentry __cerb ( __in, false );
      if ( __cerb )
 {
   try
     {
       streamsize __num = __in . width ( );
       if ( __num <= 0 )
  __num = __gnu_cxx :: __numeric_traits < streamsize > :: __max;
       const __ctype_type & __ct = use_facet < __ctype_type > ( __in . getloc ( ) );
       const int_type __eof = _Traits :: eof ( );
       __streambuf_type * __sb = __in . rdbuf ( );
       int_type __c = __sb -> sgetc ( );
       while ( __extracted < __num - 1
       && ! _Traits :: eq_int_type ( __c, __eof )
       && ! __ct . is ( ctype_base :: space,
     _Traits :: to_char_type ( __c ) ) )
  {
    * __s ++ = _Traits :: to_char_type ( __c );
    ++ __extracted;
    __c = __sb -> snextc ( );
  }
       if ( _Traits :: eq_int_type ( __c, __eof ) )
  __err |= ios_base :: eofbit;
       * __s = char_type ( );
       __in . width ( 0 );
     }
   catch ( __cxxabiv1 :: __forced_unwind & )
     {
       __in . _M_setstate ( ios_base :: badbit );
       throw;
     }
   catch ( ... )
     { __in . _M_setstate ( ios_base :: badbit ); }
 }
      if ( ! __extracted )
 __err |= ios_base :: failbit;
      if ( __err )
 __in . setstate ( __err );
      return __in;
    }
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    ws ( basic_istream < _CharT, _Traits > & __in )
    {
      typedef basic_istream < _CharT, _Traits > __istream_type;
      typedef basic_streambuf < _CharT, _Traits > __streambuf_type;
      typedef typename __istream_type :: int_type __int_type;
      typedef ctype < _CharT > __ctype_type;
      const __ctype_type & __ct = use_facet < __ctype_type > ( __in . getloc ( ) );
      const __int_type __eof = _Traits :: eof ( );
      __streambuf_type * __sb = __in . rdbuf ( );
      __int_type __c = __sb -> sgetc ( );
      while ( ! _Traits :: eq_int_type ( __c, __eof )
      && __ct . is ( ctype_base :: space, _Traits :: to_char_type ( __c ) ) )
 __c = __sb -> snextc ( );
       if ( _Traits :: eq_int_type ( __c, __eof ) )
  __in . setstate ( ios_base :: eofbit );
      return __in;
    }
extern template class basic_istream< char  , char_traits< char  >  > ;
extern template class basic_istream< char  , char_traits< char  >  > &ws(class basic_istream< char  , char_traits< char  >  > &__is);
extern template class basic_istream< char  , char_traits< char  >  > &operator>>(class basic_istream< char  , char_traits< char  >  > &__in,char &__c);
extern template class basic_istream< char  , char_traits< char  >  > &operator>>(class basic_istream< char  , char_traits< char  >  > &,char *);
extern template class basic_istream< char  , char_traits< char  >  > &operator>>(class basic_istream< char  , char_traits< char  >  > &__in,unsigned char &__c);
extern template class basic_istream< char  , char_traits< char  >  > &operator>>(class basic_istream< char  , char_traits< char  >  > &__in,signed char &__c);
extern template class basic_istream< char  , char_traits< char  >  > &operator>>(class basic_istream< char  , char_traits< char  >  > &__in,unsigned char *__s);
extern template class basic_istream< char  , char_traits< char  >  > &operator>>(class basic_istream< char  , char_traits< char  >  > &__in,signed char *__s);
extern template basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::_M_extract(unsigned short &__v);
extern template basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::_M_extract(unsigned int &__v);
extern template basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::_M_extract(long &__v);
extern template basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::_M_extract(unsigned long &__v);
extern template basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::_M_extract(bool &__v);
extern template basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::_M_extract(long long &__v);
extern template basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::_M_extract(unsigned long long &__v);
extern template basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::_M_extract(float &__v);
extern template basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::_M_extract(double &__v);
extern template basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::_M_extract(long double &__v);
extern template basic_istream< char ,char_traits< char  > > ::__istream_type &basic_istream< char ,char_traits< char  > > ::_M_extract(void *&__v);
extern template class basic_iostream< char  , char_traits< char  >  > ;
extern template class basic_istream< wchar_t  , char_traits< wchar_t  >  > ;
extern template class basic_istream< wchar_t  , char_traits< wchar_t  >  > &ws(class basic_istream< wchar_t  , char_traits< wchar_t  >  > &__is);
extern template class basic_istream< wchar_t  , char_traits< wchar_t  >  > &operator>>(class basic_istream< wchar_t  , char_traits< wchar_t  >  > &__in,wchar_t &__c);
extern template class basic_istream< wchar_t  , char_traits< wchar_t  >  > &operator>>(class basic_istream< wchar_t  , char_traits< wchar_t  >  > &,wchar_t *);
extern template basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::_M_extract(unsigned short &__v);
extern template basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::_M_extract(unsigned int &__v);
extern template basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::_M_extract(long &__v);
extern template basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::_M_extract(unsigned long &__v);
extern template basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::_M_extract(bool &__v);
extern template basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::_M_extract(long long &__v);
extern template basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::_M_extract(unsigned long long &__v);
extern template basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::_M_extract(float &__v);
extern template basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::_M_extract(double &__v);
extern template basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::_M_extract(long double &__v);
extern template basic_istream< wchar_t ,char_traits< wchar_t  > > ::__istream_type &basic_istream< wchar_t ,char_traits< wchar_t  > > ::_M_extract(void *&__v);
extern template class basic_iostream< wchar_t  , char_traits< wchar_t  >  > ;
}
namespace std
{
extern istream cin;
extern ostream cout;
extern ostream cerr;
extern ostream clog;
extern wistream wcin;
extern wostream wcout;
extern wostream wcerr;
extern wostream wclog;
static class ios_base::Init __ioinit;
}
namespace RAJA
{
const int RANGE_ALIGN = 4;
const int RANGE_MIN_LENGTH = 32;
const int DATA_ALIGN = 64;
template < typename T >
inline __attribute__ ( ( always_inline ) )
T * align_hint ( T * x )
{
  return static_cast < T * > ( __builtin_assume_aligned ( x, RAJA :: DATA_ALIGN ) );
}
}
namespace std
{
template < typename _Tp, typename _CharT = char,
           typename _Traits = char_traits < _CharT >, typename _Dist = ptrdiff_t >
    class istream_iterator
    : public iterator < input_iterator_tag, _Tp, _Dist, const _Tp *, const _Tp & >
    {
    public :
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream < _CharT, _Traits > istream_type;
    private :
      istream_type * _M_stream;
      _Tp _M_value;
      bool _M_ok;
    public :
      constexpr istream_iterator ( )
      ;
      istream_iterator ( istream_type & __s )
      ;
      istream_iterator ( const istream_iterator & __obj )
      ;
      const _Tp &
      operator * ( ) const
      ;
      const _Tp *
      operator -> ( ) const;
      istream_iterator &
      operator ++ ( )
      ;
      istream_iterator
      operator ++ ( int )
      ;
      bool
      _M_equal ( const istream_iterator & __x ) const
      ;
    private :
      void
      _M_read ( )
      ;
    };
template < typename _Tp, typename _CharT, typename _Traits, typename _Dist >
    inline bool
    operator == ( const istream_iterator < _Tp, _CharT, _Traits, _Dist > & __x,
        const istream_iterator < _Tp, _CharT, _Traits, _Dist > & __y )
    { return __x . _M_equal ( __y ); }
template < class _Tp, class _CharT, class _Traits, class _Dist >
    inline bool
    operator != ( const istream_iterator < _Tp, _CharT, _Traits, _Dist > & __x,
        const istream_iterator < _Tp, _CharT, _Traits, _Dist > & __y )
    { return ! __x . _M_equal ( __y ); }
template < typename _Tp, typename _CharT = char,
           typename _Traits = char_traits < _CharT > >
    class ostream_iterator
    : public iterator < output_iterator_tag, void, void, void, void >
    {
    public :
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream < _CharT, _Traits > ostream_type;
    private :
      ostream_type * _M_stream;
      const _CharT * _M_string;
    public :
      ostream_iterator ( ostream_type & __s );
      ostream_iterator ( ostream_type & __s, const _CharT * __c )
      ;
      ostream_iterator ( const ostream_iterator & __obj )
      ;
      ostream_iterator &
      operator = ( const _Tp & __value )
      ;
      ostream_iterator &
      operator * ( )
      ;
      ostream_iterator &
      operator ++ ( )
      ;
      ostream_iterator &
      operator ++ ( int )
      ;
    };
}
typedef long ptrdiff_t;
typedef struct {
long long __max_align_ll __attribute__((aligned(8)));
long double __max_align_ld __attribute__((aligned(16)));}max_align_t;
typedef decltype(nullptr) nullptr_t;
namespace std
{
using ::max_align_t;
}
namespace std
{
namespace rel_ops
{
template < class _Tp >
      inline bool
      operator != ( const _Tp & __x, const _Tp & __y )
      { return ! ( __x == __y ); }
template < class _Tp >
      inline bool
      operator > ( const _Tp & __x, const _Tp & __y )
      { return __y < __x; }
template < class _Tp >
      inline bool
      operator <= ( const _Tp & __x, const _Tp & __y )
      { return ! ( __y < __x ); }
template < class _Tp >
      inline bool
      operator >= ( const _Tp & __x, const _Tp & __y )
      { return ! ( __x < __y ); }
}
}
namespace std
{
template < typename _Tp >
    struct tuple_size;
template < typename _Tp >
    struct tuple_size < const _Tp >
    : integral_constant < size_t, tuple_size < _Tp > :: value > { };
template < typename _Tp >
    struct tuple_size < volatile _Tp >
    : integral_constant < size_t, tuple_size < _Tp > :: value > { };
template < typename _Tp >
    struct tuple_size < const volatile _Tp >
    : integral_constant < size_t, tuple_size < _Tp > :: value > { };
template < std :: size_t __i, typename _Tp >
    struct tuple_element;
template < std :: size_t __i, typename _Tp >
    using __tuple_element_t = typename tuple_element < __i, _Tp > :: type;
template < std :: size_t __i, typename _Tp >
    struct tuple_element < __i, const _Tp >
    {
      typedef typename add_const < __tuple_element_t < __i, _Tp >> :: type type;
    };
template < std :: size_t __i, typename _Tp >
    struct tuple_element < __i, volatile _Tp >
    {
      typedef typename add_volatile < __tuple_element_t < __i, _Tp >> :: type type;
    };
template < std :: size_t __i, typename _Tp >
    struct tuple_element < __i, const volatile _Tp >
    {
      typedef typename add_cv < __tuple_element_t < __i, _Tp >> :: type type;
    };
template < std :: size_t __i, typename _Tp >
    using tuple_element_t = typename tuple_element < __i, _Tp > :: type;
template < typename >
    struct __is_tuple_like_impl : false_type
    { };
template < typename _T1, typename _T2 >
    struct __is_tuple_like_impl < std :: pair < _T1, _T2 > > : true_type
    { };
template < class _Tp1, class _Tp2 >
    struct tuple_size < std :: pair < _Tp1, _Tp2 > >
    : public integral_constant < std :: size_t, 2 > { };
template < class _Tp1, class _Tp2 >
    struct tuple_element < 0, std :: pair < _Tp1, _Tp2 > >
    { typedef _Tp1 type; };
template < class _Tp1, class _Tp2 >
    struct tuple_element < 1, std :: pair < _Tp1, _Tp2 > >
    { typedef _Tp2 type; };
template < std :: size_t _Int >
    struct __pair_get;
template<> struct __pair_get< 0UL > 
{
template < typename _Tp1, typename _Tp2 >
        static constexpr _Tp1 &
        __get ( std :: pair < _Tp1, _Tp2 > & __pair ) noexcept
        { return __pair . first; }
template < typename _Tp1, typename _Tp2 >
        static constexpr _Tp1 &&
        __move_get ( std :: pair < _Tp1, _Tp2 > && __pair ) noexcept
        { return std :: forward < _Tp1 > ( __pair . first ); }
template < typename _Tp1, typename _Tp2 >
        static constexpr const _Tp1 &
        __const_get ( const std :: pair < _Tp1, _Tp2 > & __pair ) noexcept
        { return __pair . first; }
};
template<> struct __pair_get< 1UL > 
{
template < typename _Tp1, typename _Tp2 >
        static constexpr _Tp2 &
        __get ( std :: pair < _Tp1, _Tp2 > & __pair ) noexcept
        { return __pair . second; }
template < typename _Tp1, typename _Tp2 >
        static constexpr _Tp2 &&
        __move_get ( std :: pair < _Tp1, _Tp2 > && __pair ) noexcept
        { return std :: forward < _Tp2 > ( __pair . second ); }
template < typename _Tp1, typename _Tp2 >
        static constexpr const _Tp2 &
        __const_get ( const std :: pair < _Tp1, _Tp2 > & __pair ) noexcept
        { return __pair . second; }
};
template < std :: size_t _Int, class _Tp1, class _Tp2 >
    constexpr typename tuple_element < _Int, std :: pair < _Tp1, _Tp2 > > :: type &
    get ( std :: pair < _Tp1, _Tp2 > & __in ) noexcept
    { return __pair_get < _Int > :: __get ( __in ); }
template < std :: size_t _Int, class _Tp1, class _Tp2 >
    constexpr typename tuple_element < _Int, std :: pair < _Tp1, _Tp2 > > :: type &&
    get ( std :: pair < _Tp1, _Tp2 > && __in ) noexcept
    { return __pair_get < _Int > :: __move_get ( std :: move ( __in ) ); }
template < std :: size_t _Int, class _Tp1, class _Tp2 >
    constexpr const typename tuple_element < _Int, std :: pair < _Tp1, _Tp2 > > :: type &
    get ( const std :: pair < _Tp1, _Tp2 > & __in ) noexcept
    { return __pair_get < _Int > :: __const_get ( __in ); }
template < typename _Tp, typename _Up >
    constexpr _Tp &
    get ( pair < _Tp, _Up > & __p ) noexcept
    { return __p . first; }
template < typename _Tp, typename _Up >
    constexpr const _Tp &
    get ( const pair < _Tp, _Up > & __p ) noexcept
    { return __p . first; }
template < typename _Tp, typename _Up >
    constexpr _Tp &&
    get ( pair < _Tp, _Up > && __p ) noexcept
    { return std :: move ( __p . first ); }
template < typename _Tp, typename _Up >
    constexpr _Tp &
    get ( pair < _Up, _Tp > & __p ) noexcept
    { return __p . second; }
template < typename _Tp, typename _Up >
    constexpr const _Tp &
    get ( const pair < _Up, _Tp > & __p ) noexcept
    { return __p . second; }
template < typename _Tp, typename _Up >
    constexpr _Tp &&
    get ( pair < _Up, _Tp > && __p ) noexcept
    { return std :: move ( __p . second ); }
template < typename _Tp, typename _Up = _Tp >
    inline _Tp
    exchange ( _Tp & __obj, _Up && __new_val )
    { return std :: __exchange ( __obj, std :: forward < _Up > ( __new_val ) ); }
template < size_t ... _Indexes > struct _Index_tuple { };
template < typename _Itup1, typename _Itup2 > struct _Itup_cat;
template < size_t ... _Ind1, size_t ... _Ind2 >
    struct _Itup_cat < _Index_tuple < _Ind1 ... >, _Index_tuple < _Ind2 ... > >
    {
      using __type = _Index_tuple < _Ind1 ..., ( _Ind2 + sizeof ... ( _Ind1 ) ) ... >;
    };
template < size_t _Num >
    struct _Build_index_tuple
    : _Itup_cat < typename _Build_index_tuple < _Num / 2 > :: __type,
  typename _Build_index_tuple < _Num - _Num / 2 > :: __type >
    { };
template<> struct _Build_index_tuple< 1UL > 
{
typedef struct _Index_tuple< 0UL > __type;
};
template<> struct _Build_index_tuple< 0UL > 
{
typedef struct _Index_tuple<   > __type;
};
template < typename _Tp, _Tp ... _Idx >
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size ( );
    };
template < typename _Tp, _Tp _Num,
    typename _ISeq = typename _Build_index_tuple < _Num > :: __type >
    struct _Make_integer_sequence;
template < typename _Tp, _Tp _Num, size_t ... _Idx >
    struct _Make_integer_sequence < _Tp, _Num, _Index_tuple < _Idx ... > >
    {
      static_assert ( _Num >= 0,
       "Cannot make integer sequence of negative length" );
      typedef integer_sequence < _Tp, static_cast < _Tp > ( _Idx ) ... > __type;
    };
template < typename _Tp, _Tp _Num >
    using make_integer_sequence
      = typename _Make_integer_sequence < _Tp, _Num > :: __type;
template < size_t ... _Idx >
    using index_sequence = integer_sequence < size_t, _Idx ... >;
template < size_t _Num >
    using make_index_sequence = make_integer_sequence < size_t, _Num >;
template < typename ... _Types >
    using index_sequence_for = make_index_sequence < sizeof ... ( _Types ) >;
}
namespace camp
{
using idx_t = std::ptrdiff_t ;
using nullptr_t = ;
}
namespace camp
{
template < typename T >
T * declptr ( );
template < typename T >
auto val ( ) noexcept -> decltype ( std :: declval < T > ( ) );
template < typename T >
auto cval ( ) noexcept -> decltype ( std :: declval < T const > ( ) );
template < typename ... Ts >
 void sink ( Ts ... )
{
}
using std::begin;
using std::swap;
namespace type
{
namespace ref
{
template < class T >
    struct rem_s {
      using type = T;
    };
template < class T >
    struct rem_s < T & > {
      using type = T;
    };
template < class T >
    struct rem_s < T && > {
      using type = T;
    };
template < class T >
    using rem = typename rem_s < T > :: type;
template < class T >
    using add = T &;
}
namespace rvref
{
template < class T >
    using add = T &&;
}
namespace c
{
template < class T >
    struct rem_s {
      using type = T;
    };
template < class T >
    struct rem_s < const T > {
      using type = T;
    };
template < class T >
    using rem = typename rem_s < T > :: type;
template < class T >
    using add = const T;
}
namespace v
{
template < class T >
    struct rem_s {
      using type = T;
    };
template < class T >
    struct rem_s < volatile T > {
      using type = T;
    };
template < class T >
    using rem = typename rem_s < T > :: type;
template < class T >
    using add = volatile T;
}
namespace cv
{
template < class T >
    struct rem_s {
      using type = T;
    };
template < class T >
    struct rem_s < const T > {
      using type = T;
    };
template < class T >
    struct rem_s < volatile T > {
      using type = T;
    };
template < class T >
    struct rem_s < const volatile T > {
      using type = T;
    };
template < class T >
    using rem = typename rem_s < T > :: type;
template < class T >
    using add = const volatile T;
}
}
template < typename T >
using decay = type :: cv :: rem < type :: ref :: rem < T >>;
template < typename T >
using plain = type :: ref :: rem < T >;
template < typename T >
using diff_from = decltype ( val < plain < T >> ( ) - val < plain < T >> ( ) );
template < typename T, typename U >
using diff_between = decltype ( val < plain < T >> ( ) - val < plain < U >> ( ) );
template < typename T >
using iterator_from = decltype ( begin ( val < plain < T >> ( ) ) );
template < class T >
 constexpr T && forward ( type :: ref :: rem < T > & t ) noexcept
{
  return static_cast < T && > ( t );
}
template < class T >
 constexpr T && forward ( type :: ref :: rem < T > && t ) noexcept
{
  return static_cast < T && > ( t );
}
template < typename T >
 constexpr type :: ref :: rem < T > && move ( T && t ) noexcept
{
  return static_cast < type :: ref :: rem < T > && > ( t );
}
template < typename T >
 void safe_swap ( T & t1, T & t2 )
{
  using std :: swap;
  swap ( t1, t2 );
}
template < typename T, typename = decltype ( sink ( swap ( val < T > ( ), val < T > ( ) ) ) ) >
 void safe_swap ( T & t1, T & t2 )
{
  using std :: swap;
  swap ( t1, t2 );
}
}
namespace camp
{
template < class NumT, NumT v >
struct integral_constant {
  static constexpr NumT value = v;
  using value_type = NumT;
  using type = integral_constant;
  constexpr operator value_type ( ) const noexcept;
  constexpr value_type operator ( ) ( ) const noexcept;
};
template < idx_t N >
using num = integral_constant < idx_t, N >;
using true_type = num< 1L > ;
using false_type = num< 0L > ;
using t = num< 1L > ;
}
namespace camp
{
namespace detail
{
struct nothing ;
}
template < typename val = detail :: nothing >
struct value;
template < typename val >
struct value {
  using type = val;
};
template<> struct value< nothing  > 
{
using type = struct value< class detail::nothing  > ;
};
using nil = struct value< class detail::nothing  > ;
template < typename Val >
struct is_value_s {
  using type = camp :: t;
};
template < typename Val >
using is_value = typename is_value_s < Val > :: type;
}
namespace camp
{
template < bool Cond,
          typename Then = camp :: true_type,
          typename Else = camp :: false_type >
struct if_cs {
  using type = Then;
};
template < typename Then, typename Else >
struct if_cs < false, Then, Else > {
  using type = Else;
};
template < bool Cond,
          typename Then = camp :: true_type,
          typename Else = camp :: false_type >
using if_c = typename if_cs < Cond, Then, Else > :: type;
template < typename Cond,
          typename Then = camp :: true_type,
          typename Else = camp :: false_type >
struct if_s : if_cs < Cond :: value, Then, Else > {
};
template < typename Then, typename Else >
struct if_s < nil, Then, Else > : if_cs < false, Then, Else > {
};
template < typename ... Ts >
using if_ = typename if_s < Ts ... > :: type;
}
namespace std
{
template < typename _Tp, std :: size_t _Nm >
    struct __array_traits
    {
      typedef _Tp _Type [ _Nm ];
      static constexpr _Tp &
      _S_ref ( const _Type & __t, std :: size_t __n ) noexcept
      ;
      static constexpr _Tp *
      _S_ptr ( const _Type & __t ) noexcept
      ;
    };
template < typename _Tp >
   struct __array_traits < _Tp, 0 >
   {
     struct _Type { };
     static constexpr _Tp &
     _S_ref ( const _Type &, std :: size_t ) noexcept
     ;
     static constexpr _Tp *
     _S_ptr ( const _Type & ) noexcept
     ;
   };
template < typename _Tp, std :: size_t _Nm >
    struct array
    {
      typedef _Tp value_type;
      typedef value_type * pointer;
      typedef const value_type * const_pointer;
      typedef value_type & reference;
      typedef const value_type & const_reference;
      typedef value_type * iterator;
      typedef const value_type * const_iterator;
      typedef std :: size_t size_type;
      typedef std :: ptrdiff_t difference_type;
      typedef std :: reverse_iterator < iterator > reverse_iterator;
      typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;
      typedef std :: __array_traits < _Tp, _Nm > _AT_Type;
      typename _AT_Type :: _Type _M_elems;
      void
      fill ( const value_type & __u )
      ;
      void
      swap ( array & __other )
      noexcept ( __is_nothrow_swappable < _Tp > :: value )
      ;
      iterator
      begin ( ) noexcept
      ;
      const_iterator
      begin ( ) const noexcept
      ;
      iterator
      end ( ) noexcept
      ;
      const_iterator
      end ( ) const noexcept
      ;
      reverse_iterator
      rbegin ( ) noexcept
      ;
      const_reverse_iterator
      rbegin ( ) const noexcept
      ;
      reverse_iterator
      rend ( ) noexcept
      ;
      const_reverse_iterator
      rend ( ) const noexcept
      ;
      const_iterator
      cbegin ( ) const noexcept
      ;
      const_iterator
      cend ( ) const noexcept
      ;
      const_reverse_iterator
      crbegin ( ) const noexcept
      ;
      const_reverse_iterator
      crend ( ) const noexcept
      ;
      constexpr size_type
      size ( ) const noexcept;
      constexpr size_type
      max_size ( ) const noexcept;
      constexpr bool
      empty ( ) const noexcept;
      reference
      operator [ ] ( size_type __n ) noexcept
      ;
      constexpr const_reference
      operator [ ] ( size_type __n ) const noexcept
      ;
      reference
      at ( size_type __n )
      ;
      constexpr const_reference
      at ( size_type __n ) const
      ;
      reference
      front ( ) noexcept
      ;
      constexpr const_reference
      front ( ) const noexcept
      ;
      reference
      back ( ) noexcept
      ;
      constexpr const_reference
      back ( ) const noexcept
      ;
      pointer
      data ( ) noexcept
      ;
      const_pointer
      data ( ) const noexcept
      ;
    };
template < typename _Tp, std :: size_t _Nm >
    inline bool
    operator == ( const array < _Tp, _Nm > & __one, const array < _Tp, _Nm > & __two )
    { return std :: equal ( __one . begin ( ), __one . end ( ), __two . begin ( ) ); }
template < typename _Tp, std :: size_t _Nm >
    inline bool
    operator != ( const array < _Tp, _Nm > & __one, const array < _Tp, _Nm > & __two )
    { return ! ( __one == __two ); }
template < typename _Tp, std :: size_t _Nm >
    inline bool
    operator < ( const array < _Tp, _Nm > & __a, const array < _Tp, _Nm > & __b )
    {
      return std :: lexicographical_compare ( __a . begin ( ), __a . end ( ),
       __b . begin ( ), __b . end ( ) );
    }
template < typename _Tp, std :: size_t _Nm >
    inline bool
    operator > ( const array < _Tp, _Nm > & __one, const array < _Tp, _Nm > & __two )
    { return __two < __one; }
template < typename _Tp, std :: size_t _Nm >
    inline bool
    operator <= ( const array < _Tp, _Nm > & __one, const array < _Tp, _Nm > & __two )
    { return ! ( __one > __two ); }
template < typename _Tp, std :: size_t _Nm >
    inline bool
    operator >= ( const array < _Tp, _Nm > & __one, const array < _Tp, _Nm > & __two )
    { return ! ( __one < __two ); }
template < typename _Tp, std :: size_t _Nm >
    inline void
    swap ( array < _Tp, _Nm > & __one, array < _Tp, _Nm > & __two )
    noexcept ( noexcept ( __one . swap ( __two ) ) )
    { __one . swap ( __two ); }
template < std :: size_t _Int, typename _Tp, std :: size_t _Nm >
    constexpr _Tp &
    get ( array < _Tp, _Nm > & __arr ) noexcept
    {
      static_assert ( _Int < _Nm, "index is out of bounds" );
      return std :: __array_traits < _Tp, _Nm > ::
 _S_ref ( __arr . _M_elems, _Int );
    }
template < std :: size_t _Int, typename _Tp, std :: size_t _Nm >
    constexpr _Tp &&
    get ( array < _Tp, _Nm > && __arr ) noexcept
    {
      static_assert ( _Int < _Nm, "index is out of bounds" );
      return std :: move ( std :: get < _Int > ( __arr ) );
    }
template < std :: size_t _Int, typename _Tp, std :: size_t _Nm >
    constexpr const _Tp &
    get ( const array < _Tp, _Nm > & __arr ) noexcept
    {
      static_assert ( _Int < _Nm, "index is out of bounds" );
      return std :: __array_traits < _Tp, _Nm > ::
 _S_ref ( __arr . _M_elems, _Int );
    }
}
namespace std
{
template < typename _Tp >
    class tuple_size;
template < typename _Tp, std :: size_t _Nm >
    struct tuple_size < std :: array < _Tp, _Nm > >
    : public integral_constant < std :: size_t, _Nm > { };
template < std :: size_t _Int, typename _Tp >
    class tuple_element;
template < std :: size_t _Int, typename _Tp, std :: size_t _Nm >
    struct tuple_element < _Int, std :: array < _Tp, _Nm > >
    {
      static_assert ( _Int < _Nm, "index is out of bounds" );
      typedef _Tp type;
    };
template < typename _Tp, std :: size_t _Nm >
    struct __is_tuple_like_impl < std :: array < _Tp, _Nm > > : true_type
    { };
}
namespace camp
{
template < typename T, T ... vs >
struct int_seq {
  using type = int_seq;
};
template < idx_t ... vs >
using idx_seq = int_seq < idx_t, vs ... >;
namespace detail
{
template < typename T, typename N >
  struct gen_seq;
template < typename T, typename S1, typename S2 >
  struct concat;
template < typename T, T ... I1, T ... I2 >
  struct concat < T, int_seq < T, I1 ... >, int_seq < T, I2 ... > > {
    using type = typename int_seq < T, I1 ..., ( sizeof ... ( I1 ) + I2 ) ... > :: type;
  };
template < typename T, typename N_t >
  struct gen_seq
      : concat < T,
               typename gen_seq < T, integral_constant < T, N_t :: value / 2 >> :: type,
               typename gen_seq <
                   T,
                   integral_constant < T, N_t :: value - N_t :: value / 2 >> :: type > ::
            type {
  };
template < typename T >
  struct gen_seq < T, integral_constant < T, 0 > > : int_seq < T > {
  };
template < typename T >
  struct gen_seq < T, integral_constant < T, 1 > > : int_seq < T, 0 > {
  };
}
template < idx_t Upper >
struct make_idx_seq {
  using type =
      typename detail :: gen_seq < idx_t, integral_constant < idx_t, Upper >> :: type;
};
template < idx_t Upper >
using make_idx_seq_t = typename make_idx_seq < Upper > :: type;
template < class ... Ts >
using idx_seq_for_t = typename make_idx_seq < sizeof ... ( Ts ) > :: type;
template < typename T >
struct idx_seq_from;
template < template < typename ... > class T, typename ... Args >
struct idx_seq_from < T < Args ... > > : make_idx_seq < sizeof ... ( Args ) > {
};
template < typename T, T ... Args >
struct idx_seq_from < int_seq < T, Args ... > > : make_idx_seq < sizeof ... ( Args ) > {
};
template < typename T >
using idx_seq_from_t = typename idx_seq_from < camp :: decay < T >> :: type;
template < typename T, T Upper >
struct make_int_seq : detail :: gen_seq < T, integral_constant < T, Upper >> :: type {
};
template < typename T, idx_t Upper >
using make_int_seq_t = typename make_int_seq < T, Upper > :: type;
template < typename T >
struct not_ {
  using type = typename if_s < T, false_type, true_type > :: type;
};
template < idx_t N, typename IdxSeg >
struct seq_at;
template < idx_t N, typename T, T Idx0, T ... IdxRest >
struct seq_at < N, camp :: int_seq < T, Idx0, IdxRest ... > > {
  static constexpr T value =
      seq_at < N - 1, camp :: int_seq < T, IdxRest ... >> :: value;
};
template < typename T, T Idx0, T ... IdxRest >
struct seq_at < 0, camp :: int_seq < T, Idx0, IdxRest ... > > {
  static constexpr T value = Idx0;
};
}
namespace camp
{
template < typename T >
struct size;
}
namespace camp
{
template < typename ... Ts >
struct list {
  using type = list;
};
namespace detail
{
template < typename T >
  struct _as_list;
template < template < typename ... > class T, typename ... Args >
  struct _as_list < T < Args ... > > {
    using type = list < Args ... >;
  };
template < typename T, T ... Args >
  struct _as_list < int_seq < T, Args ... > > {
    using type = list < integral_constant < T, Args > ... >;
  };
}
template < typename T >
struct as_list_s : detail :: _as_list < T > :: type {
};
template < typename T >
using as_list = typename as_list_s < T > :: type;
template < typename ... Args >
struct size < list < Args ... > > {
  constexpr static idx_t value { sizeof ... ( Args ) };
  using type = num < sizeof ... ( Args ) >;
};
}
namespace camp
{
namespace detail
{
template < idx_t, typename >
  struct entry {
  };
template < typename, typename >
  struct entries;
template < idx_t ... keys, typename ... vals >
  struct entries < idx_seq < keys ... >, list < vals ... > > : entry < keys, vals > ... {
  };
template < idx_t key, typename val >
  value < val > _lookup_impl ( entry < key, val > * );
template < typename >
  value < > _lookup_impl ( ... );
template < typename vals, typename indices, idx_t Idx >
  struct _lookup
      : decltype ( _lookup_impl < Idx > ( declptr < entries < indices, vals >> ( ) ) ) {
  };
template < typename T, idx_t Idx >
  struct _at;
template < template < class ... > class T, typename X, typename ... Rest >
  struct _at < T < X, Rest ... >, 0 > {
    using type = X;
  };
template < template < class ... > class T,
            typename X,
            typename Y,
            typename ... Rest >
  struct _at < T < X, Y, Rest ... >, 1 > {
    using type = Y;
  };
template < template < class ... > class T, idx_t Idx, typename ... Rest >
  struct _at < T < Rest ... >, Idx > {
    static_assert ( Idx < sizeof ... ( Rest ), "at: index out of range" );
    using type = typename _lookup < T < Rest ... >,
                                  make_idx_seq_t < sizeof ... ( Rest ) >,
                                  Idx > :: type;
  };
}
template < typename Seq, typename Num >
struct at;
template < typename T, idx_t Val >
struct at < T, num < Val > > {
  using type = typename detail :: _at < T, Val > :: type;
};
template < typename T >
using first = typename at < T, num < 0 >> :: type;
template < typename T >
using second = typename at < T, num < 1 >> :: type;
template < typename T, idx_t Idx >
using at_v = typename at < T, num < Idx >> :: type;
template < typename T, typename U >
using at_t = typename at < T, U > :: type;
}
namespace camp
{
template < template < typename ... > class Expr >
struct lambda {
  template < typename ... Ts >
  using expr = typename Expr < Ts ... > :: type;
};
template < typename Lambda, typename Seq >
struct apply_l;
template < typename Lambda, typename ... Args >
struct apply_l < Lambda, list < Args ... > > {
  using type = typename Lambda :: template expr < Args ... > :: type;
};
template < typename Lambda, typename ... Args >
struct invoke_l {
  using type = typename Lambda :: template expr < Args ... > :: type;
};
template < idx_t n >
struct arg {
  template < typename ... Ts >
  using expr = typename at < list < Ts ... >, num < n - 1 >> :: type;
};
using _1 = struct arg< 1L > ;
using _2 = struct arg< 2L > ;
using _3 = struct arg< 3L > ;
using _4 = struct arg< 4L > ;
using _5 = struct arg< 5L > ;
using _6 = struct arg< 6L > ;
using _7 = struct arg< 7L > ;
using _8 = struct arg< 8L > ;
using _9 = struct arg< 9L > ;
namespace detail
{
template < typename T, typename ... Args >
  struct get_bound_arg {
    using type = T;
  };
template < idx_t i, typename ... Args >
  struct get_bound_arg < arg < i >, Args ... > {
    using type = typename arg < i > :: template expr < Args ... >;
  };
}
template < template < typename ... > class Expr, typename ... ArgBindings >
struct bind {
  using bindings = list < ArgBindings ... >;
  template < typename ... Ts >
  using expr = typename Expr <
      typename detail :: get_bound_arg < ArgBindings, Ts ... > :: type ... > :: type;
  using type = bind;
};
template < template < typename ... > class Expr, typename ... BoundArgs >
struct bind_front {
  template < typename ... Ts >
  using expr = typename Expr < BoundArgs ..., Ts ... > :: type;
  using type = bind_front;
};
template < typename Lambda, typename ... Rest > struct bind_front_l { using type = typename bind_front < Lambda :: template expr, Rest ... > :: type; };
}
namespace camp
{
namespace detail
{
template < template < typename ... > class Cond, typename ... Elements >
  struct _find_if;
template < template < typename ... > class Cond, typename First, typename ... Rest >
  struct _find_if < Cond, First, Rest ... > {
    using type = if_ < typename Cond < First > :: type,
                     First,
                     typename _find_if < Cond, Rest ... > :: type >;
  };
template < template < typename ... > class Cond >
  struct _find_if < Cond > {
    using type = nil;
  };
}
template < template < typename ... > class Cond, typename Seq >
struct find_if;
template < template < typename ... > class Cond, typename ... Elements >
struct find_if < Cond, list < Elements ... > > {
  using type = typename detail :: _find_if < Cond, Elements ... > :: type;
};
template < typename Lambda, typename ... Rest > struct find_if_l { using type = typename find_if < Lambda :: template expr, Rest ... > :: type; };
}
namespace camp
{
template < typename T, typename U >
struct is_same_s : false_type {
};
template < typename T >
struct is_same_s < T, T > : true_type {
};
template < typename T, typename U >
using is_same = typename is_same_s < T, U > :: type;
template < typename T, typename U >
using is_same_t = is_same < T, U >;
}
namespace camp
{
namespace concepts
{
namespace metalib
{
using camp::is_same;
template < typename T >
    struct negate_t : num < ! T :: value > {
    };
template < bool ... Bs >
    struct all_of : metalib :: is_same < list < t, num < Bs > ... >, list < num < Bs > ..., t >> {
    };
template < bool ... Bs >
    struct none_of
        : metalib :: is_same < idx_seq < false, Bs ... >, idx_seq < Bs ..., false >> {
    };
template < bool ... Bs >
    struct any_of : negate_t < none_of < Bs ... >> {
    };
template < typename ... Bs >
    struct all_of_t : all_of < Bs :: value ... > {
    };
template < typename ... Bs >
    struct none_of_t : none_of < Bs :: value ... > {
    };
template < typename ... Bs >
    struct any_of_t : any_of < Bs :: value ... > {
    };
}
}
}
template < typename ... T >
camp :: true_type ___valid_expr___ ( T && ... ) noexcept;
namespace camp
{
namespace concepts
{
namespace detail
{
template < class ... >
    struct TL {
    };
template < class ... >
    struct voider {
      using type = void;
    };
template < class Default,
              class,
              template < class ... > class Concept,
              class TArgs >
    struct detector {
      using value_t = false_type;
      using type = Default;
    };
template < class Default, template < class ... > class Concept, class ... Args >
    struct detector < Default,
                    typename voider < Concept < Args ... > > :: type,
                    Concept,
                    TL < Args ... > > {
      using value_t = true_type;
      using type = Concept < Args ... >;
    };
template < template < class ... > class Concept, class TArgs >
    using is_detected = detector < void, void, Concept, TArgs >;
template < template < class ... > class Concept, class TArgs >
    using detected = typename is_detected < Concept, TArgs > :: value_t;
template < typename Ret, typename T >
    Ret returns ( T const & ) noexcept;
}
template < typename T >
  using negate = metalib :: negate_t < T >;
template < typename T, typename U >
  constexpr auto convertible_to ( U && u ) noexcept
      -> decltype ( detail :: returns < camp :: true_type > ( static_cast < T > ( ( U && ) u ) ) );
template < typename T, typename U >
  constexpr auto has_type ( U && ) noexcept -> metalib :: is_same < T, U >;
template < typename BoolLike >
  constexpr auto is ( BoolLike ) noexcept
      -> camp :: if_ < BoolLike, camp :: true_type, camp :: false_type >;
template < typename BoolLike >
  constexpr auto is_not ( BoolLike ) noexcept
      -> camp :: if_c < ! BoolLike :: value, camp :: true_type, camp :: false_type >;
template < typename ... Args >
  struct all_of : metalib :: all_of_t < Args ... > {
  };
template < typename ... Args >
  struct none_of : metalib :: none_of_t < Args ... > {
  };
template < typename ... Args >
  struct any_of : metalib :: any_of_t < Args ... > {
  };
template < typename ... Args >
  using enable_if = typename std :: enable_if < all_of < Args ... > :: value, void > :: type;
template < template < class ... > class Op, class ... Args >
  struct requires_ : detail :: detected < Op, detail :: TL < Args ... >> {
  };
template < typename T >
  struct Swappable : decltype ( ___valid_expr___ ( swap ( val < T > ( ), val < T > ( ) ) ) ) {
  };
template < typename T >
  struct LessThanComparable
      : decltype ( ___valid_expr___ ( convertible_to < bool > ( val < T > ( ) < val < T > ( ) ) ) ) {
  };
template < typename T >
  struct GreaterThanComparable
      : decltype ( ___valid_expr___ ( convertible_to < bool > ( val < T > ( ) > val < T > ( ) ) ) ) {
  };
template < typename T >
  struct LessEqualComparable
      : decltype ( ___valid_expr___ ( convertible_to < bool > ( val < T > ( ) <= val < T > ( ) ) ) ) {
  };
template < typename T >
  struct GreaterEqualComparable
      : decltype ( ___valid_expr___ ( convertible_to < bool > ( val < T > ( ) >= val < T > ( ) ) ) ) {
  };
template < typename T >
  struct EqualityComparable
      : decltype ( ___valid_expr___ ( convertible_to < bool > ( val < T > ( ) == val < T > ( ) ) ) ) {
  };
template < typename T, typename U >
  struct ComparableTo
      : decltype ( ___valid_expr___ ( convertible_to < bool > ( val < U > ( ) < val < T > ( ) ), convertible_to < bool > ( val < T > ( ) < val < U > ( ) ), convertible_to < bool > ( val < U > ( ) <= val < T > ( ) ), convertible_to < bool > ( val < T > ( ) <= val < U > ( ) ), convertible_to < bool > ( val < U > ( ) > val < T > ( ) ), convertible_to < bool > ( val < T > ( ) > val < U > ( ) ), convertible_to < bool > ( val < U > ( ) >= val < T > ( ) ), convertible_to < bool > ( val < T > ( ) >= val < U > ( ) ), convertible_to < bool > ( val < U > ( ) == val < T > ( ) ), convertible_to < bool > ( val < T > ( ) == val < U > ( ) ), convertible_to < bool > ( val < U > ( ) != val < T > ( ) ), convertible_to < bool > ( val < T > ( ) != val < U > ( ) ) ) )
                                                                  {
  };
template < typename T >
  struct Comparable : ComparableTo < T, T > {
  };
template < typename T >
  struct Arithmetic : decltype ( ___valid_expr___ ( is ( std :: is_arithmetic < T > ( ) ) ) ) {
  };
template < typename T >
  struct FloatingPoint : decltype ( ___valid_expr___ ( is ( std :: is_floating_point < T > ( ) ) ) ) {
  };
template < typename T >
  struct Integral : decltype ( ___valid_expr___ ( is ( std :: is_integral < T > ( ) ) ) ) {
  };
template < typename T >
  struct Signed : decltype ( ___valid_expr___ ( Integral < T > ( ), is ( std :: is_signed < T > ( ) ) ) ) {
  };
template < typename T >
  struct Unsigned : decltype ( ___valid_expr___ ( Integral < T > ( ), is ( std :: is_unsigned < T > ( ) ) ) ) {
  };
template < typename T >
  struct Iterator
      : decltype ( ___valid_expr___ ( is_not ( Integral < T > ( ) ), * ( val < T > ( ) ), has_type < T & > ( ++ val < T & > ( ) ) ) )
                                                   {
  };
template < typename T >
  struct ForwardIterator
      : decltype ( ___valid_expr___ ( Iterator < T > ( ), val < T & > ( ) ++, * val < T & > ( ) ++ ) ) {
  };
template < typename T >
  struct BidirectionalIterator
      : decltype ( ___valid_expr___ ( ForwardIterator < T > ( ), has_type < T & > ( -- val < T & > ( ) ), convertible_to < T const & > ( val < T & > ( ) -- ), * val < T & > ( ) -- ) )
                                     {
  };
template < typename T >
  struct RandomAccessIterator
      : decltype ( ___valid_expr___ ( BidirectionalIterator < T > ( ), Comparable < T > ( ), has_type < T & > ( val < T & > ( ) += val < diff_from < T >> ( ) ), has_type < T > ( val < T > ( ) + val < diff_from < T >> ( ) ), has_type < T > ( val < diff_from < T >> ( ) + val < T > ( ) ), has_type < T & > ( val < T & > ( ) -= val < diff_from < T >> ( ) ), has_type < T > ( val < T > ( ) - val < diff_from < T >> ( ) ), val < T > ( ) [ val < diff_from < T >> ( ) ] ) )
                                                     {
  };
template < typename T >
  struct HasBeginEnd : decltype ( ___valid_expr___ ( std :: begin ( val < T > ( ) ), std :: end ( val < T > ( ) ) ) ) {
  };
template < typename T >
  struct Range : decltype ( ___valid_expr___ ( HasBeginEnd < T > ( ), Iterator < iterator_from < T >> ( ) ) ) {
  };
template < typename T >
  struct ForwardRange
      : decltype ( ___valid_expr___ ( HasBeginEnd < T > ( ), ForwardIterator < iterator_from < T >> ( ) ) ) {
  };
template < typename T >
  struct BidirectionalRange
      : decltype ( ___valid_expr___ ( HasBeginEnd < T > ( ), BidirectionalIterator < iterator_from < T >> ( ) ) )
                                                                 {
  };
template < typename T >
  struct RandomAccessRange
      : decltype ( ___valid_expr___ ( HasBeginEnd < T > ( ), RandomAccessIterator < iterator_from < T >> ( ) ) )
                                                                {
  };
}
namespace type_traits
{
template < typename ... Args > struct is_iterator : camp :: concepts :: requires_ < camp :: concepts :: Iterator, Args ... > { };
template < typename ... Args > struct is_forward_iterator : camp :: concepts :: requires_ < camp :: concepts :: ForwardIterator, Args ... > { };
template < typename ... Args > struct is_bidirectional_iterator : camp :: concepts :: requires_ < camp :: concepts :: BidirectionalIterator, Args ... > { };
template < typename ... Args > struct is_random_access_iterator : camp :: concepts :: requires_ < camp :: concepts :: RandomAccessIterator, Args ... > { };
template < typename ... Args > struct is_range : camp :: concepts :: requires_ < camp :: concepts :: Range, Args ... > { };
template < typename ... Args > struct is_forward_range : camp :: concepts :: requires_ < camp :: concepts :: ForwardRange, Args ... > { };
template < typename ... Args > struct is_bidirectional_range : camp :: concepts :: requires_ < camp :: concepts :: BidirectionalRange, Args ... > { };
template < typename ... Args > struct is_random_access_range : camp :: concepts :: requires_ < camp :: concepts :: RandomAccessRange, Args ... > { };
template < typename ... Args > struct is_comparable : camp :: concepts :: requires_ < camp :: concepts :: Comparable, Args ... > { };
template < typename ... Args > struct is_comparable_to : camp :: concepts :: requires_ < camp :: concepts :: ComparableTo, Args ... > { };
template < typename ... Args > struct is_arithmetic : camp :: concepts :: requires_ < camp :: concepts :: Arithmetic, Args ... > { };
template < typename ... Args > struct is_floating_point : camp :: concepts :: requires_ < camp :: concepts :: FloatingPoint, Args ... > { };
template < typename ... Args > struct is_integral : camp :: concepts :: requires_ < camp :: concepts :: Integral, Args ... > { };
template < typename ... Args > struct is_signed : camp :: concepts :: requires_ < camp :: concepts :: Signed, Args ... > { };
template < typename ... Args > struct is_unsigned : camp :: concepts :: requires_ < camp :: concepts :: Unsigned, Args ... > { };
template < typename T >
  using IterableValue = decltype ( * std :: begin ( camp :: val < T > ( ) ) );
template < typename T >
  using IteratorValue = decltype ( * camp :: val < T > ( ) );
namespace detail
{
template < typename, template < typename ... > class, typename ... >
    struct IsSpecialized : camp :: false_type {
    };
template < template < typename ... > class Template, typename ... T >
    struct IsSpecialized < typename concepts :: detail :: voider < decltype (
                             camp :: val < Template < T ... > > ( ) ) > :: type,
                         Template,
                         T ... > : camp :: true_type {
    };
template < template < class ... > class,
              template < class ... > class,
              bool,
              class ... >
    struct SpecializationOf : camp :: false_type {
    };
template < template < class ... > class Expected,
              template < class ... > class Actual,
              class ... Args >
    struct SpecializationOf < Expected, Actual, true, Args ... >
        : camp :: concepts :: metalib :: is_same < Expected < Args ... >, Actual < Args ... >> {
    };
}
template < template < class ... > class Outer, class ... Args >
  using IsSpecialized = detail :: IsSpecialized < void, Outer, Args ... >;
template < template < class ... > class, typename T >
  struct SpecializationOf : camp :: false_type {
  };
template < template < class ... > class Expected,
            template < class ... > class Actual,
            class ... Args >
  struct SpecializationOf < Expected, Actual < Args ... > >
      : detail :: SpecializationOf < Expected,
                                 Actual,
                                 IsSpecialized < Expected, Args ... > :: value,
                                 Args ... > {
  };
}
}
namespace RAJA
{
namespace concepts
{
using namespace camp::concepts;
}
namespace type_traits
{
using namespace camp::type_traits;
}
}
template < typename ... T >
 inline __attribute__ ( ( always_inline ) ) void RAJA_UNUSED_VAR ( T && ... ) noexcept
{
}

inline void RAJA_ABORT_OR_THROW(const char *str)
{
bool no_except = getenv("RAJA_NO_EXCEPT") != (nullptr);
if (no_except) {
abort();
}
 else {
throw std::runtime_error(str);
}
}
namespace RAJA
{
namespace operators
{
namespace detail
{

struct associative_tag 
{
}
;
template < typename Arg1, typename Arg2, typename Result >
struct binary_function {
  using first_argument_type = Arg1;
  using second_argument_type = Arg2;
  using result_type = Result;
};
template < typename Argument, typename Result >
struct unary_function {
  using argument_type = Argument;
  using result_type = Result;
};
template < typename Arg1, typename Arg2 >
struct comparison_function : public binary_function < Arg1, Arg2, bool > {
};
}
namespace types
{
template < typename T >
struct is_unsigned_int {
  static constexpr const bool value =
      std :: is_unsigned < T > :: value && std :: is_integral < T > :: value;
};
template < typename T >
struct is_signed_int {
  static constexpr const bool value =
      ! std :: is_unsigned < T > :: value && std :: is_integral < T > :: value;
};
template < typename T, bool GPU = false >
struct larger {
};
template<> struct larger< uint8_t  , false > 
{
using type = uint16_t ;
};
template<> struct larger< uint16_t  , false > 
{
using type = uint32_t ;
};
template<> struct larger< uint32_t  , false > 
{
using type = uint64_t ;
};
template<> struct larger< int8_t  , false > 
{
using type = int16_t ;
};
template<> struct larger< int16_t  , false > 
{
using type = int32_t ;
};
template<> struct larger< int32_t  , false > 
{
using type = int64_t ;
};
template<> struct larger< float  , false > 
{
using type = double ;
};
template<> struct larger< double  , false > 
{
using type = long double ;
};
template<> struct larger< double  , true > 
{
using type = double ;
};
namespace detail
{
template < typename T, bool isInt, bool isSigned, bool isFP, bool gpu = false >
struct largest {
};
template < typename T >
struct largest < T, true, false, false > {
  using type = uint64_t;
};
template < typename T >
struct largest < T, true, true, false > {
  using type = int64_t;
};
template < typename T >
struct largest < T, false, false, true, false > {
  using type = long double;
};
template < typename T >
struct largest < T, false, false, true, true > {
  using type = double;
};
}
template < typename T, bool gpu = false >
struct largest {
  using type = typename detail :: largest < T,
                                        std :: is_integral < T > :: value,
                                        std :: is_signed < T > :: value,
                                        std :: is_floating_point < T > :: value,
                                        gpu > :: type;
};
template < typename T >
struct size_of {
  enum { value = sizeof ( T ) };
};
namespace detail
{
template < typename T, typename U, bool lhsLarger >
struct larger_of {
};
template < typename T, typename U >
struct larger_of < T, U, true > {
  using type = T;
};
template < typename T, typename U >
struct larger_of < T, U, false > {
  using type = U;
};
}
template < typename T, typename U >
struct larger_of {
  using type = typename detail ::
      larger_of < T, U, ( size_of < T > :: value > size_of < U > :: value ) > :: type;
};
}
template < typename T, typename Enable = void >
struct limits;
template < typename T >
struct limits < T,
  typename std :: enable_if < std :: is_integral < T > :: value &&
  ! std :: is_unsigned < T > :: value > :: type >
{
  inline __attribute__ ( ( always_inline ) ) static constexpr T min ( )
  ;
  inline __attribute__ ( ( always_inline ) ) static constexpr T max ( )
  ;
};
template < typename T >
struct limits < T,
  typename std :: enable_if < std :: is_integral < T > :: value &&
  std :: is_unsigned < T > :: value > :: type >
{
  inline __attribute__ ( ( always_inline ) ) static constexpr T min ( )
  ;
  inline __attribute__ ( ( always_inline ) ) static constexpr T max ( )
  ;
};
template<> struct limits< float  , void  > 
{

constexpr inline static float min()
{
return - 3.40282346638528859812e+38F;
}

constexpr inline static float max()
{
return 3.40282346638528859812e+38F;
}
};
template<> struct limits< double  , void  > 
{

constexpr inline static double min()
{
return -((double )1.79769313486231570815e+308L);
}

constexpr inline static double max()
{
return (double )1.79769313486231570815e+308L;
}
};
template<> struct limits< long double  , void  > 
{

constexpr inline static long double min()
{
return - 1.18973149535723176502e+4932L;
}

constexpr inline static long double max()
{
return 1.18973149535723176502e+4932L;
}
};
template < typename Ret, typename Arg1 = Ret, typename Arg2 = Arg1 >
struct plus : public detail :: binary_function < Arg1, Arg2, Ret >,
              detail :: associative_tag {
  constexpr Ret operator ( ) ( const Arg1 & lhs,
                                            const Arg2 & rhs ) const
  ;
  static constexpr Ret identity ( );
};
template < typename Ret, typename Arg1 = Ret, typename Arg2 = Arg1 >
struct minus : public detail :: binary_function < Arg1, Arg2, Ret > {
  constexpr Ret operator ( ) ( const Arg1 & lhs,
                                            const Arg2 & rhs ) const
  ;
};
template < typename Ret, typename Arg1 = Ret, typename Arg2 = Arg1 >
struct multiplies : public detail :: binary_function < Arg1, Arg2, Ret >,
                    detail :: associative_tag {
  constexpr Ret operator ( ) ( const Arg1 & lhs,
                                            const Arg2 & rhs ) const
  ;
  static constexpr Ret identity ( );
};
template < typename Ret, typename Arg1 = Ret, typename Arg2 = Arg1 >
struct divides : public detail :: binary_function < Arg1, Arg2, Ret > {
  constexpr Ret operator ( ) ( const Arg1 & lhs,
                                            const Arg2 & rhs ) const
  ;
};
template < typename Ret, typename Arg1 = Ret, typename Arg2 = Arg1 >
struct modulus : public detail :: binary_function < Arg1, Arg2, Ret > {
  constexpr Ret operator ( ) ( const Arg1 & lhs,
                                            const Arg2 & rhs ) const
  ;
};
template < typename Arg1, typename Arg2 = Arg1 >
struct logical_and : public detail :: comparison_function < Arg1, Arg2 >,
                     detail :: associative_tag {
  constexpr bool operator ( ) ( const Arg1 & lhs,
                                             const Arg2 & rhs ) const
  ;
  static constexpr bool identity ( );
};
template < typename Arg1, typename Arg2 = Arg1 >
struct logical_or : public detail :: comparison_function < Arg1, Arg2 >,
                    detail :: associative_tag {
  constexpr bool operator ( ) ( const Arg1 & lhs,
                                             const Arg2 & rhs ) const
  ;
  static constexpr bool identity ( );
};
template < typename T >
struct logical_not : public detail :: unary_function < T, bool > {
  constexpr bool operator ( ) ( const T & lhs ) const
  ;
};
template < typename Ret, typename Arg1 = Ret, typename Arg2 = Arg1 >
struct bit_or : public detail :: binary_function < Arg1, Arg2, Ret > {
  constexpr Ret operator ( ) ( const Arg1 & lhs,
                                            const Arg2 & rhs ) const
  ;
};
template < typename Ret, typename Arg1 = Ret, typename Arg2 = Arg1 >
struct bit_and : public detail :: binary_function < Arg1, Arg2, Ret > {
  constexpr Ret operator ( ) ( const Arg1 & lhs,
                                            const Arg2 & rhs ) const
  ;
};
template < typename Ret, typename Arg1 = Ret, typename Arg2 = Arg1 >
struct bit_xor : public detail :: binary_function < Arg1, Arg2, Ret > {
  constexpr Ret operator ( ) ( const Arg1 & lhs,
                                            const Arg2 & rhs ) const
  ;
};
template < typename Ret, typename Arg1 = Ret, typename Arg2 = Arg1 >
struct minimum : public detail :: binary_function < Arg1, Arg2, Ret >,
                 detail :: associative_tag {
  constexpr Ret operator ( ) ( const Arg1 & lhs,
                                            const Arg2 & rhs ) const
  ;
  static constexpr Ret identity ( )
  ;
};
template < typename Ret, typename Arg1 = Ret, typename Arg2 = Arg1 >
struct maximum : public detail :: binary_function < Arg1, Arg2, Ret >,
                 detail :: associative_tag {
  constexpr Ret operator ( ) ( const Arg1 & lhs,
                                            const Arg2 & rhs ) const
  ;
  static constexpr Ret identity ( )
  ;
};
template < typename Arg1, typename Arg2 = Arg1 >
struct equal_to : public detail :: comparison_function < Arg1, Arg2 > {
  constexpr bool operator ( ) ( const Arg1 & lhs,
                                             const Arg2 & rhs ) const
  ;
};
template < typename Arg1, typename Arg2 = Arg1 >
struct not_equal_to : public detail :: comparison_function < Arg1, Arg2 > {
  constexpr bool operator ( ) ( const Arg1 & lhs,
                                             const Arg2 & rhs ) const
  ;
};
template < typename Arg1, typename Arg2 = Arg1 >
struct greater : public detail :: comparison_function < Arg1, Arg2 > {
  constexpr bool operator ( ) ( const Arg1 & lhs,
                                             const Arg2 & rhs ) const
  ;
};
template < typename Arg1, typename Arg2 = Arg1 >
struct less : public detail :: comparison_function < Arg1, Arg2 > {
  constexpr bool operator ( ) ( const Arg1 & lhs,
                                             const Arg2 & rhs ) const
  ;
};
template < typename Arg1, typename Arg2 = Arg1 >
struct greater_equal : public detail :: comparison_function < Arg1, Arg2 > {
  constexpr bool operator ( ) ( const Arg1 & lhs,
                                             const Arg2 & rhs ) const
  ;
};
template < typename Arg1, typename Arg2 = Arg1 >
struct less_equal : public detail :: comparison_function < Arg1, Arg2 > {
  constexpr bool operator ( ) ( const Arg1 & lhs,
                                             const Arg2 & rhs ) const
  ;
};
template < typename Ret, typename Orig = Ret >
struct identity : public detail :: unary_function < Orig, Ret > {
  constexpr Ret operator ( ) ( const Orig & lhs ) const
  ;
};
template < typename T, typename U >
struct project1st : public detail :: binary_function < T, U, T > {
  constexpr T operator ( ) ( const T & lhs,
                                          const U & ) const
  ;
};
template < typename T, typename U = T >
struct project2nd : public detail :: binary_function < T, U, U > {
  constexpr U operator ( ) ( const T &,
                                          const U & rhs ) const
  ;
};
template < typename T >
struct is_associative {
  static constexpr const bool value =
      std :: is_base_of < detail :: associative_tag, T > :: value;
};
template < typename Arg1, typename Arg2 = Arg1 >
struct safe_plus
    : public plus < Arg1,
                  Arg2,
                  typename types :: larger <
                      typename types :: larger_of < Arg1, Arg2 > :: type > :: type > {
};
}
namespace concepts
{
template < typename Function,
          typename Return,
          typename Arg1 = Return,
          typename Arg2 = Arg1 >
struct BinaryFunction
    :
     decltype ( ___valid_expr___ (
     :: RAJA :: concepts :: convertible_to < Return > ( camp :: val < Function > ( ) ( camp :: val < Arg1 > ( ), camp :: val < Arg2 > ( ) ) )
     ) )
                                                                       {
};
template < typename Function, typename Return, typename Arg = Return >
struct UnaryFunction :
                      decltype ( ___valid_expr___ (
                      :: RAJA :: concepts :: convertible_to < Return > ( camp :: val < Function > ( ) ( camp :: val < Arg > ( ) ) )
                      ) )
                                                                    {
};
namespace detail
{
template < typename Fun, typename Ret, typename T, typename U >
using is_binary_function = :: RAJA :: concepts :: requires_ < BinaryFunction, Ret, T, U >;
template < typename Fun, typename Ret, typename T >
using is_unary_function = :: RAJA :: concepts :: requires_ < UnaryFunction, Ret, T >;
}
}
namespace type_traits
{
template < typename ... Args > struct
is_binary_function
: camp :: concepts :: requires_ <
RAJA :: concepts :: BinaryFunction
, Args ... > { };
template < typename ... Args > struct
is_unary_function
: camp :: concepts :: requires_ <
RAJA :: concepts :: UnaryFunction
, Args ... > { };
}
}
namespace std
{
template < typename _Alloc >
    struct __allocated_ptr
    {
      using pointer = typename allocator_traits < _Alloc > :: pointer;
      using value_type = typename allocator_traits < _Alloc > :: value_type;
      __allocated_ptr ( _Alloc & __a, pointer __ptr ) noexcept
      ;
      template < typename _Ptr,
        typename _Req = _Require < is_same < _Ptr, value_type * >>>
      __allocated_ptr ( _Alloc & __a, _Ptr __ptr )
      : _M_alloc ( std :: __addressof ( __a ) ),
 _M_ptr ( pointer_traits < pointer > :: pointer_to ( * __ptr ) )
      { }
      __allocated_ptr ( __allocated_ptr && __gd ) noexcept
      ;
      ~ __allocated_ptr ( )
      ;
      __allocated_ptr &
      operator = ( std :: nullptr_t ) noexcept
      ;
      value_type * get ( );
    private :
      value_type * _S_raw_ptr ( value_type * __ptr );
      template < typename _Ptr >
 auto _S_raw_ptr ( _Ptr __ptr ) -> decltype ( _S_raw_ptr ( __ptr . operator -> ( ) ) )
 { return _S_raw_ptr ( __ptr . operator -> ( ) ); }
      _Alloc * _M_alloc;
      pointer _M_ptr;
    };
template < typename _Alloc >
    __allocated_ptr < _Alloc >
    __allocate_guarded ( _Alloc & __a )
    {
      return { __a, std :: allocator_traits < _Alloc > :: allocate ( __a, 1 ) };
    }
}
namespace __gnu_cxx
{
template < typename _Tp >
    struct __aligned_membuf
    {
      struct _Tp2 { _Tp _M_t; };
      alignas ( __alignof__ ( _Tp2 :: _M_t ) ) unsigned char _M_storage [ sizeof ( _Tp ) ];
      __aligned_membuf ( ) = default;
      __aligned_membuf ( std :: nullptr_t );
      void *
      _M_addr ( ) noexcept
      ;
      const void *
      _M_addr ( ) const noexcept
      ;
      _Tp *
      _M_ptr ( ) noexcept
      ;
      const _Tp *
      _M_ptr ( ) const noexcept
      ;
    };
template < typename _Tp >
    struct __aligned_buffer
    : std :: aligned_storage < sizeof ( _Tp ), std :: alignment_of < _Tp > :: value >
    {
      typename
 std :: aligned_storage < sizeof ( _Tp ), std :: alignment_of < _Tp > :: value > :: type
 _M_storage;
      __aligned_buffer ( ) = default;
      __aligned_buffer ( std :: nullptr_t );
      void *
      _M_addr ( ) noexcept
      ;
      const void *
      _M_addr ( ) const noexcept
      ;
      _Tp *
      _M_ptr ( ) noexcept
      ;
      const _Tp *
      _M_ptr ( ) const noexcept
      ;
    };
}
namespace std
{
namespace __detail
{

struct _List_node_base 
{
struct _List_node_base *_M_next;
struct _List_node_base *_M_prev;
static void swap(struct _List_node_base &__x,struct _List_node_base &__y);
void _M_transfer(struct _List_node_base *const __first,struct _List_node_base *const __last);
void _M_reverse();
void _M_hook(struct _List_node_base *const __position);
void _M_unhook();
}
;
}
template < typename _Tp >
    struct _List_node : public __detail :: _List_node_base
    {
      __gnu_cxx :: __aligned_membuf < _Tp > _M_storage;
      _Tp * _M_valptr ( );
      _Tp const * _M_valptr ( ) const;
    };
template < typename _Tp >
    struct _List_iterator
    {
      typedef _List_iterator < _Tp > _Self;
      typedef _List_node < _Tp > _Node;
      typedef ptrdiff_t difference_type;
      typedef std :: bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp * pointer;
      typedef _Tp & reference;
      _List_iterator ( ) noexcept
      ;
      explicit
      _List_iterator ( __detail :: _List_node_base * __x ) noexcept
      ;
      _Self
      _M_const_cast ( ) const noexcept
      ;
      reference
      operator * ( ) const noexcept
      ;
      pointer
      operator -> ( ) const noexcept
      ;
      _Self &
      operator ++ ( ) noexcept
      ;
      _Self
      operator ++ ( int ) noexcept
      ;
      _Self &
      operator -- ( ) noexcept
      ;
      _Self
      operator -- ( int ) noexcept
      ;
      bool
      operator == ( const _Self & __x ) const noexcept
      ;
      bool
      operator != ( const _Self & __x ) const noexcept
      ;
      __detail :: _List_node_base * _M_node;
    };
template < typename _Tp >
    struct _List_const_iterator
    {
      typedef _List_const_iterator < _Tp > _Self;
      typedef const _List_node < _Tp > _Node;
      typedef _List_iterator < _Tp > iterator;
      typedef ptrdiff_t difference_type;
      typedef std :: bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp * pointer;
      typedef const _Tp & reference;
      _List_const_iterator ( ) noexcept
      ;
      explicit
      _List_const_iterator ( const __detail :: _List_node_base * __x )
      noexcept
      ;
      _List_const_iterator ( const iterator & __x ) noexcept
      ;
      iterator
      _M_const_cast ( ) const noexcept
      ;
      reference
      operator * ( ) const noexcept
      ;
      pointer
      operator -> ( ) const noexcept
      ;
      _Self &
      operator ++ ( ) noexcept
      ;
      _Self
      operator ++ ( int ) noexcept
      ;
      _Self &
      operator -- ( ) noexcept
      ;
      _Self
      operator -- ( int ) noexcept
      ;
      bool
      operator == ( const _Self & __x ) const noexcept
      ;
      bool
      operator != ( const _Self & __x ) const noexcept
      ;
      const __detail :: _List_node_base * _M_node;
    };
template < typename _Val >
    inline bool
    operator == ( const _List_iterator < _Val > & __x,
        const _List_const_iterator < _Val > & __y ) noexcept
    { return __x . _M_node == __y . _M_node; }
template < typename _Val >
    inline bool
    operator != ( const _List_iterator < _Val > & __x,
               const _List_const_iterator < _Val > & __y ) noexcept
    { return __x . _M_node != __y . _M_node; }
namespace __cxx11
{
template < typename _Tp, typename _Alloc >
    class _List_base
    {
    protected :
      typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template
 rebind < _Tp > :: other _Tp_alloc_type;
      typedef __gnu_cxx :: __alloc_traits < _Tp_alloc_type > _Tp_alloc_traits;
      typedef typename _Tp_alloc_traits :: template
 rebind < _List_node < _Tp > > :: other _Node_alloc_type;
      typedef __gnu_cxx :: __alloc_traits < _Node_alloc_type > _Node_alloc_traits;
      static size_t
      _S_distance ( const __detail :: _List_node_base * __first,
    const __detail :: _List_node_base * __last )
      ;
      struct _List_impl
      : public _Node_alloc_type
      {
 _List_node < size_t > _M_node;
 _List_impl ( ) noexcept
 ;
 _List_impl ( const _Node_alloc_type & __a ) noexcept
 ;
 _List_impl ( _Node_alloc_type && __a ) noexcept
 ;
      };
      _List_impl _M_impl;
      size_t _M_get_size ( ) const;
      void _M_set_size ( size_t __n );
      void _M_inc_size ( size_t __n );
      void _M_dec_size ( size_t __n );
      size_t
      _M_distance ( const __detail :: _List_node_base * __first,
    const __detail :: _List_node_base * __last ) const
      ;
      size_t _M_node_count ( ) const;
      typename _Node_alloc_traits :: pointer
      _M_get_node ( )
      ;
      void
      _M_put_node ( typename _Node_alloc_traits :: pointer __p ) noexcept
      ;
  public :
      typedef _Alloc allocator_type;
      _Node_alloc_type &
      _M_get_Node_allocator ( ) noexcept
      ;
      const _Node_alloc_type &
      _M_get_Node_allocator ( ) const noexcept
      ;
      _List_base ( )
      ;
      _List_base ( const _Node_alloc_type & __a ) noexcept
      ;
      _List_base ( _List_base && __x ) noexcept
      ;
      _List_base ( _List_base && __x, _Node_alloc_type && __a )
      ;
      void
      _M_move_nodes ( _List_base && __x )
      ;
      ~ _List_base ( ) noexcept
      ;
      void
      _M_clear ( ) noexcept;
      void
      _M_init ( ) noexcept
      ;
    };
template < typename _Tp, typename _Alloc = std :: allocator < _Tp > >
    class list : protected _List_base < _Tp, _Alloc >
    {
      typedef typename _Alloc :: value_type _Alloc_value_type;
      typedef _List_base < _Tp, _Alloc > _Base;
      typedef typename _Base :: _Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base :: _Tp_alloc_traits _Tp_alloc_traits;
      typedef typename _Base :: _Node_alloc_type _Node_alloc_type;
      typedef typename _Base :: _Node_alloc_traits _Node_alloc_traits;
    public :
      typedef _Tp value_type;
      typedef typename _Tp_alloc_traits :: pointer pointer;
      typedef typename _Tp_alloc_traits :: const_pointer const_pointer;
      typedef typename _Tp_alloc_traits :: reference reference;
      typedef typename _Tp_alloc_traits :: const_reference const_reference;
      typedef _List_iterator < _Tp > iterator;
      typedef _List_const_iterator < _Tp > const_iterator;
      typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;
      typedef std :: reverse_iterator < iterator > reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected :
      typedef _List_node < _Tp > _Node;
      using _Base :: _M_impl;
      using _Base :: _M_put_node;
      using _Base :: _M_get_node;
      using _Base :: _M_get_Node_allocator;
      template < typename ... _Args >
        _Node *
        _M_create_node ( _Args && ... __args )
 {
   auto __p = this -> _M_get_node ( );
   auto & __alloc = _M_get_Node_allocator ( );
   __allocated_ptr < _Node_alloc_type > __guard { __alloc, __p };
   _Node_alloc_traits :: construct ( __alloc, __p -> _M_valptr ( ),
     std :: forward < _Args > ( __args ) ... );
   __guard = nullptr;
   return __p;
 }
    public :
      list ( )
      noexcept ( is_nothrow_default_constructible < _Node_alloc_type > :: value )
      ;
      explicit
      list ( const allocator_type & __a ) noexcept
      ;
      explicit
      list ( size_type __n, const allocator_type & __a = allocator_type ( ) )
      ;
      list ( size_type __n, const value_type & __value,
    const allocator_type & __a = allocator_type ( ) )
      ;
      list ( const list & __x )
      ;
      list ( list && __x ) noexcept
      ;
      list ( initializer_list < value_type > __l,
           const allocator_type & __a = allocator_type ( ) )
      ;
      list ( const list & __x, const allocator_type & __a )
      ;
      list ( list && __x, const allocator_type & __a )
      noexcept ( _Node_alloc_traits :: _S_always_equal ( ) )
      ;
      template < typename _InputIterator,
        typename = std :: _RequireInputIter < _InputIterator >>
        list ( _InputIterator __first, _InputIterator __last,
      const allocator_type & __a = allocator_type ( ) )
 : _Base ( _Node_alloc_type ( __a ) )
        { _M_initialize_dispatch ( __first, __last, __false_type ( ) ); }
      list &
      operator = ( const list & __x );
      list &
      operator = ( list && __x )
      noexcept ( _Node_alloc_traits :: _S_nothrow_move ( ) )
      ;
      list &
      operator = ( initializer_list < value_type > __l )
      ;
      void
      assign ( size_type __n, const value_type & __val )
      ;
      template < typename _InputIterator,
        typename = std :: _RequireInputIter < _InputIterator >>
        void
        assign ( _InputIterator __first, _InputIterator __last )
        { _M_assign_dispatch ( __first, __last, __false_type ( ) ); }
      void
      assign ( initializer_list < value_type > __l )
      ;
      allocator_type
      get_allocator ( ) const noexcept
      ;
      iterator
      begin ( ) noexcept
      ;
      const_iterator
      begin ( ) const noexcept
      ;
      iterator
      end ( ) noexcept
      ;
      const_iterator
      end ( ) const noexcept
      ;
      reverse_iterator
      rbegin ( ) noexcept
      ;
      const_reverse_iterator
      rbegin ( ) const noexcept
      ;
      reverse_iterator
      rend ( ) noexcept
      ;
      const_reverse_iterator
      rend ( ) const noexcept
      ;
      const_iterator
      cbegin ( ) const noexcept
      ;
      const_iterator
      cend ( ) const noexcept
      ;
      const_reverse_iterator
      crbegin ( ) const noexcept
      ;
      const_reverse_iterator
      crend ( ) const noexcept
      ;
      bool
      empty ( ) const noexcept
      ;
      size_type
      size ( ) const noexcept
      ;
      size_type
      max_size ( ) const noexcept
      ;
      void
      resize ( size_type __new_size );
      void
      resize ( size_type __new_size, const value_type & __x );
      reference
      front ( ) noexcept
      ;
      const_reference
      front ( ) const noexcept
      ;
      reference
      back ( ) noexcept
      ;
      const_reference
      back ( ) const noexcept
      ;
      void
      push_front ( const value_type & __x )
      ;
      void
      push_front ( value_type && __x )
      ;
      template < typename ... _Args >
        void
        emplace_front ( _Args && ... __args )
        { this -> _M_insert ( begin ( ), std :: forward < _Args > ( __args ) ... ); }
      void
      pop_front ( ) noexcept
      ;
      void
      push_back ( const value_type & __x )
      ;
      void
      push_back ( value_type && __x )
      ;
      template < typename ... _Args >
        void
        emplace_back ( _Args && ... __args )
        { this -> _M_insert ( end ( ), std :: forward < _Args > ( __args ) ... ); }
      void
      pop_back ( ) noexcept
      ;
      template < typename ... _Args >
        iterator
        emplace ( const_iterator __position, _Args && ... __args );
      iterator
      insert ( const_iterator __position, const value_type & __x );
      iterator
      insert ( const_iterator __position, value_type && __x )
      ;
      iterator
      insert ( const_iterator __p, initializer_list < value_type > __l )
      ;
      iterator
      insert ( const_iterator __position, size_type __n, const value_type & __x );
      template < typename _InputIterator,
        typename = std :: _RequireInputIter < _InputIterator >>
 iterator
 insert ( const_iterator __position, _InputIterator __first,
        _InputIterator __last );
      iterator
      erase ( const_iterator __position ) noexcept;
      iterator
      erase ( const_iterator __first, const_iterator __last ) noexcept
      ;
      void
      swap ( list & __x ) noexcept
      ;
      void
      clear ( ) noexcept
      ;
      void
      splice ( const_iterator __position, list && __x ) noexcept
      ;
      void
      splice ( const_iterator __position, list & __x ) noexcept
      ;
      void
      splice ( const_iterator __position, list && __x, const_iterator __i ) noexcept
      ;
      void
      splice ( const_iterator __position, list & __x, const_iterator __i ) noexcept
      ;
      void
      splice ( const_iterator __position, list && __x, const_iterator __first,
      const_iterator __last ) noexcept
      ;
      void
      splice ( const_iterator __position, list & __x, const_iterator __first,
      const_iterator __last ) noexcept
      ;
      void
      remove ( const _Tp & __value );
      template < typename _Predicate >
        void
        remove_if ( _Predicate );
      void
      unique ( );
      template < typename _BinaryPredicate >
        void
        unique ( _BinaryPredicate );
      void
      merge ( list && __x );
      void
      merge ( list & __x )
      ;
      template < typename _StrictWeakOrdering >
        void
        merge ( list && __x, _StrictWeakOrdering __comp );
      template < typename _StrictWeakOrdering >
        void
        merge ( list & __x, _StrictWeakOrdering __comp )
        { merge ( std :: move ( __x ), __comp ); }
      void
      reverse ( ) noexcept
      ;
      void
      sort ( );
      template < typename _StrictWeakOrdering >
        void
        sort ( _StrictWeakOrdering );
    protected :
      template < typename _Integer >
        void
        _M_initialize_dispatch ( _Integer __n, _Integer __x, __true_type )
        { _M_fill_initialize ( static_cast < size_type > ( __n ), __x ); }
      template < typename _InputIterator >
        void
        _M_initialize_dispatch ( _InputIterator __first, _InputIterator __last,
          __false_type )
        {
   for (; __first != __last; ++ __first )
     emplace_back ( * __first );
 }
      void
      _M_fill_initialize ( size_type __n, const value_type & __x )
      ;
      void
      _M_default_initialize ( size_type __n )
      ;
      void
      _M_default_append ( size_type __n );
      template < typename _Integer >
        void
        _M_assign_dispatch ( _Integer __n, _Integer __val, __true_type )
        { _M_fill_assign ( __n, __val ); }
      template < typename _InputIterator >
        void
        _M_assign_dispatch ( _InputIterator __first, _InputIterator __last,
      __false_type );
      void
      _M_fill_assign ( size_type __n, const value_type & __val );
      void
      _M_transfer ( iterator __position, iterator __first, iterator __last )
      ;
     template < typename ... _Args >
       void
       _M_insert ( iterator __position, _Args && ... __args )
       {
  _Node * __tmp = _M_create_node ( std :: forward < _Args > ( __args ) ... );
  __tmp -> _M_hook ( __position . _M_node );
  this -> _M_inc_size ( 1 );
       }
      void
      _M_erase ( iterator __position ) noexcept
      ;
      void
      _M_check_equal_allocators ( list & __x ) noexcept
      ;
      const_iterator
      _M_resize_pos ( size_type & __new_size ) const;
      void
      _M_move_assign ( list && __x, true_type ) noexcept
      ;
      void
      _M_move_assign ( list && __x, false_type )
      ;
    };
}
template < typename _Tp, typename _Alloc >
    inline bool
    operator == ( const list < _Tp, _Alloc > & __x, const list < _Tp, _Alloc > & __y )
    {
      if ( __x . size ( ) != __y . size ( ) )
 return false;
      typedef typename list < _Tp, _Alloc > :: const_iterator const_iterator;
      const_iterator __end1 = __x . end ( );
      const_iterator __end2 = __y . end ( );
      const_iterator __i1 = __x . begin ( );
      const_iterator __i2 = __y . begin ( );
      while ( __i1 != __end1 && __i2 != __end2 && * __i1 == * __i2 )
 {
   ++ __i1;
   ++ __i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
template < typename _Tp, typename _Alloc >
    inline bool
    operator < ( const list < _Tp, _Alloc > & __x, const list < _Tp, _Alloc > & __y )
    { return std :: lexicographical_compare ( __x . begin ( ), __x . end ( ),
       __y . begin ( ), __y . end ( ) ); }
template < typename _Tp, typename _Alloc >
    inline bool
    operator != ( const list < _Tp, _Alloc > & __x, const list < _Tp, _Alloc > & __y )
    { return ! ( __x == __y ); }
template < typename _Tp, typename _Alloc >
    inline bool
    operator > ( const list < _Tp, _Alloc > & __x, const list < _Tp, _Alloc > & __y )
    { return __y < __x; }
template < typename _Tp, typename _Alloc >
    inline bool
    operator <= ( const list < _Tp, _Alloc > & __x, const list < _Tp, _Alloc > & __y )
    { return ! ( __y < __x ); }
template < typename _Tp, typename _Alloc >
    inline bool
    operator >= ( const list < _Tp, _Alloc > & __x, const list < _Tp, _Alloc > & __y )
    { return ! ( __x < __y ); }
template < typename _Tp, typename _Alloc >
    inline void
    swap ( list < _Tp, _Alloc > & __x, list < _Tp, _Alloc > & __y )
    noexcept ( noexcept ( __x . swap ( __y ) ) )
    { __x . swap ( __y ); }
template < typename _Tp >
    inline ptrdiff_t
    __distance ( std :: _List_iterator < _Tp > __first,
        std :: _List_iterator < _Tp > __last,
        input_iterator_tag __tag )
    {
      typedef std :: _List_const_iterator < _Tp > _CIter;
      return std :: __distance ( _CIter ( __first ), _CIter ( __last ), __tag );
    }
template < typename _Tp >
    inline ptrdiff_t
    __distance ( std :: _List_const_iterator < _Tp > __first,
        std :: _List_const_iterator < _Tp > __last,
        input_iterator_tag )
    {
      typedef std :: _List_node < size_t > _Sentinel;
      std :: _List_const_iterator < _Tp > __beyond = __last;
      ++ __beyond;
      bool __whole = __first == __beyond;
      if ( __builtin_constant_p ( __whole ) && __whole )
 return * static_cast < const _Sentinel * > ( __last . _M_node ) -> _M_valptr ( );
      ptrdiff_t __n = 0;
      while ( __first != __last )
 {
   ++ __first;
   ++ __n;
 }
      return __n;
    }
}
namespace std
{
template < typename _Tp, typename _Alloc >
    void
    _List_base < _Tp, _Alloc > ::
    _M_clear ( ) noexcept
    {
      typedef _List_node < _Tp > _Node;
      __detail :: _List_node_base * __cur = _M_impl . _M_node . _M_next;
      while ( __cur != & _M_impl . _M_node )
 {
   _Node * __tmp = static_cast < _Node * > ( __cur );
   __cur = __tmp -> _M_next;
   _Tp * __val = __tmp -> _M_valptr ( );
   _Node_alloc_traits :: destroy ( _M_get_Node_allocator ( ), __val );
   _M_put_node ( __tmp );
 }
    }
template < typename _Tp, typename _Alloc >
    template < typename ... _Args >
      typename list < _Tp, _Alloc > :: iterator
      list < _Tp, _Alloc > ::
      emplace ( const_iterator __position, _Args && ... __args )
      {
 _Node * __tmp = _M_create_node ( std :: forward < _Args > ( __args ) ... );
 __tmp -> _M_hook ( __position . _M_const_cast ( ) . _M_node );
 this -> _M_inc_size ( 1 );
 return iterator ( __tmp );
      }
template < typename _Tp, typename _Alloc >
    typename list < _Tp, _Alloc > :: iterator
    list < _Tp, _Alloc > ::
    insert ( const_iterator __position, const value_type & __x )
    {
      _Node * __tmp = _M_create_node ( __x );
      __tmp -> _M_hook ( __position . _M_const_cast ( ) . _M_node );
      this -> _M_inc_size ( 1 );
      return iterator ( __tmp );
    }
template < typename _Tp, typename _Alloc >
    typename list < _Tp, _Alloc > :: iterator
    list < _Tp, _Alloc > ::
    insert ( const_iterator __position, size_type __n, const value_type & __x )
    {
      if ( __n )
 {
   list __tmp ( __n, __x, get_allocator ( ) );
   iterator __it = __tmp . begin ( );
   splice ( __position, __tmp );
   return __it;
 }
      return __position . _M_const_cast ( );
    }
template < typename _Tp, typename _Alloc >
    template < typename _InputIterator, typename >
      typename list < _Tp, _Alloc > :: iterator
      list < _Tp, _Alloc > ::
      insert ( const_iterator __position, _InputIterator __first,
      _InputIterator __last )
      {
 list __tmp ( __first, __last, get_allocator ( ) );
 if ( ! __tmp . empty ( ) )
   {
     iterator __it = __tmp . begin ( );
     splice ( __position, __tmp );
     return __it;
   }
 return __position . _M_const_cast ( );
      }
template < typename _Tp, typename _Alloc >
    typename list < _Tp, _Alloc > :: iterator
    list < _Tp, _Alloc > ::
    erase ( const_iterator __position ) noexcept
    {
      iterator __ret = iterator ( __position . _M_node -> _M_next );
      _M_erase ( __position . _M_const_cast ( ) );
      return __ret;
    }
template < typename _Tp, typename _Alloc >
    typename list < _Tp, _Alloc > :: const_iterator
    list < _Tp, _Alloc > ::
    _M_resize_pos ( size_type & __new_size ) const
    {
      const_iterator __i;
      const size_type __len = size ( );
      if ( __new_size < __len )
 {
   if ( __new_size <= __len / 2 )
     {
       __i = begin ( );
       std :: advance ( __i, __new_size );
     }
   else
     {
       __i = end ( );
       ptrdiff_t __num_erase = __len - __new_size;
       std :: advance ( __i, - __num_erase );
     }
   __new_size = 0;
   return __i;
 }
      else
 __i = end ( );
      __new_size -= __len;
      return __i;
    }
template < typename _Tp, typename _Alloc >
    void
    list < _Tp, _Alloc > ::
    _M_default_append ( size_type __n )
    {
      size_type __i = 0;
      try
 {
   for (; __i < __n; ++ __i )
     emplace_back ( );
 }
      catch ( ... )
 {
   for (; __i; -- __i )
     pop_back ( );
   throw;
 }
    }
template < typename _Tp, typename _Alloc >
    void
    list < _Tp, _Alloc > ::
    resize ( size_type __new_size )
    {
      const_iterator __i = _M_resize_pos ( __new_size );
      if ( __new_size )
 _M_default_append ( __new_size );
      else
        erase ( __i, end ( ) );
    }
template < typename _Tp, typename _Alloc >
    void
    list < _Tp, _Alloc > ::
    resize ( size_type __new_size, const value_type & __x )
    {
      const_iterator __i = _M_resize_pos ( __new_size );
      if ( __new_size )
        insert ( end ( ), __new_size, __x );
      else
        erase ( __i, end ( ) );
    }
template < typename _Tp, typename _Alloc >
    list < _Tp, _Alloc > &
    list < _Tp, _Alloc > ::
    operator = ( const list & __x )
    {
      if ( this != std :: __addressof ( __x ) )
 {
   if ( _Node_alloc_traits :: _S_propagate_on_copy_assign ( ) )
     {
              auto & __this_alloc = this -> _M_get_Node_allocator ( );
              auto & __that_alloc = __x . _M_get_Node_allocator ( );
              if ( ! _Node_alloc_traits :: _S_always_equal ( )
           && __this_alloc != __that_alloc )
         {
    clear ( );
  }
       std :: __alloc_on_copy ( __this_alloc, __that_alloc );
            }
   _M_assign_dispatch ( __x . begin ( ), __x . end ( ), __false_type ( ) );
 }
      return * this;
    }
template < typename _Tp, typename _Alloc >
    void
    list < _Tp, _Alloc > ::
    _M_fill_assign ( size_type __n, const value_type & __val )
    {
      iterator __i = begin ( );
      for (; __i != end ( ) && __n > 0; ++ __i, -- __n )
        * __i = __val;
      if ( __n > 0 )
        insert ( end ( ), __n, __val );
      else
        erase ( __i, end ( ) );
    }
template < typename _Tp, typename _Alloc >
    template < typename _InputIterator >
      void
      list < _Tp, _Alloc > ::
      _M_assign_dispatch ( _InputIterator __first2, _InputIterator __last2,
    __false_type )
      {
        iterator __first1 = begin ( );
        iterator __last1 = end ( );
        for (; __first1 != __last1 && __first2 != __last2;
      ++ __first1, ++ __first2 )
          * __first1 = * __first2;
        if ( __first2 == __last2 )
          erase ( __first1, __last1 );
        else
          insert ( __last1, __first2, __last2 );
      }
template < typename _Tp, typename _Alloc >
    void
    list < _Tp, _Alloc > ::
    remove ( const value_type & __value )
    {
      iterator __first = begin ( );
      iterator __last = end ( );
      iterator __extra = __last;
      while ( __first != __last )
 {
   iterator __next = __first;
   ++ __next;
   if ( * __first == __value )
     {
       if ( std :: __addressof ( * __first ) != std :: __addressof ( __value ) )
  _M_erase ( __first );
       else
  __extra = __first;
     }
   __first = __next;
 }
      if ( __extra != __last )
 _M_erase ( __extra );
    }
template < typename _Tp, typename _Alloc >
    void
    list < _Tp, _Alloc > ::
    unique ( )
    {
      iterator __first = begin ( );
      iterator __last = end ( );
      if ( __first == __last )
 return;
      iterator __next = __first;
      while ( ++ __next != __last )
 {
   if ( * __first == * __next )
     _M_erase ( __next );
   else
     __first = __next;
   __next = __first;
 }
    }
template < typename _Tp, typename _Alloc >
    void
    list < _Tp, _Alloc > ::
    merge ( list && __x )
    {
      if ( this != std :: __addressof ( __x ) )
 {
   _M_check_equal_allocators ( __x );
   iterator __first1 = begin ( );
   iterator __last1 = end ( );
   iterator __first2 = __x . begin ( );
   iterator __last2 = __x . end ( );
   while ( __first1 != __last1 && __first2 != __last2 )
     if ( * __first2 < * __first1 )
       {
  iterator __next = __first2;
  _M_transfer ( __first1, __first2, ++ __next );
  __first2 = __next;
       }
     else
       ++ __first1;
   if ( __first2 != __last2 )
     _M_transfer ( __last1, __first2, __last2 );
   this -> _M_inc_size ( __x . _M_get_size ( ) );
   __x . _M_set_size ( 0 );
 }
    }
template < typename _Tp, typename _Alloc >
    template < typename _StrictWeakOrdering >
      void
      list < _Tp, _Alloc > ::
      merge ( list && __x, _StrictWeakOrdering __comp )
      {
 if ( this != std :: __addressof ( __x ) )
   {
     _M_check_equal_allocators ( __x );
     iterator __first1 = begin ( );
     iterator __last1 = end ( );
     iterator __first2 = __x . begin ( );
     iterator __last2 = __x . end ( );
     while ( __first1 != __last1 && __first2 != __last2 )
       if ( __comp ( * __first2, * __first1 ) )
  {
    iterator __next = __first2;
    _M_transfer ( __first1, __first2, ++ __next );
    __first2 = __next;
  }
       else
  ++ __first1;
     if ( __first2 != __last2 )
       _M_transfer ( __last1, __first2, __last2 );
     this -> _M_inc_size ( __x . _M_get_size ( ) );
     __x . _M_set_size ( 0 );
   }
      }
template < typename _Tp, typename _Alloc >
    void
    list < _Tp, _Alloc > ::
    sort ( )
    {
      if ( this -> _M_impl . _M_node . _M_next != & this -> _M_impl . _M_node
   && this -> _M_impl . _M_node . _M_next -> _M_next != & this -> _M_impl . _M_node )
      {
        list __carry;
        list __tmp [ 64 ];
        list * __fill = __tmp;
        list * __counter;
        do
   {
     __carry . splice ( __carry . begin ( ), * this, begin ( ) );
     for ( __counter = __tmp;
  __counter != __fill && ! __counter -> empty ( );
  ++ __counter )
       {
  __counter -> merge ( __carry );
  __carry . swap ( * __counter );
       }
     __carry . swap ( * __counter );
     if ( __counter == __fill )
       ++ __fill;
   }
 while ( ! empty ( ) );
        for ( __counter = __tmp + 1; __counter != __fill; ++ __counter )
          __counter -> merge ( * ( __counter - 1 ) );
        swap ( * ( __fill - 1 ) );
      }
    }
template < typename _Tp, typename _Alloc >
    template < typename _Predicate >
      void
      list < _Tp, _Alloc > ::
      remove_if ( _Predicate __pred )
      {
        iterator __first = begin ( );
        iterator __last = end ( );
        while ( __first != __last )
   {
     iterator __next = __first;
     ++ __next;
     if ( __pred ( * __first ) )
       _M_erase ( __first );
     __first = __next;
   }
      }
template < typename _Tp, typename _Alloc >
    template < typename _BinaryPredicate >
      void
      list < _Tp, _Alloc > ::
      unique ( _BinaryPredicate __binary_pred )
      {
        iterator __first = begin ( );
        iterator __last = end ( );
        if ( __first == __last )
   return;
        iterator __next = __first;
        while ( ++ __next != __last )
   {
     if ( __binary_pred ( * __first, * __next ) )
       _M_erase ( __next );
     else
       __first = __next;
     __next = __first;
   }
      }
template < typename _Tp, typename _Alloc >
    template < typename _StrictWeakOrdering >
      void
      list < _Tp, _Alloc > ::
      sort ( _StrictWeakOrdering __comp )
      {
 if ( this -> _M_impl . _M_node . _M_next != & this -> _M_impl . _M_node
     && this -> _M_impl . _M_node . _M_next -> _M_next != & this -> _M_impl . _M_node )
   {
     list __carry;
     list __tmp [ 64 ];
     list * __fill = __tmp;
     list * __counter;
     do
       {
  __carry . splice ( __carry . begin ( ), * this, begin ( ) );
  for ( __counter = __tmp;
      __counter != __fill && ! __counter -> empty ( );
      ++ __counter )
    {
      __counter -> merge ( __carry, __comp );
      __carry . swap ( * __counter );
    }
  __carry . swap ( * __counter );
  if ( __counter == __fill )
    ++ __fill;
       }
     while ( ! empty ( ) );
     for ( __counter = __tmp + 1; __counter != __fill; ++ __counter )
       __counter -> merge ( * ( __counter - 1 ), __comp );
     swap ( * ( __fill - 1 ) );
   }
      }
}
namespace std
{
enum _Rb_tree_color {_S_red=0,_S_black=1} ;

struct _Rb_tree_node_base 
{
typedef struct _Rb_tree_node_base *_Base_ptr;
typedef const struct _Rb_tree_node_base *_Const_Base_ptr;
enum _Rb_tree_color _M_color;
_Base_ptr _M_parent;
_Base_ptr _M_left;
_Base_ptr _M_right;

inline static _Base_ptr _S_minimum(_Base_ptr __x)
{
while(__x -> _M_left != 0)
__x = __x -> _M_left;
return __x;
}

inline static _Const_Base_ptr _S_minimum(_Const_Base_ptr __x)
{
while(__x -> _M_left != 0)
__x = (__x -> _M_left);
return __x;
}

inline static _Base_ptr _S_maximum(_Base_ptr __x)
{
while(__x -> _M_right != 0)
__x = __x -> _M_right;
return __x;
}

inline static _Const_Base_ptr _S_maximum(_Const_Base_ptr __x)
{
while(__x -> _M_right != 0)
__x = (__x -> _M_right);
return __x;
}
}
;
template < typename _Val >
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node < _Val > * _Link_type;
      __gnu_cxx :: __aligned_membuf < _Val > _M_storage;
      _Val *
      _M_valptr ( )
      ;
      const _Val *
      _M_valptr ( ) const
      ;
    };
struct _Rb_tree_node_base *_Rb_tree_increment(struct _Rb_tree_node_base *__x) throw() __attribute__((pure))  __attribute__((no_throw))  __attribute__((visibility("default"))) ;
const struct _Rb_tree_node_base *_Rb_tree_increment(const struct _Rb_tree_node_base *__x) throw() __attribute__((pure))  __attribute__((no_throw))  __attribute__((visibility("default"))) ;
struct _Rb_tree_node_base *_Rb_tree_decrement(struct _Rb_tree_node_base *__x) throw() __attribute__((pure))  __attribute__((no_throw))  __attribute__((visibility("default"))) ;
const struct _Rb_tree_node_base *_Rb_tree_decrement(const struct _Rb_tree_node_base *__x) throw() __attribute__((pure))  __attribute__((no_throw))  __attribute__((visibility("default"))) ;
template < typename _Tp >
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp & reference;
      typedef _Tp * pointer;
      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;
      typedef _Rb_tree_iterator < _Tp > _Self;
      typedef _Rb_tree_node_base :: _Base_ptr _Base_ptr;
      typedef _Rb_tree_node < _Tp > * _Link_type;
      _Rb_tree_iterator ( ) noexcept
      ;
      explicit
      _Rb_tree_iterator ( _Base_ptr __x ) noexcept
      ;
      reference
      operator * ( ) const noexcept
      ;
      pointer
      operator -> ( ) const noexcept
      ;
      _Self &
      operator ++ ( ) noexcept
      ;
      _Self
      operator ++ ( int ) noexcept
      ;
      _Self &
      operator -- ( ) noexcept
      ;
      _Self
      operator -- ( int ) noexcept
      ;
      bool
      operator == ( const _Self & __x ) const noexcept
      ;
      bool
      operator != ( const _Self & __x ) const noexcept
      ;
      _Base_ptr _M_node;
  };
template < typename _Tp >
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp & reference;
      typedef const _Tp * pointer;
      typedef _Rb_tree_iterator < _Tp > iterator;
      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;
      typedef _Rb_tree_const_iterator < _Tp > _Self;
      typedef _Rb_tree_node_base :: _Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node < _Tp > * _Link_type;
      _Rb_tree_const_iterator ( ) noexcept
      ;
      explicit
      _Rb_tree_const_iterator ( _Base_ptr __x ) noexcept
      ;
      _Rb_tree_const_iterator ( const iterator & __it ) noexcept
      ;
      iterator
      _M_const_cast ( ) const noexcept
      ;
      reference
      operator * ( ) const noexcept
      ;
      pointer
      operator -> ( ) const noexcept
      ;
      _Self &
      operator ++ ( ) noexcept
      ;
      _Self
      operator ++ ( int ) noexcept
      ;
      _Self &
      operator -- ( ) noexcept
      ;
      _Self
      operator -- ( int ) noexcept
      ;
      bool
      operator == ( const _Self & __x ) const noexcept
      ;
      bool
      operator != ( const _Self & __x ) const noexcept
      ;
      _Base_ptr _M_node;
    };
template < typename _Val >
    inline bool
    operator == ( const _Rb_tree_iterator < _Val > & __x,
               const _Rb_tree_const_iterator < _Val > & __y ) noexcept
    { return __x . _M_node == __y . _M_node; }
template < typename _Val >
    inline bool
    operator != ( const _Rb_tree_iterator < _Val > & __x,
               const _Rb_tree_const_iterator < _Val > & __y ) noexcept
    { return __x . _M_node != __y . _M_node; }
void _Rb_tree_insert_and_rebalance(const bool __insert_left,struct _Rb_tree_node_base *__x,struct _Rb_tree_node_base *__p,struct _Rb_tree_node_base &__header) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
struct _Rb_tree_node_base *_Rb_tree_rebalance_for_erase(struct _Rb_tree_node_base *const __z,struct _Rb_tree_node_base &__header) throw() __attribute__((no_throw))  __attribute__((visibility("default"))) ;
template < typename _Cmp, typename _SfinaeType, typename = __void_t < > >
    struct __has_is_transparent
    { };
template < typename _Cmp, typename _SfinaeType >
    struct __has_is_transparent < _Cmp, _SfinaeType,
    __void_t < typename _Cmp :: is_transparent > >
    { typedef void type; };
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator < _Val > >
    class _Rb_tree
    {
      typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template
        rebind < _Rb_tree_node < _Val > > :: other _Node_allocator;
      typedef __gnu_cxx :: __alloc_traits < _Node_allocator > _Alloc_traits;
    protected :
      typedef _Rb_tree_node_base * _Base_ptr;
      typedef const _Rb_tree_node_base * _Const_Base_ptr;
      typedef _Rb_tree_node < _Val > * _Link_type;
      typedef const _Rb_tree_node < _Val > * _Const_Link_type;
    private :
      struct _Reuse_or_alloc_node
      {
 _Reuse_or_alloc_node ( _Rb_tree & __t )
   ;
 _Reuse_or_alloc_node ( const _Reuse_or_alloc_node & ) = delete;
 ~ _Reuse_or_alloc_node ( )
 ;
 template < typename _Arg >
   _Link_type
   operator ( ) ( _Arg && __arg )
   {
     _Link_type __node = static_cast < _Link_type > ( _M_extract ( ) );
     if ( __node )
       {
  _M_t . _M_destroy_node ( __node );
  _M_t . _M_construct_node ( __node, std :: forward < _Arg > ( __arg ) );
  return __node;
       }
     return _M_t . _M_create_node ( std :: forward < _Arg > ( __arg ) );
   }
      private :
 _Base_ptr
 _M_extract ( )
 ;
 _Base_ptr _M_root;
 _Base_ptr _M_nodes;
 _Rb_tree & _M_t;
      };
      struct _Alloc_node
      {
 _Alloc_node ( _Rb_tree & __t )
   ;
 template < typename _Arg >
   _Link_type
   operator ( ) ( _Arg && __arg ) const
   { return _M_t . _M_create_node ( std :: forward < _Arg > ( __arg ) ); }
      private :
 _Rb_tree & _M_t;
      };
    public :
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type * pointer;
      typedef const value_type * const_pointer;
      typedef value_type & reference;
      typedef const value_type & const_reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
      _Node_allocator &
      _M_get_Node_allocator ( ) noexcept
      ;
      const _Node_allocator &
      _M_get_Node_allocator ( ) const noexcept
      ;
      allocator_type
      get_allocator ( ) const noexcept
      ;
    protected :
      _Link_type
      _M_get_node ( )
      ;
      void
      _M_put_node ( _Link_type __p ) noexcept
      ;
      template < typename ... _Args >
 void
 _M_construct_node ( _Link_type __node, _Args && ... __args )
 {
   try
     {
       :: new ( __node ) _Rb_tree_node < _Val >;
       _Alloc_traits :: construct ( _M_get_Node_allocator ( ),
           __node -> _M_valptr ( ),
           std :: forward < _Args > ( __args ) ... );
     }
   catch ( ... )
     {
       __node -> ~ _Rb_tree_node < _Val > ( );
       _M_put_node ( __node );
       throw;
     }
 }
      template < typename ... _Args >
        _Link_type
        _M_create_node ( _Args && ... __args )
 {
   _Link_type __tmp = _M_get_node ( );
   _M_construct_node ( __tmp, std :: forward < _Args > ( __args ) ... );
   return __tmp;
 }
      void
      _M_destroy_node ( _Link_type __p ) noexcept
      ;
      void
      _M_drop_node ( _Link_type __p ) noexcept
      ;
      template < typename _NodeGen >
 _Link_type
 _M_clone_node ( _Const_Link_type __x, _NodeGen & __node_gen )
 {
   _Link_type __tmp = __node_gen ( * __x -> _M_valptr ( ) );
   __tmp -> _M_color = __x -> _M_color;
   __tmp -> _M_left = 0;
   __tmp -> _M_right = 0;
   return __tmp;
 }
    protected :
      template < typename _Key_compare,
        bool = __is_pod ( _Key_compare ) >
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;
   _Rb_tree_impl ( )
   ;
   _Rb_tree_impl ( const _Key_compare & __comp, const _Node_allocator & __a )
   ;
   _Rb_tree_impl ( const _Key_compare & __comp, _Node_allocator && __a )
   ;
   void
   _M_reset ( )
   ;
 private :
   void
   _M_initialize ( )
   ;
 };
      _Rb_tree_impl < _Compare > _M_impl;
    protected :
      _Base_ptr &
      _M_root ( ) noexcept
      ;
      _Const_Base_ptr
      _M_root ( ) const noexcept
      ;
      _Base_ptr &
      _M_leftmost ( ) noexcept
      ;
      _Const_Base_ptr
      _M_leftmost ( ) const noexcept
      ;
      _Base_ptr &
      _M_rightmost ( ) noexcept
      ;
      _Const_Base_ptr
      _M_rightmost ( ) const noexcept
      ;
      _Link_type
      _M_begin ( ) noexcept
      ;
      _Const_Link_type
      _M_begin ( ) const noexcept
      ;
      _Base_ptr
      _M_end ( ) noexcept
      ;
      _Const_Base_ptr
      _M_end ( ) const noexcept
      ;
      static const_reference
      _S_value ( _Const_Link_type __x )
      ;
      static const _Key &
      _S_key ( _Const_Link_type __x )
      ;
      static _Link_type
      _S_left ( _Base_ptr __x ) noexcept
      ;
      static _Const_Link_type
      _S_left ( _Const_Base_ptr __x ) noexcept
      ;
      static _Link_type
      _S_right ( _Base_ptr __x ) noexcept
      ;
      static _Const_Link_type
      _S_right ( _Const_Base_ptr __x ) noexcept
      ;
      static const_reference
      _S_value ( _Const_Base_ptr __x )
      ;
      static const _Key &
      _S_key ( _Const_Base_ptr __x )
      ;
      static _Base_ptr
      _S_minimum ( _Base_ptr __x ) noexcept
      ;
      static _Const_Base_ptr
      _S_minimum ( _Const_Base_ptr __x ) noexcept
      ;
      static _Base_ptr
      _S_maximum ( _Base_ptr __x ) noexcept
      ;
      static _Const_Base_ptr
      _S_maximum ( _Const_Base_ptr __x ) noexcept
      ;
    public :
      typedef _Rb_tree_iterator < value_type > iterator;
      typedef _Rb_tree_const_iterator < value_type > const_iterator;
      typedef std :: reverse_iterator < iterator > reverse_iterator;
      typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;
      pair < _Base_ptr, _Base_ptr >
      _M_get_insert_unique_pos ( const key_type & __k );
      pair < _Base_ptr, _Base_ptr >
      _M_get_insert_equal_pos ( const key_type & __k );
      pair < _Base_ptr, _Base_ptr >
      _M_get_insert_hint_unique_pos ( const_iterator __pos,
        const key_type & __k );
      pair < _Base_ptr, _Base_ptr >
      _M_get_insert_hint_equal_pos ( const_iterator __pos,
       const key_type & __k );
    private :
      template < typename _Arg, typename _NodeGen >
        iterator
 _M_insert_ ( _Base_ptr __x, _Base_ptr __y, _Arg && __v, _NodeGen & );
      iterator
      _M_insert_node ( _Base_ptr __x, _Base_ptr __y, _Link_type __z );
      template < typename _Arg >
        iterator
        _M_insert_lower ( _Base_ptr __y, _Arg && __v );
      template < typename _Arg >
        iterator
        _M_insert_equal_lower ( _Arg && __x );
      iterator
      _M_insert_lower_node ( _Base_ptr __p, _Link_type __z );
      iterator
      _M_insert_equal_lower_node ( _Link_type __z );
      template < typename _NodeGen >
 _Link_type
 _M_copy ( _Const_Link_type __x, _Base_ptr __p, _NodeGen & );
      _Link_type
      _M_copy ( _Const_Link_type __x, _Base_ptr __p )
      ;
      void
      _M_erase ( _Link_type __x );
      iterator
      _M_lower_bound ( _Link_type __x, _Base_ptr __y,
       const _Key & __k );
      const_iterator
      _M_lower_bound ( _Const_Link_type __x, _Const_Base_ptr __y,
       const _Key & __k ) const;
      iterator
      _M_upper_bound ( _Link_type __x, _Base_ptr __y,
       const _Key & __k );
      const_iterator
      _M_upper_bound ( _Const_Link_type __x, _Const_Base_ptr __y,
       const _Key & __k ) const;
    public :
      _Rb_tree ( );
      _Rb_tree ( const _Compare & __comp,
        const allocator_type & __a = allocator_type ( ) )
      ;
      _Rb_tree ( const _Rb_tree & __x )
      ;
      _Rb_tree ( const allocator_type & __a )
      ;
      _Rb_tree ( const _Rb_tree & __x, const allocator_type & __a )
      ;
      _Rb_tree ( _Rb_tree && __x )
      ;
      _Rb_tree ( _Rb_tree && __x, const allocator_type & __a )
      ;
      _Rb_tree ( _Rb_tree && __x, _Node_allocator && __a );
      ~ _Rb_tree ( ) noexcept
      ;
      _Rb_tree &
      operator = ( const _Rb_tree & __x );
      _Compare
      key_comp ( ) const
      ;
      iterator
      begin ( ) noexcept
      ;
      const_iterator
      begin ( ) const noexcept
      ;
      iterator
      end ( ) noexcept
      ;
      const_iterator
      end ( ) const noexcept
      ;
      reverse_iterator
      rbegin ( ) noexcept
      ;
      const_reverse_iterator
      rbegin ( ) const noexcept
      ;
      reverse_iterator
      rend ( ) noexcept
      ;
      const_reverse_iterator
      rend ( ) const noexcept
      ;
      bool
      empty ( ) const noexcept
      ;
      size_type
      size ( ) const noexcept
      ;
      size_type
      max_size ( ) const noexcept
      ;
      void
      swap ( _Rb_tree & __t )
      noexcept ( __is_nothrow_swappable < _Compare > :: value );
      template < typename _Arg >
        pair < iterator, bool >
        _M_insert_unique ( _Arg && __x );
      template < typename _Arg >
        iterator
        _M_insert_equal ( _Arg && __x );
      template < typename _Arg, typename _NodeGen >
        iterator
 _M_insert_unique_ ( const_iterator __pos, _Arg && __x, _NodeGen & );
      template < typename _Arg >
 iterator
 _M_insert_unique_ ( const_iterator __pos, _Arg && __x )
 {
   _Alloc_node __an ( * this );
   return _M_insert_unique_ ( __pos, std :: forward < _Arg > ( __x ), __an );
 }
      template < typename _Arg, typename _NodeGen >
 iterator
 _M_insert_equal_ ( const_iterator __pos, _Arg && __x, _NodeGen & );
      template < typename _Arg >
 iterator
 _M_insert_equal_ ( const_iterator __pos, _Arg && __x )
 {
   _Alloc_node __an ( * this );
   return _M_insert_equal_ ( __pos, std :: forward < _Arg > ( __x ), __an );
 }
      template < typename ... _Args >
 pair < iterator, bool >
 _M_emplace_unique ( _Args && ... __args );
      template < typename ... _Args >
 iterator
 _M_emplace_equal ( _Args && ... __args );
      template < typename ... _Args >
 iterator
 _M_emplace_hint_unique ( const_iterator __pos, _Args && ... __args );
      template < typename ... _Args >
 iterator
 _M_emplace_hint_equal ( const_iterator __pos, _Args && ... __args );
      template < typename _InputIterator >
        void
        _M_insert_unique ( _InputIterator __first, _InputIterator __last );
      template < typename _InputIterator >
        void
        _M_insert_equal ( _InputIterator __first, _InputIterator __last );
    private :
      void
      _M_erase_aux ( const_iterator __position );
      void
      _M_erase_aux ( const_iterator __first, const_iterator __last );
    public :
      __attribute__ ( ( __abi_tag__ ( "cxx11" ) ) )
      iterator
      erase ( const_iterator __position )
      ;
      __attribute__ ( ( __abi_tag__ ( "cxx11" ) ) )
      iterator
      erase ( iterator __position )
      ;
      size_type
      erase ( const key_type & __x );
      __attribute__ ( ( __abi_tag__ ( "cxx11" ) ) )
      iterator
      erase ( const_iterator __first, const_iterator __last )
      ;
      void
      erase ( const key_type * __first, const key_type * __last );
      void
      clear ( ) noexcept
      ;
      iterator
      find ( const key_type & __k );
      const_iterator
      find ( const key_type & __k ) const;
      size_type
      count ( const key_type & __k ) const;
      iterator
      lower_bound ( const key_type & __k )
      ;
      const_iterator
      lower_bound ( const key_type & __k ) const
      ;
      iterator
      upper_bound ( const key_type & __k )
      ;
      const_iterator
      upper_bound ( const key_type & __k ) const
      ;
      pair < iterator, iterator >
      equal_range ( const key_type & __k );
      pair < const_iterator, const_iterator >
      equal_range ( const key_type & __k ) const;
      template < typename _Kt,
        typename _Req =
   typename __has_is_transparent < _Compare, _Kt > :: type >
 iterator
 _M_find_tr ( const _Kt & __k )
 {
   const _Rb_tree * __const_this = this;
   return __const_this -> _M_find_tr ( __k ) . _M_const_cast ( );
 }
      template < typename _Kt,
        typename _Req =
   typename __has_is_transparent < _Compare, _Kt > :: type >
 const_iterator
 _M_find_tr ( const _Kt & __k ) const
 {
   auto __j = _M_lower_bound_tr ( __k );
   if ( __j != end ( ) && _M_impl . _M_key_compare ( __k, _S_key ( __j . _M_node ) ) )
     __j = end ( );
   return __j;
 }
      template < typename _Kt,
        typename _Req =
   typename __has_is_transparent < _Compare, _Kt > :: type >
 size_type
 _M_count_tr ( const _Kt & __k ) const
 {
   auto __p = _M_equal_range_tr ( __k );
   return std :: distance ( __p . first, __p . second );
 }
      template < typename _Kt,
        typename _Req =
   typename __has_is_transparent < _Compare, _Kt > :: type >
 iterator
 _M_lower_bound_tr ( const _Kt & __k )
 {
   const _Rb_tree * __const_this = this;
   return __const_this -> _M_lower_bound_tr ( __k ) . _M_const_cast ( );
 }
      template < typename _Kt,
        typename _Req =
   typename __has_is_transparent < _Compare, _Kt > :: type >
 const_iterator
 _M_lower_bound_tr ( const _Kt & __k ) const
 {
   auto __x = _M_begin ( );
   auto __y = _M_end ( );
   while ( __x != 0 )
     if ( ! _M_impl . _M_key_compare ( _S_key ( __x ), __k ) )
       {
  __y = __x;
  __x = _S_left ( __x );
       }
     else
       __x = _S_right ( __x );
   return const_iterator ( __y );
 }
      template < typename _Kt,
        typename _Req =
   typename __has_is_transparent < _Compare, _Kt > :: type >
 iterator
 _M_upper_bound_tr ( const _Kt & __k )
 {
   const _Rb_tree * __const_this = this;
   return __const_this -> _M_upper_bound_tr ( __k ) . _M_const_cast ( );
 }
      template < typename _Kt,
        typename _Req =
   typename __has_is_transparent < _Compare, _Kt > :: type >
 const_iterator
 _M_upper_bound_tr ( const _Kt & __k ) const
 {
   auto __x = _M_begin ( );
   auto __y = _M_end ( );
   while ( __x != 0 )
     if ( _M_impl . _M_key_compare ( __k, _S_key ( __x ) ) )
       {
  __y = __x;
  __x = _S_left ( __x );
       }
     else
       __x = _S_right ( __x );
   return const_iterator ( __y );
 }
      template < typename _Kt,
        typename _Req =
   typename __has_is_transparent < _Compare, _Kt > :: type >
 pair < iterator, iterator >
 _M_equal_range_tr ( const _Kt & __k )
 {
   const _Rb_tree * __const_this = this;
   auto __ret = __const_this -> _M_equal_range_tr ( __k );
   return { __ret . first . _M_const_cast ( ), __ret . second . _M_const_cast ( ) };
 }
      template < typename _Kt,
        typename _Req =
   typename __has_is_transparent < _Compare, _Kt > :: type >
 pair < const_iterator, const_iterator >
 _M_equal_range_tr ( const _Kt & __k ) const
 {
   auto __low = _M_lower_bound_tr ( __k );
   auto __high = __low;
   auto & __cmp = _M_impl . _M_key_compare;
   while ( __high != end ( ) && ! __cmp ( __k, _S_key ( __high . _M_node ) ) )
     ++ __high;
   return { __low, __high };
 }
      bool
      __rb_verify ( ) const;
      _Rb_tree &
      operator = ( _Rb_tree && )
      noexcept ( _Alloc_traits :: _S_nothrow_move ( )
        && is_nothrow_move_assignable < _Compare > :: value );
      template < typename _Iterator >
 void
 _M_assign_unique ( _Iterator, _Iterator );
      template < typename _Iterator >
 void
 _M_assign_equal ( _Iterator, _Iterator );
    private :
      void
      _M_move_data ( _Rb_tree &, std :: true_type );
      void
      _M_move_data ( _Rb_tree &, std :: false_type );
    };
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    inline bool
    operator == ( const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x,
        const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y )
    {
      return __x . size ( ) == __y . size ( )
      && std :: equal ( __x . begin ( ), __x . end ( ), __y . begin ( ) );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    inline bool
    operator < ( const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x,
       const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y )
    {
      return std :: lexicographical_compare ( __x . begin ( ), __x . end ( ),
       __y . begin ( ), __y . end ( ) );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    inline bool
    operator != ( const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x,
        const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y )
    { return ! ( __x == __y ); }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    inline bool
    operator > ( const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x,
       const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y )
    { return __y < __x; }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    inline bool
    operator <= ( const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x,
        const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y )
    { return ! ( __y < __x ); }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    inline bool
    operator >= ( const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x,
        const _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y )
    { return ! ( __x < __y ); }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    inline void
    swap ( _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x,
  _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y )
    { __x . swap ( __y ); }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _Rb_tree ( _Rb_tree && __x, _Node_allocator && __a )
    : _M_impl ( __x . _M_impl . _M_key_compare, std :: move ( __a ) )
    {
      using __eq = typename _Alloc_traits :: is_always_equal;
      if ( __x . _M_root ( ) != nullptr )
 _M_move_data ( __x, __eq ( ) );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    void
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_move_data ( _Rb_tree & __x, std :: true_type )
    {
      _M_root ( ) = __x . _M_root ( );
      _M_leftmost ( ) = __x . _M_leftmost ( );
      _M_rightmost ( ) = __x . _M_rightmost ( );
      _M_root ( ) -> _M_parent = _M_end ( );
      __x . _M_root ( ) = 0;
      __x . _M_leftmost ( ) = __x . _M_end ( );
      __x . _M_rightmost ( ) = __x . _M_end ( );
      this -> _M_impl . _M_node_count = __x . _M_impl . _M_node_count;
      __x . _M_impl . _M_node_count = 0;
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    void
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_move_data ( _Rb_tree & __x, std :: false_type )
    {
      if ( _M_get_Node_allocator ( ) == __x . _M_get_Node_allocator ( ) )
   _M_move_data ( __x, std :: true_type ( ) );
      else
 {
   _Alloc_node __an ( * this );
   auto __lbd =
     [ & __an ] ( const value_type & __cval )
     {
       auto & __val = const_cast < value_type & > ( __cval );
       return __an ( std :: move_if_noexcept ( __val ) );
     };
   _M_root ( ) = _M_copy ( __x . _M_begin ( ), _M_end ( ), __lbd );
   _M_leftmost ( ) = _S_minimum ( _M_root ( ) );
   _M_rightmost ( ) = _S_maximum ( _M_root ( ) );
   _M_impl . _M_node_count = __x . _M_impl . _M_node_count;
 }
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > &
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    operator = ( _Rb_tree && __x )
    noexcept ( _Alloc_traits :: _S_nothrow_move ( )
      && is_nothrow_move_assignable < _Compare > :: value )
    {
      _M_impl . _M_key_compare = __x . _M_impl . _M_key_compare;
      if ( _Alloc_traits :: _S_propagate_on_move_assign ( )
   || _Alloc_traits :: _S_always_equal ( )
   || _M_get_Node_allocator ( ) == __x . _M_get_Node_allocator ( ) )
 {
   clear ( );
   if ( __x . _M_root ( ) != nullptr )
     _M_move_data ( __x, std :: true_type ( ) );
   std :: __alloc_on_move ( _M_get_Node_allocator ( ),
          __x . _M_get_Node_allocator ( ) );
   return * this;
 }
      _Reuse_or_alloc_node __roan ( * this );
      _M_impl . _M_reset ( );
      if ( __x . _M_root ( ) != nullptr )
 {
   auto __lbd =
     [ & __roan ] ( const value_type & __cval )
     {
       auto & __val = const_cast < value_type & > ( __cval );
       return __roan ( std :: move_if_noexcept ( __val ) );
     };
   _M_root ( ) = _M_copy ( __x . _M_begin ( ), _M_end ( ), __lbd );
   _M_leftmost ( ) = _S_minimum ( _M_root ( ) );
   _M_rightmost ( ) = _S_maximum ( _M_root ( ) );
   _M_impl . _M_node_count = __x . _M_impl . _M_node_count;
   __x . clear ( );
 }
      return * this;
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename _Iterator >
      void
      _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
      _M_assign_unique ( _Iterator __first, _Iterator __last )
      {
 _Reuse_or_alloc_node __roan ( * this );
 _M_impl . _M_reset ( );
 for (; __first != __last; ++ __first )
   _M_insert_unique_ ( end ( ), * __first, __roan );
      }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename _Iterator >
      void
      _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
      _M_assign_equal ( _Iterator __first, _Iterator __last )
      {
 _Reuse_or_alloc_node __roan ( * this );
 _M_impl . _M_reset ( );
 for (; __first != __last; ++ __first )
   _M_insert_equal_ ( end ( ), * __first, __roan );
      }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > &
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    operator = ( const _Rb_tree & __x )
    {
      if ( this != & __x )
 {
   if ( _Alloc_traits :: _S_propagate_on_copy_assign ( ) )
     {
       auto & __this_alloc = this -> _M_get_Node_allocator ( );
       auto & __that_alloc = __x . _M_get_Node_allocator ( );
       if ( ! _Alloc_traits :: _S_always_equal ( )
    && __this_alloc != __that_alloc )
  {
    clear ( );
    std :: __alloc_on_copy ( __this_alloc, __that_alloc );
  }
     }
   _Reuse_or_alloc_node __roan ( * this );
   _M_impl . _M_reset ( );
   _M_impl . _M_key_compare = __x . _M_impl . _M_key_compare;
   if ( __x . _M_root ( ) != 0 )
     {
       _M_root ( ) = _M_copy ( __x . _M_begin ( ), _M_end ( ), __roan );
       _M_leftmost ( ) = _S_minimum ( _M_root ( ) );
       _M_rightmost ( ) = _S_maximum ( _M_root ( ) );
       _M_impl . _M_node_count = __x . _M_impl . _M_node_count;
     }
 }
      return * this;
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename _Arg, typename _NodeGen >
      typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
      _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
      _M_insert_ ( _Base_ptr __x, _Base_ptr __p,
   _Arg && __v,
   _NodeGen & __node_gen )
      {
 bool __insert_left = ( __x != 0 || __p == _M_end ( )
         || _M_impl . _M_key_compare ( _KeyOfValue ( ) ( __v ),
       _S_key ( __p ) ) );
 _Link_type __z = __node_gen ( std :: forward < _Arg > ( __v ) );
 _Rb_tree_insert_and_rebalance ( __insert_left, __z, __p,
          this -> _M_impl . _M_header );
 ++ _M_impl . _M_node_count;
 return iterator ( __z );
      }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename _Arg >
    typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_insert_lower ( _Base_ptr __p, _Arg && __v )
    {
      bool __insert_left = ( __p == _M_end ( )
       || ! _M_impl . _M_key_compare ( _S_key ( __p ),
             _KeyOfValue ( ) ( __v ) ) );
      _Link_type __z = _M_create_node ( std :: forward < _Arg > ( __v ) );
      _Rb_tree_insert_and_rebalance ( __insert_left, __z, __p,
        this -> _M_impl . _M_header );
      ++ _M_impl . _M_node_count;
      return iterator ( __z );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename _Arg >
    typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_insert_equal_lower ( _Arg && __v )
    {
      _Link_type __x = _M_begin ( );
      _Base_ptr __y = _M_end ( );
      while ( __x != 0 )
 {
   __y = __x;
   __x = ! _M_impl . _M_key_compare ( _S_key ( __x ), _KeyOfValue ( ) ( __v ) ) ?
         _S_left ( __x ) : _S_right ( __x );
 }
      return _M_insert_lower ( __y, std :: forward < _Arg > ( __v ) );
    }
template < typename _Key, typename _Val, typename _KoV,
    typename _Compare, typename _Alloc >
    template < typename _NodeGen >
      typename _Rb_tree < _Key, _Val, _KoV, _Compare, _Alloc > :: _Link_type
      _Rb_tree < _Key, _Val, _KoV, _Compare, _Alloc > ::
      _M_copy ( _Const_Link_type __x, _Base_ptr __p, _NodeGen & __node_gen )
      {
 _Link_type __top = _M_clone_node ( __x, __node_gen );
 __top -> _M_parent = __p;
 try
   {
     if ( __x -> _M_right )
       __top -> _M_right = _M_copy ( _S_right ( __x ), __top, __node_gen );
     __p = __top;
     __x = _S_left ( __x );
     while ( __x != 0 )
       {
  _Link_type __y = _M_clone_node ( __x, __node_gen );
  __p -> _M_left = __y;
  __y -> _M_parent = __p;
  if ( __x -> _M_right )
    __y -> _M_right = _M_copy ( _S_right ( __x ), __y, __node_gen );
  __p = __y;
  __x = _S_left ( __x );
       }
   }
 catch ( ... )
   {
     _M_erase ( __top );
     throw;
   }
 return __top;
      }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    void
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_erase ( _Link_type __x )
    {
      while ( __x != 0 )
 {
   _M_erase ( _S_right ( __x ) );
   _Link_type __y = _S_left ( __x );
   _M_drop_node ( __x );
   __x = __y;
 }
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    typename _Rb_tree < _Key, _Val, _KeyOfValue,
        _Compare, _Alloc > :: iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_lower_bound ( _Link_type __x, _Base_ptr __y,
     const _Key & __k )
    {
      while ( __x != 0 )
 if ( ! _M_impl . _M_key_compare ( _S_key ( __x ), __k ) )
   __y = __x, __x = _S_left ( __x );
 else
   __x = _S_right ( __x );
      return iterator ( __y );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    typename _Rb_tree < _Key, _Val, _KeyOfValue,
        _Compare, _Alloc > :: const_iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_lower_bound ( _Const_Link_type __x, _Const_Base_ptr __y,
     const _Key & __k ) const
    {
      while ( __x != 0 )
 if ( ! _M_impl . _M_key_compare ( _S_key ( __x ), __k ) )
   __y = __x, __x = _S_left ( __x );
 else
   __x = _S_right ( __x );
      return const_iterator ( __y );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    typename _Rb_tree < _Key, _Val, _KeyOfValue,
        _Compare, _Alloc > :: iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_upper_bound ( _Link_type __x, _Base_ptr __y,
     const _Key & __k )
    {
      while ( __x != 0 )
 if ( _M_impl . _M_key_compare ( __k, _S_key ( __x ) ) )
   __y = __x, __x = _S_left ( __x );
 else
   __x = _S_right ( __x );
      return iterator ( __y );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    typename _Rb_tree < _Key, _Val, _KeyOfValue,
        _Compare, _Alloc > :: const_iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_upper_bound ( _Const_Link_type __x, _Const_Base_ptr __y,
     const _Key & __k ) const
    {
      while ( __x != 0 )
 if ( _M_impl . _M_key_compare ( __k, _S_key ( __x ) ) )
   __y = __x, __x = _S_left ( __x );
 else
   __x = _S_right ( __x );
      return const_iterator ( __y );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    pair < typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: iterator,
  typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: iterator >
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    equal_range ( const _Key & __k )
    {
      _Link_type __x = _M_begin ( );
      _Base_ptr __y = _M_end ( );
      while ( __x != 0 )
 {
   if ( _M_impl . _M_key_compare ( _S_key ( __x ), __k ) )
     __x = _S_right ( __x );
   else if ( _M_impl . _M_key_compare ( __k, _S_key ( __x ) ) )
     __y = __x, __x = _S_left ( __x );
   else
     {
       _Link_type __xu ( __x );
       _Base_ptr __yu ( __y );
       __y = __x, __x = _S_left ( __x );
       __xu = _S_right ( __xu );
       return pair < iterator,
            iterator > ( _M_lower_bound ( __x, __y, __k ),
        _M_upper_bound ( __xu, __yu, __k ) );
     }
 }
      return pair < iterator, iterator > ( iterator ( __y ),
          iterator ( __y ) );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    pair < typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: const_iterator,
  typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: const_iterator >
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    equal_range ( const _Key & __k ) const
    {
      _Const_Link_type __x = _M_begin ( );
      _Const_Base_ptr __y = _M_end ( );
      while ( __x != 0 )
 {
   if ( _M_impl . _M_key_compare ( _S_key ( __x ), __k ) )
     __x = _S_right ( __x );
   else if ( _M_impl . _M_key_compare ( __k, _S_key ( __x ) ) )
     __y = __x, __x = _S_left ( __x );
   else
     {
       _Const_Link_type __xu ( __x );
       _Const_Base_ptr __yu ( __y );
       __y = __x, __x = _S_left ( __x );
       __xu = _S_right ( __xu );
       return pair < const_iterator,
            const_iterator > ( _M_lower_bound ( __x, __y, __k ),
       _M_upper_bound ( __xu, __yu, __k ) );
     }
 }
      return pair < const_iterator, const_iterator > ( const_iterator ( __y ),
        const_iterator ( __y ) );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    void
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    swap ( _Rb_tree & __t )
    noexcept ( __is_nothrow_swappable < _Compare > :: value )
    {
      if ( _M_root ( ) == 0 )
 {
   if ( __t . _M_root ( ) != 0 )
     {
       _M_root ( ) = __t . _M_root ( );
       _M_leftmost ( ) = __t . _M_leftmost ( );
       _M_rightmost ( ) = __t . _M_rightmost ( );
       _M_root ( ) -> _M_parent = _M_end ( );
       _M_impl . _M_node_count = __t . _M_impl . _M_node_count;
       __t . _M_impl . _M_reset ( );
     }
 }
      else if ( __t . _M_root ( ) == 0 )
 {
   __t . _M_root ( ) = _M_root ( );
   __t . _M_leftmost ( ) = _M_leftmost ( );
   __t . _M_rightmost ( ) = _M_rightmost ( );
   __t . _M_root ( ) -> _M_parent = __t . _M_end ( );
   __t . _M_impl . _M_node_count = _M_impl . _M_node_count;
   _M_impl . _M_reset ( );
 }
      else
 {
   std :: swap ( _M_root ( ), __t . _M_root ( ) );
   std :: swap ( _M_leftmost ( ), __t . _M_leftmost ( ) );
   std :: swap ( _M_rightmost ( ), __t . _M_rightmost ( ) );
   _M_root ( ) -> _M_parent = _M_end ( );
   __t . _M_root ( ) -> _M_parent = __t . _M_end ( );
   std :: swap ( this -> _M_impl . _M_node_count, __t . _M_impl . _M_node_count );
 }
      std :: swap ( this -> _M_impl . _M_key_compare, __t . _M_impl . _M_key_compare );
      _Alloc_traits :: _S_on_swap ( _M_get_Node_allocator ( ),
    __t . _M_get_Node_allocator ( ) );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    pair < typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: _Base_ptr,
  typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: _Base_ptr >
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_get_insert_unique_pos ( const key_type & __k )
    {
      typedef pair < _Base_ptr, _Base_ptr > _Res;
      _Link_type __x = _M_begin ( );
      _Base_ptr __y = _M_end ( );
      bool __comp = true;
      while ( __x != 0 )
 {
   __y = __x;
   __comp = _M_impl . _M_key_compare ( __k, _S_key ( __x ) );
   __x = __comp ? _S_left ( __x ) : _S_right ( __x );
 }
      iterator __j = iterator ( __y );
      if ( __comp )
 {
   if ( __j == begin ( ) )
     return _Res ( __x, __y );
   else
     -- __j;
 }
      if ( _M_impl . _M_key_compare ( _S_key ( __j . _M_node ), __k ) )
 return _Res ( __x, __y );
      return _Res ( __j . _M_node, 0 );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    pair < typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: _Base_ptr,
  typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: _Base_ptr >
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_get_insert_equal_pos ( const key_type & __k )
    {
      typedef pair < _Base_ptr, _Base_ptr > _Res;
      _Link_type __x = _M_begin ( );
      _Base_ptr __y = _M_end ( );
      while ( __x != 0 )
 {
   __y = __x;
   __x = _M_impl . _M_key_compare ( __k, _S_key ( __x ) ) ?
         _S_left ( __x ) : _S_right ( __x );
 }
      return _Res ( __x, __y );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename _Arg >
    pair < typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: iterator, bool >
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_insert_unique ( _Arg && __v )
    {
      typedef pair < iterator, bool > _Res;
      pair < _Base_ptr, _Base_ptr > __res
 = _M_get_insert_unique_pos ( _KeyOfValue ( ) ( __v ) );
      if ( __res . second )
 {
   _Alloc_node __an ( * this );
   return _Res ( _M_insert_ ( __res . first, __res . second,
     std :: forward < _Arg > ( __v ), __an ),
        true );
 }
      return _Res ( iterator ( __res . first ), false );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename _Arg >
    typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_insert_equal ( _Arg && __v )
    {
      pair < _Base_ptr, _Base_ptr > __res
 = _M_get_insert_equal_pos ( _KeyOfValue ( ) ( __v ) );
      _Alloc_node __an ( * this );
      return _M_insert_ ( __res . first, __res . second,
   std :: forward < _Arg > ( __v ), __an );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    pair < typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: _Base_ptr,
         typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: _Base_ptr >
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_get_insert_hint_unique_pos ( const_iterator __position,
      const key_type & __k )
    {
      iterator __pos = __position . _M_const_cast ( );
      typedef pair < _Base_ptr, _Base_ptr > _Res;
      if ( __pos . _M_node == _M_end ( ) )
 {
   if ( size ( ) > 0
       && _M_impl . _M_key_compare ( _S_key ( _M_rightmost ( ) ), __k ) )
     return _Res ( 0, _M_rightmost ( ) );
   else
     return _M_get_insert_unique_pos ( __k );
 }
      else if ( _M_impl . _M_key_compare ( __k, _S_key ( __pos . _M_node ) ) )
 {
   iterator __before = __pos;
   if ( __pos . _M_node == _M_leftmost ( ) )
     return _Res ( _M_leftmost ( ), _M_leftmost ( ) );
   else if ( _M_impl . _M_key_compare ( _S_key ( ( -- __before ) . _M_node ), __k ) )
     {
       if ( _S_right ( __before . _M_node ) == 0 )
  return _Res ( 0, __before . _M_node );
       else
  return _Res ( __pos . _M_node, __pos . _M_node );
     }
   else
     return _M_get_insert_unique_pos ( __k );
 }
      else if ( _M_impl . _M_key_compare ( _S_key ( __pos . _M_node ), __k ) )
 {
   iterator __after = __pos;
   if ( __pos . _M_node == _M_rightmost ( ) )
     return _Res ( 0, _M_rightmost ( ) );
   else if ( _M_impl . _M_key_compare ( __k, _S_key ( ( ++ __after ) . _M_node ) ) )
     {
       if ( _S_right ( __pos . _M_node ) == 0 )
  return _Res ( 0, __pos . _M_node );
       else
  return _Res ( __after . _M_node, __after . _M_node );
     }
   else
     return _M_get_insert_unique_pos ( __k );
 }
      else
 return _Res ( __pos . _M_node, 0 );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename _Arg, typename _NodeGen >
      typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
      _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
      _M_insert_unique_ ( const_iterator __position,
   _Arg && __v,
   _NodeGen & __node_gen )
    {
      pair < _Base_ptr, _Base_ptr > __res
 = _M_get_insert_hint_unique_pos ( __position, _KeyOfValue ( ) ( __v ) );
      if ( __res . second )
 return _M_insert_ ( __res . first, __res . second,
     std :: forward < _Arg > ( __v ),
     __node_gen );
      return iterator ( __res . first );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    pair < typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: _Base_ptr,
         typename _Rb_tree < _Key, _Val, _KeyOfValue,
      _Compare, _Alloc > :: _Base_ptr >
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_get_insert_hint_equal_pos ( const_iterator __position, const key_type & __k )
    {
      iterator __pos = __position . _M_const_cast ( );
      typedef pair < _Base_ptr, _Base_ptr > _Res;
      if ( __pos . _M_node == _M_end ( ) )
 {
   if ( size ( ) > 0
       && ! _M_impl . _M_key_compare ( __k, _S_key ( _M_rightmost ( ) ) ) )
     return _Res ( 0, _M_rightmost ( ) );
   else
     return _M_get_insert_equal_pos ( __k );
 }
      else if ( ! _M_impl . _M_key_compare ( _S_key ( __pos . _M_node ), __k ) )
 {
   iterator __before = __pos;
   if ( __pos . _M_node == _M_leftmost ( ) )
     return _Res ( _M_leftmost ( ), _M_leftmost ( ) );
   else if ( ! _M_impl . _M_key_compare ( __k, _S_key ( ( -- __before ) . _M_node ) ) )
     {
       if ( _S_right ( __before . _M_node ) == 0 )
  return _Res ( 0, __before . _M_node );
       else
  return _Res ( __pos . _M_node, __pos . _M_node );
     }
   else
     return _M_get_insert_equal_pos ( __k );
 }
      else
 {
   iterator __after = __pos;
   if ( __pos . _M_node == _M_rightmost ( ) )
     return _Res ( 0, _M_rightmost ( ) );
   else if ( ! _M_impl . _M_key_compare ( _S_key ( ( ++ __after ) . _M_node ), __k ) )
     {
       if ( _S_right ( __pos . _M_node ) == 0 )
  return _Res ( 0, __pos . _M_node );
       else
  return _Res ( __after . _M_node, __after . _M_node );
     }
   else
     return _Res ( 0, 0 );
 }
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename _Arg, typename _NodeGen >
      typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
      _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
      _M_insert_equal_ ( const_iterator __position,
         _Arg && __v,
         _NodeGen & __node_gen )
      {
 pair < _Base_ptr, _Base_ptr > __res
   = _M_get_insert_hint_equal_pos ( __position, _KeyOfValue ( ) ( __v ) );
 if ( __res . second )
   return _M_insert_ ( __res . first, __res . second,
       std :: forward < _Arg > ( __v ),
       __node_gen );
 return _M_insert_equal_lower ( std :: forward < _Arg > ( __v ) );
      }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_insert_node ( _Base_ptr __x, _Base_ptr __p, _Link_type __z )
    {
      bool __insert_left = ( __x != 0 || __p == _M_end ( )
       || _M_impl . _M_key_compare ( _S_key ( __z ),
            _S_key ( __p ) ) );
      _Rb_tree_insert_and_rebalance ( __insert_left, __z, __p,
        this -> _M_impl . _M_header );
      ++ _M_impl . _M_node_count;
      return iterator ( __z );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_insert_lower_node ( _Base_ptr __p, _Link_type __z )
    {
      bool __insert_left = ( __p == _M_end ( )
       || ! _M_impl . _M_key_compare ( _S_key ( __p ),
             _S_key ( __z ) ) );
      _Rb_tree_insert_and_rebalance ( __insert_left, __z, __p,
        this -> _M_impl . _M_header );
      ++ _M_impl . _M_node_count;
      return iterator ( __z );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_insert_equal_lower_node ( _Link_type __z )
    {
      _Link_type __x = _M_begin ( );
      _Base_ptr __y = _M_end ( );
      while ( __x != 0 )
 {
   __y = __x;
   __x = ! _M_impl . _M_key_compare ( _S_key ( __x ), _S_key ( __z ) ) ?
         _S_left ( __x ) : _S_right ( __x );
 }
      return _M_insert_lower_node ( __y, __z );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename ... _Args >
      pair < typename _Rb_tree < _Key, _Val, _KeyOfValue,
        _Compare, _Alloc > :: iterator, bool >
      _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
      _M_emplace_unique ( _Args && ... __args )
      {
 _Link_type __z = _M_create_node ( std :: forward < _Args > ( __args ) ... );
 try
   {
     typedef pair < iterator, bool > _Res;
     auto __res = _M_get_insert_unique_pos ( _S_key ( __z ) );
     if ( __res . second )
       return _Res ( _M_insert_node ( __res . first, __res . second, __z ), true );
     _M_drop_node ( __z );
     return _Res ( iterator ( __res . first ), false );
   }
 catch ( ... )
   {
     _M_drop_node ( __z );
     throw;
   }
      }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename ... _Args >
      typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
      _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
      _M_emplace_equal ( _Args && ... __args )
      {
 _Link_type __z = _M_create_node ( std :: forward < _Args > ( __args ) ... );
 try
   {
     auto __res = _M_get_insert_equal_pos ( _S_key ( __z ) );
     return _M_insert_node ( __res . first, __res . second, __z );
   }
 catch ( ... )
   {
     _M_drop_node ( __z );
     throw;
   }
      }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename ... _Args >
      typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
      _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
      _M_emplace_hint_unique ( const_iterator __pos, _Args && ... __args )
      {
 _Link_type __z = _M_create_node ( std :: forward < _Args > ( __args ) ... );
 try
   {
     auto __res = _M_get_insert_hint_unique_pos ( __pos, _S_key ( __z ) );
     if ( __res . second )
       return _M_insert_node ( __res . first, __res . second, __z );
     _M_drop_node ( __z );
     return iterator ( __res . first );
   }
 catch ( ... )
   {
     _M_drop_node ( __z );
     throw;
   }
      }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    template < typename ... _Args >
      typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: iterator
      _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
      _M_emplace_hint_equal ( const_iterator __pos, _Args && ... __args )
      {
 _Link_type __z = _M_create_node ( std :: forward < _Args > ( __args ) ... );
 try
   {
     auto __res = _M_get_insert_hint_equal_pos ( __pos, _S_key ( __z ) );
     if ( __res . second )
       return _M_insert_node ( __res . first, __res . second, __z );
     return _M_insert_equal_lower_node ( __z );
   }
 catch ( ... )
   {
     _M_drop_node ( __z );
     throw;
   }
      }
template < typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc >
    template < class _II >
      void
      _Rb_tree < _Key, _Val, _KoV, _Cmp, _Alloc > ::
      _M_insert_unique ( _II __first, _II __last )
      {
 _Alloc_node __an ( * this );
 for (; __first != __last; ++ __first )
   _M_insert_unique_ ( end ( ), * __first, __an );
      }
template < typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc >
    template < class _II >
      void
      _Rb_tree < _Key, _Val, _KoV, _Cmp, _Alloc > ::
      _M_insert_equal ( _II __first, _II __last )
      {
 _Alloc_node __an ( * this );
 for (; __first != __last; ++ __first )
   _M_insert_equal_ ( end ( ), * __first, __an );
      }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    void
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_erase_aux ( const_iterator __position )
    {
      _Link_type __y =
 static_cast < _Link_type > ( _Rb_tree_rebalance_for_erase
    ( const_cast < _Base_ptr > ( __position . _M_node ),
     this -> _M_impl . _M_header ) );
      _M_drop_node ( __y );
      -- _M_impl . _M_node_count;
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    void
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    _M_erase_aux ( const_iterator __first, const_iterator __last )
    {
      if ( __first == begin ( ) && __last == end ( ) )
 clear ( );
      else
 while ( __first != __last )
   erase ( __first ++ );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: size_type
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    erase ( const _Key & __x )
    {
      pair < iterator, iterator > __p = equal_range ( __x );
      const size_type __old_size = size ( );
      erase ( __p . first, __p . second );
      return __old_size - size ( );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    void
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    erase ( const _Key * __first, const _Key * __last )
    {
      while ( __first != __last )
 erase ( * __first ++ );
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    typename _Rb_tree < _Key, _Val, _KeyOfValue,
        _Compare, _Alloc > :: iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    find ( const _Key & __k )
    {
      iterator __j = _M_lower_bound ( _M_begin ( ), _M_end ( ), __k );
      return ( __j == end ( )
       || _M_impl . _M_key_compare ( __k,
     _S_key ( __j . _M_node ) ) ) ? end ( ) : __j;
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    typename _Rb_tree < _Key, _Val, _KeyOfValue,
        _Compare, _Alloc > :: const_iterator
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    find ( const _Key & __k ) const
    {
      const_iterator __j = _M_lower_bound ( _M_begin ( ), _M_end ( ), __k );
      return ( __j == end ( )
       || _M_impl . _M_key_compare ( __k,
     _S_key ( __j . _M_node ) ) ) ? end ( ) : __j;
    }
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    typename _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: size_type
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > ::
    count ( const _Key & __k ) const
    {
      pair < const_iterator, const_iterator > __p = equal_range ( __k );
      const size_type __n = std :: distance ( __p . first, __p . second );
      return __n;
    }
unsigned int _Rb_tree_black_count(const struct _Rb_tree_node_base *__node,const struct _Rb_tree_node_base *__root) throw() __attribute__((pure))  __attribute__((no_throw))  __attribute__((visibility("default"))) ;
template < typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc >
    bool
    _Rb_tree < _Key, _Val, _KeyOfValue, _Compare, _Alloc > :: __rb_verify ( ) const
    {
      if ( _M_impl . _M_node_count == 0 || begin ( ) == end ( ) )
 return _M_impl . _M_node_count == 0 && begin ( ) == end ( )
        && this -> _M_impl . _M_header . _M_left == _M_end ( )
        && this -> _M_impl . _M_header . _M_right == _M_end ( );
      unsigned int __len = _Rb_tree_black_count ( _M_leftmost ( ), _M_root ( ) );
      for ( const_iterator __it = begin ( ); __it != end ( ); ++ __it )
 {
   _Const_Link_type __x = static_cast < _Const_Link_type > ( __it . _M_node );
   _Const_Link_type __L = _S_left ( __x );
   _Const_Link_type __R = _S_right ( __x );
   if ( __x -> _M_color == _S_red )
     if ( ( __L && __L -> _M_color == _S_red )
  || ( __R && __R -> _M_color == _S_red ) )
       return false;
   if ( __L && _M_impl . _M_key_compare ( _S_key ( __x ), _S_key ( __L ) ) )
     return false;
   if ( __R && _M_impl . _M_key_compare ( _S_key ( __R ), _S_key ( __x ) ) )
     return false;
   if ( ! __L && ! __R && _Rb_tree_black_count ( __x, _M_root ( ) ) != __len )
     return false;
 }
      if ( _M_leftmost ( ) != _Rb_tree_node_base :: _S_minimum ( _M_root ( ) ) )
 return false;
      if ( _M_rightmost ( ) != _Rb_tree_node_base :: _S_maximum ( _M_root ( ) ) )
 return false;
      return true;
    }
}
namespace std
{

struct __erased_type 
{
}
;
template < typename _Alloc, typename _Tp >
    using __is_erased_or_convertible
      = __or_ < is_same < _Tp, __erased_type >, is_convertible < _Alloc, _Tp >>;

struct allocator_arg_t 
{
inline explicit allocator_arg_t() = default;
}
;
constexpr struct allocator_arg_t allocator_arg;
template < typename _Tp, typename _Alloc, typename = __void_t < > >
    struct __uses_allocator_helper
    : false_type { };
template < typename _Tp, typename _Alloc >
    struct __uses_allocator_helper < _Tp, _Alloc,
       __void_t < typename _Tp :: allocator_type > >
    : __is_erased_or_convertible < _Alloc, typename _Tp :: allocator_type > :: type
    { };
template < typename _Tp, typename _Alloc >
    struct uses_allocator
    : __uses_allocator_helper < _Tp, _Alloc > :: type
    { };

struct __uses_alloc_base 
{
}
;

struct __uses_alloc0 : public __uses_alloc_base
{
struct _Sink {

inline void operator=(const void *)
{
}
}_M_a;
}
;
template < typename _Alloc >
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc * _M_a; };
template < typename _Alloc >
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc * _M_a; };
template < bool, typename _Tp, typename _Alloc, typename ... _Args >
    struct __uses_alloc;
template < typename _Tp, typename _Alloc, typename ... _Args >
    struct __uses_alloc < true, _Tp, _Alloc, _Args ... >
    : conditional <
        is_constructible < _Tp, allocator_arg_t, _Alloc, _Args ... > :: value,
        __uses_alloc1 < _Alloc >,
        __uses_alloc2 < _Alloc >> :: type
    {
      static_assert ( __or_ <
   is_constructible < _Tp, allocator_arg_t, _Alloc, _Args ... >,
   is_constructible < _Tp, _Args ..., _Alloc >> :: value, "construction with an allocator must be possible if uses_allocator is true"
                                                             );
    };
template < typename _Tp, typename _Alloc, typename ... _Args >
    struct __uses_alloc < false, _Tp, _Alloc, _Args ... >
    : __uses_alloc0 { };
template < typename _Tp, typename _Alloc, typename ... _Args >
    using __uses_alloc_t =
      __uses_alloc < uses_allocator < _Tp, _Alloc > :: value, _Tp, _Alloc, _Args ... >;
template < typename _Tp, typename _Alloc, typename ... _Args >
    inline __uses_alloc_t < _Tp, _Alloc, _Args ... >
    __use_alloc ( const _Alloc & __a )
    {
      __uses_alloc_t < _Tp, _Alloc, _Args ... > __ret;
      __ret . _M_a = std :: __addressof ( __a );
      return __ret;
    }
}
namespace std
{
template < std :: size_t _Idx, typename _Head, bool _IsEmptyNotFinal >
    struct _Head_base;
template < std :: size_t _Idx, typename _Head >
    struct _Head_base < _Idx, _Head, true >
    : public _Head
    {
      constexpr _Head_base ( )
      ;
      constexpr _Head_base ( const _Head & __h )
      ;
      constexpr _Head_base ( const _Head_base & ) = default;
      constexpr _Head_base ( _Head_base && ) = default;
      template < typename _UHead >
        constexpr _Head_base ( _UHead && __h )
 : _Head ( std :: forward < _UHead > ( __h ) ) { }
      _Head_base ( allocator_arg_t, __uses_alloc0 )
      ;
      template < typename _Alloc >
 _Head_base ( allocator_arg_t, __uses_alloc1 < _Alloc > __a )
 : _Head ( allocator_arg, * __a . _M_a ) { }
      template < typename _Alloc >
 _Head_base ( allocator_arg_t, __uses_alloc2 < _Alloc > __a )
 : _Head ( * __a . _M_a ) { }
      template < typename _UHead >
 _Head_base ( __uses_alloc0, _UHead && __uhead )
 : _Head ( std :: forward < _UHead > ( __uhead ) ) { }
      template < typename _Alloc, typename _UHead >
 _Head_base ( __uses_alloc1 < _Alloc > __a, _UHead && __uhead )
 : _Head ( allocator_arg, * __a . _M_a, std :: forward < _UHead > ( __uhead ) ) { }
      template < typename _Alloc, typename _UHead >
 _Head_base ( __uses_alloc2 < _Alloc > __a, _UHead && __uhead )
 : _Head ( std :: forward < _UHead > ( __uhead ), * __a . _M_a ) { }
      static constexpr _Head &
      _M_head ( _Head_base & __b ) noexcept;
      static constexpr const _Head &
      _M_head ( const _Head_base & __b ) noexcept;
    };
template < std :: size_t _Idx, typename _Head >
    struct _Head_base < _Idx, _Head, false >
    {
      constexpr _Head_base ( )
      ;
      constexpr _Head_base ( const _Head & __h )
      ;
      constexpr _Head_base ( const _Head_base & ) = default;
      constexpr _Head_base ( _Head_base && ) = default;
      template < typename _UHead >
        constexpr _Head_base ( _UHead && __h )
 : _M_head_impl ( std :: forward < _UHead > ( __h ) ) { }
      _Head_base ( allocator_arg_t, __uses_alloc0 )
      ;
      template < typename _Alloc >
 _Head_base ( allocator_arg_t, __uses_alloc1 < _Alloc > __a )
 : _M_head_impl ( allocator_arg, * __a . _M_a ) { }
      template < typename _Alloc >
 _Head_base ( allocator_arg_t, __uses_alloc2 < _Alloc > __a )
 : _M_head_impl ( * __a . _M_a ) { }
      template < typename _UHead >
 _Head_base ( __uses_alloc0, _UHead && __uhead )
 : _M_head_impl ( std :: forward < _UHead > ( __uhead ) ) { }
      template < typename _Alloc, typename _UHead >
 _Head_base ( __uses_alloc1 < _Alloc > __a, _UHead && __uhead )
 : _M_head_impl ( allocator_arg, * __a . _M_a, std :: forward < _UHead > ( __uhead ) )
 { }
      template < typename _Alloc, typename _UHead >
 _Head_base ( __uses_alloc2 < _Alloc > __a, _UHead && __uhead )
 : _M_head_impl ( std :: forward < _UHead > ( __uhead ), * __a . _M_a ) { }
      static constexpr _Head &
      _M_head ( _Head_base & __b ) noexcept;
      static constexpr const _Head &
      _M_head ( const _Head_base & __b ) noexcept;
      _Head _M_head_impl;
    };
template < std :: size_t _Idx, typename ... _Elements >
    struct _Tuple_impl;
template < typename _Tp >
    struct __is_empty_non_tuple : is_empty < _Tp > { };
template < typename _El0, typename ... _El >
    struct __is_empty_non_tuple < tuple < _El0, _El ... > > : false_type { };
template < typename _Tp >
    using __empty_not_final
    = typename conditional < __is_final ( _Tp ), false_type,
      __is_empty_non_tuple < _Tp >> :: type;
template < std :: size_t _Idx, typename _Head, typename ... _Tail >
    struct _Tuple_impl < _Idx, _Head, _Tail ... >
    : public _Tuple_impl < _Idx + 1, _Tail ... >,
      private _Head_base < _Idx, _Head, __empty_not_final < _Head > :: value >
    {
      template < std :: size_t, typename ... > friend class _Tuple_impl;
      typedef _Tuple_impl < _Idx + 1, _Tail ... > _Inherited;
      typedef _Head_base < _Idx, _Head, __empty_not_final < _Head > :: value > _Base;
      static constexpr _Head &
      _M_head ( _Tuple_impl & __t ) noexcept;
      static constexpr const _Head &
      _M_head ( const _Tuple_impl & __t ) noexcept;
      static constexpr _Inherited &
      _M_tail ( _Tuple_impl & __t ) noexcept;
      static constexpr const _Inherited &
      _M_tail ( const _Tuple_impl & __t ) noexcept;
      constexpr _Tuple_impl ( )
      ;
      explicit
      constexpr _Tuple_impl ( const _Head & __head, const _Tail & ... __tail )
      ;
      template < typename _UHead, typename ... _UTail, typename = typename
               enable_if < sizeof ... ( _Tail ) == sizeof ... ( _UTail ) > :: type >
        explicit
        constexpr _Tuple_impl ( _UHead && __head, _UTail && ... __tail )
 : _Inherited ( std :: forward < _UTail > ( __tail ) ... ),
   _Base ( std :: forward < _UHead > ( __head ) ) { }
      constexpr _Tuple_impl ( const _Tuple_impl & ) = default;
      constexpr
      _Tuple_impl ( _Tuple_impl && __in )
      noexcept ( __and_ < is_nothrow_move_constructible < _Head >,
               is_nothrow_move_constructible < _Inherited >> :: value )
      ;
      template < typename ... _UElements >
        constexpr _Tuple_impl ( const _Tuple_impl < _Idx, _UElements ... > & __in )
 : _Inherited ( _Tuple_impl < _Idx, _UElements ... > :: _M_tail ( __in ) ),
   _Base ( _Tuple_impl < _Idx, _UElements ... > :: _M_head ( __in ) ) { }
      template < typename _UHead, typename ... _UTails >
        constexpr _Tuple_impl ( _Tuple_impl < _Idx, _UHead, _UTails ... > && __in )
 : _Inherited ( std :: move
       ( _Tuple_impl < _Idx, _UHead, _UTails ... > :: _M_tail ( __in ) ) ),
   _Base ( std :: forward < _UHead >
  ( _Tuple_impl < _Idx, _UHead, _UTails ... > :: _M_head ( __in ) ) ) { }
      template < typename _Alloc >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a )
 : _Inherited ( __tag, __a ),
          _Base ( __tag, __use_alloc < _Head > ( __a ) ) { }
      template < typename _Alloc >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
      const _Head & __head, const _Tail & ... __tail )
 : _Inherited ( __tag, __a, __tail ... ),
          _Base ( __use_alloc < _Head, _Alloc, _Head > ( __a ), __head ) { }
      template < typename _Alloc, typename _UHead, typename ... _UTail,
               typename = typename enable_if < sizeof ... ( _Tail )
          == sizeof ... ( _UTail ) > :: type >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
             _UHead && __head, _UTail && ... __tail )
 : _Inherited ( __tag, __a, std :: forward < _UTail > ( __tail ) ... ),
          _Base ( __use_alloc < _Head, _Alloc, _UHead > ( __a ),
         std :: forward < _UHead > ( __head ) ) { }
      template < typename _Alloc >
        _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
             const _Tuple_impl & __in )
 : _Inherited ( __tag, __a, _M_tail ( __in ) ),
          _Base ( __use_alloc < _Head, _Alloc, _Head > ( __a ), _M_head ( __in ) ) { }
      template < typename _Alloc >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
             _Tuple_impl && __in )
 : _Inherited ( __tag, __a, std :: move ( _M_tail ( __in ) ) ),
   _Base ( __use_alloc < _Head, _Alloc, _Head > ( __a ),
         std :: forward < _Head > ( _M_head ( __in ) ) ) { }
      template < typename _Alloc, typename ... _UElements >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
             const _Tuple_impl < _Idx, _UElements ... > & __in )
 : _Inherited ( __tag, __a,
       _Tuple_impl < _Idx, _UElements ... > :: _M_tail ( __in ) ),
   _Base ( __use_alloc < _Head, _Alloc, _Head > ( __a ),
  _Tuple_impl < _Idx, _UElements ... > :: _M_head ( __in ) ) { }
      template < typename _Alloc, typename _UHead, typename ... _UTails >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
             _Tuple_impl < _Idx, _UHead, _UTails ... > && __in )
 : _Inherited ( __tag, __a, std :: move
       ( _Tuple_impl < _Idx, _UHead, _UTails ... > :: _M_tail ( __in ) ) ),
   _Base ( __use_alloc < _Head, _Alloc, _UHead > ( __a ),
                std :: forward < _UHead >
  ( _Tuple_impl < _Idx, _UHead, _UTails ... > :: _M_head ( __in ) ) ) { }
      _Tuple_impl &
      operator = ( const _Tuple_impl & __in )
      ;
      _Tuple_impl &
      operator = ( _Tuple_impl && __in )
      noexcept ( __and_ < is_nothrow_move_assignable < _Head >,
               is_nothrow_move_assignable < _Inherited >> :: value )
      ;
      template < typename ... _UElements >
        _Tuple_impl &
        operator = ( const _Tuple_impl < _Idx, _UElements ... > & __in )
        {
   _M_head ( * this ) = _Tuple_impl < _Idx, _UElements ... > :: _M_head ( __in );
   _M_tail ( * this ) = _Tuple_impl < _Idx, _UElements ... > :: _M_tail ( __in );
   return * this;
 }
      template < typename _UHead, typename ... _UTails >
        _Tuple_impl &
        operator = ( _Tuple_impl < _Idx, _UHead, _UTails ... > && __in )
        {
   _M_head ( * this ) = std :: forward < _UHead >
     ( _Tuple_impl < _Idx, _UHead, _UTails ... > :: _M_head ( __in ) );
   _M_tail ( * this ) = std :: move
     ( _Tuple_impl < _Idx, _UHead, _UTails ... > :: _M_tail ( __in ) );
   return * this;
 }
    protected :
      void
      _M_swap ( _Tuple_impl & __in )
      noexcept ( __is_nothrow_swappable < _Head > :: value
               && noexcept ( _M_tail ( __in ) . _M_swap ( _M_tail ( __in ) ) ) )
      ;
    };
template < std :: size_t _Idx, typename _Head >
    struct _Tuple_impl < _Idx, _Head >
    : private _Head_base < _Idx, _Head, __empty_not_final < _Head > :: value >
    {
      template < std :: size_t, typename ... > friend class _Tuple_impl;
      typedef _Head_base < _Idx, _Head, __empty_not_final < _Head > :: value > _Base;
      static constexpr _Head &
      _M_head ( _Tuple_impl & __t ) noexcept;
      static constexpr const _Head &
      _M_head ( const _Tuple_impl & __t ) noexcept;
      constexpr _Tuple_impl ( )
      ;
      explicit
      constexpr _Tuple_impl ( const _Head & __head )
      ;
      template < typename _UHead >
        explicit
        constexpr _Tuple_impl ( _UHead && __head )
 : _Base ( std :: forward < _UHead > ( __head ) ) { }
      constexpr _Tuple_impl ( const _Tuple_impl & ) = default;
      constexpr
      _Tuple_impl ( _Tuple_impl && __in )
      noexcept ( is_nothrow_move_constructible < _Head > :: value )
      ;
      template < typename _UHead >
        constexpr _Tuple_impl ( const _Tuple_impl < _Idx, _UHead > & __in )
 : _Base ( _Tuple_impl < _Idx, _UHead > :: _M_head ( __in ) ) { }
      template < typename _UHead >
        constexpr _Tuple_impl ( _Tuple_impl < _Idx, _UHead > && __in )
 : _Base ( std :: forward < _UHead > ( _Tuple_impl < _Idx, _UHead > :: _M_head ( __in ) ) )
 { }
      template < typename _Alloc >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a )
 : _Base ( __tag, __use_alloc < _Head > ( __a ) ) { }
      template < typename _Alloc >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
      const _Head & __head )
 : _Base ( __use_alloc < _Head, _Alloc, _Head > ( __a ), __head ) { }
      template < typename _Alloc, typename _UHead >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
             _UHead && __head )
 : _Base ( __use_alloc < _Head, _Alloc, _UHead > ( __a ),
         std :: forward < _UHead > ( __head ) ) { }
      template < typename _Alloc >
        _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
             const _Tuple_impl & __in )
 : _Base ( __use_alloc < _Head, _Alloc, _Head > ( __a ), _M_head ( __in ) ) { }
      template < typename _Alloc >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
             _Tuple_impl && __in )
 : _Base ( __use_alloc < _Head, _Alloc, _Head > ( __a ),
         std :: forward < _Head > ( _M_head ( __in ) ) ) { }
      template < typename _Alloc, typename _UHead >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
             const _Tuple_impl < _Idx, _UHead > & __in )
 : _Base ( __use_alloc < _Head, _Alloc, _Head > ( __a ),
  _Tuple_impl < _Idx, _UHead > :: _M_head ( __in ) ) { }
      template < typename _Alloc, typename _UHead >
 _Tuple_impl ( allocator_arg_t __tag, const _Alloc & __a,
             _Tuple_impl < _Idx, _UHead > && __in )
 : _Base ( __use_alloc < _Head, _Alloc, _UHead > ( __a ),
                std :: forward < _UHead > ( _Tuple_impl < _Idx, _UHead > :: _M_head ( __in ) ) )
 { }
      _Tuple_impl &
      operator = ( const _Tuple_impl & __in )
      ;
      _Tuple_impl &
      operator = ( _Tuple_impl && __in )
      noexcept ( is_nothrow_move_assignable < _Head > :: value )
      ;
      template < typename _UHead >
        _Tuple_impl &
        operator = ( const _Tuple_impl < _Idx, _UHead > & __in )
        {
   _M_head ( * this ) = _Tuple_impl < _Idx, _UHead > :: _M_head ( __in );
   return * this;
 }
      template < typename _UHead >
        _Tuple_impl &
        operator = ( _Tuple_impl < _Idx, _UHead > && __in )
        {
   _M_head ( * this )
     = std :: forward < _UHead > ( _Tuple_impl < _Idx, _UHead > :: _M_head ( __in ) );
   return * this;
 }
    protected :
      void
      _M_swap ( _Tuple_impl & __in )
      noexcept ( __is_nothrow_swappable < _Head > :: value )
      ;
    };
template < typename ... _Elements >
    class tuple;
template < bool, typename ... _Elements >
  struct _TC
  {
    template < typename ... _UElements >
    static constexpr bool _ConstructibleTuple ( )
    {
      return __and_ < is_constructible < _Elements, const _UElements & > ... > :: value;
    }
    template < typename ... _UElements >
    static constexpr bool _ImplicitlyConvertibleTuple ( )
    {
      return __and_ < is_convertible < const _UElements &, _Elements > ... > :: value;
    }
    template < typename ... _UElements >
    static constexpr bool _MoveConstructibleTuple ( )
    {
      return __and_ < is_constructible < _Elements, _UElements && > ... > :: value;
    }
    template < typename ... _UElements >
    static constexpr bool _ImplicitlyMoveConvertibleTuple ( )
    {
      return __and_ < is_convertible < _UElements &&, _Elements > ... > :: value;
    }
    template < typename _SrcTuple >
    static constexpr bool _NonNestedTuple ( )
    {
      return __and_ < __not_ < is_same < tuple < _Elements ... >,
                                   typename remove_cv <
                                     typename remove_reference < _SrcTuple > :: type
                                   > :: type >>,
                     __not_ < is_convertible < _SrcTuple, _Elements ... >>,
                     __not_ < is_constructible < _Elements ..., _SrcTuple >>
              > :: value;
    }
  };
template < typename ... _Elements >
  struct _TC < false, _Elements ... >
  {
    template < typename ... _UElements >
    static constexpr bool _ConstructibleTuple ( )
    {
      return false;
    }
    template < typename ... _UElements >
    static constexpr bool _ImplicitlyConvertibleTuple ( )
    {
      return false;
    }
    template < typename ... _UElements >
    static constexpr bool _MoveConstructibleTuple ( )
    {
      return false;
    }
    template < typename ... _UElements >
    static constexpr bool _ImplicitlyMoveConvertibleTuple ( )
    {
      return false;
    }
    template < typename ... _UElements >
    static constexpr bool _NonNestedTuple ( )
    {
      return true;
    }
  };
template < typename ... _Elements >
    class tuple : public _Tuple_impl < 0, _Elements ... >
    {
      typedef _Tuple_impl < 0, _Elements ... > _Inherited;
      template < typename _Dummy >
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple ( )
        ;
        static constexpr bool _ImplicitlyDefaultConstructibleTuple ( )
        ;
      };
    public :
      template < typename _Dummy = void,
               typename enable_if < _TC2 < _Dummy > ::
                                    _ImplicitlyDefaultConstructibleTuple ( ),
                                  bool > :: type = true >
      constexpr tuple ( )
      : _Inherited ( ) { }
      template < typename _Dummy = void,
               typename enable_if < _TC2 < _Dummy > ::
                                    _DefaultConstructibleTuple ( )
                                  &&
                                  ! _TC2 < _Dummy > ::
                                    _ImplicitlyDefaultConstructibleTuple ( ),
                                  bool > :: type = false >
      explicit constexpr tuple ( )
      : _Inherited ( ) { }
      template < typename _Dummy > using _TCC =
        _TC < is_same < _Dummy, void > :: value,
            _Elements ... >;
      template < typename _Dummy = void,
               typename enable_if <
                 _TCC < _Dummy > :: template
                   _ConstructibleTuple < _Elements ... > ( )
                 && _TCC < _Dummy > :: template
                   _ImplicitlyConvertibleTuple < _Elements ... > ( )
                 && ( sizeof ... ( _Elements ) >= 1 ),
               bool > :: type = true >
        constexpr tuple ( const _Elements & ... __elements )
      : _Inherited ( __elements ... ) { }
      template < typename _Dummy = void,
               typename enable_if <
                 _TCC < _Dummy > :: template
                   _ConstructibleTuple < _Elements ... > ( )
                 && ! _TCC < _Dummy > :: template
                   _ImplicitlyConvertibleTuple < _Elements ... > ( )
                 && ( sizeof ... ( _Elements ) >= 1 ),
               bool > :: type = false >
      explicit constexpr tuple ( const _Elements & ... __elements )
      : _Inherited ( __elements ... ) { }
      template < typename ... _UElements > using _TMC =
                  _TC < ( sizeof ... ( _Elements ) == sizeof ... ( _UElements ) ),
                      _Elements ... >;
      template < typename ... _UElements, typename
        enable_if < _TMC < _UElements ... > :: template
                    _MoveConstructibleTuple < _UElements ... > ( )
                  && _TMC < _UElements ... > :: template
                    _ImplicitlyMoveConvertibleTuple < _UElements ... > ( )
                  && ( sizeof ... ( _Elements ) >= 1 ),
        bool > :: type = true >
        constexpr tuple ( _UElements && ... __elements )
        : _Inherited ( std :: forward < _UElements > ( __elements ) ... ) { }
      template < typename ... _UElements, typename
        enable_if < _TMC < _UElements ... > :: template
                    _MoveConstructibleTuple < _UElements ... > ( )
                  && ! _TMC < _UElements ... > :: template
                    _ImplicitlyMoveConvertibleTuple < _UElements ... > ( )
                  && ( sizeof ... ( _Elements ) >= 1 ),
        bool > :: type = false >
        explicit constexpr tuple ( _UElements && ... __elements )
 : _Inherited ( std :: forward < _UElements > ( __elements ) ... ) { }
      constexpr tuple ( const tuple & ) = default;
      constexpr tuple ( tuple && ) = default;
      template < typename _Dummy > using _TNTC =
        _TC < is_same < _Dummy, void > :: value && sizeof ... ( _Elements ) == 1,
            _Elements ... >;
      template < typename ... _UElements, typename _Dummy = void, typename
        enable_if < _TMC < _UElements ... > :: template
                    _ConstructibleTuple < _UElements ... > ( )
                  && _TMC < _UElements ... > :: template
                    _ImplicitlyConvertibleTuple < _UElements ... > ( )
                  && _TNTC < _Dummy > :: template
                    _NonNestedTuple < const tuple < _UElements ... > & > ( ),
        bool > :: type = true >
        constexpr tuple ( const tuple < _UElements ... > & __in )
        : _Inherited ( static_cast < const _Tuple_impl < 0, _UElements ... > & > ( __in ) )
        { }
      template < typename ... _UElements, typename _Dummy = void, typename
        enable_if < _TMC < _UElements ... > :: template
                    _ConstructibleTuple < _UElements ... > ( )
                  && ! _TMC < _UElements ... > :: template
                    _ImplicitlyConvertibleTuple < _UElements ... > ( )
                  && _TNTC < _Dummy > :: template
                    _NonNestedTuple < const tuple < _UElements ... > & > ( ),
        bool > :: type = false >
        explicit constexpr tuple ( const tuple < _UElements ... > & __in )
        : _Inherited ( static_cast < const _Tuple_impl < 0, _UElements ... > & > ( __in ) )
        { }
      template < typename ... _UElements, typename _Dummy = void, typename
        enable_if < _TMC < _UElements ... > :: template
                    _MoveConstructibleTuple < _UElements ... > ( )
                  && _TMC < _UElements ... > :: template
                    _ImplicitlyMoveConvertibleTuple < _UElements ... > ( )
                  && _TNTC < _Dummy > :: template
                    _NonNestedTuple < tuple < _UElements ... > && > ( ),
        bool > :: type = true >
        constexpr tuple ( tuple < _UElements ... > && __in )
        : _Inherited ( static_cast < _Tuple_impl < 0, _UElements ... > && > ( __in ) ) { }
      template < typename ... _UElements, typename _Dummy = void, typename
        enable_if < _TMC < _UElements ... > :: template
                    _MoveConstructibleTuple < _UElements ... > ( )
                  && ! _TMC < _UElements ... > :: template
                    _ImplicitlyMoveConvertibleTuple < _UElements ... > ( )
                  && _TNTC < _Dummy > :: template
                    _NonNestedTuple < tuple < _UElements ... > && > ( ),
        bool > :: type = false >
        explicit constexpr tuple ( tuple < _UElements ... > && __in )
        : _Inherited ( static_cast < _Tuple_impl < 0, _UElements ... > && > ( __in ) ) { }
      template < typename _Alloc >
 tuple ( allocator_arg_t __tag, const _Alloc & __a )
 : _Inherited ( __tag, __a ) { }
      template < typename _Alloc, typename _Dummy = void,
               typename enable_if <
                 _TCC < _Dummy > :: template
                   _ConstructibleTuple < _Elements ... > ( )
                 && _TCC < _Dummy > :: template
                   _ImplicitlyConvertibleTuple < _Elements ... > ( ),
               bool > :: type = true >
 tuple ( allocator_arg_t __tag, const _Alloc & __a,
       const _Elements & ... __elements )
 : _Inherited ( __tag, __a, __elements ... ) { }
      template < typename _Alloc, typename _Dummy = void,
               typename enable_if <
                 _TCC < _Dummy > :: template
                   _ConstructibleTuple < _Elements ... > ( )
                 && ! _TCC < _Dummy > :: template
                   _ImplicitlyConvertibleTuple < _Elements ... > ( ),
               bool > :: type = false >
 explicit tuple ( allocator_arg_t __tag, const _Alloc & __a,
                       const _Elements & ... __elements )
 : _Inherited ( __tag, __a, __elements ... ) { }
      template < typename _Alloc, typename ... _UElements, typename
        enable_if < _TMC < _UElements ... > :: template
                    _MoveConstructibleTuple < _UElements ... > ( )
                  && _TMC < _UElements ... > :: template
                    _ImplicitlyMoveConvertibleTuple < _UElements ... > ( ),
        bool > :: type = true >
 tuple ( allocator_arg_t __tag, const _Alloc & __a,
       _UElements && ... __elements )
 : _Inherited ( __tag, __a, std :: forward < _UElements > ( __elements ) ... )
        { }
      template < typename _Alloc, typename ... _UElements, typename
        enable_if < _TMC < _UElements ... > :: template
                    _MoveConstructibleTuple < _UElements ... > ( )
                  && ! _TMC < _UElements ... > :: template
                    _ImplicitlyMoveConvertibleTuple < _UElements ... > ( ),
        bool > :: type = false >
 explicit tuple ( allocator_arg_t __tag, const _Alloc & __a,
       _UElements && ... __elements )
 : _Inherited ( __tag, __a, std :: forward < _UElements > ( __elements ) ... )
        { }
      template < typename _Alloc >
 tuple ( allocator_arg_t __tag, const _Alloc & __a, const tuple & __in )
 : _Inherited ( __tag, __a, static_cast < const _Inherited & > ( __in ) ) { }
      template < typename _Alloc >
 tuple ( allocator_arg_t __tag, const _Alloc & __a, tuple && __in )
 : _Inherited ( __tag, __a, static_cast < _Inherited && > ( __in ) ) { }
      template < typename _Alloc, typename ... _UElements, typename
        enable_if < _TMC < _UElements ... > :: template
                    _ConstructibleTuple < _UElements ... > ( )
                  && _TMC < _UElements ... > :: template
                    _ImplicitlyConvertibleTuple < _UElements ... > ( ),
        bool > :: type = true >
 tuple ( allocator_arg_t __tag, const _Alloc & __a,
       const tuple < _UElements ... > & __in )
 : _Inherited ( __tag, __a,
              static_cast < const _Tuple_impl < 0, _UElements ... > & > ( __in ) )
 { }
      template < typename _Alloc, typename ... _UElements, typename
        enable_if < _TMC < _UElements ... > :: template
                    _ConstructibleTuple < _UElements ... > ( )
                  && ! _TMC < _UElements ... > :: template
                    _ImplicitlyConvertibleTuple < _UElements ... > ( ),
        bool > :: type = false >
 explicit tuple ( allocator_arg_t __tag, const _Alloc & __a,
       const tuple < _UElements ... > & __in )
 : _Inherited ( __tag, __a,
              static_cast < const _Tuple_impl < 0, _UElements ... > & > ( __in ) )
 { }
      template < typename _Alloc, typename ... _UElements, typename
        enable_if < _TMC < _UElements ... > :: template
                    _MoveConstructibleTuple < _UElements ... > ( )
                  && _TMC < _UElements ... > :: template
                    _ImplicitlyMoveConvertibleTuple < _UElements ... > ( ),
        bool > :: type = true >
 tuple ( allocator_arg_t __tag, const _Alloc & __a,
       tuple < _UElements ... > && __in )
 : _Inherited ( __tag, __a,
              static_cast < _Tuple_impl < 0, _UElements ... > && > ( __in ) )
 { }
      template < typename _Alloc, typename ... _UElements, typename
        enable_if < _TMC < _UElements ... > :: template
                    _MoveConstructibleTuple < _UElements ... > ( )
                  && ! _TMC < _UElements ... > :: template
                    _ImplicitlyMoveConvertibleTuple < _UElements ... > ( ),
        bool > :: type = false >
 explicit tuple ( allocator_arg_t __tag, const _Alloc & __a,
       tuple < _UElements ... > && __in )
 : _Inherited ( __tag, __a,
              static_cast < _Tuple_impl < 0, _UElements ... > && > ( __in ) )
 { }
      tuple &
      operator = ( const tuple & __in )
      ;
      tuple &
      operator = ( tuple && __in )
      noexcept ( is_nothrow_move_assignable < _Inherited > :: value )
      ;
      template < typename ... _UElements, typename = typename
        enable_if < sizeof ... ( _UElements )
    == sizeof ... ( _Elements ) > :: type >
        tuple &
        operator = ( const tuple < _UElements ... > & __in )
        {
   static_cast < _Inherited & > ( * this ) = __in;
   return * this;
 }
      template < typename ... _UElements, typename = typename
        enable_if < sizeof ... ( _UElements )
    == sizeof ... ( _Elements ) > :: type >
        tuple &
        operator = ( tuple < _UElements ... > && __in )
        {
   static_cast < _Inherited & > ( * this ) = std :: move ( __in );
   return * this;
 }
      void
      swap ( tuple & __in )
      noexcept ( noexcept ( __in . _M_swap ( __in ) ) )
      ;
    };
template<> class tuple<   > 
{

public: inline void swap(class tuple<   > &)
{
}
};
template < typename _T1, typename _T2 >
    class tuple < _T1, _T2 > : public _Tuple_impl < 0, _T1, _T2 >
    {
      typedef _Tuple_impl < 0, _T1, _T2 > _Inherited;
    public :
      template < typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if < __and_ <
                                     __is_implicitly_default_constructible < _U1 >,
                                     __is_implicitly_default_constructible < _U2 >>
                                   :: value, bool > :: type = true >
      constexpr tuple ( )
      : _Inherited ( ) { }
      template < typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if <
                  __and_ <
                    is_default_constructible < _U1 >,
                    is_default_constructible < _U2 >,
                    __not_ <
                      __and_ < __is_implicitly_default_constructible < _U1 >,
                             __is_implicitly_default_constructible < _U2 >>> >
                  :: value, bool > :: type = false >
      explicit constexpr tuple ( )
      : _Inherited ( ) { }
      template < typename _Dummy > using _TCC =
        _TC < is_same < _Dummy, void > :: value, _T1, _T2 >;
      template < typename _Dummy = void, typename
               enable_if < _TCC < _Dummy > :: template
                           _ConstructibleTuple < _T1, _T2 > ( )
                         && _TCC < _Dummy > :: template
                           _ImplicitlyConvertibleTuple < _T1, _T2 > ( ),
 bool > :: type = true >
        constexpr tuple ( const _T1 & __a1, const _T2 & __a2 )
        : _Inherited ( __a1, __a2 ) { }
      template < typename _Dummy = void, typename
               enable_if < _TCC < _Dummy > :: template
                           _ConstructibleTuple < _T1, _T2 > ( )
                         && ! _TCC < _Dummy > :: template
                           _ImplicitlyConvertibleTuple < _T1, _T2 > ( ),
 bool > :: type = false >
        explicit constexpr tuple ( const _T1 & __a1, const _T2 & __a2 )
        : _Inherited ( __a1, __a2 ) { }
      using _TMC = _TC < true, _T1, _T2 >;
      template < typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = true >
        constexpr tuple ( _U1 && __a1, _U2 && __a2 )
 : _Inherited ( std :: forward < _U1 > ( __a1 ), std :: forward < _U2 > ( __a2 ) ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && ! _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = false >
        explicit constexpr tuple ( _U1 && __a1, _U2 && __a2 )
 : _Inherited ( std :: forward < _U1 > ( __a1 ), std :: forward < _U2 > ( __a2 ) ) { }
      constexpr tuple ( const tuple & ) = default;
      constexpr tuple ( tuple && ) = default;
      template < typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _ConstructibleTuple < _U1, _U2 > ( )
                  && _TMC :: template
                    _ImplicitlyConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = true >
        constexpr tuple ( const tuple < _U1, _U2 > & __in )
 : _Inherited ( static_cast < const _Tuple_impl < 0, _U1, _U2 > & > ( __in ) ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _ConstructibleTuple < _U1, _U2 > ( )
                  && ! _TMC :: template
                    _ImplicitlyConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = false >
        explicit constexpr tuple ( const tuple < _U1, _U2 > & __in )
 : _Inherited ( static_cast < const _Tuple_impl < 0, _U1, _U2 > & > ( __in ) ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = true >
        constexpr tuple ( tuple < _U1, _U2 > && __in )
 : _Inherited ( static_cast < _Tuple_impl < 0, _U1, _U2 > && > ( __in ) ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && ! _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = false >
        explicit constexpr tuple ( tuple < _U1, _U2 > && __in )
 : _Inherited ( static_cast < _Tuple_impl < 0, _U1, _U2 > && > ( __in ) ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _ConstructibleTuple < _U1, _U2 > ( )
                  && _TMC :: template
                    _ImplicitlyConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = true >
        constexpr tuple ( const pair < _U1, _U2 > & __in )
 : _Inherited ( __in . first, __in . second ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _ConstructibleTuple < _U1, _U2 > ( )
                  && ! _TMC :: template
                    _ImplicitlyConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = false >
        explicit constexpr tuple ( const pair < _U1, _U2 > & __in )
 : _Inherited ( __in . first, __in . second ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = true >
        constexpr tuple ( pair < _U1, _U2 > && __in )
 : _Inherited ( std :: forward < _U1 > ( __in . first ),
       std :: forward < _U2 > ( __in . second ) ) { }
      template < typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && ! _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = false >
        explicit constexpr tuple ( pair < _U1, _U2 > && __in )
 : _Inherited ( std :: forward < _U1 > ( __in . first ),
       std :: forward < _U2 > ( __in . second ) ) { }
      template < typename _Alloc >
 tuple ( allocator_arg_t __tag, const _Alloc & __a )
 : _Inherited ( __tag, __a ) { }
      template < typename _Alloc, typename _Dummy = void,
               typename enable_if <
                 _TCC < _Dummy > :: template
                   _ConstructibleTuple < _T1, _T2 > ( )
                 && _TCC < _Dummy > :: template
                   _ImplicitlyConvertibleTuple < _T1, _T2 > ( ),
               bool > :: type = true >
 tuple ( allocator_arg_t __tag, const _Alloc & __a,
       const _T1 & __a1, const _T2 & __a2 )
 : _Inherited ( __tag, __a, __a1, __a2 ) { }
      template < typename _Alloc, typename _Dummy = void,
               typename enable_if <
                 _TCC < _Dummy > :: template
                   _ConstructibleTuple < _T1, _T2 > ( )
                 && ! _TCC < _Dummy > :: template
                   _ImplicitlyConvertibleTuple < _T1, _T2 > ( ),
               bool > :: type = false >
 explicit tuple ( allocator_arg_t __tag, const _Alloc & __a,
       const _T1 & __a1, const _T2 & __a2 )
 : _Inherited ( __tag, __a, __a1, __a2 ) { }
      template < typename _Alloc, typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = true >
 tuple ( allocator_arg_t __tag, const _Alloc & __a, _U1 && __a1, _U2 && __a2 )
 : _Inherited ( __tag, __a, std :: forward < _U1 > ( __a1 ),
              std :: forward < _U2 > ( __a2 ) ) { }
      template < typename _Alloc, typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && ! _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = false >
 explicit tuple ( allocator_arg_t __tag, const _Alloc & __a,
                       _U1 && __a1, _U2 && __a2 )
 : _Inherited ( __tag, __a, std :: forward < _U1 > ( __a1 ),
              std :: forward < _U2 > ( __a2 ) ) { }
      template < typename _Alloc >
 tuple ( allocator_arg_t __tag, const _Alloc & __a, const tuple & __in )
 : _Inherited ( __tag, __a, static_cast < const _Inherited & > ( __in ) ) { }
      template < typename _Alloc >
 tuple ( allocator_arg_t __tag, const _Alloc & __a, tuple && __in )
 : _Inherited ( __tag, __a, static_cast < _Inherited && > ( __in ) ) { }
      template < typename _Alloc, typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _ConstructibleTuple < _U1, _U2 > ( )
                  && _TMC :: template
                    _ImplicitlyConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = true >
 tuple ( allocator_arg_t __tag, const _Alloc & __a,
       const tuple < _U1, _U2 > & __in )
 : _Inherited ( __tag, __a,
              static_cast < const _Tuple_impl < 0, _U1, _U2 > & > ( __in ) )
 { }
      template < typename _Alloc, typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _ConstructibleTuple < _U1, _U2 > ( )
                  && ! _TMC :: template
                    _ImplicitlyConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = false >
 explicit tuple ( allocator_arg_t __tag, const _Alloc & __a,
       const tuple < _U1, _U2 > & __in )
 : _Inherited ( __tag, __a,
              static_cast < const _Tuple_impl < 0, _U1, _U2 > & > ( __in ) )
 { }
      template < typename _Alloc, typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = true >
 tuple ( allocator_arg_t __tag, const _Alloc & __a, tuple < _U1, _U2 > && __in )
 : _Inherited ( __tag, __a, static_cast < _Tuple_impl < 0, _U1, _U2 > && > ( __in ) )
 { }
      template < typename _Alloc, typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && ! _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = false >
 explicit tuple ( allocator_arg_t __tag, const _Alloc & __a,
                       tuple < _U1, _U2 > && __in )
 : _Inherited ( __tag, __a, static_cast < _Tuple_impl < 0, _U1, _U2 > && > ( __in ) )
 { }
      template < typename _Alloc, typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _ConstructibleTuple < _U1, _U2 > ( )
                  && _TMC :: template
                    _ImplicitlyConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = true >
        tuple ( allocator_arg_t __tag, const _Alloc & __a,
       const pair < _U1, _U2 > & __in )
 : _Inherited ( __tag, __a, __in . first, __in . second ) { }
      template < typename _Alloc, typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _ConstructibleTuple < _U1, _U2 > ( )
                  && ! _TMC :: template
                    _ImplicitlyConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = false >
        explicit tuple ( allocator_arg_t __tag, const _Alloc & __a,
       const pair < _U1, _U2 > & __in )
 : _Inherited ( __tag, __a, __in . first, __in . second ) { }
      template < typename _Alloc, typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = true >
        tuple ( allocator_arg_t __tag, const _Alloc & __a, pair < _U1, _U2 > && __in )
 : _Inherited ( __tag, __a, std :: forward < _U1 > ( __in . first ),
       std :: forward < _U2 > ( __in . second ) ) { }
      template < typename _Alloc, typename _U1, typename _U2, typename
        enable_if < _TMC :: template
                    _MoveConstructibleTuple < _U1, _U2 > ( )
                  && ! _TMC :: template
                    _ImplicitlyMoveConvertibleTuple < _U1, _U2 > ( ),
 bool > :: type = false >
        explicit tuple ( allocator_arg_t __tag, const _Alloc & __a,
                       pair < _U1, _U2 > && __in )
 : _Inherited ( __tag, __a, std :: forward < _U1 > ( __in . first ),
       std :: forward < _U2 > ( __in . second ) ) { }
      tuple &
      operator = ( const tuple & __in )
      ;
      tuple &
      operator = ( tuple && __in )
      noexcept ( is_nothrow_move_assignable < _Inherited > :: value )
      ;
      template < typename _U1, typename _U2 >
        tuple &
        operator = ( const tuple < _U1, _U2 > & __in )
        {
   static_cast < _Inherited & > ( * this ) = __in;
   return * this;
 }
      template < typename _U1, typename _U2 >
        tuple &
        operator = ( tuple < _U1, _U2 > && __in )
        {
   static_cast < _Inherited & > ( * this ) = std :: move ( __in );
   return * this;
 }
      template < typename _U1, typename _U2 >
        tuple &
        operator = ( const pair < _U1, _U2 > & __in )
        {
   this -> _M_head ( * this ) = __in . first;
   this -> _M_tail ( * this ) . _M_head ( * this ) = __in . second;
   return * this;
 }
      template < typename _U1, typename _U2 >
        tuple &
        operator = ( pair < _U1, _U2 > && __in )
        {
   this -> _M_head ( * this ) = std :: forward < _U1 > ( __in . first );
   this -> _M_tail ( * this ) . _M_head ( * this ) = std :: forward < _U2 > ( __in . second );
   return * this;
 }
      void
      swap ( tuple & __in )
      noexcept ( noexcept ( __in . _M_swap ( __in ) ) )
      ;
    };
template < std :: size_t __i, typename _Head, typename ... _Tail >
    struct tuple_element < __i, tuple < _Head, _Tail ... > >
    : tuple_element < __i - 1, tuple < _Tail ... > > { };
template < typename _Head, typename ... _Tail >
    struct tuple_element < 0, tuple < _Head, _Tail ... > >
    {
      typedef _Head type;
    };
template < typename ... _Elements >
    struct tuple_size < tuple < _Elements ... > >
    : public integral_constant < std :: size_t, sizeof ... ( _Elements ) > { };
template < std :: size_t __i, typename _Head, typename ... _Tail >
    constexpr _Head &
    __get_helper ( _Tuple_impl < __i, _Head, _Tail ... > & __t ) noexcept
    { return _Tuple_impl < __i, _Head, _Tail ... > :: _M_head ( __t ); }
template < std :: size_t __i, typename _Head, typename ... _Tail >
    constexpr const _Head &
    __get_helper ( const _Tuple_impl < __i, _Head, _Tail ... > & __t ) noexcept
    { return _Tuple_impl < __i, _Head, _Tail ... > :: _M_head ( __t ); }
template < std :: size_t __i, typename ... _Elements >
    constexpr __tuple_element_t < __i, tuple < _Elements ... > > &
    get ( tuple < _Elements ... > & __t ) noexcept
    { return std :: __get_helper < __i > ( __t ); }
template < std :: size_t __i, typename ... _Elements >
    constexpr const __tuple_element_t < __i, tuple < _Elements ... > > &
    get ( const tuple < _Elements ... > & __t ) noexcept
    { return std :: __get_helper < __i > ( __t ); }
template < std :: size_t __i, typename ... _Elements >
    constexpr __tuple_element_t < __i, tuple < _Elements ... > > &&
    get ( tuple < _Elements ... > && __t ) noexcept
    {
      typedef __tuple_element_t < __i, tuple < _Elements ... >> __element_type;
      return std :: forward < __element_type && > ( std :: get < __i > ( __t ) );
    }
template < typename _Head, size_t __i, typename ... _Tail >
    constexpr _Head &
    __get_helper2 ( _Tuple_impl < __i, _Head, _Tail ... > & __t ) noexcept
    { return _Tuple_impl < __i, _Head, _Tail ... > :: _M_head ( __t ); }
template < typename _Head, size_t __i, typename ... _Tail >
    constexpr const _Head &
    __get_helper2 ( const _Tuple_impl < __i, _Head, _Tail ... > & __t ) noexcept
    { return _Tuple_impl < __i, _Head, _Tail ... > :: _M_head ( __t ); }
template < typename _Tp, typename ... _Types >
    constexpr _Tp &
    get ( tuple < _Types ... > & __t ) noexcept
    { return std :: __get_helper2 < _Tp > ( __t ); }
template < typename _Tp, typename ... _Types >
    constexpr _Tp &&
    get ( tuple < _Types ... > && __t ) noexcept
    { return std :: forward < _Tp && > ( std :: __get_helper2 < _Tp > ( __t ) ); }
template < typename _Tp, typename ... _Types >
    constexpr const _Tp &
    get ( const tuple < _Types ... > & __t ) noexcept
    { return std :: __get_helper2 < _Tp > ( __t ); }
template < typename _Tp, typename _Up, size_t __i, size_t __size >
    struct __tuple_compare
    {
      static constexpr bool
      __eq ( const _Tp & __t, const _Up & __u )
      ;
      static constexpr bool
      __less ( const _Tp & __t, const _Up & __u )
      ;
    };
template < typename _Tp, typename _Up, size_t __size >
    struct __tuple_compare < _Tp, _Up, __size, __size >
    {
      static constexpr bool
      __eq ( const _Tp &, const _Up & );
      static constexpr bool
      __less ( const _Tp &, const _Up & );
    };
template < typename ... _TElements, typename ... _UElements >
    constexpr bool
    operator == ( const tuple < _TElements ... > & __t,
        const tuple < _UElements ... > & __u )
    {
      static_assert ( sizeof ... ( _TElements ) == sizeof ... ( _UElements ),
   "tuple objects can only be compared if they have equal sizes." );
      using __compare = __tuple_compare < tuple < _TElements ... >,
     tuple < _UElements ... >,
     0, sizeof ... ( _TElements ) >;
      return __compare :: __eq ( __t, __u );
    }
template < typename ... _TElements, typename ... _UElements >
    constexpr bool
    operator < ( const tuple < _TElements ... > & __t,
       const tuple < _UElements ... > & __u )
    {
      static_assert ( sizeof ... ( _TElements ) == sizeof ... ( _UElements ),
   "tuple objects can only be compared if they have equal sizes." );
      using __compare = __tuple_compare < tuple < _TElements ... >,
     tuple < _UElements ... >,
     0, sizeof ... ( _TElements ) >;
      return __compare :: __less ( __t, __u );
    }
template < typename ... _TElements, typename ... _UElements >
    constexpr bool
    operator != ( const tuple < _TElements ... > & __t,
        const tuple < _UElements ... > & __u )
    { return ! ( __t == __u ); }
template < typename ... _TElements, typename ... _UElements >
    constexpr bool
    operator > ( const tuple < _TElements ... > & __t,
       const tuple < _UElements ... > & __u )
    { return __u < __t; }
template < typename ... _TElements, typename ... _UElements >
    constexpr bool
    operator <= ( const tuple < _TElements ... > & __t,
        const tuple < _UElements ... > & __u )
    { return ! ( __u < __t ); }
template < typename ... _TElements, typename ... _UElements >
    constexpr bool
    operator >= ( const tuple < _TElements ... > & __t,
        const tuple < _UElements ... > & __u )
    { return ! ( __t < __u ); }
template < typename ... _Elements >
    constexpr tuple < typename __decay_and_strip < _Elements > :: __type ... >
    make_tuple ( _Elements && ... __args )
    {
      typedef tuple < typename __decay_and_strip < _Elements > :: __type ... >
 __result_type;
      return __result_type ( std :: forward < _Elements > ( __args ) ... );
    }
template < typename ... _Elements >
    constexpr tuple < _Elements && ... >
    forward_as_tuple ( _Elements && ... __args ) noexcept
    { return tuple < _Elements && ... > ( std :: forward < _Elements > ( __args ) ... ); }
template < typename ... _Tps >
    struct __is_tuple_like_impl < tuple < _Tps ... > > : true_type
    { };
template < typename _Tp >
    struct __is_tuple_like
    : public __is_tuple_like_impl < typename std :: remove_cv
            < typename std :: remove_reference < _Tp > :: type > :: type > :: type
    { };
template < size_t, typename, typename, size_t >
    struct __make_tuple_impl;
template < size_t _Idx, typename _Tuple, typename ... _Tp, size_t _Nm >
    struct __make_tuple_impl < _Idx, tuple < _Tp ... >, _Tuple, _Nm >
    : __make_tuple_impl < _Idx + 1,
   tuple < _Tp ..., __tuple_element_t < _Idx, _Tuple >>,
   _Tuple, _Nm >
    { };
template < std :: size_t _Nm, typename _Tuple, typename ... _Tp >
    struct __make_tuple_impl < _Nm, tuple < _Tp ... >, _Tuple, _Nm >
    {
      typedef tuple < _Tp ... > __type;
    };
template < typename _Tuple >
    struct __do_make_tuple
    : __make_tuple_impl < 0, tuple < >, _Tuple, std :: tuple_size < _Tuple > :: value >
    { };
template < typename _Tuple >
    struct __make_tuple
    : public __do_make_tuple < typename std :: remove_cv
            < typename std :: remove_reference < _Tuple > :: type > :: type >
    { };
template < typename ... >
    struct __combine_tuples;
template<> struct __combine_tuples<   > 
{
typedef class tuple<   > __type;
};
template < typename ... _Ts >
    struct __combine_tuples < tuple < _Ts ... > >
    {
      typedef tuple < _Ts ... > __type;
    };
template < typename ... _T1s, typename ... _T2s, typename ... _Rem >
    struct __combine_tuples < tuple < _T1s ... >, tuple < _T2s ... >, _Rem ... >
    {
      typedef typename __combine_tuples < tuple < _T1s ..., _T2s ... >,
     _Rem ... > :: __type __type;
    };
template < typename ... _Tpls >
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        < typename __make_tuple < _Tpls > :: __type ... > :: __type __type;
    };
template < typename ... >
    struct __make_1st_indices;
template<> struct __make_1st_indices<   > 
{
typedef struct _Index_tuple<   > __type;
};
template < typename _Tp, typename ... _Tpls >
    struct __make_1st_indices < _Tp, _Tpls ... >
    {
      typedef typename std :: _Build_index_tuple < std :: tuple_size <
 typename std :: remove_reference < _Tp > :: type > :: value > :: __type __type;
    };
template < typename _Ret, typename _Indices, typename ... _Tpls >
    struct __tuple_concater;
template < typename _Ret, std :: size_t ... _Is, typename _Tp, typename ... _Tpls >
    struct __tuple_concater < _Ret, std :: _Index_tuple < _Is ... >, _Tp, _Tpls ... >
    {
      template < typename ... _Us >
        static constexpr _Ret
        _S_do ( _Tp && __tp, _Tpls && ... __tps, _Us && ... __us )
        {
   typedef typename __make_1st_indices < _Tpls ... > :: __type __idx;
   typedef __tuple_concater < _Ret, __idx, _Tpls ... > __next;
   return __next :: _S_do ( std :: forward < _Tpls > ( __tps ) ...,
          std :: forward < _Us > ( __us ) ...,
          std :: get < _Is > ( std :: forward < _Tp > ( __tp ) ) ... );
 }
    };
template < typename _Ret >
    struct __tuple_concater < _Ret, std :: _Index_tuple < > >
    {
      template < typename ... _Us >
 static constexpr _Ret
 _S_do ( _Us && ... __us )
        {
   return _Ret ( std :: forward < _Us > ( __us ) ... );
 }
    };
template < typename ... _Tpls, typename = typename
           enable_if < __and_ < __is_tuple_like < _Tpls > ... > :: value > :: type >
    constexpr auto
    tuple_cat ( _Tpls && ... __tpls )
    -> typename __tuple_cat_result < _Tpls ... > :: __type
    {
      typedef typename __tuple_cat_result < _Tpls ... > :: __type __ret;
      typedef typename __make_1st_indices < _Tpls ... > :: __type __idx;
      typedef __tuple_concater < __ret, __idx, _Tpls ... > __concater;
      return __concater :: _S_do ( std :: forward < _Tpls > ( __tpls ) ... );
    }
template < typename ... _Elements >
    constexpr tuple < _Elements & ... >
    tie ( _Elements & ... __args ) noexcept
    { return tuple < _Elements & ... > ( __args ... ); }
template < typename ... _Elements >
    inline void
    swap ( tuple < _Elements ... > & __x, tuple < _Elements ... > & __y )
    noexcept ( noexcept ( __x . swap ( __y ) ) )
    { __x . swap ( __y ); }

struct _Swallow_assign 
{
template < class _Tp >
      const _Swallow_assign &
      operator = ( const _Tp & ) const
      { return * this; }
}
;
const struct _Swallow_assign ignore = {};
template < typename ... _Types, typename _Alloc >
    struct uses_allocator < tuple < _Types ... >, _Alloc > : true_type { };
template < class _T1, class _T2 >
    template < typename ... _Args1, typename ... _Args2 >
      inline
      pair < _T1, _T2 > ::
      pair ( piecewise_construct_t,
    tuple < _Args1 ... > __first, tuple < _Args2 ... > __second )
      : pair ( __first, __second,
      typename _Build_index_tuple < sizeof ... ( _Args1 ) > :: __type ( ),
      typename _Build_index_tuple < sizeof ... ( _Args2 ) > :: __type ( ) )
      { }
template < class _T1, class _T2 >
    template < typename ... _Args1, std :: size_t ... _Indexes1,
             typename ... _Args2, std :: size_t ... _Indexes2 >
      inline
      pair < _T1, _T2 > ::
      pair ( tuple < _Args1 ... > & __tuple1, tuple < _Args2 ... > & __tuple2,
    _Index_tuple < _Indexes1 ... >, _Index_tuple < _Indexes2 ... > )
      : first ( std :: forward < _Args1 > ( std :: get < _Indexes1 > ( __tuple1 ) ) ... ),
        second ( std :: forward < _Args2 > ( std :: get < _Indexes2 > ( __tuple2 ) ) ... )
      { }
}
namespace std
{
template < typename _Key, typename _Tp, typename _Compare = std :: less < _Key >,
            typename _Alloc = std :: allocator < std :: pair < const _Key, _Tp > > >
    class map
    {
    public :
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std :: pair < const _Key, _Tp > value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
    private :
      typedef typename _Alloc :: value_type _Alloc_value_type;
    public :
      class value_compare
      : public std :: binary_function < value_type, value_type, bool >
      {
 friend class map < _Key, _Tp, _Compare, _Alloc >;
      protected :
 _Compare comp;
 value_compare ( _Compare __c )
 ;
      public :
 bool operator ( ) ( const value_type & __x, const value_type & __y ) const
 ;
      };
    private :
      typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template
 rebind < value_type > :: other _Pair_alloc_type;
      typedef _Rb_tree < key_type, value_type, _Select1st < value_type >,
         key_compare, _Pair_alloc_type > _Rep_type;
      _Rep_type _M_t;
      typedef __gnu_cxx :: __alloc_traits < _Pair_alloc_type > _Alloc_traits;
    public :
      typedef typename _Alloc_traits :: pointer pointer;
      typedef typename _Alloc_traits :: const_pointer const_pointer;
      typedef typename _Alloc_traits :: reference reference;
      typedef typename _Alloc_traits :: const_reference const_reference;
      typedef typename _Rep_type :: iterator iterator;
      typedef typename _Rep_type :: const_iterator const_iterator;
      typedef typename _Rep_type :: size_type size_type;
      typedef typename _Rep_type :: difference_type difference_type;
      typedef typename _Rep_type :: reverse_iterator reverse_iterator;
      typedef typename _Rep_type :: const_reverse_iterator const_reverse_iterator;
      map ( )
      noexcept ( is_nothrow_default_constructible < allocator_type > :: value )
      ;
      explicit
      map ( const _Compare & __comp,
   const allocator_type & __a = allocator_type ( ) )
      ;
      map ( const map & __x )
      ;
      map ( map && __x )
      noexcept ( is_nothrow_copy_constructible < _Compare > :: value )
      ;
      map ( initializer_list < value_type > __l,
   const _Compare & __comp = _Compare ( ),
   const allocator_type & __a = allocator_type ( ) )
      ;
      explicit
      map ( const allocator_type & __a )
      ;
      map ( const map & __m, const allocator_type & __a )
      ;
      map ( map && __m, const allocator_type & __a )
      noexcept ( is_nothrow_copy_constructible < _Compare > :: value
        && _Alloc_traits :: _S_always_equal ( ) )
      ;
      map ( initializer_list < value_type > __l, const allocator_type & __a )
      ;
      template < typename _InputIterator >
        map ( _InputIterator __first, _InputIterator __last,
     const allocator_type & __a )
 : _M_t ( _Compare ( ), _Pair_alloc_type ( __a ) )
        { _M_t . _M_insert_unique ( __first, __last ); }
      template < typename _InputIterator >
        map ( _InputIterator __first, _InputIterator __last )
 : _M_t ( )
        { _M_t . _M_insert_unique ( __first, __last ); }
      template < typename _InputIterator >
        map ( _InputIterator __first, _InputIterator __last,
     const _Compare & __comp,
     const allocator_type & __a = allocator_type ( ) )
 : _M_t ( __comp, _Pair_alloc_type ( __a ) )
        { _M_t . _M_insert_unique ( __first, __last ); }
      map &
      operator = ( const map & __x )
      ;
      map &
      operator = ( map && ) = default;
      map &
      operator = ( initializer_list < value_type > __l )
      ;
      allocator_type
      get_allocator ( ) const noexcept
      ;
      iterator
      begin ( ) noexcept
      ;
      const_iterator
      begin ( ) const noexcept
      ;
      iterator
      end ( ) noexcept
      ;
      const_iterator
      end ( ) const noexcept
      ;
      reverse_iterator
      rbegin ( ) noexcept
      ;
      const_reverse_iterator
      rbegin ( ) const noexcept
      ;
      reverse_iterator
      rend ( ) noexcept
      ;
      const_reverse_iterator
      rend ( ) const noexcept
      ;
      const_iterator
      cbegin ( ) const noexcept
      ;
      const_iterator
      cend ( ) const noexcept
      ;
      const_reverse_iterator
      crbegin ( ) const noexcept
      ;
      const_reverse_iterator
      crend ( ) const noexcept
      ;
      bool
      empty ( ) const noexcept
      ;
      size_type
      size ( ) const noexcept
      ;
      size_type
      max_size ( ) const noexcept
      ;
      mapped_type &
      operator [ ] ( const key_type & __k )
      ;
      mapped_type &
      operator [ ] ( key_type && __k )
      ;
      mapped_type &
      at ( const key_type & __k )
      ;
      const mapped_type &
      at ( const key_type & __k ) const
      ;
      template < typename ... _Args >
 std :: pair < iterator, bool >
 emplace ( _Args && ... __args )
 { return _M_t . _M_emplace_unique ( std :: forward < _Args > ( __args ) ... ); }
      template < typename ... _Args >
 iterator
 emplace_hint ( const_iterator __pos, _Args && ... __args )
 {
   return _M_t . _M_emplace_hint_unique ( __pos,
          std :: forward < _Args > ( __args ) ... );
 }
      std :: pair < iterator, bool >
      insert ( const value_type & __x )
      ;
      template < typename _Pair, typename = typename
        std :: enable_if < std :: is_constructible < value_type,
          _Pair && > :: value > :: type >
        std :: pair < iterator, bool >
        insert ( _Pair && __x )
        { return _M_t . _M_insert_unique ( std :: forward < _Pair > ( __x ) ); }
      void
      insert ( std :: initializer_list < value_type > __list )
      ;
      iterator
      insert ( const_iterator __position, const value_type & __x )
      ;
      template < typename _Pair, typename = typename
        std :: enable_if < std :: is_constructible < value_type,
          _Pair && > :: value > :: type >
        iterator
        insert ( const_iterator __position, _Pair && __x )
        { return _M_t . _M_insert_unique_ ( __position,
     std :: forward < _Pair > ( __x ) ); }
      template < typename _InputIterator >
        void
        insert ( _InputIterator __first, _InputIterator __last )
        { _M_t . _M_insert_unique ( __first, __last ); }
      iterator
      erase ( const_iterator __position )
      ;
      __attribute__ ( ( __abi_tag__ ( "cxx11" ) ) )
      iterator
      erase ( iterator __position )
      ;
      size_type
      erase ( const key_type & __x )
      ;
      iterator
      erase ( const_iterator __first, const_iterator __last )
      ;
      void
      swap ( map & __x )
      noexcept ( __is_nothrow_swappable < _Compare > :: value )
      ;
      void
      clear ( ) noexcept
      ;
      key_compare
      key_comp ( ) const
      ;
      value_compare
      value_comp ( ) const
      ;
      iterator
      find ( const key_type & __x )
      ;
      template < typename _Kt >
 auto
 find ( const _Kt & __x ) -> decltype ( _M_t . _M_find_tr ( __x ) )
 { return _M_t . _M_find_tr ( __x ); }
      const_iterator
      find ( const key_type & __x ) const
      ;
      template < typename _Kt >
 auto
 find ( const _Kt & __x ) const -> decltype ( _M_t . _M_find_tr ( __x ) )
 { return _M_t . _M_find_tr ( __x ); }
      size_type
      count ( const key_type & __x ) const
      ;
      template < typename _Kt >
 auto
 count ( const _Kt & __x ) const -> decltype ( _M_t . _M_count_tr ( __x ) )
 { return _M_t . _M_find_tr ( __x ) == _M_t . end ( ) ? 0 : 1; }
      iterator
      lower_bound ( const key_type & __x )
      ;
      template < typename _Kt >
 auto
 lower_bound ( const _Kt & __x )
 -> decltype ( _M_t . _M_lower_bound_tr ( __x ) )
 { return _M_t . _M_lower_bound_tr ( __x ); }
      const_iterator
      lower_bound ( const key_type & __x ) const
      ;
      template < typename _Kt >
 auto
 lower_bound ( const _Kt & __x ) const
 -> decltype ( _M_t . _M_lower_bound_tr ( __x ) )
 { return _M_t . _M_lower_bound_tr ( __x ); }
      iterator
      upper_bound ( const key_type & __x )
      ;
      template < typename _Kt >
 auto
 upper_bound ( const _Kt & __x )
 -> decltype ( _M_t . _M_upper_bound_tr ( __x ) )
 { return _M_t . _M_upper_bound_tr ( __x ); }
      const_iterator
      upper_bound ( const key_type & __x ) const
      ;
      template < typename _Kt >
 auto
 upper_bound ( const _Kt & __x ) const
 -> decltype ( _M_t . _M_upper_bound_tr ( __x ) )
 { return _M_t . _M_upper_bound_tr ( __x ); }
      std :: pair < iterator, iterator >
      equal_range ( const key_type & __x )
      ;
      template < typename _Kt >
 auto
 equal_range ( const _Kt & __x )
 -> decltype ( _M_t . _M_equal_range_tr ( __x ) )
 { return _M_t . _M_equal_range_tr ( __x ); }
      std :: pair < const_iterator, const_iterator >
      equal_range ( const key_type & __x ) const
      ;
      template < typename _Kt >
 auto
 equal_range ( const _Kt & __x ) const
 -> decltype ( _M_t . _M_equal_range_tr ( __x ) )
 { return _M_t . _M_equal_range_tr ( __x ); }
      template < typename _K1, typename _T1, typename _C1, typename _A1 >
        friend bool
        operator == ( const map < _K1, _T1, _C1, _A1 > &,
     const map < _K1, _T1, _C1, _A1 > & );
      template < typename _K1, typename _T1, typename _C1, typename _A1 >
        friend bool
        operator < ( const map < _K1, _T1, _C1, _A1 > &,
    const map < _K1, _T1, _C1, _A1 > & );
    };
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator == ( const map < _Key, _Tp, _Compare, _Alloc > & __x,
               const map < _Key, _Tp, _Compare, _Alloc > & __y )
    { return __x . _M_t == __y . _M_t; }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator < ( const map < _Key, _Tp, _Compare, _Alloc > & __x,
              const map < _Key, _Tp, _Compare, _Alloc > & __y )
    { return __x . _M_t < __y . _M_t; }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator != ( const map < _Key, _Tp, _Compare, _Alloc > & __x,
               const map < _Key, _Tp, _Compare, _Alloc > & __y )
    { return ! ( __x == __y ); }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator > ( const map < _Key, _Tp, _Compare, _Alloc > & __x,
              const map < _Key, _Tp, _Compare, _Alloc > & __y )
    { return __y < __x; }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator <= ( const map < _Key, _Tp, _Compare, _Alloc > & __x,
               const map < _Key, _Tp, _Compare, _Alloc > & __y )
    { return ! ( __y < __x ); }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator >= ( const map < _Key, _Tp, _Compare, _Alloc > & __x,
               const map < _Key, _Tp, _Compare, _Alloc > & __y )
    { return ! ( __x < __y ); }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline void
    swap ( map < _Key, _Tp, _Compare, _Alloc > & __x,
  map < _Key, _Tp, _Compare, _Alloc > & __y )
    noexcept ( noexcept ( __x . swap ( __y ) ) )
    { __x . swap ( __y ); }
}
namespace std
{
template < typename _Key, typename _Tp,
     typename _Compare = std :: less < _Key >,
     typename _Alloc = std :: allocator < std :: pair < const _Key, _Tp > > >
    class multimap
    {
    public :
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std :: pair < const _Key, _Tp > value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
    private :
      typedef typename _Alloc :: value_type _Alloc_value_type;
    public :
      class value_compare
      : public std :: binary_function < value_type, value_type, bool >
      {
 friend class multimap < _Key, _Tp, _Compare, _Alloc >;
      protected :
 _Compare comp;
 value_compare ( _Compare __c )
 ;
      public :
 bool operator ( ) ( const value_type & __x, const value_type & __y ) const
 ;
      };
    private :
      typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template
 rebind < value_type > :: other _Pair_alloc_type;
      typedef _Rb_tree < key_type, value_type, _Select1st < value_type >,
         key_compare, _Pair_alloc_type > _Rep_type;
      _Rep_type _M_t;
      typedef __gnu_cxx :: __alloc_traits < _Pair_alloc_type > _Alloc_traits;
    public :
      typedef typename _Alloc_traits :: pointer pointer;
      typedef typename _Alloc_traits :: const_pointer const_pointer;
      typedef typename _Alloc_traits :: reference reference;
      typedef typename _Alloc_traits :: const_reference const_reference;
      typedef typename _Rep_type :: iterator iterator;
      typedef typename _Rep_type :: const_iterator const_iterator;
      typedef typename _Rep_type :: size_type size_type;
      typedef typename _Rep_type :: difference_type difference_type;
      typedef typename _Rep_type :: reverse_iterator reverse_iterator;
      typedef typename _Rep_type :: const_reverse_iterator const_reverse_iterator;
      multimap ( )
      noexcept ( is_nothrow_default_constructible < allocator_type > :: value )
      ;
      explicit
      multimap ( const _Compare & __comp,
        const allocator_type & __a = allocator_type ( ) )
      ;
      multimap ( const multimap & __x )
      ;
      multimap ( multimap && __x )
      noexcept ( is_nothrow_copy_constructible < _Compare > :: value )
      ;
      multimap ( initializer_list < value_type > __l,
        const _Compare & __comp = _Compare ( ),
        const allocator_type & __a = allocator_type ( ) )
      ;
      explicit
      multimap ( const allocator_type & __a )
      ;
      multimap ( const multimap & __m, const allocator_type & __a )
      ;
      multimap ( multimap && __m, const allocator_type & __a )
      noexcept ( is_nothrow_copy_constructible < _Compare > :: value
        && _Alloc_traits :: _S_always_equal ( ) )
      ;
      multimap ( initializer_list < value_type > __l, const allocator_type & __a )
      ;
      template < typename _InputIterator >
        multimap ( _InputIterator __first, _InputIterator __last,
   const allocator_type & __a )
 : _M_t ( _Compare ( ), _Pair_alloc_type ( __a ) )
        { _M_t . _M_insert_equal ( __first, __last ); }
      template < typename _InputIterator >
        multimap ( _InputIterator __first, _InputIterator __last )
 : _M_t ( )
        { _M_t . _M_insert_equal ( __first, __last ); }
      template < typename _InputIterator >
        multimap ( _InputIterator __first, _InputIterator __last,
   const _Compare & __comp,
   const allocator_type & __a = allocator_type ( ) )
 : _M_t ( __comp, _Pair_alloc_type ( __a ) )
        { _M_t . _M_insert_equal ( __first, __last ); }
      multimap &
      operator = ( const multimap & __x )
      ;
      multimap &
      operator = ( multimap && ) = default;
      multimap &
      operator = ( initializer_list < value_type > __l )
      ;
      allocator_type
      get_allocator ( ) const noexcept
      ;
      iterator
      begin ( ) noexcept
      ;
      const_iterator
      begin ( ) const noexcept
      ;
      iterator
      end ( ) noexcept
      ;
      const_iterator
      end ( ) const noexcept
      ;
      reverse_iterator
      rbegin ( ) noexcept
      ;
      const_reverse_iterator
      rbegin ( ) const noexcept
      ;
      reverse_iterator
      rend ( ) noexcept
      ;
      const_reverse_iterator
      rend ( ) const noexcept
      ;
      const_iterator
      cbegin ( ) const noexcept
      ;
      const_iterator
      cend ( ) const noexcept
      ;
      const_reverse_iterator
      crbegin ( ) const noexcept
      ;
      const_reverse_iterator
      crend ( ) const noexcept
      ;
      bool
      empty ( ) const noexcept
      ;
      size_type
      size ( ) const noexcept
      ;
      size_type
      max_size ( ) const noexcept
      ;
      template < typename ... _Args >
 iterator
 emplace ( _Args && ... __args )
 { return _M_t . _M_emplace_equal ( std :: forward < _Args > ( __args ) ... ); }
      template < typename ... _Args >
 iterator
 emplace_hint ( const_iterator __pos, _Args && ... __args )
 {
   return _M_t . _M_emplace_hint_equal ( __pos,
         std :: forward < _Args > ( __args ) ... );
 }
      iterator
      insert ( const value_type & __x )
      ;
      template < typename _Pair, typename = typename
        std :: enable_if < std :: is_constructible < value_type,
          _Pair && > :: value > :: type >
        iterator
        insert ( _Pair && __x )
        { return _M_t . _M_insert_equal ( std :: forward < _Pair > ( __x ) ); }
      iterator
      insert ( const_iterator __position, const value_type & __x )
      ;
      template < typename _Pair, typename = typename
        std :: enable_if < std :: is_constructible < value_type,
          _Pair && > :: value > :: type >
        iterator
        insert ( const_iterator __position, _Pair && __x )
        { return _M_t . _M_insert_equal_ ( __position,
           std :: forward < _Pair > ( __x ) ); }
      template < typename _InputIterator >
        void
        insert ( _InputIterator __first, _InputIterator __last )
        { _M_t . _M_insert_equal ( __first, __last ); }
      void
      insert ( initializer_list < value_type > __l )
      ;
      iterator
      erase ( const_iterator __position )
      ;
      __attribute__ ( ( __abi_tag__ ( "cxx11" ) ) )
      iterator
      erase ( iterator __position )
      ;
      size_type
      erase ( const key_type & __x )
      ;
      iterator
      erase ( const_iterator __first, const_iterator __last )
      ;
      void
      swap ( multimap & __x )
      noexcept ( __is_nothrow_swappable < _Compare > :: value )
      ;
      void
      clear ( ) noexcept
      ;
      key_compare
      key_comp ( ) const
      ;
      value_compare
      value_comp ( ) const
      ;
      iterator
      find ( const key_type & __x )
      ;
      template < typename _Kt >
 auto
 find ( const _Kt & __x ) -> decltype ( _M_t . _M_find_tr ( __x ) )
 { return _M_t . _M_find_tr ( __x ); }
      const_iterator
      find ( const key_type & __x ) const
      ;
      template < typename _Kt >
 auto
 find ( const _Kt & __x ) const -> decltype ( _M_t . _M_find_tr ( __x ) )
 { return _M_t . _M_find_tr ( __x ); }
      size_type
      count ( const key_type & __x ) const
      ;
      template < typename _Kt >
 auto
 count ( const _Kt & __x ) const -> decltype ( _M_t . _M_count_tr ( __x ) )
 { return _M_t . _M_count_tr ( __x ); }
      iterator
      lower_bound ( const key_type & __x )
      ;
      template < typename _Kt >
 auto
 lower_bound ( const _Kt & __x )
 -> decltype ( _M_t . _M_lower_bound_tr ( __x ) )
 { return _M_t . _M_lower_bound_tr ( __x ); }
      const_iterator
      lower_bound ( const key_type & __x ) const
      ;
      template < typename _Kt >
 auto
 lower_bound ( const _Kt & __x ) const
 -> decltype ( _M_t . _M_lower_bound_tr ( __x ) )
 { return _M_t . _M_lower_bound_tr ( __x ); }
      iterator
      upper_bound ( const key_type & __x )
      ;
      template < typename _Kt >
 auto
 upper_bound ( const _Kt & __x )
 -> decltype ( _M_t . _M_upper_bound_tr ( __x ) )
 { return _M_t . _M_upper_bound_tr ( __x ); }
      const_iterator
      upper_bound ( const key_type & __x ) const
      ;
      template < typename _Kt >
 auto
 upper_bound ( const _Kt & __x ) const
 -> decltype ( _M_t . _M_upper_bound_tr ( __x ) )
 { return _M_t . _M_upper_bound_tr ( __x ); }
      std :: pair < iterator, iterator >
      equal_range ( const key_type & __x )
      ;
      template < typename _Kt >
 auto
 equal_range ( const _Kt & __x )
 -> decltype ( _M_t . _M_equal_range_tr ( __x ) )
 { return _M_t . _M_equal_range_tr ( __x ); }
      std :: pair < const_iterator, const_iterator >
      equal_range ( const key_type & __x ) const
      ;
      template < typename _Kt >
 auto
 equal_range ( const _Kt & __x ) const
 -> decltype ( _M_t . _M_equal_range_tr ( __x ) )
 { return _M_t . _M_equal_range_tr ( __x ); }
      template < typename _K1, typename _T1, typename _C1, typename _A1 >
        friend bool
        operator == ( const multimap < _K1, _T1, _C1, _A1 > &,
     const multimap < _K1, _T1, _C1, _A1 > & );
      template < typename _K1, typename _T1, typename _C1, typename _A1 >
        friend bool
        operator < ( const multimap < _K1, _T1, _C1, _A1 > &,
    const multimap < _K1, _T1, _C1, _A1 > & );
  };
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator == ( const multimap < _Key, _Tp, _Compare, _Alloc > & __x,
               const multimap < _Key, _Tp, _Compare, _Alloc > & __y )
    { return __x . _M_t == __y . _M_t; }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator < ( const multimap < _Key, _Tp, _Compare, _Alloc > & __x,
              const multimap < _Key, _Tp, _Compare, _Alloc > & __y )
    { return __x . _M_t < __y . _M_t; }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator != ( const multimap < _Key, _Tp, _Compare, _Alloc > & __x,
               const multimap < _Key, _Tp, _Compare, _Alloc > & __y )
    { return ! ( __x == __y ); }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator > ( const multimap < _Key, _Tp, _Compare, _Alloc > & __x,
              const multimap < _Key, _Tp, _Compare, _Alloc > & __y )
    { return __y < __x; }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator <= ( const multimap < _Key, _Tp, _Compare, _Alloc > & __x,
               const multimap < _Key, _Tp, _Compare, _Alloc > & __y )
    { return ! ( __y < __x ); }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool
    operator >= ( const multimap < _Key, _Tp, _Compare, _Alloc > & __x,
               const multimap < _Key, _Tp, _Compare, _Alloc > & __y )
    { return ! ( __x < __y ); }
template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline void
    swap ( multimap < _Key, _Tp, _Compare, _Alloc > & __x,
         multimap < _Key, _Tp, _Compare, _Alloc > & __y )
    noexcept ( noexcept ( __x . swap ( __y ) ) )
    { __x . swap ( __y ); }
}
namespace RAJA
{

inline void * __attribute__((always_inline)) align(size_t alignment,size_t size,void *&ptr,size_t &space)
{
void *r = (nullptr);
if (size <= space) {
char *p1 = static_cast < char * >  (ptr);
char *p2 = reinterpret_cast < char * >  (((reinterpret_cast < size_t  >  ((p1 + ((static_cast < ptrdiff_t  >  (alignment)) - 1)))) & -alignment));
size_t d = static_cast < size_t  >  ((p2 - p1));
if (d <= space - size) {
r = p2;
ptr = r;
space -= d;
}
}
return r;
}
}
namespace RAJA
{
template < typename mutex_type >
class lock_guard
{
public :
  explicit lock_guard ( mutex_type & m );
  lock_guard ( const lock_guard & ) = delete;
  lock_guard ( lock_guard && ) = delete;
  lock_guard & operator = ( const lock_guard & ) = delete;
  lock_guard & operator = ( lock_guard && ) = delete;
  ~ lock_guard ( );
private :
  mutex_type & m_mutex;
};
}
namespace RAJA
{
namespace basic_mempool
{
namespace detail
{
class MemoryArena ;

class MemoryArena 
{
using free_type = class ::std::map< void * , void * , class ::std::less< void * >  , class ::std::allocator< class ::std::pair< void *const  , void * >  >  > ;
using free_value_type = ::std::map< void *,void *,class ::std::less< void * > ,class ::std::allocator< class ::std::pair< void *const  , void * >  > > ::value_type ;
using used_type = class ::std::map< void * , void * , class ::std::less< void * >  , class ::std::allocator< class ::std::pair< void *const  , void * >  >  > ;
using used_value_type = ::std::map< void *,void *,class ::std::less< void * > ,class ::std::allocator< class ::std::pair< void *const  , void * >  > > ::value_type ;

public: inline MemoryArena(void *ptr,size_t size) : m_allocation({ptr, ((static_cast < char * >  (ptr)) + size)}), m_free_space(), m_used_space()
{
(this) -> m_free_space[ptr] = ((static_cast < char * >  (ptr)) + size);
if ((this) -> m_allocation . begin == (nullptr)) {
fprintf(stderr,"Attempt to create MemoryArena with no memory");
abort();
}
}
inline MemoryArena(const class MemoryArena &) = delete;

inline MemoryArena &operator=(const class MemoryArena &)
{
}
inline MemoryArena(class MemoryArena &&) = default;

inline MemoryArena &operator=(class MemoryArena &&)
{
}

inline size_t capacity()
{
return ((static_cast < char * >  ((this) -> m_allocation . end)) - (static_cast < char * >  ((this) -> m_allocation . begin)));
}

inline bool unused()
{
return (this) -> m_used_space . empty();
}

inline void *get_allocation()
{
return (this) -> m_allocation . begin;
}

inline void *get(size_t nbytes,size_t alignment)
{
void *ptr_out = (nullptr);
if ((this) ->  capacity () >= nbytes) {
::std::map< void *,void *,class ::std::less< void * > ,class ::std::allocator< class ::std::pair< void *const  , void * >  > > ::iterator end = (this) -> m_free_space . end();
for (::std::map< void *,void *,class ::std::less< void * > ,class ::std::allocator< class ::std::pair< void *const  , void * >  > > ::iterator iter = (this) -> m_free_space . begin(); iter != end;  ++ iter) {
void *adj_ptr = iter -> first;
size_t cap = ((static_cast < char * >  ((iter -> second))) - (static_cast < char * >  (adj_ptr)));
if ((align(alignment,nbytes,adj_ptr,cap))) {
ptr_out = adj_ptr;
(this) ->  remove_free_chunk (iter,adj_ptr,((static_cast < char * >  (adj_ptr)) + nbytes));
(this) ->  add_used_chunk (adj_ptr,((static_cast < char * >  (adj_ptr)) + nbytes));
break; 
}
}
}
return ptr_out;
}

inline bool give(void *ptr)
{
if ((this) -> m_allocation . begin <= ptr && ptr < (this) -> m_allocation . end) {
::std::map< void *,void *,class ::std::less< void * > ,class ::std::allocator< class ::std::pair< void *const  , void * >  > > ::iterator found = (this) -> m_used_space . find(ptr);
if (found != (this) -> m_used_space . end()) {
(this) ->  add_free_chunk ((found -> first),(found -> second));
(this) -> m_used_space . erase(found);
}
 else {
fprintf(stderr,"Invalid free %p",ptr);
abort();
}
return true;
}
 else {
return false;
}
}

private: struct memory_chunk 
{
void *begin;
void *end;
}
;

private: inline void add_free_chunk(void *begin,void *end)
{
::std::map< void *,void *,class ::std::less< void * > ,class ::std::allocator< class ::std::pair< void *const  , void * >  > > ::iterator invl = (this) -> m_free_space . end();
::std::map< void *,void *,class ::std::less< void * > ,class ::std::allocator< class ::std::pair< void *const  , void * >  > > ::iterator next = (this) -> m_free_space . lower_bound(begin);
if (next != (this) -> m_free_space . begin()) {
::std::map< void *,void *,class ::std::less< void * > ,class ::std::allocator< class ::std::pair< void *const  , void * >  > > ::iterator prev = next;
 -- prev;
if (prev -> second == begin) {
prev -> second = end;
if (next != invl) {
static_cast < void  >  (0);
if (next -> first == end) {
prev -> second = next -> second;
(this) -> m_free_space . erase(next);
}
}
return ;
}
}
if (next != invl) {
static_cast < void  >  (0);
if (next -> first == end) {
(this) -> m_free_space . insert(next,::std::pair< void *const ,void *> {begin,next -> second});
(this) -> m_free_space . erase(next);
return ;
}
}
(this) -> m_free_space . insert(next,::std::pair< void *const ,void *> {begin,end});
}

inline void remove_free_chunk(::std::map< void *,void *,class ::std::less< void * > ,class ::std::allocator< class ::std::pair< void *const  , void * >  > > ::iterator iter,void *begin,void *end)
{
void *ptr = iter -> first;
void *ptr_end = iter -> second;
if (ptr != begin) {
iter -> second = begin;
if (end != ptr_end) {
::std::map< void *,void *,class ::std::less< void * > ,class ::std::allocator< class ::std::pair< void *const  , void * >  > > ::iterator next = iter;
 ++ next;
(this) -> m_free_space . insert(next,::std::pair< void *const ,void *> {end,ptr_end});
}
}
 else if (end != ptr_end) {
::std::map< void *,void *,class ::std::less< void * > ,class ::std::allocator< class ::std::pair< void *const  , void * >  > > ::iterator next = iter;
 ++ next;
(this) -> m_free_space . insert(next,::std::pair< void *const ,void *> {end,ptr_end});
(this) -> m_free_space . erase(iter);
}
 else {
(this) -> m_free_space . erase(iter);
}
}

inline void add_used_chunk(void *begin,void *end)
{
(this) -> m_used_space . insert(::std::pair< void *const ,void *> {begin,end});
}
struct memory_chunk m_allocation;
free_type m_free_space;
used_type m_used_space;
}
;
}
template < typename allocator_t >
class MemPool
{
public :
  using allocator_type = allocator_t;
  static inline MemPool < allocator_t > & getInstance ( )
  ;
  static const size_t default_default_arena_size = 32ULL * 1024ULL * 1024ULL;
  MemPool ( )
      ;
  ~ MemPool ( )
  ;
  void free_chunks ( )
  ;
  size_t arena_size ( )
  ;
  size_t arena_size ( size_t new_size )
  ;
  template < typename T >
  T * malloc ( size_t nTs, size_t alignment = alignof ( T ) )
  {
    const size_t size = nTs * sizeof ( T );
    void * ptr = nullptr;
    arena_container_type :: iterator end = m_arenas . end ( );
    for ( arena_container_type :: iterator iter = m_arenas . begin ( ); iter != end;
         ++ iter ) {
      ptr = iter -> get ( size, alignment );
      if ( ptr != nullptr ) {
        break;
      }
    }
    if ( ptr == nullptr ) {
      const size_t alloc_size =
          std :: max ( size + alignment, m_default_arena_size );
      void * arena_ptr = m_alloc . malloc ( alloc_size );
      if ( arena_ptr != nullptr ) {
        m_arenas . emplace_front ( arena_ptr, alloc_size );
        ptr = m_arenas . front ( ) . get ( size, alignment );
      }
    }
    return static_cast < T * > ( ptr );
  }
  void free ( const void * cptr )
  ;
private :
  using arena_container_type = std :: list < detail :: MemoryArena >;
  arena_container_type m_arenas;
  size_t m_default_arena_size;
  allocator_t m_alloc;
};

struct generic_allocator 
{

inline void *malloc(size_t nbytes)
{
return ::malloc(nbytes);
}

inline bool free(void *ptr)
{
::free(ptr);
return true;
}
}
;
}
}
namespace std
{
template < typename _T1, typename ... _Args >
    inline void
    _Construct ( _T1 * __p, _Args && ... __args )
    { :: new ( static_cast < void * > ( __p ) ) _T1 ( std :: forward < _Args > ( __args ) ... ); }
template < typename _Tp >
    inline void
    _Destroy ( _Tp * __pointer )
    { __pointer -> ~ _Tp ( ); }
template < bool >
    struct _Destroy_aux
    {
      template < typename _ForwardIterator >
        static void
        __destroy ( _ForwardIterator __first, _ForwardIterator __last )
 {
   for (; __first != __last; ++ __first )
     std :: _Destroy ( std :: __addressof ( * __first ) );
 }
    };
template<> struct _Destroy_aux< true > 
{
template < typename _ForwardIterator >
        static void
        __destroy ( _ForwardIterator, _ForwardIterator ) { }
};
template < typename _ForwardIterator >
    inline void
    _Destroy ( _ForwardIterator __first, _ForwardIterator __last )
    {
      typedef typename iterator_traits < _ForwardIterator > :: value_type
                       _Value_type;
      std :: _Destroy_aux < __has_trivial_destructor ( _Value_type ) > ::
 __destroy ( __first, __last );
    }
template < typename _ForwardIterator, typename _Allocator >
    void
    _Destroy ( _ForwardIterator __first, _ForwardIterator __last,
      _Allocator & __alloc )
    {
      typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits;
      for (; __first != __last; ++ __first )
 __traits :: destroy ( __alloc, std :: __addressof ( * __first ) );
    }
template < typename _ForwardIterator, typename _Tp >
    inline void
    _Destroy ( _ForwardIterator __first, _ForwardIterator __last,
      allocator < _Tp > & )
    {
      _Destroy ( __first, __last );
    }
}
namespace std
{
template < bool _TrivialValueTypes >
    struct __uninitialized_copy
    {
      template < typename _InputIterator, typename _ForwardIterator >
        static _ForwardIterator
        __uninit_copy ( _InputIterator __first, _InputIterator __last,
        _ForwardIterator __result )
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++ __first, ( void ) ++ __cur )
  std :: _Construct ( std :: __addressof ( * __cur ), * __first );
       return __cur;
     }
   catch ( ... )
     {
       std :: _Destroy ( __result, __cur );
       throw;
     }
 }
    };
template<> struct __uninitialized_copy< true > 
{
template < typename _InputIterator, typename _ForwardIterator >
        static _ForwardIterator
        __uninit_copy ( _InputIterator __first, _InputIterator __last,
        _ForwardIterator __result )
        { return std :: copy ( __first, __last, __result ); }
};
template < typename _InputIterator, typename _ForwardIterator >
    inline _ForwardIterator
    uninitialized_copy ( _InputIterator __first, _InputIterator __last,
         _ForwardIterator __result )
    {
      typedef typename iterator_traits < _InputIterator > :: value_type
 _ValueType1;
      typedef typename iterator_traits < _ForwardIterator > :: value_type
 _ValueType2;
      typedef typename iterator_traits < _InputIterator > :: reference _RefType1;
      typedef typename iterator_traits < _ForwardIterator > :: reference _RefType2;
      const bool __assignable = is_assignable < _RefType2, _RefType1 > :: value;
      return std :: __uninitialized_copy < __is_trivial ( _ValueType1 )
           && __is_trivial ( _ValueType2 )
           && __assignable > ::
 __uninit_copy ( __first, __last, __result );
    }
template < bool _TrivialValueType >
    struct __uninitialized_fill
    {
      template < typename _ForwardIterator, typename _Tp >
        static void
        __uninit_fill ( _ForwardIterator __first, _ForwardIterator __last,
        const _Tp & __x )
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++ __cur )
  std :: _Construct ( std :: __addressof ( * __cur ), __x );
     }
   catch ( ... )
     {
       std :: _Destroy ( __first, __cur );
       throw;
     }
 }
    };
template<> struct __uninitialized_fill< true > 
{
template < typename _ForwardIterator, typename _Tp >
        static void
        __uninit_fill ( _ForwardIterator __first, _ForwardIterator __last,
        const _Tp & __x )
        { std :: fill ( __first, __last, __x ); }
};
template < typename _ForwardIterator, typename _Tp >
    inline void
    uninitialized_fill ( _ForwardIterator __first, _ForwardIterator __last,
         const _Tp & __x )
    {
      typedef typename iterator_traits < _ForwardIterator > :: value_type
 _ValueType;
      const bool __assignable = is_copy_assignable < _ValueType > :: value;
      std :: __uninitialized_fill < __is_trivial ( _ValueType ) && __assignable > ::
 __uninit_fill ( __first, __last, __x );
    }
template < bool _TrivialValueType >
    struct __uninitialized_fill_n
    {
      template < typename _ForwardIterator, typename _Size, typename _Tp >
        static _ForwardIterator
        __uninit_fill_n ( _ForwardIterator __first, _Size __n,
   const _Tp & __x )
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; -- __n, ++ __cur )
  std :: _Construct ( std :: __addressof ( * __cur ), __x );
       return __cur;
     }
   catch ( ... )
     {
       std :: _Destroy ( __first, __cur );
       throw;
     }
 }
    };
template<> struct __uninitialized_fill_n< true > 
{
template < typename _ForwardIterator, typename _Size, typename _Tp >
        static _ForwardIterator
        __uninit_fill_n ( _ForwardIterator __first, _Size __n,
   const _Tp & __x )
        { return std :: fill_n ( __first, __n, __x ); }
};
template < typename _ForwardIterator, typename _Size, typename _Tp >
    inline _ForwardIterator
    uninitialized_fill_n ( _ForwardIterator __first, _Size __n, const _Tp & __x )
    {
      typedef typename iterator_traits < _ForwardIterator > :: value_type
 _ValueType;
      const bool __assignable = is_copy_assignable < _ValueType > :: value;
      return __uninitialized_fill_n < __is_trivial ( _ValueType ) && __assignable > ::
 __uninit_fill_n ( __first, __n, __x );
    }
template < typename _InputIterator, typename _ForwardIterator,
    typename _Allocator >
    _ForwardIterator
    __uninitialized_copy_a ( _InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator & __alloc )
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits;
   for (; __first != __last; ++ __first, ( void ) ++ __cur )
     __traits :: construct ( __alloc, std :: __addressof ( * __cur ), * __first );
   return __cur;
 }
      catch ( ... )
 {
   std :: _Destroy ( __result, __cur, __alloc );
   throw;
 }
    }
template < typename _InputIterator, typename _ForwardIterator, typename _Tp >
    inline _ForwardIterator
    __uninitialized_copy_a ( _InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator < _Tp > & )
    { return std :: uninitialized_copy ( __first, __last, __result ); }
template < typename _InputIterator, typename _ForwardIterator,
    typename _Allocator >
    inline _ForwardIterator
    __uninitialized_move_a ( _InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator & __alloc )
    {
      return std :: __uninitialized_copy_a ( std :: make_move_iterator ( __first ),
      std :: make_move_iterator ( __last ),
      __result, __alloc );
    }
template < typename _InputIterator, typename _ForwardIterator,
    typename _Allocator >
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a ( _InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator & __alloc )
    {
      return std :: __uninitialized_copy_a
 ( std :: __make_move_if_noexcept_iterator ( __first ),
  std :: __make_move_if_noexcept_iterator ( __last ), __result, __alloc );
    }
template < typename _ForwardIterator, typename _Tp, typename _Allocator >
    void
    __uninitialized_fill_a ( _ForwardIterator __first, _ForwardIterator __last,
      const _Tp & __x, _Allocator & __alloc )
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits;
   for (; __cur != __last; ++ __cur )
     __traits :: construct ( __alloc, std :: __addressof ( * __cur ), __x );
 }
      catch ( ... )
 {
   std :: _Destroy ( __first, __cur, __alloc );
   throw;
 }
    }
template < typename _ForwardIterator, typename _Tp, typename _Tp2 >
    inline void
    __uninitialized_fill_a ( _ForwardIterator __first, _ForwardIterator __last,
      const _Tp & __x, allocator < _Tp2 > & )
    { std :: uninitialized_fill ( __first, __last, __x ); }
template < typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator >
    _ForwardIterator
    __uninitialized_fill_n_a ( _ForwardIterator __first, _Size __n,
        const _Tp & __x, _Allocator & __alloc )
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits;
   for (; __n > 0; -- __n, ++ __cur )
     __traits :: construct ( __alloc, std :: __addressof ( * __cur ), __x );
   return __cur;
 }
      catch ( ... )
 {
   std :: _Destroy ( __first, __cur, __alloc );
   throw;
 }
    }
template < typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2 >
    inline _ForwardIterator
    __uninitialized_fill_n_a ( _ForwardIterator __first, _Size __n,
        const _Tp & __x, allocator < _Tp2 > & )
    { return std :: uninitialized_fill_n ( __first, __n, __x ); }
template < typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator >
    inline _ForwardIterator
    __uninitialized_copy_move ( _InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator & __alloc )
    {
      _ForwardIterator __mid = std :: __uninitialized_copy_a ( __first1, __last1,
          __result,
          __alloc );
      try
 {
   return std :: __uninitialized_move_a ( __first2, __last2, __mid, __alloc );
 }
      catch ( ... )
 {
   std :: _Destroy ( __result, __mid, __alloc );
   throw;
 }
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator >
    inline _ForwardIterator
    __uninitialized_move_copy ( _InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator & __alloc )
    {
      _ForwardIterator __mid = std :: __uninitialized_move_a ( __first1, __last1,
          __result,
          __alloc );
      try
 {
   return std :: __uninitialized_copy_a ( __first2, __last2, __mid, __alloc );
 }
      catch ( ... )
 {
   std :: _Destroy ( __result, __mid, __alloc );
   throw;
 }
    }
template < typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator >
    inline _ForwardIterator
    __uninitialized_fill_move ( _ForwardIterator __result, _ForwardIterator __mid,
         const _Tp & __x, _InputIterator __first,
         _InputIterator __last, _Allocator & __alloc )
    {
      std :: __uninitialized_fill_a ( __result, __mid, __x, __alloc );
      try
 {
   return std :: __uninitialized_move_a ( __first, __last, __mid, __alloc );
 }
      catch ( ... )
 {
   std :: _Destroy ( __result, __mid, __alloc );
   throw;
 }
    }
template < typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator >
    inline void
    __uninitialized_move_fill ( _InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp & __x,
         _Allocator & __alloc )
    {
      _ForwardIterator __mid2 = std :: __uninitialized_move_a ( __first1, __last1,
           __first2,
           __alloc );
      try
 {
   std :: __uninitialized_fill_a ( __mid2, __last2, __x, __alloc );
 }
      catch ( ... )
 {
   std :: _Destroy ( __first2, __mid2, __alloc );
   throw;
 }
    }
template < bool _TrivialValueType >
    struct __uninitialized_default_1
    {
      template < typename _ForwardIterator >
        static void
        __uninit_default ( _ForwardIterator __first, _ForwardIterator __last )
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++ __cur )
  std :: _Construct ( std :: __addressof ( * __cur ) );
     }
   catch ( ... )
     {
       std :: _Destroy ( __first, __cur );
       throw;
     }
 }
    };
template<> struct __uninitialized_default_1< true > 
{
template < typename _ForwardIterator >
        static void
        __uninit_default ( _ForwardIterator __first, _ForwardIterator __last )
        {
   typedef typename iterator_traits < _ForwardIterator > :: value_type
     _ValueType;
   std :: fill ( __first, __last, _ValueType ( ) );
 }
};
template < bool _TrivialValueType >
    struct __uninitialized_default_n_1
    {
      template < typename _ForwardIterator, typename _Size >
        static _ForwardIterator
        __uninit_default_n ( _ForwardIterator __first, _Size __n )
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; -- __n, ++ __cur )
  std :: _Construct ( std :: __addressof ( * __cur ) );
       return __cur;
     }
   catch ( ... )
     {
       std :: _Destroy ( __first, __cur );
       throw;
     }
 }
    };
template<> struct __uninitialized_default_n_1< true > 
{
template < typename _ForwardIterator, typename _Size >
        static _ForwardIterator
        __uninit_default_n ( _ForwardIterator __first, _Size __n )
        {
   typedef typename iterator_traits < _ForwardIterator > :: value_type
     _ValueType;
   return std :: fill_n ( __first, __n, _ValueType ( ) );
 }
};
template < typename _ForwardIterator >
    inline void
    __uninitialized_default ( _ForwardIterator __first,
       _ForwardIterator __last )
    {
      typedef typename iterator_traits < _ForwardIterator > :: value_type
 _ValueType;
      const bool __assignable = is_copy_assignable < _ValueType > :: value;
      std :: __uninitialized_default_1 < __is_trivial ( _ValueType )
         && __assignable > ::
 __uninit_default ( __first, __last );
    }
template < typename _ForwardIterator, typename _Size >
    inline _ForwardIterator
    __uninitialized_default_n ( _ForwardIterator __first, _Size __n )
    {
      typedef typename iterator_traits < _ForwardIterator > :: value_type
 _ValueType;
      const bool __assignable = is_copy_assignable < _ValueType > :: value;
      return __uninitialized_default_n_1 < __is_trivial ( _ValueType )
           && __assignable > ::
 __uninit_default_n ( __first, __n );
    }
template < typename _ForwardIterator, typename _Allocator >
    void
    __uninitialized_default_a ( _ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator & __alloc )
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits;
   for (; __cur != __last; ++ __cur )
     __traits :: construct ( __alloc, std :: __addressof ( * __cur ) );
 }
      catch ( ... )
 {
   std :: _Destroy ( __first, __cur, __alloc );
   throw;
 }
    }
template < typename _ForwardIterator, typename _Tp >
    inline void
    __uninitialized_default_a ( _ForwardIterator __first,
         _ForwardIterator __last,
         allocator < _Tp > & )
    { std :: __uninitialized_default ( __first, __last ); }
template < typename _ForwardIterator, typename _Size, typename _Allocator >
    _ForwardIterator
    __uninitialized_default_n_a ( _ForwardIterator __first, _Size __n,
    _Allocator & __alloc )
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits;
   for (; __n > 0; -- __n, ++ __cur )
     __traits :: construct ( __alloc, std :: __addressof ( * __cur ) );
   return __cur;
 }
      catch ( ... )
 {
   std :: _Destroy ( __first, __cur, __alloc );
   throw;
 }
    }
template < typename _ForwardIterator, typename _Size, typename _Tp >
    inline _ForwardIterator
    __uninitialized_default_n_a ( _ForwardIterator __first, _Size __n,
    allocator < _Tp > & )
    { return std :: __uninitialized_default_n ( __first, __n ); }
template < typename _InputIterator, typename _Size,
    typename _ForwardIterator >
    _ForwardIterator
    __uninitialized_copy_n ( _InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag )
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; -- __n, ++ __first, ++ __cur )
     std :: _Construct ( std :: __addressof ( * __cur ), * __first );
   return __cur;
 }
      catch ( ... )
 {
   std :: _Destroy ( __result, __cur );
   throw;
 }
    }
template < typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator >
    inline _ForwardIterator
    __uninitialized_copy_n ( _RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag )
    { return std :: uninitialized_copy ( __first, __first + __n, __result ); }
template < typename _InputIterator, typename _Size, typename _ForwardIterator >
    inline _ForwardIterator
    uninitialized_copy_n ( _InputIterator __first, _Size __n,
    _ForwardIterator __result )
    { return std :: __uninitialized_copy_n ( __first, __n, __result,
      std :: __iterator_category ( __first ) ); }
}
namespace std
{
template < typename _Tp >
    pair < _Tp *, ptrdiff_t >
    get_temporary_buffer ( ptrdiff_t __len ) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx :: __numeric_traits < ptrdiff_t > :: __max / sizeof ( _Tp );
      if ( __len > __max )
 __len = __max;
      while ( __len > 0 )
 {
   _Tp * __tmp = static_cast < _Tp * > ( :: operator new ( __len * sizeof ( _Tp ),
       std :: nothrow ) );
   if ( __tmp != 0 )
     return std :: pair < _Tp *, ptrdiff_t > ( __tmp, __len );
   __len /= 2;
 }
      return std :: pair < _Tp *, ptrdiff_t > ( static_cast < _Tp * > ( 0 ), 0 );
    }
template < typename _Tp >
    inline void
    return_temporary_buffer ( _Tp * __p )
    { :: operator delete ( __p, std :: nothrow ); }
template < typename _ForwardIterator, typename _Tp >
    class _Temporary_buffer
    {
    public :
      typedef _Tp value_type;
      typedef value_type * pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;
    protected :
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;
    public :
      size_type
      size ( ) const
      ;
      size_type
      requested_size ( ) const
      ;
      iterator
      begin ( )
      ;
      iterator
      end ( )
      ;
      _Temporary_buffer ( _ForwardIterator __first, _ForwardIterator __last );
      ~ _Temporary_buffer ( )
      ;
    private :
      _Temporary_buffer ( const _Temporary_buffer & );
      void
      operator = ( const _Temporary_buffer & );
    };
template < bool >
    struct __uninitialized_construct_buf_dispatch
    {
      template < typename _Pointer, typename _ForwardIterator >
        static void
        __ucr ( _Pointer __first, _Pointer __last,
       _ForwardIterator __seed )
        {
   if ( __first == __last )
     return;
   _Pointer __cur = __first;
   try
     {
       std :: _Construct ( std :: __addressof ( * __first ),
         std :: move ( * __seed ) );
       _Pointer __prev = __cur;
       ++ __cur;
       for (; __cur != __last; ++ __cur, ++ __prev )
  std :: _Construct ( std :: __addressof ( * __cur ),
    std :: move ( * __prev ) );
       * __seed = std :: move ( * __prev );
     }
   catch ( ... )
     {
       std :: _Destroy ( __first, __cur );
       throw;
     }
 }
    };
template<> struct __uninitialized_construct_buf_dispatch< true > 
{
template < typename _Pointer, typename _ForwardIterator >
        static void
        __ucr ( _Pointer, _Pointer, _ForwardIterator ) { }
};
template < typename _Pointer, typename _ForwardIterator >
    inline void
    __uninitialized_construct_buf ( _Pointer __first, _Pointer __last,
      _ForwardIterator __seed )
    {
      typedef typename std :: iterator_traits < _Pointer > :: value_type
 _ValueType;
      std :: __uninitialized_construct_buf_dispatch <
        __has_trivial_constructor ( _ValueType ) > ::
   __ucr ( __first, __last, __seed );
    }
template < typename _ForwardIterator, typename _Tp >
    _Temporary_buffer < _ForwardIterator, _Tp > ::
    _Temporary_buffer ( _ForwardIterator __first, _ForwardIterator __last )
    : _M_original_len ( std :: distance ( __first, __last ) ),
      _M_len ( 0 ), _M_buffer ( 0 )
    {
      try
 {
   std :: pair < pointer, size_type > __p ( std :: get_temporary_buffer <
         value_type > ( _M_original_len ) );
   _M_buffer = __p . first;
   _M_len = __p . second;
   if ( _M_buffer )
     std :: __uninitialized_construct_buf ( _M_buffer, _M_buffer + _M_len,
            __first );
 }
      catch ( ... )
 {
   std :: return_temporary_buffer ( _M_buffer );
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }
}
namespace std
{
template < class _OutputIterator, class _Tp >
    class raw_storage_iterator
    : public iterator < output_iterator_tag, void, void, void, void >
    {
    protected :
      _OutputIterator _M_iter;
    public :
      explicit
      raw_storage_iterator ( _OutputIterator __x )
      ;
      raw_storage_iterator &
      operator * ( );
      raw_storage_iterator &
      operator = ( const _Tp & __element )
      ;
      raw_storage_iterator < _OutputIterator, _Tp > &
      operator ++ ( )
      ;
      raw_storage_iterator < _OutputIterator, _Tp >
      operator ++ ( int )
      ;
      _OutputIterator base ( ) const;
    };
}
#pragma GCC visibility push ( default )
extern "C++" {
namespace __cxxabiv1
{
class __class_type_info ;
}
namespace std
{

class type_info 
{
public: virtual ~type_info();

inline const char *name() const
{
return (this) -> __name[0] == '*'?(this) -> __name + 1 : (this) -> __name;
}

inline bool before(const class type_info &__arg) const
{
return (this) -> __name[0] == '*' && __arg . __name[0] == '*'?(this) -> __name < __arg . __name : __builtin_strcmp((this) -> __name,__arg . __name) < 0;
}

inline bool operator==(const class type_info &__arg) const
{
return (this) -> __name == __arg . __name || (this) -> __name[0] != '*' && __builtin_strcmp((this) -> __name,__arg . __name) == 0;
}

inline bool operator!=(const class type_info &__arg) const
{
return !((this) ->  operator== (__arg));
}

inline size_t hash_code() const
{
return _Hash_bytes(((this) ->  name ()),(__builtin_strlen(((this) ->  name ()))),static_cast < size_t  >  (0xc70f6907UL));
}
virtual bool __is_pointer_p() const;
virtual bool __is_function_p() const;
virtual bool __do_catch(const class type_info *__thr_type,void **__thr_obj,unsigned int __outer) const;
virtual bool __do_upcast(const class __cxxabiv1::__class_type_info *__target,void **__obj_ptr) const;
protected: const char *__name;

inline explicit type_info(const char *__n) : __name(__n)
{
}
private: type_info &operator=(const class type_info &);
type_info(const class type_info &);
}
;

class bad_cast : public exception
{

public: inline bad_cast()
{
}
virtual ~bad_cast();
virtual const char *what() const;
}
;

class bad_typeid : public exception
{

public: inline bad_typeid()
{
}
virtual ~bad_typeid();
virtual const char *what() const;
}
;
}
}
#pragma GCC visibility pop
namespace __gnu_cxx
{
enum _Lock_policy {_S_single=0,_S_mutex=1,_S_atomic=2} ;
static const enum _Lock_policy __default_lock_policy = _S_atomic;

class __concurrence_lock_error : public std::exception
{

public: virtual inline const char *what() const throw()
{
return "__gnu_cxx::__concurrence_lock_error";
}
}
;

class __concurrence_unlock_error : public std::exception
{

public: virtual inline const char *what() const throw()
{
return "__gnu_cxx::__concurrence_unlock_error";
}
}
;

class __concurrence_broadcast_error : public std::exception
{

public: virtual inline const char *what() const throw()
{
return "__gnu_cxx::__concurrence_broadcast_error";
}
}
;

class __concurrence_wait_error : public std::exception
{

public: virtual inline const char *what() const throw()
{
return "__gnu_cxx::__concurrence_wait_error";
}
}
;

inline void  __attribute__((visibility("default"))) __throw_concurrence_lock_error()
{
throw __concurrence_lock_error();
}

inline void  __attribute__((visibility("default"))) __throw_concurrence_unlock_error()
{
throw __concurrence_unlock_error();
}

inline void  __attribute__((visibility("default"))) __throw_concurrence_broadcast_error()
{
throw __concurrence_broadcast_error();
}

inline void  __attribute__((visibility("default"))) __throw_concurrence_wait_error()
{
throw __concurrence_wait_error();
}

class __mutex 
{
private: __gthread_mutex_t _M_mutex;
__mutex(const class __mutex &);
__mutex &operator=(const class __mutex &);

public: inline __mutex()
{
}

inline void lock()
{
if ((__gthread_active_p())) {
if (__gthread_mutex_lock(&(this) -> _M_mutex) != 0) 
__throw_concurrence_lock_error();
}
}

inline void unlock()
{
if ((__gthread_active_p())) {
if (__gthread_mutex_unlock(&(this) -> _M_mutex) != 0) 
__throw_concurrence_unlock_error();
}
}

inline __gthread_mutex_t *gthread_mutex()
{
return &(this) -> _M_mutex;
}
}
;

class __recursive_mutex 
{
private: __gthread_recursive_mutex_t _M_mutex;
__recursive_mutex(const class __recursive_mutex &);
__recursive_mutex &operator=(const class __recursive_mutex &);

public: inline __recursive_mutex()
{
}

inline void lock()
{
if ((__gthread_active_p())) {
if (__gthread_recursive_mutex_lock(&(this) -> _M_mutex) != 0) 
__throw_concurrence_lock_error();
}
}

inline void unlock()
{
if ((__gthread_active_p())) {
if (__gthread_recursive_mutex_unlock(&(this) -> _M_mutex) != 0) 
__throw_concurrence_unlock_error();
}
}

inline __gthread_recursive_mutex_t *gthread_recursive_mutex()
{
return &(this) -> _M_mutex;
}
}
;

class __scoped_lock 
{
public: typedef class __mutex __mutex_type;
private: __mutex_type &_M_device;
__scoped_lock(const class __scoped_lock &);
__scoped_lock &operator=(const class __scoped_lock &);

public: inline explicit __scoped_lock(__mutex_type &__name) : _M_device(__name)
{
(this) -> _M_device .  lock ();
}

inline ~__scoped_lock() throw()
{
(this) -> _M_device .  unlock ();
}
}
;

class __cond 
{
private: __gthread_cond_t _M_cond;
__cond(const class __cond &);
__cond &operator=(const class __cond &);

public: inline __cond()
{
}

inline void broadcast()
{
if ((__gthread_active_p())) {
if (__gthread_cond_broadcast(&(this) -> _M_cond) != 0) 
__throw_concurrence_broadcast_error();
}
}

inline void wait(class __mutex *mutex)
{
{
if (__gthread_cond_wait(&(this) -> _M_cond,(mutex ->  gthread_mutex ())) != 0) 
__throw_concurrence_wait_error();
}
}

inline void wait_recursive(class __recursive_mutex *mutex)
{
{
if (__gthread_cond_wait_recursive(&(this) -> _M_cond,(mutex ->  gthread_recursive_mutex ())) != 0) 
__throw_concurrence_wait_error();
}
}
}
;
}
namespace std
{
template < typename _MemberPointer >
    class _Mem_fn;
template < typename _Tp, typename _Class >
    _Mem_fn < _Tp _Class :: * >
    mem_fn ( _Tp _Class :: * ) noexcept;
template < typename _Functor, typename = __void_t < > >
    struct _Maybe_get_result_type
    { };
template < typename _Functor >
    struct _Maybe_get_result_type < _Functor,
      __void_t < typename _Functor :: result_type > >
    { typedef typename _Functor :: result_type result_type; };
template < typename _Functor >
    struct _Weak_result_type_impl
    : _Maybe_get_result_type < _Functor >
    { };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _ArgTypes ... ) >
    { typedef _Res result_type; };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _ArgTypes ... ... ) >
    { typedef _Res result_type; };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _ArgTypes ... ) const >
    { typedef _Res result_type; };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _ArgTypes ... ... ) const >
    { typedef _Res result_type; };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _ArgTypes ... ) volatile >
    { typedef _Res result_type; };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _ArgTypes ... ... ) volatile >
    { typedef _Res result_type; };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _ArgTypes ... ) const volatile >
    { typedef _Res result_type; };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _ArgTypes ... ... ) const volatile >
    { typedef _Res result_type; };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( & ) ( _ArgTypes ... ) >
    { typedef _Res result_type; };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( & ) ( _ArgTypes ... ... ) >
    { typedef _Res result_type; };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( * ) ( _ArgTypes ... ) >
    { typedef _Res result_type; };
template < typename _Res, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( * ) ( _ArgTypes ... ... ) >
    { typedef _Res result_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _Class :: * ) ( _ArgTypes ... ) >
    { typedef _Res result_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _Class :: * ) ( _ArgTypes ... ... ) >
    { typedef _Res result_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _Class :: * ) ( _ArgTypes ... ) const >
    { typedef _Res result_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _Class :: * ) ( _ArgTypes ... ... ) const >
    { typedef _Res result_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _Class :: * ) ( _ArgTypes ... ) volatile >
    { typedef _Res result_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _Class :: * ) ( _ArgTypes ... ... ) volatile >
    { typedef _Res result_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _Class :: * ) ( _ArgTypes ... )
      const volatile >
    { typedef _Res result_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes >
    struct _Weak_result_type_impl < _Res ( _Class :: * ) ( _ArgTypes ... ... )
      const volatile >
    { typedef _Res result_type; };
template < typename _Functor >
    struct _Weak_result_type
    : _Weak_result_type_impl < typename remove_cv < _Functor > :: type >
    { };
template < typename _Tp, typename _Up = typename decay < _Tp > :: type >
    struct _Unwrap
    {
      using type = _Tp &&;
      static constexpr _Tp &&
      _S_fwd ( _Tp & __t ) noexcept;
    };
template < typename _Tp, typename _Up >
    struct _Unwrap < _Tp, reference_wrapper < _Up > >
    {
      using type = _Up &;
      static _Up &
      _S_fwd ( const _Tp & __t ) noexcept;
    };
template < typename _Tp >
    inline typename _Unwrap < _Tp > :: type
    __invfwd ( typename remove_reference < _Tp > :: type & __t ) noexcept
    { return _Unwrap < _Tp > :: _S_fwd ( __t ); }
template < typename _Res, typename _Fn, typename ... _Args >
    inline _Res
    __invoke_impl ( __invoke_other, _Fn && __f, _Args && ... __args )
    noexcept ( noexcept ( std :: forward < _Fn > ( __f ) ( std :: forward < _Args > ( __args ) ... ) ) )
    { return std :: forward < _Fn > ( __f ) ( std :: forward < _Args > ( __args ) ... ); }
template < typename _Res, typename _MemFun, typename _Tp, typename ... _Args >
    inline _Res
    __invoke_impl ( __invoke_memfun_ref, _MemFun && __f, _Tp && __t,
    _Args && ... __args )
    noexcept ( noexcept (
   ( __invfwd < _Tp > ( __t ) .* __f ) ( std :: forward < _Args > ( __args ) ... ) ) )
    { return ( __invfwd < _Tp > ( __t ) .* __f ) ( std :: forward < _Args > ( __args ) ... ); }
template < typename _Res, typename _MemFun, typename _Tp, typename ... _Args >
    inline _Res
    __invoke_impl ( __invoke_memfun_deref, _MemFun && __f, _Tp && __t,
    _Args && ... __args )
    noexcept ( noexcept (
   ( ( * std :: forward < _Tp > ( __t ) ) .* __f ) ( std :: forward < _Args > ( __args ) ... ) ) )
    {
      return ( ( * std :: forward < _Tp > ( __t ) ) .* __f ) ( std :: forward < _Args > ( __args ) ... );
    }
template < typename _Res, typename _MemFun, typename _Tp, typename ... _Args >
    inline _Res
    __invoke_impl ( __invoke_memobj_ref, _MemFun && __f, _Tp && __t )
    noexcept ( noexcept ( __invfwd < _Tp > ( __t ) .* __f ) )
    { return __invfwd < _Tp > ( __t ) .* __f; }
template < typename _Res, typename _MemFun, typename _Tp, typename ... _Args >
    inline _Res
    __invoke_impl ( __invoke_memobj_deref, _MemFun && __f, _Tp && __t,
    _Args && ... __args )
    noexcept ( noexcept ( ( * std :: forward < _Tp > ( __t ) ) .* __f ) )
    { return ( * std :: forward < _Tp > ( __t ) ) .* __f; }
template < typename _Callable, typename ... _Args >
    inline typename result_of < _Callable && ( _Args && ... ) > :: type
    __invoke ( _Callable && __fn, _Args && ... __args )
    {
      using __result_of = result_of < _Callable && ( _Args && ... ) >;
      using __type = typename __result_of :: type;
      using __tag = typename __result_of :: __invoke_type;
      return std :: __invoke_impl < __type > ( __tag { }, std :: forward < _Callable > ( __fn ),
     std :: forward < _Args > ( __args ) ... );
    }
template < bool _Unary, bool _Binary, typename _Tp >
    struct _Reference_wrapper_base_impl;
template < typename _Tp >
    struct _Reference_wrapper_base_impl < false, false, _Tp >
    : _Weak_result_type < _Tp >
    { };
template < typename _Tp >
    struct _Reference_wrapper_base_impl < true, false, _Tp >
    : _Weak_result_type < _Tp >
    {
      typedef typename _Tp :: argument_type argument_type;
    };
template < typename _Tp >
    struct _Reference_wrapper_base_impl < false, true, _Tp >
    : _Weak_result_type < _Tp >
    {
      typedef typename _Tp :: first_argument_type first_argument_type;
      typedef typename _Tp :: second_argument_type second_argument_type;
    };
template < typename _Tp >
    struct _Reference_wrapper_base_impl < true, true, _Tp >
    : _Weak_result_type < _Tp >
    {
      typedef typename _Tp :: argument_type argument_type;
      typedef typename _Tp :: first_argument_type first_argument_type;
      typedef typename _Tp :: second_argument_type second_argument_type;
    };
template < typename _Tp, typename = __void_t < > > struct __has_argument_type : false_type { };
template < typename _Tp > struct __has_argument_type < _Tp, __void_t < typename _Tp :: argument_type > > : true_type { };
template < typename _Tp, typename = __void_t < > > struct __has_first_argument_type : false_type { };
template < typename _Tp > struct __has_first_argument_type < _Tp, __void_t < typename _Tp :: first_argument_type > > : true_type { };
template < typename _Tp, typename = __void_t < > > struct __has_second_argument_type : false_type { };
template < typename _Tp > struct __has_second_argument_type < _Tp, __void_t < typename _Tp :: second_argument_type > > : true_type { };
template < typename _Tp >
    struct _Reference_wrapper_base
    : _Reference_wrapper_base_impl <
      __has_argument_type < _Tp > :: value,
      __has_first_argument_type < _Tp > :: value
      && __has_second_argument_type < _Tp > :: value,
      _Tp >
    { };
template < typename _Res, typename _T1 >
    struct _Reference_wrapper_base < _Res ( _T1 ) >
    : unary_function < _T1, _Res >
    { };
template < typename _Res, typename _T1 >
    struct _Reference_wrapper_base < _Res ( _T1 ) const >
    : unary_function < _T1, _Res >
    { };
template < typename _Res, typename _T1 >
    struct _Reference_wrapper_base < _Res ( _T1 ) volatile >
    : unary_function < _T1, _Res >
    { };
template < typename _Res, typename _T1 >
    struct _Reference_wrapper_base < _Res ( _T1 ) const volatile >
    : unary_function < _T1, _Res >
    { };
template < typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base < _Res ( _T1, _T2 ) >
    : binary_function < _T1, _T2, _Res >
    { };
template < typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base < _Res ( _T1, _T2 ) const >
    : binary_function < _T1, _T2, _Res >
    { };
template < typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base < _Res ( _T1, _T2 ) volatile >
    : binary_function < _T1, _T2, _Res >
    { };
template < typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base < _Res ( _T1, _T2 ) const volatile >
    : binary_function < _T1, _T2, _Res >
    { };
template < typename _Res, typename _T1 >
    struct _Reference_wrapper_base < _Res ( * ) ( _T1 ) >
    : unary_function < _T1, _Res >
    { };
template < typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base < _Res ( * ) ( _T1, _T2 ) >
    : binary_function < _T1, _T2, _Res >
    { };
template < typename _Res, typename _T1 >
    struct _Reference_wrapper_base < _Res ( _T1 :: * ) ( ) >
    : unary_function < _T1 *, _Res >
    { };
template < typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base < _Res ( _T1 :: * ) ( _T2 ) >
    : binary_function < _T1 *, _T2, _Res >
    { };
template < typename _Res, typename _T1 >
    struct _Reference_wrapper_base < _Res ( _T1 :: * ) ( ) const >
    : unary_function < const _T1 *, _Res >
    { };
template < typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base < _Res ( _T1 :: * ) ( _T2 ) const >
    : binary_function < const _T1 *, _T2, _Res >
    { };
template < typename _Res, typename _T1 >
    struct _Reference_wrapper_base < _Res ( _T1 :: * ) ( ) volatile >
    : unary_function < volatile _T1 *, _Res >
    { };
template < typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base < _Res ( _T1 :: * ) ( _T2 ) volatile >
    : binary_function < volatile _T1 *, _T2, _Res >
    { };
template < typename _Res, typename _T1 >
    struct _Reference_wrapper_base < _Res ( _T1 :: * ) ( ) const volatile >
    : unary_function < const volatile _T1 *, _Res >
    { };
template < typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base < _Res ( _T1 :: * ) ( _T2 ) const volatile >
    : binary_function < const volatile _T1 *, _T2, _Res >
    { };
template < typename _Tp >
    class reference_wrapper
    : public _Reference_wrapper_base < typename remove_cv < _Tp > :: type >
    {
      _Tp * _M_data;
    public :
      typedef _Tp type;
      reference_wrapper ( _Tp & __indata ) noexcept
      ;
      reference_wrapper ( _Tp && ) = delete;
      reference_wrapper ( const reference_wrapper & ) = default;
      reference_wrapper &
      operator = ( const reference_wrapper & ) = default;
      operator _Tp & ( ) const noexcept
      ;
      _Tp &
      get ( ) const noexcept
      ;
      template < typename ... _Args >
 typename result_of < _Tp & ( _Args && ... ) > :: type
 operator ( ) ( _Args && ... __args ) const
 {
   return std :: __invoke ( get ( ), std :: forward < _Args > ( __args ) ... );
 }
    };
template < typename _Tp >
    inline reference_wrapper < _Tp >
    ref ( _Tp & __t ) noexcept
    { return reference_wrapper < _Tp > ( __t ); }
template < typename _Tp >
    inline reference_wrapper < const _Tp >
    cref ( const _Tp & __t ) noexcept
    { return reference_wrapper < const _Tp > ( __t ); }
template < typename _Tp >
    void ref ( const _Tp && ) = delete;
template < typename _Tp >
    void cref ( const _Tp && ) = delete;
template < typename _Tp >
    inline reference_wrapper < _Tp >
    ref ( reference_wrapper < _Tp > __t ) noexcept
    { return ref ( __t . get ( ) ); }
template < typename _Tp >
    inline reference_wrapper < const _Tp >
    cref ( reference_wrapper < _Tp > __t ) noexcept
    { return cref ( __t . get ( ) ); }
template < typename ... _Types >
    struct _Pack : integral_constant < size_t, sizeof ... ( _Types ) >
    { };
template < typename _From, typename _To, bool = _From :: value == _To :: value >
    struct _AllConvertible : false_type
    { };
template < typename ... _From, typename ... _To >
    struct _AllConvertible < _Pack < _From ... >, _Pack < _To ... >, true >
    : __and_ < is_convertible < _From, _To > ... >
    { };
template < typename _Tp1, typename _Tp2 >
    using _NotSame = __not_ < is_same < typename std :: decay < _Tp1 > :: type,
        typename std :: decay < _Tp2 > :: type >>;
template < typename _Res, typename ... _ArgTypes >
    struct _Maybe_unary_or_binary_function { };
template < typename _Res, typename _T1 >
    struct _Maybe_unary_or_binary_function < _Res, _T1 >
    : std :: unary_function < _T1, _Res > { };
template < typename _Res, typename _T1, typename _T2 >
    struct _Maybe_unary_or_binary_function < _Res, _T1, _T2 >
    : std :: binary_function < _T1, _T2, _Res > { };
template < typename _Signature >
    struct _Mem_fn_traits;
template < typename _Res, typename _Class, typename ... _ArgTypes >
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function < _Res, _Class *, _ArgTypes ... >;
      using __arity = integral_constant < size_t, sizeof ... ( _ArgTypes ) >;
    };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) > : _Mem_fn_traits_base < _Res, _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) > : _Mem_fn_traits_base < _Res, _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) const > : _Mem_fn_traits_base < _Res, const _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) const > : _Mem_fn_traits_base < _Res, const _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) volatile > : _Mem_fn_traits_base < _Res, volatile _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) volatile > : _Mem_fn_traits_base < _Res, volatile _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) const volatile > : _Mem_fn_traits_base < _Res, const volatile _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) const volatile > : _Mem_fn_traits_base < _Res, const volatile _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) & > : _Mem_fn_traits_base < _Res, _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) & > : _Mem_fn_traits_base < _Res, _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) const & > : _Mem_fn_traits_base < _Res, const _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) const & > : _Mem_fn_traits_base < _Res, const _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) volatile & > : _Mem_fn_traits_base < _Res, volatile _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) volatile & > : _Mem_fn_traits_base < _Res, volatile _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) const volatile & > : _Mem_fn_traits_base < _Res, const volatile _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) const volatile & > : _Mem_fn_traits_base < _Res, const volatile _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) && > : _Mem_fn_traits_base < _Res, _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) && > : _Mem_fn_traits_base < _Res, _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) const && > : _Mem_fn_traits_base < _Res, const _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) const && > : _Mem_fn_traits_base < _Res, const _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) volatile && > : _Mem_fn_traits_base < _Res, volatile _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) volatile && > : _Mem_fn_traits_base < _Res, volatile _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ) const volatile && > : _Mem_fn_traits_base < _Res, const volatile _Class, _ArgTypes ... > { using __vararg = false_type; };
template < typename _Res, typename _Class, typename ... _ArgTypes > struct _Mem_fn_traits < _Res ( _Class :: * ) ( _ArgTypes ... ... ) const volatile && > : _Mem_fn_traits_base < _Res, const volatile _Class, _ArgTypes ... > { using __vararg = true_type; };
template < typename _MemFunPtr,
    bool __is_mem_fn = is_member_function_pointer < _MemFunPtr > :: value >
    class _Mem_fn_base
    : public _Mem_fn_traits < _MemFunPtr > :: __maybe_type
    {
      using _Traits = _Mem_fn_traits < _MemFunPtr >;
      using _Arity = typename _Traits :: __arity;
      using _Varargs = typename _Traits :: __vararg;
      template < typename _Func, typename ... _BoundArgs >
 friend struct _Bind_check_arity;
      _MemFunPtr _M_pmf;
    public :
      using result_type = typename _Traits :: __result_type;
      explicit constexpr
      _Mem_fn_base ( _MemFunPtr __pmf ) noexcept;
      template < typename ... _Args >
 auto
 operator ( ) ( _Args && ... __args ) const
 noexcept ( noexcept (
       std :: __invoke ( _M_pmf, std :: forward < _Args > ( __args ) ... ) ) )
 -> decltype ( std :: __invoke ( _M_pmf, std :: forward < _Args > ( __args ) ... ) )
 { return std :: __invoke ( _M_pmf, std :: forward < _Args > ( __args ) ... ); }
    };
template < typename _MemObjPtr >
    class _Mem_fn_base < _MemObjPtr, false >
    {
      using _Arity = integral_constant < size_t, 0 >;
      using _Varargs = false_type;
      template < typename _Func, typename ... _BoundArgs >
 friend struct _Bind_check_arity;
      _MemObjPtr _M_pm;
    public :
      explicit constexpr
      _Mem_fn_base ( _MemObjPtr __pm ) noexcept;
      template < typename _Tp >
 auto
 operator ( ) ( _Tp && __obj ) const
 noexcept ( noexcept ( std :: __invoke ( _M_pm, std :: forward < _Tp > ( __obj ) ) ) )
 -> decltype ( std :: __invoke ( _M_pm, std :: forward < _Tp > ( __obj ) ) )
 { return std :: __invoke ( _M_pm, std :: forward < _Tp > ( __obj ) ); }
    };
template < typename _Res, typename _Class >
    struct _Mem_fn < _Res _Class :: * >
    : _Mem_fn_base < _Res _Class :: * >
    {
      using _Mem_fn_base < _Res _Class :: * > :: _Mem_fn_base;
    };
template < typename _Tp, typename _Class >
    inline _Mem_fn < _Tp _Class :: * >
    mem_fn ( _Tp _Class :: * __pm ) noexcept
    {
      return _Mem_fn < _Tp _Class :: * > ( __pm );
    }
template < typename _Tp >
    struct is_bind_expression
    : public false_type { };
template < typename _Tp >
    struct is_placeholder
    : public integral_constant < int, 0 >
    { };
template < int _Num > struct _Placeholder { };
namespace placeholders
{
extern const struct _Placeholder< 1 > _1;
extern const struct _Placeholder< 2 > _2;
extern const struct _Placeholder< 3 > _3;
extern const struct _Placeholder< 4 > _4;
extern const struct _Placeholder< 5 > _5;
extern const struct _Placeholder< 6 > _6;
extern const struct _Placeholder< 7 > _7;
extern const struct _Placeholder< 8 > _8;
extern const struct _Placeholder< 9 > _9;
extern const struct _Placeholder< 10 > _10;
extern const struct _Placeholder< 11 > _11;
extern const struct _Placeholder< 12 > _12;
extern const struct _Placeholder< 13 > _13;
extern const struct _Placeholder< 14 > _14;
extern const struct _Placeholder< 15 > _15;
extern const struct _Placeholder< 16 > _16;
extern const struct _Placeholder< 17 > _17;
extern const struct _Placeholder< 18 > _18;
extern const struct _Placeholder< 19 > _19;
extern const struct _Placeholder< 20 > _20;
extern const struct _Placeholder< 21 > _21;
extern const struct _Placeholder< 22 > _22;
extern const struct _Placeholder< 23 > _23;
extern const struct _Placeholder< 24 > _24;
extern const struct _Placeholder< 25 > _25;
extern const struct _Placeholder< 26 > _26;
extern const struct _Placeholder< 27 > _27;
extern const struct _Placeholder< 28 > _28;
extern const struct _Placeholder< 29 > _29;
}
template < int _Num >
    struct is_placeholder < _Placeholder < _Num > >
    : public integral_constant < int, _Num >
    { };
template < int _Num >
    struct is_placeholder < const _Placeholder < _Num > >
    : public integral_constant < int, _Num >
    { };
template < std :: size_t __i, typename _Tuple >
   using _Safe_tuple_element_t
     = typename enable_if < ( __i < tuple_size < _Tuple > :: value ),
     tuple_element < __i, _Tuple >> :: type :: type;
template < typename _Arg,
    bool _IsBindExp = is_bind_expression < _Arg > :: value,
    bool _IsPlaceholder = ( is_placeholder < _Arg > :: value > 0 ) >
    class _Mu;
template < typename _Tp >
    class _Mu < reference_wrapper < _Tp >, false, false >
    {
    public :
      template < typename _CVRef, typename _Tuple >
 _Tp &
 operator ( ) ( _CVRef & __arg, _Tuple & ) const volatile
 { return __arg . get ( ); }
    };
template < typename _Arg >
    class _Mu < _Arg, true, false >
    {
    public :
      template < typename _CVArg, typename ... _Args >
 auto
 operator ( ) ( _CVArg & __arg,
     tuple < _Args ... > & __tuple ) const volatile
 -> decltype ( __arg ( declval < _Args > ( ) ... ) )
 {
   typedef typename _Build_index_tuple < sizeof ... ( _Args ) > :: __type
     _Indexes;
   return this -> __call ( __arg, __tuple, _Indexes ( ) );
 }
    private :
      template < typename _CVArg, typename ... _Args, std :: size_t ... _Indexes >
 auto
 __call ( _CVArg & __arg, tuple < _Args ... > & __tuple,
        const _Index_tuple < _Indexes ... > & ) const volatile
 -> decltype ( __arg ( declval < _Args > ( ) ... ) )
 {
   return __arg ( std :: forward < _Args > ( std :: get < _Indexes > ( __tuple ) ) ... );
 }
    };
template < typename _Arg >
    class _Mu < _Arg, false, true >
    {
    public :
      template < typename _Tuple >
 _Safe_tuple_element_t < ( is_placeholder < _Arg > :: value - 1 ), _Tuple > &&
 operator ( ) ( const volatile _Arg &, _Tuple & __tuple ) const volatile
 {
   using __type
     = __tuple_element_t < ( is_placeholder < _Arg > :: value - 1 ), _Tuple >;
   return std :: forward < __type > (
       :: std :: get < ( is_placeholder < _Arg > :: value - 1 ) > ( __tuple ) );
 }
    };
template < typename _Arg >
    class _Mu < _Arg, false, false >
    {
    public :
      template < typename _CVArg, typename _Tuple >
 _CVArg &&
 operator ( ) ( _CVArg && __arg, _Tuple & ) const volatile
 { return std :: forward < _CVArg > ( __arg ); }
    };
template < typename _Tp >
    struct _Maybe_wrap_member_pointer
    {
      typedef _Tp type;
      static constexpr const _Tp &
      __do_wrap ( const _Tp & __x )
      ;
      static constexpr _Tp &&
      __do_wrap ( _Tp && __x )
      ;
    };
template < typename _Tp, typename _Class >
    struct _Maybe_wrap_member_pointer < _Tp _Class :: * >
    {
      typedef _Mem_fn < _Tp _Class :: * > type;
      static constexpr type
      __do_wrap ( _Tp _Class :: * __pm )
      ;
    };
template<> struct _Maybe_wrap_member_pointer< void  > 
{
typedef void type;
};
template < std :: size_t _Ind, typename ... _Tp >
    inline auto
    __volget ( volatile tuple < _Tp ... > & __tuple )
    -> __tuple_element_t < _Ind, tuple < _Tp ... > > volatile &
    { return std :: get < _Ind > ( const_cast < tuple < _Tp ... > & > ( __tuple ) ); }
template < std :: size_t _Ind, typename ... _Tp >
    inline auto
    __volget ( const volatile tuple < _Tp ... > & __tuple )
    -> __tuple_element_t < _Ind, tuple < _Tp ... > > const volatile &
    { return std :: get < _Ind > ( const_cast < const tuple < _Tp ... > & > ( __tuple ) ); }
template < typename _Signature >
    struct _Bind;
template < typename _Functor, typename ... _Bound_args >
    class _Bind < _Functor ( _Bound_args ... ) >
    : public _Weak_result_type < _Functor >
    {
      typedef _Bind __self_type;
      typedef typename _Build_index_tuple < sizeof ... ( _Bound_args ) > :: __type
 _Bound_indexes;
      _Functor _M_f;
      tuple < _Bound_args ... > _M_bound_args;
      template < typename _Result, typename ... _Args, std :: size_t ... _Indexes >
 _Result
 __call ( tuple < _Args ... > && __args, _Index_tuple < _Indexes ... > )
 {
   return _M_f ( _Mu < _Bound_args > ( )
        ( std :: get < _Indexes > ( _M_bound_args ), __args ) ... );
 }
      template < typename _Result, typename ... _Args, std :: size_t ... _Indexes >
 _Result
 __call_c ( tuple < _Args ... > && __args, _Index_tuple < _Indexes ... > ) const
 {
   return _M_f ( _Mu < _Bound_args > ( )
        ( std :: get < _Indexes > ( _M_bound_args ), __args ) ... );
 }
      template < typename _Result, typename ... _Args, std :: size_t ... _Indexes >
 _Result
 __call_v ( tuple < _Args ... > && __args,
   _Index_tuple < _Indexes ... > ) volatile
 {
   return _M_f ( _Mu < _Bound_args > ( )
        ( __volget < _Indexes > ( _M_bound_args ), __args ) ... );
 }
      template < typename _Result, typename ... _Args, std :: size_t ... _Indexes >
 _Result
 __call_c_v ( tuple < _Args ... > && __args,
     _Index_tuple < _Indexes ... > ) const volatile
 {
   return _M_f ( _Mu < _Bound_args > ( )
        ( __volget < _Indexes > ( _M_bound_args ), __args ) ... );
 }
     public :
      template < typename ... _Args >
 explicit _Bind ( const _Functor & __f, _Args && ... __args )
 : _M_f ( __f ), _M_bound_args ( std :: forward < _Args > ( __args ) ... )
 { }
      template < typename ... _Args >
 explicit _Bind ( _Functor && __f, _Args && ... __args )
 : _M_f ( std :: move ( __f ) ), _M_bound_args ( std :: forward < _Args > ( __args ) ... )
 { }
      _Bind ( const _Bind & ) = default;
      _Bind ( _Bind && __b )
      ;
      template < typename ... _Args, typename _Result
 = decltype ( std :: declval < _Functor & > ( ) (
       _Mu < _Bound_args > ( ) ( std :: declval < _Bound_args & > ( ),
      std :: declval < tuple < _Args ... > & > ( ) ) ... ) ) >
 _Result
 operator ( ) ( _Args && ... __args )
 {
   return this -> __call < _Result > (
       std :: forward_as_tuple ( std :: forward < _Args > ( __args ) ... ),
       _Bound_indexes ( ) );
 }
      template < typename ... _Args, typename _Result
 = decltype ( std :: declval < typename enable_if < ( sizeof ... ( _Args ) >= 0 ),
         typename add_const < _Functor > :: type & > :: type > ( ) (
       _Mu < _Bound_args > ( ) ( std :: declval < const _Bound_args & > ( ),
      std :: declval < tuple < _Args ... > & > ( ) ) ... ) ) >
 _Result
 operator ( ) ( _Args && ... __args ) const
 {
   return this -> __call_c < _Result > (
       std :: forward_as_tuple ( std :: forward < _Args > ( __args ) ... ),
       _Bound_indexes ( ) );
 }
      template < typename ... _Args, typename _Result
 = decltype ( std :: declval < typename enable_if < ( sizeof ... ( _Args ) >= 0 ),
                       typename add_volatile < _Functor > :: type & > :: type > ( ) (
       _Mu < _Bound_args > ( ) ( std :: declval < volatile _Bound_args & > ( ),
      std :: declval < tuple < _Args ... > & > ( ) ) ... ) ) >
 _Result
 operator ( ) ( _Args && ... __args ) volatile
 {
   return this -> __call_v < _Result > (
       std :: forward_as_tuple ( std :: forward < _Args > ( __args ) ... ),
       _Bound_indexes ( ) );
 }
      template < typename ... _Args, typename _Result
 = decltype ( std :: declval < typename enable_if < ( sizeof ... ( _Args ) >= 0 ),
                       typename add_cv < _Functor > :: type & > :: type > ( ) (
       _Mu < _Bound_args > ( ) ( std :: declval < const volatile _Bound_args & > ( ),
      std :: declval < tuple < _Args ... > & > ( ) ) ... ) ) >
 _Result
 operator ( ) ( _Args && ... __args ) const volatile
 {
   return this -> __call_c_v < _Result > (
       std :: forward_as_tuple ( std :: forward < _Args > ( __args ) ... ),
       _Bound_indexes ( ) );
 }
    };
template < typename _Result, typename _Signature >
    struct _Bind_result;
template < typename _Result, typename _Functor, typename ... _Bound_args >
    class _Bind_result < _Result, _Functor ( _Bound_args ... ) >
    {
      typedef _Bind_result __self_type;
      typedef typename _Build_index_tuple < sizeof ... ( _Bound_args ) > :: __type
 _Bound_indexes;
      _Functor _M_f;
      tuple < _Bound_args ... > _M_bound_args;
      template < typename _Res >
 struct __enable_if_void : enable_if < is_void < _Res > :: value, int > { };
      template < typename _Res >
 struct __disable_if_void : enable_if < ! is_void < _Res > :: value, int > { };
      template < typename _Res, typename ... _Args, std :: size_t ... _Indexes >
 _Result
 __call ( tuple < _Args ... > && __args, _Index_tuple < _Indexes ... >,
     typename __disable_if_void < _Res > :: type = 0 )
 {
   return _M_f ( _Mu < _Bound_args > ( )
        ( std :: get < _Indexes > ( _M_bound_args ), __args ) ... );
 }
      template < typename _Res, typename ... _Args, std :: size_t ... _Indexes >
 void
 __call ( tuple < _Args ... > && __args, _Index_tuple < _Indexes ... >,
     typename __enable_if_void < _Res > :: type = 0 )
 {
   _M_f ( _Mu < _Bound_args > ( )
        ( std :: get < _Indexes > ( _M_bound_args ), __args ) ... );
 }
      template < typename _Res, typename ... _Args, std :: size_t ... _Indexes >
 _Result
 __call ( tuple < _Args ... > && __args, _Index_tuple < _Indexes ... >,
     typename __disable_if_void < _Res > :: type = 0 ) const
 {
   return _M_f ( _Mu < _Bound_args > ( )
        ( std :: get < _Indexes > ( _M_bound_args ), __args ) ... );
 }
      template < typename _Res, typename ... _Args, std :: size_t ... _Indexes >
 void
 __call ( tuple < _Args ... > && __args, _Index_tuple < _Indexes ... >,
     typename __enable_if_void < _Res > :: type = 0 ) const
 {
   _M_f ( _Mu < _Bound_args > ( )
        ( std :: get < _Indexes > ( _M_bound_args ), __args ) ... );
 }
      template < typename _Res, typename ... _Args, std :: size_t ... _Indexes >
 _Result
 __call ( tuple < _Args ... > && __args, _Index_tuple < _Indexes ... >,
     typename __disable_if_void < _Res > :: type = 0 ) volatile
 {
   return _M_f ( _Mu < _Bound_args > ( )
        ( __volget < _Indexes > ( _M_bound_args ), __args ) ... );
 }
      template < typename _Res, typename ... _Args, std :: size_t ... _Indexes >
 void
 __call ( tuple < _Args ... > && __args, _Index_tuple < _Indexes ... >,
     typename __enable_if_void < _Res > :: type = 0 ) volatile
 {
   _M_f ( _Mu < _Bound_args > ( )
        ( __volget < _Indexes > ( _M_bound_args ), __args ) ... );
 }
      template < typename _Res, typename ... _Args, std :: size_t ... _Indexes >
 _Result
 __call ( tuple < _Args ... > && __args, _Index_tuple < _Indexes ... >,
     typename __disable_if_void < _Res > :: type = 0 ) const volatile
 {
   return _M_f ( _Mu < _Bound_args > ( )
        ( __volget < _Indexes > ( _M_bound_args ), __args ) ... );
 }
      template < typename _Res, typename ... _Args, std :: size_t ... _Indexes >
 void
 __call ( tuple < _Args ... > && __args,
        _Index_tuple < _Indexes ... >,
     typename __enable_if_void < _Res > :: type = 0 ) const volatile
 {
   _M_f ( _Mu < _Bound_args > ( )
        ( __volget < _Indexes > ( _M_bound_args ), __args ) ... );
 }
    public :
      typedef _Result result_type;
      template < typename ... _Args >
 explicit _Bind_result ( const _Functor & __f, _Args && ... __args )
 : _M_f ( __f ), _M_bound_args ( std :: forward < _Args > ( __args ) ... )
 { }
      template < typename ... _Args >
 explicit _Bind_result ( _Functor && __f, _Args && ... __args )
 : _M_f ( std :: move ( __f ) ), _M_bound_args ( std :: forward < _Args > ( __args ) ... )
 { }
      _Bind_result ( const _Bind_result & ) = default;
      _Bind_result ( _Bind_result && __b )
      ;
      template < typename ... _Args >
 result_type
 operator ( ) ( _Args && ... __args )
 {
   return this -> __call < _Result > (
       std :: forward_as_tuple ( std :: forward < _Args > ( __args ) ... ),
       _Bound_indexes ( ) );
 }
      template < typename ... _Args >
 result_type
 operator ( ) ( _Args && ... __args ) const
 {
   return this -> __call < _Result > (
       std :: forward_as_tuple ( std :: forward < _Args > ( __args ) ... ),
       _Bound_indexes ( ) );
 }
      template < typename ... _Args >
 result_type
 operator ( ) ( _Args && ... __args ) volatile
 {
   return this -> __call < _Result > (
       std :: forward_as_tuple ( std :: forward < _Args > ( __args ) ... ),
       _Bound_indexes ( ) );
 }
      template < typename ... _Args >
 result_type
 operator ( ) ( _Args && ... __args ) const volatile
 {
   return this -> __call < _Result > (
       std :: forward_as_tuple ( std :: forward < _Args > ( __args ) ... ),
       _Bound_indexes ( ) );
 }
    };
template < typename _Signature >
    struct is_bind_expression < _Bind < _Signature > >
    : public true_type { };
template < typename _Signature >
    struct is_bind_expression < const _Bind < _Signature > >
    : public true_type { };
template < typename _Signature >
    struct is_bind_expression < volatile _Bind < _Signature > >
    : public true_type { };
template < typename _Signature >
    struct is_bind_expression < const volatile _Bind < _Signature > >
    : public true_type { };
template < typename _Result, typename _Signature >
    struct is_bind_expression < _Bind_result < _Result, _Signature > >
    : public true_type { };
template < typename _Result, typename _Signature >
    struct is_bind_expression < const _Bind_result < _Result, _Signature > >
    : public true_type { };
template < typename _Result, typename _Signature >
    struct is_bind_expression < volatile _Bind_result < _Result, _Signature > >
    : public true_type { };
template < typename _Result, typename _Signature >
    struct is_bind_expression < const volatile _Bind_result < _Result, _Signature > >
    : public true_type { };
template < typename _Func, typename ... _BoundArgs >
    struct _Bind_check_arity { };
template < typename _Ret, typename ... _Args, typename ... _BoundArgs >
    struct _Bind_check_arity < _Ret ( * ) ( _Args ... ), _BoundArgs ... >
    {
      static_assert ( sizeof ... ( _BoundArgs ) == sizeof ... ( _Args ),
                   "Wrong number of arguments for function" );
    };
template < typename _Ret, typename ... _Args, typename ... _BoundArgs >
    struct _Bind_check_arity < _Ret ( * ) ( _Args ... ... ), _BoundArgs ... >
    {
      static_assert ( sizeof ... ( _BoundArgs ) >= sizeof ... ( _Args ),
                   "Wrong number of arguments for function" );
    };
template < typename _Tp, typename _Class, typename ... _BoundArgs >
    struct _Bind_check_arity < _Tp _Class :: *, _BoundArgs ... >
    {
      using _Arity = typename _Mem_fn < _Tp _Class :: * > :: _Arity;
      using _Varargs = typename _Mem_fn < _Tp _Class :: * > :: _Varargs;
      static_assert ( _Varargs :: value
      ? sizeof ... ( _BoundArgs ) >= _Arity :: value + 1
      : sizeof ... ( _BoundArgs ) == _Arity :: value + 1,
      "Wrong number of arguments for pointer-to-member" );
    };
template < typename _Tp, typename _Tp2 = typename decay < _Tp > :: type >
    using __is_socketlike = __or_ < is_integral < _Tp2 >, is_enum < _Tp2 >>;
template < bool _SocketLike, typename _Func, typename ... _BoundArgs >
    struct _Bind_helper
    : _Bind_check_arity < typename decay < _Func > :: type, _BoundArgs ... >
    {
      typedef _Maybe_wrap_member_pointer < typename decay < _Func > :: type >
 __maybe_type;
      typedef typename __maybe_type :: type __func_type;
      typedef _Bind < __func_type ( typename decay < _BoundArgs > :: type ... ) > type;
    };
template < typename _Func, typename ... _BoundArgs >
    struct _Bind_helper < true, _Func, _BoundArgs ... >
    { };
template < typename _Func, typename ... _BoundArgs >
    inline typename
    _Bind_helper < __is_socketlike < _Func > :: value, _Func, _BoundArgs ... > :: type
    bind ( _Func && __f, _BoundArgs && ... __args )
    {
      typedef _Bind_helper < false, _Func, _BoundArgs ... > __helper_type;
      typedef typename __helper_type :: __maybe_type __maybe_type;
      typedef typename __helper_type :: type __result_type;
      return __result_type ( __maybe_type :: __do_wrap ( std :: forward < _Func > ( __f ) ),
      std :: forward < _BoundArgs > ( __args ) ... );
    }
template < typename _Result, typename _Func, typename ... _BoundArgs >
    struct _Bindres_helper
    : _Bind_check_arity < typename decay < _Func > :: type, _BoundArgs ... >
    {
      typedef _Maybe_wrap_member_pointer < typename decay < _Func > :: type >
 __maybe_type;
      typedef typename __maybe_type :: type __functor_type;
      typedef _Bind_result < _Result,
      __functor_type ( typename decay < _BoundArgs > :: type ... ) >
 type;
    };
template < typename _Result, typename _Func, typename ... _BoundArgs >
    inline
    typename _Bindres_helper < _Result, _Func, _BoundArgs ... > :: type
    bind ( _Func && __f, _BoundArgs && ... __args )
    {
      typedef _Bindres_helper < _Result, _Func, _BoundArgs ... > __helper_type;
      typedef typename __helper_type :: __maybe_type __maybe_type;
      typedef typename __helper_type :: type __result_type;
      return __result_type ( __maybe_type :: __do_wrap ( std :: forward < _Func > ( __f ) ),
      std :: forward < _BoundArgs > ( __args ) ... );
    }
template < typename _Signature >
    struct _Bind_simple;
template < typename _Callable, typename ... _Args >
    struct _Bind_simple < _Callable ( _Args ... ) >
    {
      typedef typename result_of < _Callable ( _Args ... ) > :: type result_type;
      template < typename _Tp, typename ... _Up >
        explicit
        _Bind_simple ( _Tp && __f, _Up && ... __args )
        : _M_bound ( std :: forward < _Tp > ( __f ), std :: forward < _Up > ( __args ) ... )
        { }
      _Bind_simple ( const _Bind_simple & ) = default;
      _Bind_simple ( _Bind_simple && ) = default;
      result_type
      operator ( ) ( )
      ;
    private :
      template < std :: size_t ... _Indices >
        typename result_of < _Callable ( _Args ... ) > :: type
        _M_invoke ( _Index_tuple < _Indices ... > )
        {
          return std :: forward < _Callable > ( std :: get < 0 > ( _M_bound ) ) (
              std :: forward < _Args > ( std :: get < _Indices + 1 > ( _M_bound ) ) ... );
        }
      std :: tuple < _Callable, _Args ... > _M_bound;
    };
template < typename _Func, typename ... _BoundArgs >
    struct _Bind_simple_helper
    : _Bind_check_arity < typename decay < _Func > :: type, _BoundArgs ... >
    {
      typedef _Maybe_wrap_member_pointer < typename decay < _Func > :: type >
        __maybe_type;
      typedef typename __maybe_type :: type __func_type;
      typedef _Bind_simple < __func_type ( typename decay < _BoundArgs > :: type ... ) >
        __type;
    };
template < typename _Callable, typename ... _Args >
    typename _Bind_simple_helper < _Callable, _Args ... > :: __type
    __bind_simple ( _Callable && __callable, _Args && ... __args )
    {
      typedef _Bind_simple_helper < _Callable, _Args ... > __helper_type;
      typedef typename __helper_type :: __maybe_type __maybe_type;
      typedef typename __helper_type :: __type __result_type;
      return __result_type (
          __maybe_type :: __do_wrap ( std :: forward < _Callable > ( __callable ) ),
          std :: forward < _Args > ( __args ) ... );
    }

class bad_function_call : public exception
{
public: virtual ~bad_function_call();
virtual const char *what() const;
}
;
template < typename _Tp >
    struct __is_location_invariant
    : is_trivially_copyable < _Tp > :: type
    { };
class _Undefined_class ;

union _Nocopy_types 
{
void *_M_object;
const void *_M_const_object;
void (*_M_function_pointer)();
void (_Undefined_class::*_M_member_pointer)();
}
;

union _Any_data 
{

inline void *_M_access()
{
return (&(this) -> _M_pod_data[0]);
}

inline const void *_M_access() const
{
return (&(this) -> _M_pod_data[0]);
}
template < typename _Tp >
      _Tp &
      _M_access ( )
      { return * static_cast < _Tp * > ( _M_access ( ) ); }
template < typename _Tp >
      const _Tp &
      _M_access ( ) const
      { return * static_cast < const _Tp * > ( _M_access ( ) ); }
union _Nocopy_types _M_unused;
char _M_pod_data[16];
}
;
enum _Manager_operation {__get_type_info=0,__get_functor_ptr=1,__clone_functor=2,__destroy_functor=3} ;
template < typename _Tp >
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper ( _Tp __value );
      _Tp __value;
    };
template < typename _Tp >
    struct __is_location_invariant < _Simple_type_wrapper < _Tp > >
    : __is_location_invariant < _Tp >
    { };
template < typename _Functor >
    inline _Functor &
    __callable_functor ( _Functor & __f )
    { return __f; }
template < typename _Member, typename _Class >
    inline _Mem_fn < _Member _Class :: * >
    __callable_functor ( _Member _Class :: * & __p )
    { return std :: mem_fn ( __p ); }
template < typename _Member, typename _Class >
    inline _Mem_fn < _Member _Class :: * >
    __callable_functor ( _Member _Class :: * const & __p )
    { return std :: mem_fn ( __p ); }
template < typename _Member, typename _Class >
    inline _Mem_fn < _Member _Class :: * >
    __callable_functor ( _Member _Class :: * volatile & __p )
    { return std :: mem_fn ( __p ); }
template < typename _Member, typename _Class >
    inline _Mem_fn < _Member _Class :: * >
    __callable_functor ( _Member _Class :: * const volatile & __p )
    { return std :: mem_fn ( __p ); }
template < typename _Signature >
    class function;

class _Function_base 
{
public: static const size_t _M_max_size = sizeof(union _Nocopy_types );
static const size_t _M_max_align = __alignof__(union _Nocopy_types );
template < typename _Functor >
      class _Base_manager
      {
      protected :
 static const bool __stored_locally =
 ( __is_location_invariant < _Functor > :: value
  && sizeof ( _Functor ) <= _M_max_size
  && __alignof__ ( _Functor ) <= _M_max_align
  && ( _M_max_align % __alignof__ ( _Functor ) == 0 ) );
 typedef integral_constant < bool, __stored_locally > _Local_storage;
 static _Functor *
 _M_get_pointer ( const _Any_data & __source )
 ;
 static void
 _M_clone ( _Any_data & __dest, const _Any_data & __source, true_type )
 ;
 static void
 _M_clone ( _Any_data & __dest, const _Any_data & __source, false_type )
 ;
 static void
 _M_destroy ( _Any_data & __victim, true_type )
 ;
 static void
 _M_destroy ( _Any_data & __victim, false_type )
 ;
      public :
 static bool
 _M_manager ( _Any_data & __dest, const _Any_data & __source,
     _Manager_operation __op )
 ;
 static void
 _M_init_functor ( _Any_data & __functor, _Functor && __f )
 ;
 template < typename _Signature >
   static bool
   _M_not_empty_function ( const function < _Signature > & __f )
   { return static_cast < bool > ( __f ); }
 template < typename _Tp >
   static bool
   _M_not_empty_function ( _Tp * __fp )
   { return __fp != nullptr; }
 template < typename _Class, typename _Tp >
   static bool
   _M_not_empty_function ( _Tp _Class :: * __mp )
   { return __mp != nullptr; }
 template < typename _Tp >
   static bool
   _M_not_empty_function ( const _Tp & )
   { return true; }
      private :
 static void
 _M_init_functor ( _Any_data & __functor, _Functor && __f, true_type )
 ;
 static void
 _M_init_functor ( _Any_data & __functor, _Functor && __f, false_type )
 ;
      };
template < typename _Functor >
      class _Ref_manager : public _Base_manager < _Functor * >
      {
 typedef _Function_base :: _Base_manager < _Functor * > _Base;
      public :
 static bool
 _M_manager ( _Any_data & __dest, const _Any_data & __source,
     _Manager_operation __op )
 ;
 static void
 _M_init_functor ( _Any_data & __functor, reference_wrapper < _Functor > __f )
 ;
      };

inline _Function_base() : _M_manager((nullptr))
{
}

inline ~_Function_base()
{
if (((this) -> _M_manager)) 
((this) -> _M_manager)(((this) -> _M_functor),((this) -> _M_functor),__destroy_functor);
}

inline bool _M_empty() const
{
return !((this) -> _M_manager);
}
typedef bool (*_Manager_type)(union ::std::_Any_data&, const union ::std::_Any_data&, ::std::_Manager_operation);
union _Any_data _M_functor;
_Manager_type _M_manager;
}
;
template < typename _Signature, typename _Functor >
    class _Function_handler;
template < typename _Res, typename _Functor, typename ... _ArgTypes >
    class _Function_handler < _Res ( _ArgTypes ... ), _Functor >
    : public _Function_base :: _Base_manager < _Functor >
    {
      typedef _Function_base :: _Base_manager < _Functor > _Base;
    public :
      static _Res
      _M_invoke ( const _Any_data & __functor, _ArgTypes && ... __args )
      ;
    };
template < typename _Functor, typename ... _ArgTypes >
    class _Function_handler < void ( _ArgTypes ... ), _Functor >
    : public _Function_base :: _Base_manager < _Functor >
    {
      typedef _Function_base :: _Base_manager < _Functor > _Base;
     public :
      static void
      _M_invoke ( const _Any_data & __functor, _ArgTypes && ... __args )
      ;
    };
template < typename _Res, typename _Functor, typename ... _ArgTypes >
    class _Function_handler < _Res ( _ArgTypes ... ), reference_wrapper < _Functor > >
    : public _Function_base :: _Ref_manager < _Functor >
    {
      typedef _Function_base :: _Ref_manager < _Functor > _Base;
     public :
      static _Res
      _M_invoke ( const _Any_data & __functor, _ArgTypes && ... __args )
      ;
    };
template < typename _Functor, typename ... _ArgTypes >
    class _Function_handler < void ( _ArgTypes ... ), reference_wrapper < _Functor > >
    : public _Function_base :: _Ref_manager < _Functor >
    {
      typedef _Function_base :: _Ref_manager < _Functor > _Base;
     public :
      static void
      _M_invoke ( const _Any_data & __functor, _ArgTypes && ... __args )
      ;
    };
template < typename _Class, typename _Member, typename _Res,
    typename ... _ArgTypes >
    class _Function_handler < _Res ( _ArgTypes ... ), _Member _Class :: * >
    : public _Function_handler < void ( _ArgTypes ... ), _Member _Class :: * >
    {
      typedef _Function_handler < void ( _ArgTypes ... ), _Member _Class :: * >
 _Base;
     public :
      static _Res
      _M_invoke ( const _Any_data & __functor, _ArgTypes && ... __args )
      ;
    };
template < typename _Class, typename _Member, typename ... _ArgTypes >
    class _Function_handler < void ( _ArgTypes ... ), _Member _Class :: * >
    : public _Function_base :: _Base_manager <
   _Simple_type_wrapper < _Member _Class :: * > >
    {
      typedef _Member _Class :: * _Functor;
      typedef _Simple_type_wrapper < _Functor > _Wrapper;
      typedef _Function_base :: _Base_manager < _Wrapper > _Base;
    public :
      static bool
      _M_manager ( _Any_data & __dest, const _Any_data & __source,
   _Manager_operation __op )
      ;
      static void
      _M_invoke ( const _Any_data & __functor, _ArgTypes && ... __args )
      ;
    };
template < typename _From, typename _To >
    using __check_func_return_type
      = __or_ < is_void < _To >, is_same < _From, _To >, is_convertible < _From, _To >>;
template < typename _Res, typename ... _ArgTypes >
    class function < _Res ( _ArgTypes ... ) >
    : public _Maybe_unary_or_binary_function < _Res, _ArgTypes ... >,
      private _Function_base
    {
      typedef _Res _Signature_type ( _ArgTypes ... );
      template < typename _Func,
        typename _Res2 = typename result_of < _Func ( _ArgTypes ... ) > :: type >
 struct _Callable : __check_func_return_type < _Res2, _Res > { };
      template < typename _Tp >
 struct _Callable < function, _Tp > : false_type { };
      template < typename _Cond, typename _Tp >
 using _Requires = typename enable_if < _Cond :: value, _Tp > :: type;
    public :
      typedef _Res result_type;
      function ( ) noexcept
      ;
      function ( nullptr_t ) noexcept
      ;
      function ( const function & __x );
      function ( function && __x );
      template < typename _Functor,
        typename = _Requires < __not_ < is_same < _Functor, function >>, void >,
        typename = _Requires < _Callable < _Functor >, void >>
 function ( _Functor );
      function &
      operator = ( const function & __x )
      ;
      function &
      operator = ( function && __x )
      ;
      function &
      operator = ( nullptr_t ) noexcept
      ;
      template < typename _Functor >
 _Requires < _Callable < typename decay < _Functor > :: type >, function & >
 operator = ( _Functor && __f )
 {
   function ( std :: forward < _Functor > ( __f ) ) . swap ( * this );
   return * this;
 }
      template < typename _Functor >
 function &
 operator = ( reference_wrapper < _Functor > __f ) noexcept
 {
   function ( __f ) . swap ( * this );
   return * this;
 }
      void swap ( function & __x )
      ;
      explicit operator bool ( ) const noexcept
      ;
      _Res operator ( ) ( _ArgTypes ... __args ) const;
      const type_info & target_type ( ) const noexcept;
      template < typename _Functor > _Functor * target ( ) noexcept;
      template < typename _Functor > const _Functor * target ( ) const noexcept;
    private :
      using _Invoker_type = _Res ( * ) ( const _Any_data &, _ArgTypes && ... );
      _Invoker_type _M_invoker;
  };
template < typename _Res, typename ... _ArgTypes >
    function < _Res ( _ArgTypes ... ) > ::
    function ( const function & __x )
    : _Function_base ( )
    {
      if ( static_cast < bool > ( __x ) )
 {
   __x . _M_manager ( _M_functor, __x . _M_functor, __clone_functor );
   _M_invoker = __x . _M_invoker;
   _M_manager = __x . _M_manager;
 }
    }
template < typename _Res, typename ... _ArgTypes >
    template < typename _Functor, typename, typename >
      function < _Res ( _ArgTypes ... ) > ::
      function ( _Functor __f )
      : _Function_base ( )
      {
 typedef _Function_handler < _Signature_type, _Functor > _My_handler;
 if ( _My_handler :: _M_not_empty_function ( __f ) )
   {
     _My_handler :: _M_init_functor ( _M_functor, std :: move ( __f ) );
     _M_invoker = & _My_handler :: _M_invoke;
     _M_manager = & _My_handler :: _M_manager;
   }
      }
template < typename _Res, typename ... _ArgTypes >
    _Res
    function < _Res ( _ArgTypes ... ) > ::
    operator ( ) ( _ArgTypes ... __args ) const
    {
      if ( _M_empty ( ) )
 __throw_bad_function_call ( );
      return _M_invoker ( _M_functor, std :: forward < _ArgTypes > ( __args ) ... );
    }
template < typename _Res, typename ... _ArgTypes >
    const type_info &
    function < _Res ( _ArgTypes ... ) > ::
    target_type ( ) const noexcept
    {
      if ( _M_manager )
 {
   _Any_data __typeinfo_result;
   _M_manager ( __typeinfo_result, _M_functor, __get_type_info );
   return * __typeinfo_result . _M_access < const type_info * > ( );
 }
      else
 return typeid ( void );
    }
template < typename _Res, typename ... _ArgTypes >
    template < typename _Functor >
      _Functor *
      function < _Res ( _ArgTypes ... ) > ::
      target ( ) noexcept
      {
 if ( typeid ( _Functor ) == target_type ( ) && _M_manager )
   {
     _Any_data __ptr;
     if ( _M_manager ( __ptr, _M_functor, __get_functor_ptr )
  && ! is_const < _Functor > :: value )
       return 0;
     else
       return __ptr . _M_access < _Functor * > ( );
   }
 else
   return 0;
      }
template < typename _Res, typename ... _ArgTypes >
    template < typename _Functor >
      const _Functor *
      function < _Res ( _ArgTypes ... ) > ::
      target ( ) const noexcept
      {
 if ( typeid ( _Functor ) == target_type ( ) && _M_manager )
   {
     _Any_data __ptr;
     _M_manager ( __ptr, _M_functor, __get_functor_ptr );
     return __ptr . _M_access < const _Functor * > ( );
   }
 else
   return 0;
      }
template < typename _Res, typename ... _Args >
    inline bool
    operator == ( const function < _Res ( _Args ... ) > & __f, nullptr_t ) noexcept
    { return ! static_cast < bool > ( __f ); }
template < typename _Res, typename ... _Args >
    inline bool
    operator == ( nullptr_t, const function < _Res ( _Args ... ) > & __f ) noexcept
    { return ! static_cast < bool > ( __f ); }
template < typename _Res, typename ... _Args >
    inline bool
    operator != ( const function < _Res ( _Args ... ) > & __f, nullptr_t ) noexcept
    { return static_cast < bool > ( __f ); }
template < typename _Res, typename ... _Args >
    inline bool
    operator != ( nullptr_t, const function < _Res ( _Args ... ) > & __f ) noexcept
    { return static_cast < bool > ( __f ); }
template < typename _Res, typename ... _Args >
    inline void
    swap ( function < _Res ( _Args ... ) > & __x, function < _Res ( _Args ... ) > & __y )
    { __x . swap ( __y ); }
}
namespace std
{
template < typename > class auto_ptr;
template < typename _Tp >
    struct default_delete
    {
      constexpr default_delete ( ) noexcept = default;
      template < typename _Up, typename = typename
        enable_if < is_convertible < _Up *, _Tp * > :: value > :: type >
        default_delete ( const default_delete < _Up > & ) noexcept { }
      void
      operator ( ) ( _Tp * __ptr ) const
      ;
    };
template < typename _Tp >
    struct default_delete < _Tp [ ] >
    {
    public :
      constexpr default_delete ( ) noexcept = default;
      template < typename _Up, typename = typename
        enable_if < is_convertible < _Up ( * ) [ ], _Tp ( * ) [ ] > :: value > :: type >
        default_delete ( const default_delete < _Up [ ] > & ) noexcept { }
      template < typename _Up >
      typename enable_if < is_convertible < _Up ( * ) [ ], _Tp ( * ) [ ] > :: value > :: type
 operator ( ) ( _Up * __ptr ) const
      {
 static_assert ( sizeof ( _Tp ) > 0,
        "can\'t delete pointer to incomplete type" );
 delete [ ] __ptr;
      }
    };
template < typename _Tp, typename _Dp = default_delete < _Tp > >
    class unique_ptr
    {
      class _Pointer
      {
 template < typename _Up >
   static typename _Up :: pointer __test ( typename _Up :: pointer * );
 template < typename _Up >
   static _Tp * __test ( ... );
 typedef typename remove_reference < _Dp > :: type _Del;
      public :
 typedef decltype ( __test < _Del > ( 0 ) ) type;
      };
      typedef std :: tuple < typename _Pointer :: type, _Dp > __tuple_type;
      __tuple_type _M_t;
    public :
      typedef typename _Pointer :: type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;
      template < typename _Up, typename _Ep >
 using __safe_conversion_up = __and_ <
         is_convertible < typename unique_ptr < _Up, _Ep > :: pointer, pointer >,
                __not_ < is_array < _Up >>,
                __or_ < __and_ < is_reference < deleter_type >,
                             is_same < deleter_type, _Ep >>,
                      __and_ < __not_ < is_reference < deleter_type >>,
                             is_convertible < _Ep, deleter_type >>
                >
              >;
      constexpr unique_ptr ( ) noexcept
      ;
      explicit
      unique_ptr ( pointer __p ) noexcept
      ;
      unique_ptr ( pointer __p,
   typename conditional < is_reference < deleter_type > :: value,
     deleter_type, const deleter_type & > :: type __d ) noexcept
      ;
      unique_ptr ( pointer __p,
   typename remove_reference < deleter_type > :: type && __d ) noexcept
      ;
      constexpr unique_ptr ( nullptr_t ) noexcept;
      unique_ptr ( unique_ptr && __u ) noexcept
      ;
      template < typename _Up, typename _Ep, typename = _Require <
               __safe_conversion_up < _Up, _Ep >,
        typename conditional < is_reference < _Dp > :: value,
        is_same < _Ep, _Dp >,
        is_convertible < _Ep, _Dp >> :: type >>
 unique_ptr ( unique_ptr < _Up, _Ep > && __u ) noexcept
 : _M_t ( __u . release ( ), std :: forward < _Ep > ( __u . get_deleter ( ) ) )
 { }
      template < typename _Up, typename = _Require <
        is_convertible < _Up *, _Tp * >, is_same < _Dp, default_delete < _Tp >>> >
 unique_ptr ( auto_ptr < _Up > && __u ) noexcept;
      ~ unique_ptr ( ) noexcept
      ;
      unique_ptr &
      operator = ( unique_ptr && __u ) noexcept
      ;
      template < typename _Up, typename _Ep >
        typename enable_if < __and_ <
          __safe_conversion_up < _Up, _Ep >,
          is_assignable < deleter_type &, _Ep && >
          > :: value,
          unique_ptr & > :: type
 operator = ( unique_ptr < _Up, _Ep > && __u ) noexcept
 {
   reset ( __u . release ( ) );
   get_deleter ( ) = std :: forward < _Ep > ( __u . get_deleter ( ) );
   return * this;
 }
      unique_ptr &
      operator = ( nullptr_t ) noexcept
      ;
      typename add_lvalue_reference < element_type > :: type
      operator * ( ) const
      ;
      pointer
      operator -> ( ) const noexcept
      ;
      pointer
      get ( ) const noexcept
      ;
      deleter_type &
      get_deleter ( ) noexcept
      ;
      const deleter_type &
      get_deleter ( ) const noexcept
      ;
      explicit operator bool ( ) const noexcept
      ;
      pointer
      release ( ) noexcept
      ;
      void
      reset ( pointer __p = pointer ( ) ) noexcept
      ;
      void
      swap ( unique_ptr & __u ) noexcept
      ;
      unique_ptr ( const unique_ptr & ) = delete;
      unique_ptr & operator = ( const unique_ptr & ) = delete;
  };
template < typename _Tp, typename _Dp >
    class unique_ptr < _Tp [ ], _Dp >
    {
      class _Pointer
      {
 template < typename _Up >
   static typename _Up :: pointer __test ( typename _Up :: pointer * );
 template < typename _Up >
   static _Tp * __test ( ... );
 typedef typename remove_reference < _Dp > :: type _Del;
      public :
 typedef decltype ( __test < _Del > ( 0 ) ) type;
      };
      typedef std :: tuple < typename _Pointer :: type, _Dp > __tuple_type;
      __tuple_type _M_t;
      template < typename _Up >
 using __remove_cv = typename remove_cv < _Up > :: type;
      template < typename _Up >
 using __is_derived_Tp
   = __and_ < is_base_of < _Tp, _Up >,
      __not_ < is_same < __remove_cv < _Tp >, __remove_cv < _Up >>> >;
    public :
      typedef typename _Pointer :: type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;
      template < typename _Up, typename _Ep,
               typename _Up_up = unique_ptr < _Up, _Ep >,
        typename _Up_element_type = typename _Up_up :: element_type >
 using __safe_conversion_up = __and_ <
          is_array < _Up >,
          is_same < pointer, element_type * >,
          is_same < typename _Up_up :: pointer, _Up_element_type * >,
          is_convertible < _Up_element_type ( * ) [ ], element_type ( * ) [ ] >,
          __or_ < __and_ < is_reference < deleter_type >, is_same < deleter_type, _Ep >>,
                __and_ < __not_ < is_reference < deleter_type >>,
                       is_convertible < _Ep, deleter_type >>>
        >;
      template < typename _Up >
        using __safe_conversion_raw = __and_ <
          __or_ < __or_ < is_same < _Up, pointer >,
                      is_same < _Up, nullptr_t >>,
                __and_ < is_pointer < _Up >,
                       is_same < pointer, element_type * >,
                       is_convertible <
                         typename remove_pointer < _Up > :: type ( * ) [ ],
                         element_type ( * ) [ ] >
                >
          >
        >;
      constexpr unique_ptr ( ) noexcept
      ;
      template < typename _Up,
               typename = typename enable_if <
                 __safe_conversion_raw < _Up > :: value, bool > :: type >
      explicit
      unique_ptr ( _Up __p ) noexcept
      : _M_t ( __p, deleter_type ( ) )
      { static_assert ( ! is_pointer < deleter_type > :: value,
        "constructed with null function pointer deleter" ); }
      template < typename _Up,
               typename = typename enable_if <
                 __safe_conversion_raw < _Up > :: value, bool > :: type >
      unique_ptr ( _Up __p,
                 typename conditional < is_reference < deleter_type > :: value,
                 deleter_type, const deleter_type & > :: type __d ) noexcept
      : _M_t ( __p, __d ) { }
      template < typename _Up,
               typename = typename enable_if <
                 __safe_conversion_raw < _Up > :: value, bool > :: type >
      unique_ptr ( _Up __p, typename
   remove_reference < deleter_type > :: type && __d ) noexcept
      : _M_t ( std :: move ( __p ), std :: move ( __d ) )
      { static_assert ( ! is_reference < deleter_type > :: value,
        "rvalue deleter bound to reference" ); }
      unique_ptr ( unique_ptr && __u ) noexcept
      ;
      constexpr unique_ptr ( nullptr_t ) noexcept;
      template < typename _Up, typename _Ep,
        typename = _Require < __safe_conversion_up < _Up, _Ep >>>
 unique_ptr ( unique_ptr < _Up, _Ep > && __u ) noexcept
 : _M_t ( __u . release ( ), std :: forward < _Ep > ( __u . get_deleter ( ) ) )
 { }
      ~ unique_ptr ( )
      ;
      unique_ptr &
      operator = ( unique_ptr && __u ) noexcept
      ;
      template < typename _Up, typename _Ep >
 typename
 enable_if < __and_ < __safe_conversion_up < _Up, _Ep >,
                         is_assignable < deleter_type &, _Ep && >
                  > :: value,
                  unique_ptr & > :: type
 operator = ( unique_ptr < _Up, _Ep > && __u ) noexcept
 {
   reset ( __u . release ( ) );
   get_deleter ( ) = std :: forward < _Ep > ( __u . get_deleter ( ) );
   return * this;
 }
      unique_ptr &
      operator = ( nullptr_t ) noexcept
      ;
      typename std :: add_lvalue_reference < element_type > :: type
      operator [ ] ( size_t __i ) const
      ;
      pointer
      get ( ) const noexcept
      ;
      deleter_type &
      get_deleter ( ) noexcept
      ;
      const deleter_type &
      get_deleter ( ) const noexcept
      ;
      explicit operator bool ( ) const noexcept
      ;
      pointer
      release ( ) noexcept
      ;
      template < typename _Up,
                typename = _Require <
                  __or_ < is_same < _Up, pointer >,
                        __and_ < is_same < pointer, element_type * >,
                               is_pointer < _Up >,
                               is_convertible <
                                 typename remove_pointer < _Up > :: type ( * ) [ ],
                                 element_type ( * ) [ ]
                               >
                        >
                  >
               >>
      void
      reset ( _Up __p ) noexcept
      {
 using std :: swap;
 swap ( std :: get < 0 > ( _M_t ), __p );
 if ( __p != nullptr )
   get_deleter ( ) ( __p );
      }
      void reset ( nullptr_t = nullptr ) noexcept
      ;
      void
      swap ( unique_ptr & __u ) noexcept
      ;
      unique_ptr ( const unique_ptr & ) = delete;
      unique_ptr & operator = ( const unique_ptr & ) = delete;
    };
template < typename _Tp, typename _Dp >
    inline void
    swap ( unique_ptr < _Tp, _Dp > & __x,
  unique_ptr < _Tp, _Dp > & __y ) noexcept
    { __x . swap ( __y ); }
template < typename _Tp, typename _Dp,
    typename _Up, typename _Ep >
    inline bool
    operator == ( const unique_ptr < _Tp, _Dp > & __x,
        const unique_ptr < _Up, _Ep > & __y )
    { return __x . get ( ) == __y . get ( ); }
template < typename _Tp, typename _Dp >
    inline bool
    operator == ( const unique_ptr < _Tp, _Dp > & __x, nullptr_t ) noexcept
    { return ! __x; }
template < typename _Tp, typename _Dp >
    inline bool
    operator == ( nullptr_t, const unique_ptr < _Tp, _Dp > & __x ) noexcept
    { return ! __x; }
template < typename _Tp, typename _Dp,
    typename _Up, typename _Ep >
    inline bool
    operator != ( const unique_ptr < _Tp, _Dp > & __x,
        const unique_ptr < _Up, _Ep > & __y )
    { return __x . get ( ) != __y . get ( ); }
template < typename _Tp, typename _Dp >
    inline bool
    operator != ( const unique_ptr < _Tp, _Dp > & __x, nullptr_t ) noexcept
    { return ( bool ) __x; }
template < typename _Tp, typename _Dp >
    inline bool
    operator != ( nullptr_t, const unique_ptr < _Tp, _Dp > & __x ) noexcept
    { return ( bool ) __x; }
template < typename _Tp, typename _Dp,
    typename _Up, typename _Ep >
    inline bool
    operator < ( const unique_ptr < _Tp, _Dp > & __x,
       const unique_ptr < _Up, _Ep > & __y )
    {
      typedef typename
 std :: common_type < typename unique_ptr < _Tp, _Dp > :: pointer,
                  typename unique_ptr < _Up, _Ep > :: pointer > :: type _CT;
      return std :: less < _CT > ( ) ( __x . get ( ), __y . get ( ) );
    }
template < typename _Tp, typename _Dp >
    inline bool
    operator < ( const unique_ptr < _Tp, _Dp > & __x, nullptr_t )
    { return std :: less < typename unique_ptr < _Tp, _Dp > :: pointer > ( ) ( __x . get ( ),
         nullptr ); }
template < typename _Tp, typename _Dp >
    inline bool
    operator < ( nullptr_t, const unique_ptr < _Tp, _Dp > & __x )
    { return std :: less < typename unique_ptr < _Tp, _Dp > :: pointer > ( ) ( nullptr,
         __x . get ( ) ); }
template < typename _Tp, typename _Dp,
    typename _Up, typename _Ep >
    inline bool
    operator <= ( const unique_ptr < _Tp, _Dp > & __x,
        const unique_ptr < _Up, _Ep > & __y )
    { return ! ( __y < __x ); }
template < typename _Tp, typename _Dp >
    inline bool
    operator <= ( const unique_ptr < _Tp, _Dp > & __x, nullptr_t )
    { return ! ( nullptr < __x ); }
template < typename _Tp, typename _Dp >
    inline bool
    operator <= ( nullptr_t, const unique_ptr < _Tp, _Dp > & __x )
    { return ! ( __x < nullptr ); }
template < typename _Tp, typename _Dp,
    typename _Up, typename _Ep >
    inline bool
    operator > ( const unique_ptr < _Tp, _Dp > & __x,
       const unique_ptr < _Up, _Ep > & __y )
    { return ( __y < __x ); }
template < typename _Tp, typename _Dp >
    inline bool
    operator > ( const unique_ptr < _Tp, _Dp > & __x, nullptr_t )
    { return std :: less < typename unique_ptr < _Tp, _Dp > :: pointer > ( ) ( nullptr,
         __x . get ( ) ); }
template < typename _Tp, typename _Dp >
    inline bool
    operator > ( nullptr_t, const unique_ptr < _Tp, _Dp > & __x )
    { return std :: less < typename unique_ptr < _Tp, _Dp > :: pointer > ( ) ( __x . get ( ),
         nullptr ); }
template < typename _Tp, typename _Dp,
    typename _Up, typename _Ep >
    inline bool
    operator >= ( const unique_ptr < _Tp, _Dp > & __x,
        const unique_ptr < _Up, _Ep > & __y )
    { return ! ( __x < __y ); }
template < typename _Tp, typename _Dp >
    inline bool
    operator >= ( const unique_ptr < _Tp, _Dp > & __x, nullptr_t )
    { return ! ( __x < nullptr ); }
template < typename _Tp, typename _Dp >
    inline bool
    operator >= ( nullptr_t, const unique_ptr < _Tp, _Dp > & __x )
    { return ! ( nullptr < __x ); }
template < typename _Tp, typename _Dp >
    struct hash < unique_ptr < _Tp, _Dp > >
    : public __hash_base < size_t, unique_ptr < _Tp, _Dp >>
    {
      size_t
      operator ( ) ( const unique_ptr < _Tp, _Dp > & __u ) const noexcept
      ;
    };
template < typename _Tp >
    struct _MakeUniq
    { typedef unique_ptr < _Tp > __single_object; };
template < typename _Tp >
    struct _MakeUniq < _Tp [ ] >
    { typedef unique_ptr < _Tp [ ] > __array; };
template < typename _Tp, size_t _Bound >
    struct _MakeUniq < _Tp [ _Bound ] >
    { struct __invalid_type { }; };
template < typename _Tp, typename ... _Args >
    inline typename _MakeUniq < _Tp > :: __single_object
    make_unique ( _Args && ... __args )
    { return unique_ptr < _Tp > ( new _Tp ( std :: forward < _Args > ( __args ) ... ) ); }
template < typename _Tp >
    inline typename _MakeUniq < _Tp > :: __array
    make_unique ( size_t __num )
    { return unique_ptr < _Tp > ( new remove_extent_t < _Tp > [ __num ] ( ) ); }
template < typename _Tp, typename ... _Args >
    inline typename _MakeUniq < _Tp > :: __invalid_type
    make_unique ( _Args && ... ) = delete;
}
namespace std
{
template < typename > class auto_ptr;

class bad_weak_ptr : public exception
{
public: virtual const char *what() const;
virtual ~bad_weak_ptr();
}
;

inline void  __attribute__((visibility("default"))) __throw_bad_weak_ptr()
{
throw bad_weak_ptr();
}
using __gnu_cxx::_Lock_policy;
using __gnu_cxx::__default_lock_policy;
using __gnu_cxx::_S_single;
using __gnu_cxx::_S_mutex;
using __gnu_cxx::_S_atomic;
template < _Lock_policy _Lp >
    class _Mutex_base
    {
    protected :
      enum { _S_need_barriers = 0 };
    };
template<> class _Mutex_base< __gnu_cxx::_S_mutex > : public __gnu_cxx::__mutex
{
protected: enum __anonymous_0x6cd8890 {_S_need_barriers=1} ;
};
template < _Lock_policy _Lp = __default_lock_policy >
    class _Sp_counted_base
    : public _Mutex_base < _Lp >
    {
    public :
      _Sp_counted_base ( ) noexcept
      ;
      virtual
      ~ _Sp_counted_base ( ) noexcept
      ;
      virtual void
      _M_dispose ( ) noexcept = 0;
      virtual void
      _M_destroy ( ) noexcept
      ;
      virtual void *
      _M_get_deleter ( const std :: type_info & ) noexcept = 0;
      void
      _M_add_ref_copy ( )
      ;
      void
      _M_add_ref_lock ( );
      bool
      _M_add_ref_lock_nothrow ( );
      void
      _M_release ( ) noexcept
      ;
      void
      _M_weak_add_ref ( ) noexcept
      ;
      void
      _M_weak_release ( ) noexcept
      ;
      long
      _M_get_use_count ( ) const noexcept
      ;
    private :
      _Sp_counted_base ( _Sp_counted_base const & ) = delete;
      _Sp_counted_base & operator = ( _Sp_counted_base const & ) = delete;
      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };

template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_add_ref_lock()
{
if ((this) -> _M_use_count == 0) 
__throw_bad_weak_ptr();
++(this) -> _M_use_count;
}

template<> inline void _Sp_counted_base< __gnu_cxx::_S_mutex> ::_M_add_ref_lock()
{
class __gnu_cxx::__scoped_lock sentry(( *(this)));
if (__gnu_cxx::__exchange_and_add_dispatch(&(this) -> _M_use_count,1) == 0) {
(this) -> _M_use_count = 0;
__throw_bad_weak_ptr();
}
}

template<> inline void _Sp_counted_base< __gnu_cxx::_S_atomic> ::_M_add_ref_lock()
{
_Atomic_word __count = ((this) -> _M_get_use_count());
do {
if (__count == 0) 
__throw_bad_weak_ptr();
}while (!false);
}

template<> inline bool _Sp_counted_base< __gnu_cxx::_S_single> ::_M_add_ref_lock_nothrow()
{
if ((this) -> _M_use_count == 0) 
return false;
++(this) -> _M_use_count;
return true;
}

template<> inline bool _Sp_counted_base< __gnu_cxx::_S_mutex> ::_M_add_ref_lock_nothrow()
{
class __gnu_cxx::__scoped_lock sentry(( *(this)));
if (__gnu_cxx::__exchange_and_add_dispatch(&(this) -> _M_use_count,1) == 0) {
(this) -> _M_use_count = 0;
return false;
}
return true;
}

template<> inline bool _Sp_counted_base< __gnu_cxx::_S_atomic> ::_M_add_ref_lock_nothrow()
{
_Atomic_word __count = ((this) -> _M_get_use_count());
do {
if (__count == 0) 
return false;
}while (!false);
return true;
}

template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_add_ref_copy()
{
++(this) -> _M_use_count;
}

template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_release()
{
if (--(this) -> _M_use_count == 0) {
(this) -> _M_dispose();
if (--(this) -> _M_weak_count == 0) 
(this) -> _M_destroy();
}
}

template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_weak_add_ref()
{
++(this) -> _M_weak_count;
}

template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_weak_release()
{
if (--(this) -> _M_weak_count == 0) 
(this) -> _M_destroy();
}

template<> inline long _Sp_counted_base< __gnu_cxx::_S_single> ::_M_get_use_count() const
{
return ((this) -> _M_use_count);
}
template < typename _Tp, _Lock_policy _Lp = __default_lock_policy >
    class __shared_ptr;
template < typename _Tp, _Lock_policy _Lp = __default_lock_policy >
    class __weak_ptr;
template < typename _Tp, _Lock_policy _Lp = __default_lock_policy >
    class __enable_shared_from_this;
template < typename _Tp >
    class shared_ptr;
template < typename _Tp >
    class weak_ptr;
template < typename _Tp >
    struct owner_less;
template < typename _Tp >
    class enable_shared_from_this;
template < _Lock_policy _Lp = __default_lock_policy >
    class __weak_count;
template < _Lock_policy _Lp = __default_lock_policy >
    class __shared_count;
template < typename _Ptr, _Lock_policy _Lp >
    class _Sp_counted_ptr : public _Sp_counted_base < _Lp >
    {
    public :
      explicit
      _Sp_counted_ptr ( _Ptr __p ) noexcept
      ;
      virtual void
      _M_dispose ( ) noexcept
      ;
      virtual void
      _M_destroy ( ) noexcept
      ;
      virtual void *
      _M_get_deleter ( const std :: type_info & ) noexcept
      ;
      _Sp_counted_ptr ( const _Sp_counted_ptr & ) = delete;
      _Sp_counted_ptr & operator = ( const _Sp_counted_ptr & ) = delete;
    private :
      _Ptr _M_ptr;
    };

template<> inline void _Sp_counted_ptr< nullptr_t ,__gnu_cxx::_S_single> ::_M_dispose()
{
}

template<> inline void _Sp_counted_ptr< nullptr_t ,__gnu_cxx::_S_mutex> ::_M_dispose()
{
}

template<> inline void _Sp_counted_ptr< nullptr_t ,__gnu_cxx::_S_atomic> ::_M_dispose()
{
}
template < int _Nm, typename _Tp,
    bool __use_ebo = ! __is_final ( _Tp ) && __is_empty ( _Tp ) >
    struct _Sp_ebo_helper;
template < int _Nm, typename _Tp >
    struct _Sp_ebo_helper < _Nm, _Tp, true > : private _Tp
    {
      explicit _Sp_ebo_helper ( const _Tp & __tp );
      static _Tp &
      _S_get ( _Sp_ebo_helper & __eboh );
    };
template < int _Nm, typename _Tp >
    struct _Sp_ebo_helper < _Nm, _Tp, false >
    {
      explicit _Sp_ebo_helper ( const _Tp & __tp );
      static _Tp &
      _S_get ( _Sp_ebo_helper & __eboh )
      ;
    private :
      _Tp _M_tp;
    };
template < typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp >
    class _Sp_counted_deleter : public _Sp_counted_base < _Lp >
    {
      class _Impl : _Sp_ebo_helper < 0, _Deleter >, _Sp_ebo_helper < 1, _Alloc >
      {
 typedef _Sp_ebo_helper < 0, _Deleter > _Del_base;
 typedef _Sp_ebo_helper < 1, _Alloc > _Alloc_base;
      public :
 _Impl ( _Ptr __p, _Deleter __d, const _Alloc & __a ) noexcept
 ;
 _Deleter & _M_del ( ) noexcept;
 _Alloc & _M_alloc ( ) noexcept;
 _Ptr _M_ptr;
      };
    public :
      using __allocator_type = __alloc_rebind < _Alloc, _Sp_counted_deleter >;
      _Sp_counted_deleter ( _Ptr __p, _Deleter __d ) noexcept
      ;
      _Sp_counted_deleter ( _Ptr __p, _Deleter __d, const _Alloc & __a ) noexcept
      ;
      ~ _Sp_counted_deleter ( ) noexcept;
      virtual void
      _M_dispose ( ) noexcept
      ;
      virtual void
      _M_destroy ( ) noexcept
      ;
      virtual void *
      _M_get_deleter ( const std :: type_info & __ti ) noexcept
      ;
    private :
      _Impl _M_impl;
    };

struct _Sp_make_shared_tag 
{
}
;
template < typename _Tp, typename _Alloc, _Lock_policy _Lp >
    class _Sp_counted_ptr_inplace : public _Sp_counted_base < _Lp >
    {
      class _Impl : _Sp_ebo_helper < 0, _Alloc >
      {
 typedef _Sp_ebo_helper < 0, _Alloc > _A_base;
      public :
 explicit _Impl ( _Alloc __a ) noexcept;
 _Alloc & _M_alloc ( ) noexcept;
 __gnu_cxx :: __aligned_buffer < _Tp > _M_storage;
      };
    public :
      using __allocator_type = __alloc_rebind < _Alloc, _Sp_counted_ptr_inplace >;
      template < typename ... _Args >
 _Sp_counted_ptr_inplace ( _Alloc __a, _Args && ... __args )
 : _M_impl ( __a )
 {
   allocator_traits < _Alloc > :: construct ( __a, _M_ptr ( ),
       std :: forward < _Args > ( __args ) ... );
 }
      ~ _Sp_counted_ptr_inplace ( ) noexcept;
      virtual void
      _M_dispose ( ) noexcept
      ;
      virtual void
      _M_destroy ( ) noexcept
      ;
      virtual void *
      _M_get_deleter ( const std :: type_info & __ti ) noexcept
      ;
    private :
      _Tp * _M_ptr ( ) noexcept;
      _Impl _M_impl;
    };
template < _Lock_policy _Lp >
    class __shared_count
    {
    public :
      constexpr __shared_count ( ) noexcept;
      template < typename _Ptr >
        explicit
 __shared_count ( _Ptr __p ) : _M_pi ( 0 )
 {
   try
     {
       _M_pi = new _Sp_counted_ptr < _Ptr, _Lp > ( __p );
     }
   catch ( ... )
     {
       delete __p;
       throw;
     }
 }
      template < typename _Ptr, typename _Deleter >
 __shared_count ( _Ptr __p, _Deleter __d )
 : __shared_count ( __p, std :: move ( __d ), allocator < void > ( ) )
 { }
      template < typename _Ptr, typename _Deleter, typename _Alloc >
 __shared_count ( _Ptr __p, _Deleter __d, _Alloc __a ) : _M_pi ( 0 )
 {
   typedef _Sp_counted_deleter < _Ptr, _Deleter, _Alloc, _Lp > _Sp_cd_type;
   try
     {
       typename _Sp_cd_type :: __allocator_type __a2 ( __a );
       auto __guard = std :: __allocate_guarded ( __a2 );
       _Sp_cd_type * __mem = __guard . get ( );
       :: new ( __mem ) _Sp_cd_type ( __p, std :: move ( __d ), std :: move ( __a ) );
       _M_pi = __mem;
       __guard = nullptr;
     }
   catch ( ... )
     {
       __d ( __p );
       throw;
     }
 }
      template < typename _Tp, typename _Alloc, typename ... _Args >
 __shared_count ( _Sp_make_shared_tag, _Tp *, const _Alloc & __a,
         _Args && ... __args )
 : _M_pi ( 0 )
 {
   typedef _Sp_counted_ptr_inplace < _Tp, _Alloc, _Lp > _Sp_cp_type;
   typename _Sp_cp_type :: __allocator_type __a2 ( __a );
   auto __guard = std :: __allocate_guarded ( __a2 );
   _Sp_cp_type * __mem = __guard . get ( );
   :: new ( __mem ) _Sp_cp_type ( std :: move ( __a ),
        std :: forward < _Args > ( __args ) ... );
   _M_pi = __mem;
   __guard = nullptr;
 }
      template < typename _Tp >
        explicit
 __shared_count ( std :: auto_ptr < _Tp > && __r );
      template < typename _Tp, typename _Del >
        explicit
 __shared_count ( std :: unique_ptr < _Tp, _Del > && __r ) : _M_pi ( 0 )
 {
   if ( __r . get ( ) == nullptr )
     return;
   using _Ptr = typename unique_ptr < _Tp, _Del > :: pointer;
   using _Del2 = typename conditional < is_reference < _Del > :: value,
       reference_wrapper < typename remove_reference < _Del > :: type >,
       _Del > :: type;
   using _Sp_cd_type
     = _Sp_counted_deleter < _Ptr, _Del2, allocator < void >, _Lp >;
   using _Alloc = allocator < _Sp_cd_type >;
   using _Alloc_traits = allocator_traits < _Alloc >;
   _Alloc __a;
   _Sp_cd_type * __mem = _Alloc_traits :: allocate ( __a, 1 );
   _Alloc_traits :: construct ( __a, __mem, __r . release ( ),
       __r . get_deleter ( ) );
   _M_pi = __mem;
 }
      explicit __shared_count ( const __weak_count < _Lp > & __r );
      explicit __shared_count ( const __weak_count < _Lp > & __r, std :: nothrow_t );
      ~ __shared_count ( ) noexcept
      ;
      __shared_count ( const __shared_count & __r ) noexcept
      ;
      __shared_count &
      operator = ( const __shared_count & __r ) noexcept
      ;
      void
      _M_swap ( __shared_count & __r ) noexcept
      ;
      long
      _M_get_use_count ( ) const noexcept
      ;
      bool
      _M_unique ( ) const noexcept
      ;
      void *
      _M_get_deleter ( const std :: type_info & __ti ) const noexcept
      ;
      bool
      _M_less ( const __shared_count & __rhs ) const noexcept
      ;
      bool
      _M_less ( const __weak_count < _Lp > & __rhs ) const noexcept
      ;
      friend inline bool
      operator == ( const __shared_count & __a, const __shared_count & __b ) noexcept;
    private :
      friend class __weak_count < _Lp >;
      _Sp_counted_base < _Lp > * _M_pi;
    };
template < _Lock_policy _Lp >
    class __weak_count
    {
    public :
      constexpr __weak_count ( ) noexcept;
      __weak_count ( const __shared_count < _Lp > & __r ) noexcept
      ;
      __weak_count ( const __weak_count & __r ) noexcept
      ;
      __weak_count ( __weak_count && __r ) noexcept
      ;
      ~ __weak_count ( ) noexcept
      ;
      __weak_count &
      operator = ( const __shared_count < _Lp > & __r ) noexcept
      ;
      __weak_count &
      operator = ( const __weak_count & __r ) noexcept
      ;
      __weak_count &
      operator = ( __weak_count && __r ) noexcept
      ;
      void
      _M_swap ( __weak_count & __r ) noexcept
      ;
      long
      _M_get_use_count ( ) const noexcept
      ;
      bool
      _M_less ( const __weak_count & __rhs ) const noexcept
      ;
      bool
      _M_less ( const __shared_count < _Lp > & __rhs ) const noexcept
      ;
      friend inline bool
      operator == ( const __weak_count & __a, const __weak_count & __b ) noexcept;
    private :
      friend class __shared_count < _Lp >;
      _Sp_counted_base < _Lp > * _M_pi;
    };
template < _Lock_policy _Lp >
    inline
    __shared_count < _Lp > :: __shared_count ( const __weak_count < _Lp > & __r )
    : _M_pi ( __r . _M_pi )
    {
      if ( _M_pi != nullptr )
 _M_pi -> _M_add_ref_lock ( );
      else
 __throw_bad_weak_ptr ( );
    }
template < _Lock_policy _Lp >
    inline
    __shared_count < _Lp > ::
    __shared_count ( const __weak_count < _Lp > & __r, std :: nothrow_t )
    : _M_pi ( __r . _M_pi )
    {
      if ( _M_pi != nullptr )
 if ( ! _M_pi -> _M_add_ref_lock_nothrow ( ) )
   _M_pi = nullptr;
    }
template < _Lock_policy _Lp, typename _Tp1, typename _Tp2 >
    void
    __enable_shared_from_this_helper ( const __shared_count < _Lp > &,
         const __enable_shared_from_this < _Tp1,
         _Lp > *, const _Tp2 * ) noexcept;
template < typename _Tp1, typename _Tp2 >
    void
    __enable_shared_from_this_helper ( const __shared_count < > &,
         const enable_shared_from_this < _Tp1 > *,
         const _Tp2 * ) noexcept;
template < _Lock_policy _Lp >
    inline void
    __enable_shared_from_this_helper ( const __shared_count < _Lp > &, ... ) noexcept
    { }
template < typename _Tp, _Lock_policy _Lp >
    class __shared_ptr
    {
      template < typename _Ptr >
 using _Convertible
   = typename enable_if < is_convertible < _Ptr, _Tp * > :: value > :: type;
    public :
      typedef _Tp element_type;
      constexpr __shared_ptr ( ) noexcept
      ;
      template < typename _Tp1 >
 explicit __shared_ptr ( _Tp1 * __p )
        : _M_ptr ( __p ), _M_refcount ( __p )
 {
   static_assert ( ! is_void < _Tp1 > :: value, "incomplete type" );
   static_assert ( sizeof ( _Tp1 ) > 0, "incomplete type" );
   __enable_shared_from_this_helper ( _M_refcount, __p, __p );
 }
      template < typename _Tp1, typename _Deleter >
 __shared_ptr ( _Tp1 * __p, _Deleter __d )
 : _M_ptr ( __p ), _M_refcount ( __p, __d )
 {
   __enable_shared_from_this_helper ( _M_refcount, __p, __p );
 }
      template < typename _Tp1, typename _Deleter, typename _Alloc >
 __shared_ptr ( _Tp1 * __p, _Deleter __d, _Alloc __a )
 : _M_ptr ( __p ), _M_refcount ( __p, __d, std :: move ( __a ) )
 {
   __enable_shared_from_this_helper ( _M_refcount, __p, __p );
 }
      template < typename _Deleter >
 __shared_ptr ( nullptr_t __p, _Deleter __d )
 : _M_ptr ( 0 ), _M_refcount ( __p, __d )
 { }
      template < typename _Deleter, typename _Alloc >
        __shared_ptr ( nullptr_t __p, _Deleter __d, _Alloc __a )
 : _M_ptr ( 0 ), _M_refcount ( __p, __d, std :: move ( __a ) )
 { }
      template < typename _Tp1 >
 __shared_ptr ( const __shared_ptr < _Tp1, _Lp > & __r, _Tp * __p ) noexcept
 : _M_ptr ( __p ), _M_refcount ( __r . _M_refcount )
 { }
      __shared_ptr ( const __shared_ptr & ) noexcept = default;
      __shared_ptr & operator = ( const __shared_ptr & ) noexcept = default;
      ~ __shared_ptr ( ) = default;
      template < typename _Tp1, typename = _Convertible < _Tp1 * >>
 __shared_ptr ( const __shared_ptr < _Tp1, _Lp > & __r ) noexcept
 : _M_ptr ( __r . _M_ptr ), _M_refcount ( __r . _M_refcount )
 { }
      __shared_ptr ( __shared_ptr && __r ) noexcept
      ;
      template < typename _Tp1, typename = _Convertible < _Tp1 * >>
 __shared_ptr ( __shared_ptr < _Tp1, _Lp > && __r ) noexcept
 : _M_ptr ( __r . _M_ptr ), _M_refcount ( )
 {
   _M_refcount . _M_swap ( __r . _M_refcount );
   __r . _M_ptr = 0;
 }
      template < typename _Tp1 >
 explicit __shared_ptr ( const __weak_ptr < _Tp1, _Lp > & __r )
 : _M_refcount ( __r . _M_refcount )
 {
   _M_ptr = __r . _M_ptr;
 }
      template < typename _Tp1, typename _Del, typename
        = _Convertible < typename unique_ptr < _Tp1, _Del > :: pointer >>
 __shared_ptr ( std :: unique_ptr < _Tp1, _Del > && __r )
 : _M_ptr ( __r . get ( ) ), _M_refcount ( )
 {
   auto __raw = _S_raw_ptr ( __r . get ( ) );
   _M_refcount = __shared_count < _Lp > ( std :: move ( __r ) );
   __enable_shared_from_this_helper ( _M_refcount, __raw, __raw );
 }
      template < typename _Tp1 >
 __shared_ptr ( std :: auto_ptr < _Tp1 > && __r );
      constexpr __shared_ptr ( nullptr_t ) noexcept;
      template < typename _Tp1 >
 __shared_ptr &
 operator = ( const __shared_ptr < _Tp1, _Lp > & __r ) noexcept
 {
   _M_ptr = __r . _M_ptr;
   _M_refcount = __r . _M_refcount;
   return * this;
 }
      template < typename _Tp1 >
 __shared_ptr &
 operator = ( std :: auto_ptr < _Tp1 > && __r )
 {
   __shared_ptr ( std :: move ( __r ) ) . swap ( * this );
   return * this;
 }
      __shared_ptr &
      operator = ( __shared_ptr && __r ) noexcept
      ;
      template < class _Tp1 >
 __shared_ptr &
 operator = ( __shared_ptr < _Tp1, _Lp > && __r ) noexcept
 {
   __shared_ptr ( std :: move ( __r ) ) . swap ( * this );
   return * this;
 }
      template < typename _Tp1, typename _Del >
 __shared_ptr &
 operator = ( std :: unique_ptr < _Tp1, _Del > && __r )
 {
   __shared_ptr ( std :: move ( __r ) ) . swap ( * this );
   return * this;
 }
      void
      reset ( ) noexcept
      ;
      template < typename _Tp1 >
 void
 reset ( _Tp1 * __p )
 {
   ;
   __shared_ptr ( __p ) . swap ( * this );
 }
      template < typename _Tp1, typename _Deleter >
 void
 reset ( _Tp1 * __p, _Deleter __d )
 { __shared_ptr ( __p, __d ) . swap ( * this ); }
      template < typename _Tp1, typename _Deleter, typename _Alloc >
 void
        reset ( _Tp1 * __p, _Deleter __d, _Alloc __a )
        { __shared_ptr ( __p, __d, std :: move ( __a ) ) . swap ( * this ); }
      typename std :: add_lvalue_reference < _Tp > :: type
      operator * ( ) const noexcept
      ;
      _Tp *
      operator -> ( ) const noexcept
      ;
      _Tp *
      get ( ) const noexcept
      ;
      explicit operator bool ( ) const
      ;
      bool
      unique ( ) const noexcept
      ;
      long
      use_count ( ) const noexcept
      ;
      void
      swap ( __shared_ptr < _Tp, _Lp > & __other ) noexcept
      ;
      template < typename _Tp1 >
 bool
 owner_before ( __shared_ptr < _Tp1, _Lp > const & __rhs ) const
 { return _M_refcount . _M_less ( __rhs . _M_refcount ); }
      template < typename _Tp1 >
 bool
 owner_before ( __weak_ptr < _Tp1, _Lp > const & __rhs ) const
 { return _M_refcount . _M_less ( __rhs . _M_refcount ); }
    protected :
      template < typename _Alloc, typename ... _Args >
 __shared_ptr ( _Sp_make_shared_tag __tag, const _Alloc & __a,
       _Args && ... __args )
 : _M_ptr ( ), _M_refcount ( __tag, ( _Tp * ) 0, __a,
    std :: forward < _Args > ( __args ) ... )
 {
   void * __p = _M_refcount . _M_get_deleter ( typeid ( __tag ) );
   _M_ptr = static_cast < _Tp * > ( __p );
   __enable_shared_from_this_helper ( _M_refcount, _M_ptr, _M_ptr );
 }
      template < typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
        typename ... _Args >
 friend __shared_ptr < _Tp1, _Lp1 >
 __allocate_shared ( const _Alloc & __a, _Args && ... __args );
      __shared_ptr ( const __weak_ptr < _Tp, _Lp > & __r, std :: nothrow_t )
      ;
      friend class __weak_ptr < _Tp, _Lp >;
    private :
      void *
      _M_get_deleter ( const std :: type_info & __ti ) const noexcept
      ;
      template < typename _Tp1 >
 static _Tp1 *
 _S_raw_ptr ( _Tp1 * __ptr )
 { return __ptr; }
      template < typename _Tp1 >
 static auto
 _S_raw_ptr ( _Tp1 __ptr ) -> decltype ( std :: __addressof ( * __ptr ) )
 { return std :: __addressof ( * __ptr ); }
      template < typename _Tp1, _Lock_policy _Lp1 > friend class __shared_ptr;
      template < typename _Tp1, _Lock_policy _Lp1 > friend class __weak_ptr;
      template < typename _Del, typename _Tp1, _Lock_policy _Lp1 >
 friend _Del * get_deleter ( const __shared_ptr < _Tp1, _Lp1 > & ) noexcept;
      _Tp * _M_ptr;
      __shared_count < _Lp > _M_refcount;
    };
template < typename _Tp1, typename _Tp2, _Lock_policy _Lp >
    inline bool
    operator == ( const __shared_ptr < _Tp1, _Lp > & __a,
        const __shared_ptr < _Tp2, _Lp > & __b ) noexcept
    { return __a . get ( ) == __b . get ( ); }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator == ( const __shared_ptr < _Tp, _Lp > & __a, nullptr_t ) noexcept
    { return ! __a; }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator == ( nullptr_t, const __shared_ptr < _Tp, _Lp > & __a ) noexcept
    { return ! __a; }
template < typename _Tp1, typename _Tp2, _Lock_policy _Lp >
    inline bool
    operator != ( const __shared_ptr < _Tp1, _Lp > & __a,
        const __shared_ptr < _Tp2, _Lp > & __b ) noexcept
    { return __a . get ( ) != __b . get ( ); }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator != ( const __shared_ptr < _Tp, _Lp > & __a, nullptr_t ) noexcept
    { return ( bool ) __a; }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator != ( nullptr_t, const __shared_ptr < _Tp, _Lp > & __a ) noexcept
    { return ( bool ) __a; }
template < typename _Tp1, typename _Tp2, _Lock_policy _Lp >
    inline bool
    operator < ( const __shared_ptr < _Tp1, _Lp > & __a,
       const __shared_ptr < _Tp2, _Lp > & __b ) noexcept
    {
      typedef typename std :: common_type < _Tp1 *, _Tp2 * > :: type _CT;
      return std :: less < _CT > ( ) ( __a . get ( ), __b . get ( ) );
    }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator < ( const __shared_ptr < _Tp, _Lp > & __a, nullptr_t ) noexcept
    { return std :: less < _Tp * > ( ) ( __a . get ( ), nullptr ); }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator < ( nullptr_t, const __shared_ptr < _Tp, _Lp > & __a ) noexcept
    { return std :: less < _Tp * > ( ) ( nullptr, __a . get ( ) ); }
template < typename _Tp1, typename _Tp2, _Lock_policy _Lp >
    inline bool
    operator <= ( const __shared_ptr < _Tp1, _Lp > & __a,
        const __shared_ptr < _Tp2, _Lp > & __b ) noexcept
    { return ! ( __b < __a ); }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator <= ( const __shared_ptr < _Tp, _Lp > & __a, nullptr_t ) noexcept
    { return ! ( nullptr < __a ); }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator <= ( nullptr_t, const __shared_ptr < _Tp, _Lp > & __a ) noexcept
    { return ! ( __a < nullptr ); }
template < typename _Tp1, typename _Tp2, _Lock_policy _Lp >
    inline bool
    operator > ( const __shared_ptr < _Tp1, _Lp > & __a,
       const __shared_ptr < _Tp2, _Lp > & __b ) noexcept
    { return ( __b < __a ); }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator > ( const __shared_ptr < _Tp, _Lp > & __a, nullptr_t ) noexcept
    { return std :: less < _Tp * > ( ) ( nullptr, __a . get ( ) ); }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator > ( nullptr_t, const __shared_ptr < _Tp, _Lp > & __a ) noexcept
    { return std :: less < _Tp * > ( ) ( __a . get ( ), nullptr ); }
template < typename _Tp1, typename _Tp2, _Lock_policy _Lp >
    inline bool
    operator >= ( const __shared_ptr < _Tp1, _Lp > & __a,
        const __shared_ptr < _Tp2, _Lp > & __b ) noexcept
    { return ! ( __a < __b ); }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator >= ( const __shared_ptr < _Tp, _Lp > & __a, nullptr_t ) noexcept
    { return ! ( __a < nullptr ); }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    operator >= ( nullptr_t, const __shared_ptr < _Tp, _Lp > & __a ) noexcept
    { return ! ( nullptr < __a ); }
template < typename _Sp >
    struct _Sp_less : public binary_function < _Sp, _Sp, bool >
    {
      bool
      operator ( ) ( const _Sp & __lhs, const _Sp & __rhs ) const noexcept
      ;
    };
template < typename _Tp, _Lock_policy _Lp >
    struct less < __shared_ptr < _Tp, _Lp > >
    : public _Sp_less < __shared_ptr < _Tp, _Lp >>
    { };
template < typename _Tp, _Lock_policy _Lp >
    inline void
    swap ( __shared_ptr < _Tp, _Lp > & __a, __shared_ptr < _Tp, _Lp > & __b ) noexcept
    { __a . swap ( __b ); }
template < typename _Tp, typename _Tp1, _Lock_policy _Lp >
    inline __shared_ptr < _Tp, _Lp >
    static_pointer_cast ( const __shared_ptr < _Tp1, _Lp > & __r ) noexcept
    { return __shared_ptr < _Tp, _Lp > ( __r, static_cast < _Tp * > ( __r . get ( ) ) ); }
template < typename _Tp, typename _Tp1, _Lock_policy _Lp >
    inline __shared_ptr < _Tp, _Lp >
    const_pointer_cast ( const __shared_ptr < _Tp1, _Lp > & __r ) noexcept
    { return __shared_ptr < _Tp, _Lp > ( __r, const_cast < _Tp * > ( __r . get ( ) ) ); }
template < typename _Tp, typename _Tp1, _Lock_policy _Lp >
    inline __shared_ptr < _Tp, _Lp >
    dynamic_pointer_cast ( const __shared_ptr < _Tp1, _Lp > & __r ) noexcept
    {
      if ( _Tp * __p = dynamic_cast < _Tp * > ( __r . get ( ) ) )
 return __shared_ptr < _Tp, _Lp > ( __r, __p );
      return __shared_ptr < _Tp, _Lp > ( );
    }
template < typename _Tp, _Lock_policy _Lp >
    class __weak_ptr
    {
      template < typename _Ptr >
 using _Convertible
   = typename enable_if < is_convertible < _Ptr, _Tp * > :: value > :: type;
    public :
      typedef _Tp element_type;
      constexpr __weak_ptr ( ) noexcept
      ;
      __weak_ptr ( const __weak_ptr & ) noexcept = default;
      ~ __weak_ptr ( ) = default;
      template < typename _Tp1, typename = _Convertible < _Tp1 * >>
 __weak_ptr ( const __weak_ptr < _Tp1, _Lp > & __r ) noexcept
 : _M_refcount ( __r . _M_refcount )
        { _M_ptr = __r . lock ( ) . get ( ); }
      template < typename _Tp1, typename = _Convertible < _Tp1 * >>
 __weak_ptr ( const __shared_ptr < _Tp1, _Lp > & __r ) noexcept
 : _M_ptr ( __r . _M_ptr ), _M_refcount ( __r . _M_refcount )
 { }
      __weak_ptr ( __weak_ptr && __r ) noexcept
      ;
      template < typename _Tp1, typename = _Convertible < _Tp1 * >>
 __weak_ptr ( __weak_ptr < _Tp1, _Lp > && __r ) noexcept
 : _M_ptr ( __r . lock ( ) . get ( ) ), _M_refcount ( std :: move ( __r . _M_refcount ) )
        { __r . _M_ptr = nullptr; }
      __weak_ptr &
      operator = ( const __weak_ptr & __r ) noexcept = default;
      template < typename _Tp1 >
 __weak_ptr &
 operator = ( const __weak_ptr < _Tp1, _Lp > & __r ) noexcept
 {
   _M_ptr = __r . lock ( ) . get ( );
   _M_refcount = __r . _M_refcount;
   return * this;
 }
      template < typename _Tp1 >
 __weak_ptr &
 operator = ( const __shared_ptr < _Tp1, _Lp > & __r ) noexcept
 {
   _M_ptr = __r . _M_ptr;
   _M_refcount = __r . _M_refcount;
   return * this;
 }
      __weak_ptr &
      operator = ( __weak_ptr && __r ) noexcept
      ;
      template < typename _Tp1 >
 __weak_ptr &
 operator = ( __weak_ptr < _Tp1, _Lp > && __r ) noexcept
 {
   _M_ptr = __r . lock ( ) . get ( );
   _M_refcount = std :: move ( __r . _M_refcount );
   __r . _M_ptr = nullptr;
   return * this;
 }
      __shared_ptr < _Tp, _Lp >
      lock ( ) const noexcept
      ;
      long
      use_count ( ) const noexcept
      ;
      bool
      expired ( ) const noexcept
      ;
      template < typename _Tp1 >
 bool
 owner_before ( const __shared_ptr < _Tp1, _Lp > & __rhs ) const
 { return _M_refcount . _M_less ( __rhs . _M_refcount ); }
      template < typename _Tp1 >
 bool
 owner_before ( const __weak_ptr < _Tp1, _Lp > & __rhs ) const
 { return _M_refcount . _M_less ( __rhs . _M_refcount ); }
      void
      reset ( ) noexcept
      ;
      void
      swap ( __weak_ptr & __s ) noexcept
      ;
    private :
      void
      _M_assign ( _Tp * __ptr, const __shared_count < _Lp > & __refcount ) noexcept
      ;
      template < typename _Tp1, _Lock_policy _Lp1 > friend class __shared_ptr;
      template < typename _Tp1, _Lock_policy _Lp1 > friend class __weak_ptr;
      friend class __enable_shared_from_this < _Tp, _Lp >;
      friend class enable_shared_from_this < _Tp >;
      _Tp * _M_ptr;
      __weak_count < _Lp > _M_refcount;
    };
template < typename _Tp, _Lock_policy _Lp >
    inline void
    swap ( __weak_ptr < _Tp, _Lp > & __a, __weak_ptr < _Tp, _Lp > & __b ) noexcept
    { __a . swap ( __b ); }
template < typename _Tp, typename _Tp1 >
    struct _Sp_owner_less : public binary_function < _Tp, _Tp, bool >
    {
      bool
      operator ( ) ( const _Tp & __lhs, const _Tp & __rhs ) const
      ;
      bool
      operator ( ) ( const _Tp & __lhs, const _Tp1 & __rhs ) const
      ;
      bool
      operator ( ) ( const _Tp1 & __lhs, const _Tp & __rhs ) const
      ;
    };
template < typename _Tp, _Lock_policy _Lp >
    struct owner_less < __shared_ptr < _Tp, _Lp > >
    : public _Sp_owner_less < __shared_ptr < _Tp, _Lp >, __weak_ptr < _Tp, _Lp >>
    { };
template < typename _Tp, _Lock_policy _Lp >
    struct owner_less < __weak_ptr < _Tp, _Lp > >
    : public _Sp_owner_less < __weak_ptr < _Tp, _Lp >, __shared_ptr < _Tp, _Lp >>
    { };
template < typename _Tp, _Lock_policy _Lp >
    class __enable_shared_from_this
    {
    protected :
      constexpr __enable_shared_from_this ( ) noexcept;
      __enable_shared_from_this ( const __enable_shared_from_this & ) noexcept;
      __enable_shared_from_this &
      operator = ( const __enable_shared_from_this & ) noexcept
      ;
      ~ __enable_shared_from_this ( );
    public :
      __shared_ptr < _Tp, _Lp >
      shared_from_this ( )
      ;
      __shared_ptr < const _Tp, _Lp >
      shared_from_this ( ) const
      ;
    private :
      template < typename _Tp1 >
 void
 _M_weak_assign ( _Tp1 * __p, const __shared_count < _Lp > & __n ) const noexcept
 { _M_weak_this . _M_assign ( __p, __n ); }
      template < _Lock_policy _Lp1, typename _Tp1, typename _Tp2 >
 friend void
 __enable_shared_from_this_helper ( const __shared_count < _Lp1 > &,
      const __enable_shared_from_this < _Tp1,
      _Lp1 > *, const _Tp2 * ) noexcept;
      mutable __weak_ptr < _Tp, _Lp > _M_weak_this;
    };
template < _Lock_policy _Lp1, typename _Tp1, typename _Tp2 >
    inline void
    __enable_shared_from_this_helper ( const __shared_count < _Lp1 > & __pn,
         const __enable_shared_from_this < _Tp1,
         _Lp1 > * __pe,
         const _Tp2 * __px ) noexcept
    {
      if ( __pe != nullptr )
 __pe -> _M_weak_assign ( const_cast < _Tp2 * > ( __px ), __pn );
    }
template < typename _Tp, _Lock_policy _Lp, typename _Alloc, typename ... _Args >
    inline __shared_ptr < _Tp, _Lp >
    __allocate_shared ( const _Alloc & __a, _Args && ... __args )
    {
      return __shared_ptr < _Tp, _Lp > ( _Sp_make_shared_tag ( ), __a,
        std :: forward < _Args > ( __args ) ... );
    }
template < typename _Tp, _Lock_policy _Lp, typename ... _Args >
    inline __shared_ptr < _Tp, _Lp >
    __make_shared ( _Args && ... __args )
    {
      typedef typename std :: remove_const < _Tp > :: type _Tp_nc;
      return std :: __allocate_shared < _Tp, _Lp > ( std :: allocator < _Tp_nc > ( ),
           std :: forward < _Args > ( __args ) ... );
    }
template < typename _Tp, _Lock_policy _Lp >
    struct hash < __shared_ptr < _Tp, _Lp > >
    : public __hash_base < size_t, __shared_ptr < _Tp, _Lp >>
    {
      size_t
      operator ( ) ( const __shared_ptr < _Tp, _Lp > & __s ) const noexcept
      ;
    };
}
namespace std
{
template < typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp >
    inline std :: basic_ostream < _Ch, _Tr > &
    operator << ( std :: basic_ostream < _Ch, _Tr > & __os,
        const __shared_ptr < _Tp, _Lp > & __p )
    {
      __os << __p . get ( );
      return __os;
    }
template < typename _Del, typename _Tp, _Lock_policy _Lp >
    inline _Del *
    get_deleter ( const __shared_ptr < _Tp, _Lp > & __p ) noexcept
    {
      return static_cast < _Del * > ( __p . _M_get_deleter ( typeid ( _Del ) ) );
    }
template < typename _Tp >
    class shared_ptr : public __shared_ptr < _Tp >
    {
      template < typename _Ptr >
 using _Convertible
   = typename enable_if < is_convertible < _Ptr, _Tp * > :: value > :: type;
    public :
      constexpr shared_ptr ( ) noexcept
      ;
      shared_ptr ( const shared_ptr & ) noexcept = default;
      template < typename _Tp1 >
 explicit shared_ptr ( _Tp1 * __p )
        : __shared_ptr < _Tp > ( __p ) { }
      template < typename _Tp1, typename _Deleter >
 shared_ptr ( _Tp1 * __p, _Deleter __d )
        : __shared_ptr < _Tp > ( __p, __d ) { }
      template < typename _Deleter >
 shared_ptr ( nullptr_t __p, _Deleter __d )
        : __shared_ptr < _Tp > ( __p, __d ) { }
      template < typename _Tp1, typename _Deleter, typename _Alloc >
 shared_ptr ( _Tp1 * __p, _Deleter __d, _Alloc __a )
 : __shared_ptr < _Tp > ( __p, __d, std :: move ( __a ) ) { }
      template < typename _Deleter, typename _Alloc >
 shared_ptr ( nullptr_t __p, _Deleter __d, _Alloc __a )
 : __shared_ptr < _Tp > ( __p, __d, std :: move ( __a ) ) { }
      template < typename _Tp1 >
 shared_ptr ( const shared_ptr < _Tp1 > & __r, _Tp * __p ) noexcept
 : __shared_ptr < _Tp > ( __r, __p ) { }
      template < typename _Tp1, typename = _Convertible < _Tp1 * >>
 shared_ptr ( const shared_ptr < _Tp1 > & __r ) noexcept
        : __shared_ptr < _Tp > ( __r ) { }
      shared_ptr ( shared_ptr && __r ) noexcept
      ;
      template < typename _Tp1, typename = _Convertible < _Tp1 * >>
 shared_ptr ( shared_ptr < _Tp1 > && __r ) noexcept
 : __shared_ptr < _Tp > ( std :: move ( __r ) ) { }
      template < typename _Tp1 >
 explicit shared_ptr ( const weak_ptr < _Tp1 > & __r )
 : __shared_ptr < _Tp > ( __r ) { }
      template < typename _Tp1 >
 shared_ptr ( std :: auto_ptr < _Tp1 > && __r );
      template < typename _Tp1, typename _Del, typename
        = _Convertible < typename unique_ptr < _Tp1, _Del > :: pointer >>
 shared_ptr ( std :: unique_ptr < _Tp1, _Del > && __r )
 : __shared_ptr < _Tp > ( std :: move ( __r ) ) { }
      constexpr shared_ptr ( nullptr_t ) noexcept;
      shared_ptr & operator = ( const shared_ptr & ) noexcept = default;
      template < typename _Tp1 >
 shared_ptr &
 operator = ( const shared_ptr < _Tp1 > & __r ) noexcept
 {
   this -> __shared_ptr < _Tp > :: operator = ( __r );
   return * this;
 }
      template < typename _Tp1 >
 shared_ptr &
 operator = ( std :: auto_ptr < _Tp1 > && __r )
 {
   this -> __shared_ptr < _Tp > :: operator = ( std :: move ( __r ) );
   return * this;
 }
      shared_ptr &
      operator = ( shared_ptr && __r ) noexcept
      ;
      template < class _Tp1 >
 shared_ptr &
 operator = ( shared_ptr < _Tp1 > && __r ) noexcept
 {
   this -> __shared_ptr < _Tp > :: operator = ( std :: move ( __r ) );
   return * this;
 }
      template < typename _Tp1, typename _Del >
 shared_ptr &
 operator = ( std :: unique_ptr < _Tp1, _Del > && __r )
 {
   this -> __shared_ptr < _Tp > :: operator = ( std :: move ( __r ) );
   return * this;
 }
    private :
      template < typename _Alloc, typename ... _Args >
 shared_ptr ( _Sp_make_shared_tag __tag, const _Alloc & __a,
     _Args && ... __args )
 : __shared_ptr < _Tp > ( __tag, __a, std :: forward < _Args > ( __args ) ... )
 { }
      template < typename _Tp1, typename _Alloc, typename ... _Args >
 friend shared_ptr < _Tp1 >
 allocate_shared ( const _Alloc & __a, _Args && ... __args );
      shared_ptr ( const weak_ptr < _Tp > & __r, std :: nothrow_t )
      ;
      friend class weak_ptr < _Tp >;
    };
template < typename _Tp1, typename _Tp2 >
    inline bool
    operator == ( const shared_ptr < _Tp1 > & __a,
        const shared_ptr < _Tp2 > & __b ) noexcept
    { return __a . get ( ) == __b . get ( ); }
template < typename _Tp >
    inline bool
    operator == ( const shared_ptr < _Tp > & __a, nullptr_t ) noexcept
    { return ! __a; }
template < typename _Tp >
    inline bool
    operator == ( nullptr_t, const shared_ptr < _Tp > & __a ) noexcept
    { return ! __a; }
template < typename _Tp1, typename _Tp2 >
    inline bool
    operator != ( const shared_ptr < _Tp1 > & __a,
        const shared_ptr < _Tp2 > & __b ) noexcept
    { return __a . get ( ) != __b . get ( ); }
template < typename _Tp >
    inline bool
    operator != ( const shared_ptr < _Tp > & __a, nullptr_t ) noexcept
    { return ( bool ) __a; }
template < typename _Tp >
    inline bool
    operator != ( nullptr_t, const shared_ptr < _Tp > & __a ) noexcept
    { return ( bool ) __a; }
template < typename _Tp1, typename _Tp2 >
    inline bool
    operator < ( const shared_ptr < _Tp1 > & __a,
       const shared_ptr < _Tp2 > & __b ) noexcept
    {
      typedef typename std :: common_type < _Tp1 *, _Tp2 * > :: type _CT;
      return std :: less < _CT > ( ) ( __a . get ( ), __b . get ( ) );
    }
template < typename _Tp >
    inline bool
    operator < ( const shared_ptr < _Tp > & __a, nullptr_t ) noexcept
    { return std :: less < _Tp * > ( ) ( __a . get ( ), nullptr ); }
template < typename _Tp >
    inline bool
    operator < ( nullptr_t, const shared_ptr < _Tp > & __a ) noexcept
    { return std :: less < _Tp * > ( ) ( nullptr, __a . get ( ) ); }
template < typename _Tp1, typename _Tp2 >
    inline bool
    operator <= ( const shared_ptr < _Tp1 > & __a,
        const shared_ptr < _Tp2 > & __b ) noexcept
    { return ! ( __b < __a ); }
template < typename _Tp >
    inline bool
    operator <= ( const shared_ptr < _Tp > & __a, nullptr_t ) noexcept
    { return ! ( nullptr < __a ); }
template < typename _Tp >
    inline bool
    operator <= ( nullptr_t, const shared_ptr < _Tp > & __a ) noexcept
    { return ! ( __a < nullptr ); }
template < typename _Tp1, typename _Tp2 >
    inline bool
    operator > ( const shared_ptr < _Tp1 > & __a,
       const shared_ptr < _Tp2 > & __b ) noexcept
    { return ( __b < __a ); }
template < typename _Tp >
    inline bool
    operator > ( const shared_ptr < _Tp > & __a, nullptr_t ) noexcept
    { return std :: less < _Tp * > ( ) ( nullptr, __a . get ( ) ); }
template < typename _Tp >
    inline bool
    operator > ( nullptr_t, const shared_ptr < _Tp > & __a ) noexcept
    { return std :: less < _Tp * > ( ) ( __a . get ( ), nullptr ); }
template < typename _Tp1, typename _Tp2 >
    inline bool
    operator >= ( const shared_ptr < _Tp1 > & __a,
        const shared_ptr < _Tp2 > & __b ) noexcept
    { return ! ( __a < __b ); }
template < typename _Tp >
    inline bool
    operator >= ( const shared_ptr < _Tp > & __a, nullptr_t ) noexcept
    { return ! ( __a < nullptr ); }
template < typename _Tp >
    inline bool
    operator >= ( nullptr_t, const shared_ptr < _Tp > & __a ) noexcept
    { return ! ( nullptr < __a ); }
template < typename _Tp >
    struct less < shared_ptr < _Tp > > : public _Sp_less < shared_ptr < _Tp >>
    { };
template < typename _Tp >
    inline void
    swap ( shared_ptr < _Tp > & __a, shared_ptr < _Tp > & __b ) noexcept
    { __a . swap ( __b ); }
template < typename _Tp, typename _Tp1 >
    inline shared_ptr < _Tp >
    static_pointer_cast ( const shared_ptr < _Tp1 > & __r ) noexcept
    { return shared_ptr < _Tp > ( __r, static_cast < _Tp * > ( __r . get ( ) ) ); }
template < typename _Tp, typename _Tp1 >
    inline shared_ptr < _Tp >
    const_pointer_cast ( const shared_ptr < _Tp1 > & __r ) noexcept
    { return shared_ptr < _Tp > ( __r, const_cast < _Tp * > ( __r . get ( ) ) ); }
template < typename _Tp, typename _Tp1 >
    inline shared_ptr < _Tp >
    dynamic_pointer_cast ( const shared_ptr < _Tp1 > & __r ) noexcept
    {
      if ( _Tp * __p = dynamic_cast < _Tp * > ( __r . get ( ) ) )
 return shared_ptr < _Tp > ( __r, __p );
      return shared_ptr < _Tp > ( );
    }
template < typename _Tp >
    class weak_ptr : public __weak_ptr < _Tp >
    {
      template < typename _Ptr >
 using _Convertible
   = typename enable_if < is_convertible < _Ptr, _Tp * > :: value > :: type;
    public :
      constexpr weak_ptr ( ) noexcept = default;
      template < typename _Tp1, typename = _Convertible < _Tp1 * >>
 weak_ptr ( const shared_ptr < _Tp1 > & __r ) noexcept
 : __weak_ptr < _Tp > ( __r ) { }
      weak_ptr ( const weak_ptr & ) noexcept = default;
      template < typename _Tp1, typename = _Convertible < _Tp1 * >>
 weak_ptr ( const weak_ptr < _Tp1 > & __r ) noexcept
 : __weak_ptr < _Tp > ( __r ) { }
      weak_ptr ( weak_ptr && ) noexcept = default;
      template < typename _Tp1, typename = _Convertible < _Tp1 * >>
 weak_ptr ( weak_ptr < _Tp1 > && __r ) noexcept
 : __weak_ptr < _Tp > ( std :: move ( __r ) ) { }
      weak_ptr &
      operator = ( const weak_ptr & __r ) noexcept = default;
      template < typename _Tp1 >
 weak_ptr &
 operator = ( const weak_ptr < _Tp1 > & __r ) noexcept
 {
   this -> __weak_ptr < _Tp > :: operator = ( __r );
   return * this;
 }
      template < typename _Tp1 >
 weak_ptr &
 operator = ( const shared_ptr < _Tp1 > & __r ) noexcept
 {
   this -> __weak_ptr < _Tp > :: operator = ( __r );
   return * this;
 }
      weak_ptr &
      operator = ( weak_ptr && __r ) noexcept = default;
      template < typename _Tp1 >
 weak_ptr &
 operator = ( weak_ptr < _Tp1 > && __r ) noexcept
 {
   this -> __weak_ptr < _Tp > :: operator = ( std :: move ( __r ) );
   return * this;
 }
      shared_ptr < _Tp >
      lock ( ) const noexcept
      ;
    };
template < typename _Tp >
    inline void
    swap ( weak_ptr < _Tp > & __a, weak_ptr < _Tp > & __b ) noexcept
    { __a . swap ( __b ); }
template < typename _Tp >
    struct owner_less;
template < typename _Tp >
    struct owner_less < shared_ptr < _Tp > >
    : public _Sp_owner_less < shared_ptr < _Tp >, weak_ptr < _Tp >>
    { };
template < typename _Tp >
    struct owner_less < weak_ptr < _Tp > >
    : public _Sp_owner_less < weak_ptr < _Tp >, shared_ptr < _Tp >>
    { };
template < typename _Tp >
    class enable_shared_from_this
    {
    protected :
      constexpr enable_shared_from_this ( ) noexcept;
      enable_shared_from_this ( const enable_shared_from_this & ) noexcept;
      enable_shared_from_this &
      operator = ( const enable_shared_from_this & ) noexcept
      ;
      ~ enable_shared_from_this ( );
    public :
      shared_ptr < _Tp >
      shared_from_this ( )
      ;
      shared_ptr < const _Tp >
      shared_from_this ( ) const
      ;
    private :
      template < typename _Tp1 >
 void
 _M_weak_assign ( _Tp1 * __p, const __shared_count < > & __n ) const noexcept
 { _M_weak_this . _M_assign ( __p, __n ); }
      template < typename _Tp1, typename _Tp2 >
 friend void
 __enable_shared_from_this_helper ( const __shared_count < > &,
      const enable_shared_from_this < _Tp1 > *,
      const _Tp2 * ) noexcept;
      mutable weak_ptr < _Tp > _M_weak_this;
    };
template < typename _Tp1, typename _Tp2 >
    inline void
    __enable_shared_from_this_helper ( const __shared_count < > & __pn,
         const enable_shared_from_this < _Tp1 > *
         __pe, const _Tp2 * __px ) noexcept
    {
      if ( __pe != nullptr )
 __pe -> _M_weak_assign ( const_cast < _Tp2 * > ( __px ), __pn );
    }
template < typename _Tp, typename _Alloc, typename ... _Args >
    inline shared_ptr < _Tp >
    allocate_shared ( const _Alloc & __a, _Args && ... __args )
    {
      return shared_ptr < _Tp > ( _Sp_make_shared_tag ( ), __a,
        std :: forward < _Args > ( __args ) ... );
    }
template < typename _Tp, typename ... _Args >
    inline shared_ptr < _Tp >
    make_shared ( _Args && ... __args )
    {
      typedef typename std :: remove_const < _Tp > :: type _Tp_nc;
      return std :: allocate_shared < _Tp > ( std :: allocator < _Tp_nc > ( ),
           std :: forward < _Args > ( __args ) ... );
    }
template < typename _Tp >
    struct hash < shared_ptr < _Tp > >
    : public __hash_base < size_t, shared_ptr < _Tp >>
    {
      size_t
      operator ( ) ( const shared_ptr < _Tp > & __s ) const noexcept
      ;
    };
}
namespace std
{
typedef enum memory_order {memory_order_relaxed=0,memory_order_consume=1,memory_order_acquire=2,memory_order_release=3,memory_order_acq_rel=4,memory_order_seq_cst=5}memory_order;
enum __memory_order_modifier {__memory_order_mask=65535,__memory_order_modifier_mask=-65536,__memory_order_hle_acquire=65536,__memory_order_hle_release=131072} ;

constexpr inline memory_order  __attribute__((visibility("default"))) operator|(std::memory_order __m,enum __memory_order_modifier __mod)
{
return (std::memory_order )(__m | ((int )__mod));
}

constexpr inline memory_order  __attribute__((visibility("default"))) operator&(std::memory_order __m,enum __memory_order_modifier __mod)
{
return (std::memory_order )(__m & ((int )__mod));
}

constexpr inline memory_order  __attribute__((no_throw))  __attribute__((visibility("default"))) __cmpexch_failure_order2(std::memory_order __m)
{
return __m == memory_order_acq_rel?memory_order_acquire : ((__m == memory_order_release?memory_order_relaxed : __m));
}

constexpr inline memory_order  __attribute__((no_throw))  __attribute__((visibility("default"))) __cmpexch_failure_order(std::memory_order __m)
{
return (std::memory_order )((__cmpexch_failure_order2((__m&__memory_order_mask))) | (__m&__memory_order_modifier_mask));
}

inline void  __attribute__((always_inline))  __attribute__((no_throw))  __attribute__((visibility("default"))) atomic_thread_fence(std::memory_order __m)
{
__atomic_thread_fence(__m);
}

inline void  __attribute__((always_inline))  __attribute__((no_throw))  __attribute__((visibility("default"))) atomic_signal_fence(std::memory_order __m)
{
__atomic_signal_fence(__m);
}
template < typename _Tp >
    inline _Tp
    kill_dependency ( _Tp __y ) noexcept
    {
      _Tp __ret ( __y );
      return __ret;
    }
template < typename _IntTp >
    struct __atomic_base;
template < typename _Tp >
    struct atomic;
template < typename _Tp >
    struct atomic < _Tp * >;
typedef bool __atomic_flag_data_type;
  extern "C" {

struct __atomic_flag_base 
{
__atomic_flag_data_type _M_i;
}
;
}

struct atomic_flag : public __atomic_flag_base
{
inline atomic_flag() = default;

inline ~atomic_flag()
{
}
inline atomic_flag(const struct atomic_flag &) = delete;

inline atomic_flag &operator=(const struct atomic_flag &)
{
}

inline atomic_flag &operator=(const struct atomic_flag &) volatile
{
}

constexpr inline atomic_flag(bool __i) : __atomic_flag_base({_S_init(__i)})
{
}

inline bool test_and_set(std::memory_order __m = memory_order_seq_cst)
{
return false;
}

inline bool test_and_set(std::memory_order __m = memory_order_seq_cst) volatile
{
return false;
}

inline void clear(std::memory_order __m = memory_order_seq_cst)
{
std::memory_order __b = __m&__memory_order_mask;
;
;
;
;
}

inline void clear(std::memory_order __m = memory_order_seq_cst) volatile
{
std::memory_order __b = __m&__memory_order_mask;
;
;
;
;
}

constexpr inline static __atomic_flag_data_type _S_init(bool __i)
{
return (__i?1 : 0);
}
}
;
template < typename _ITp >
    struct __atomic_base
    {
    private :
      typedef _ITp __int_type;
      static constexpr int _S_alignment =
 sizeof ( _ITp ) > alignof ( _ITp ) ? sizeof ( _ITp ) : alignof ( _ITp );
      alignas ( _S_alignment ) __int_type _M_i;
    public :
      __atomic_base ( ) noexcept = default;
      ~ __atomic_base ( ) noexcept = default;
      __atomic_base ( const __atomic_base & ) = delete;
      __atomic_base & operator = ( const __atomic_base & ) = delete;
      __atomic_base & operator = ( const __atomic_base & ) volatile = delete;
      constexpr __atomic_base ( __int_type __i ) noexcept;
      operator __int_type ( ) const noexcept
      ;
      operator __int_type ( ) const volatile noexcept
      ;
      __int_type
      operator = ( __int_type __i ) noexcept
      ;
      __int_type
      operator = ( __int_type __i ) volatile noexcept
      ;
      __int_type
      operator ++ ( int ) noexcept
      ;
      __int_type
      operator ++ ( int ) volatile noexcept
      ;
      __int_type
      operator -- ( int ) noexcept
      ;
      __int_type
      operator -- ( int ) volatile noexcept
      ;
      __int_type
      operator ++ ( ) noexcept
      ;
      __int_type
      operator ++ ( ) volatile noexcept
      ;
      __int_type
      operator -- ( ) noexcept
      ;
      __int_type
      operator -- ( ) volatile noexcept
      ;
      __int_type
      operator += ( __int_type __i ) noexcept
      ;
      __int_type
      operator += ( __int_type __i ) volatile noexcept
      ;
      __int_type
      operator -= ( __int_type __i ) noexcept
      ;
      __int_type
      operator -= ( __int_type __i ) volatile noexcept
      ;
      __int_type
      operator &= ( __int_type __i ) noexcept
      ;
      __int_type
      operator &= ( __int_type __i ) volatile noexcept
      ;
      __int_type
      operator |= ( __int_type __i ) noexcept
      ;
      __int_type
      operator |= ( __int_type __i ) volatile noexcept
      ;
      __int_type
      operator ^= ( __int_type __i ) noexcept
      ;
      __int_type
      operator ^= ( __int_type __i ) volatile noexcept
      ;
      bool
      is_lock_free ( ) const noexcept
      ;
      bool
      is_lock_free ( ) const volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) void
      store ( __int_type __i, memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) void
      store ( __int_type __i,
     memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      load ( memory_order __m = memory_order_seq_cst ) const noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      load ( memory_order __m = memory_order_seq_cst ) const volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      exchange ( __int_type __i,
        memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      exchange ( __int_type __i,
        memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) bool
      compare_exchange_weak ( __int_type & __i1, __int_type __i2,
       memory_order __m1, memory_order __m2 ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) bool
      compare_exchange_weak ( __int_type & __i1, __int_type __i2,
       memory_order __m1,
       memory_order __m2 ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) bool
      compare_exchange_weak ( __int_type & __i1, __int_type __i2,
       memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) bool
      compare_exchange_weak ( __int_type & __i1, __int_type __i2,
     memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) bool
      compare_exchange_strong ( __int_type & __i1, __int_type __i2,
         memory_order __m1, memory_order __m2 ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) bool
      compare_exchange_strong ( __int_type & __i1, __int_type __i2,
         memory_order __m1,
         memory_order __m2 ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) bool
      compare_exchange_strong ( __int_type & __i1, __int_type __i2,
         memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) bool
      compare_exchange_strong ( __int_type & __i1, __int_type __i2,
   memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      fetch_add ( __int_type __i,
  memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      fetch_add ( __int_type __i,
  memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      fetch_sub ( __int_type __i,
  memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      fetch_sub ( __int_type __i,
  memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      fetch_and ( __int_type __i,
  memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      fetch_and ( __int_type __i,
  memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      fetch_or ( __int_type __i,
        memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      fetch_or ( __int_type __i,
        memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      fetch_xor ( __int_type __i,
  memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __int_type
      fetch_xor ( __int_type __i,
  memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
    };
template < typename _PTp >
    struct __atomic_base < _PTp * >
    {
    private :
      typedef _PTp * __pointer_type;
      __pointer_type _M_p;
      constexpr ptrdiff_t
      _M_type_size ( ptrdiff_t __d ) const;
      constexpr ptrdiff_t
      _M_type_size ( ptrdiff_t __d ) const volatile;
    public :
      __atomic_base ( ) noexcept = default;
      ~ __atomic_base ( ) noexcept = default;
      __atomic_base ( const __atomic_base & ) = delete;
      __atomic_base & operator = ( const __atomic_base & ) = delete;
      __atomic_base & operator = ( const __atomic_base & ) volatile = delete;
      constexpr __atomic_base ( __pointer_type __p ) noexcept;
      operator __pointer_type ( ) const noexcept
      ;
      operator __pointer_type ( ) const volatile noexcept
      ;
      __pointer_type
      operator = ( __pointer_type __p ) noexcept
      ;
      __pointer_type
      operator = ( __pointer_type __p ) volatile noexcept
      ;
      __pointer_type
      operator ++ ( int ) noexcept
      ;
      __pointer_type
      operator ++ ( int ) volatile noexcept
      ;
      __pointer_type
      operator -- ( int ) noexcept
      ;
      __pointer_type
      operator -- ( int ) volatile noexcept
      ;
      __pointer_type
      operator ++ ( ) noexcept
      ;
      __pointer_type
      operator ++ ( ) volatile noexcept
      ;
      __pointer_type
      operator -- ( ) noexcept
      ;
      __pointer_type
      operator -- ( ) volatile noexcept
      ;
      __pointer_type
      operator += ( ptrdiff_t __d ) noexcept
      ;
      __pointer_type
      operator += ( ptrdiff_t __d ) volatile noexcept
      ;
      __pointer_type
      operator -= ( ptrdiff_t __d ) noexcept
      ;
      __pointer_type
      operator -= ( ptrdiff_t __d ) volatile noexcept
      ;
      bool
      is_lock_free ( ) const noexcept
      ;
      bool
      is_lock_free ( ) const volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) void
      store ( __pointer_type __p,
     memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) void
      store ( __pointer_type __p,
     memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __pointer_type
      load ( memory_order __m = memory_order_seq_cst ) const noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __pointer_type
      load ( memory_order __m = memory_order_seq_cst ) const volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __pointer_type
      exchange ( __pointer_type __p,
        memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __pointer_type
      exchange ( __pointer_type __p,
        memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) bool
      compare_exchange_strong ( __pointer_type & __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2 ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) bool
      compare_exchange_strong ( __pointer_type & __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2 ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __pointer_type
      fetch_add ( ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __pointer_type
      fetch_add ( ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __pointer_type
      fetch_sub ( ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst ) noexcept
      ;
      inline __attribute__ ( ( __always_inline__ ) ) __pointer_type
      fetch_sub ( ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst ) volatile noexcept
      ;
    };
}
namespace std
{

struct _Sp_locker 
{
inline _Sp_locker(const struct _Sp_locker &) = delete;

inline _Sp_locker &operator=(const struct _Sp_locker &)
{
}
explicit _Sp_locker(const void *);
_Sp_locker(const void *,const void *);
~_Sp_locker();
unsigned char _M_key1;
unsigned char _M_key2;
}
;
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    atomic_is_lock_free ( const __shared_ptr < _Tp, _Lp > * __p )
    {
      return __gthread_active_p ( ) == 0;
    }
template < typename _Tp >
    inline bool
    atomic_is_lock_free ( const shared_ptr < _Tp > * __p )
    { return std :: atomic_is_lock_free < _Tp, __default_lock_policy > ( __p ); }
template < typename _Tp >
    inline shared_ptr < _Tp >
    atomic_load_explicit ( const shared_ptr < _Tp > * __p, memory_order )
    {
      _Sp_locker __lock { __p };
      return * __p;
    }
template < typename _Tp >
    inline shared_ptr < _Tp >
    atomic_load ( const shared_ptr < _Tp > * __p )
    { return std :: atomic_load_explicit ( __p, memory_order_seq_cst ); }
template < typename _Tp, _Lock_policy _Lp >
    inline __shared_ptr < _Tp, _Lp >
    atomic_load_explicit ( const __shared_ptr < _Tp, _Lp > * __p, memory_order )
    {
      _Sp_locker __lock { __p };
      return * __p;
    }
template < typename _Tp, _Lock_policy _Lp >
    inline __shared_ptr < _Tp, _Lp >
    atomic_load ( const __shared_ptr < _Tp, _Lp > * __p )
    { return std :: atomic_load_explicit ( __p, memory_order_seq_cst ); }
template < typename _Tp >
    inline void
    atomic_store_explicit ( shared_ptr < _Tp > * __p, shared_ptr < _Tp > __r,
     memory_order )
    {
      _Sp_locker __lock { __p };
      __p -> swap ( __r );
    }
template < typename _Tp >
    inline void
    atomic_store ( shared_ptr < _Tp > * __p, shared_ptr < _Tp > __r )
    { std :: atomic_store_explicit ( __p, std :: move ( __r ), memory_order_seq_cst ); }
template < typename _Tp, _Lock_policy _Lp >
    inline void
    atomic_store_explicit ( __shared_ptr < _Tp, _Lp > * __p,
     __shared_ptr < _Tp, _Lp > __r,
     memory_order )
    {
      _Sp_locker __lock { __p };
      __p -> swap ( __r );
    }
template < typename _Tp, _Lock_policy _Lp >
    inline void
    atomic_store ( __shared_ptr < _Tp, _Lp > * __p, __shared_ptr < _Tp, _Lp > __r )
    { std :: atomic_store_explicit ( __p, std :: move ( __r ), memory_order_seq_cst ); }
template < typename _Tp >
    inline shared_ptr < _Tp >
    atomic_exchange_explicit ( shared_ptr < _Tp > * __p, shared_ptr < _Tp > __r,
        memory_order )
    {
      _Sp_locker __lock { __p };
      __p -> swap ( __r );
      return __r;
    }
template < typename _Tp >
    inline shared_ptr < _Tp >
    atomic_exchange ( shared_ptr < _Tp > * __p, shared_ptr < _Tp > __r )
    {
      return std :: atomic_exchange_explicit ( __p, std :: move ( __r ),
        memory_order_seq_cst );
    }
template < typename _Tp, _Lock_policy _Lp >
    inline __shared_ptr < _Tp, _Lp >
    atomic_exchange_explicit ( __shared_ptr < _Tp, _Lp > * __p,
        __shared_ptr < _Tp, _Lp > __r,
        memory_order )
    {
      _Sp_locker __lock { __p };
      __p -> swap ( __r );
      return __r;
    }
template < typename _Tp, _Lock_policy _Lp >
    inline __shared_ptr < _Tp, _Lp >
    atomic_exchange ( __shared_ptr < _Tp, _Lp > * __p, __shared_ptr < _Tp, _Lp > __r )
    {
      return std :: atomic_exchange_explicit ( __p, std :: move ( __r ),
        memory_order_seq_cst );
    }
template < typename _Tp >
    bool
    atomic_compare_exchange_strong_explicit ( shared_ptr < _Tp > * __p,
         shared_ptr < _Tp > * __v,
         shared_ptr < _Tp > __w,
         memory_order,
         memory_order )
    {
      shared_ptr < _Tp > __x;
      _Sp_locker __lock { __p, __v };
      owner_less < shared_ptr < _Tp >> __less;
      if ( * __p == * __v && ! __less ( * __p, * __v ) && ! __less ( * __v, * __p ) )
 {
   __x = std :: move ( * __p );
   * __p = std :: move ( __w );
   return true;
 }
      __x = std :: move ( * __v );
      * __v = * __p;
      return false;
    }
template < typename _Tp >
    inline bool
    atomic_compare_exchange_strong ( shared_ptr < _Tp > * __p, shared_ptr < _Tp > * __v,
     shared_ptr < _Tp > __w )
    {
      return std :: atomic_compare_exchange_strong_explicit ( __p, __v,
   std :: move ( __w ), memory_order_seq_cst, memory_order_seq_cst );
    }
template < typename _Tp >
    inline bool
    atomic_compare_exchange_weak_explicit ( shared_ptr < _Tp > * __p,
       shared_ptr < _Tp > * __v,
       shared_ptr < _Tp > __w,
       memory_order __success,
       memory_order __failure )
    {
      return std :: atomic_compare_exchange_strong_explicit ( __p, __v,
   std :: move ( __w ), __success, __failure );
    }
template < typename _Tp >
    inline bool
    atomic_compare_exchange_weak ( shared_ptr < _Tp > * __p, shared_ptr < _Tp > * __v,
     shared_ptr < _Tp > __w )
    {
      return std :: atomic_compare_exchange_weak_explicit ( __p, __v,
   std :: move ( __w ), memory_order_seq_cst, memory_order_seq_cst );
    }
template < typename _Tp, _Lock_policy _Lp >
    bool
    atomic_compare_exchange_strong_explicit ( __shared_ptr < _Tp, _Lp > * __p,
         __shared_ptr < _Tp, _Lp > * __v,
         __shared_ptr < _Tp, _Lp > __w,
         memory_order,
         memory_order )
    {
      __shared_ptr < _Tp, _Lp > __x;
      _Sp_locker __lock { __p, __v };
      owner_less < __shared_ptr < _Tp, _Lp >> __less;
      if ( * __p == * __v && ! __less ( * __p, * __v ) && ! __less ( * __v, * __p ) )
 {
   __x = std :: move ( * __p );
   * __p = std :: move ( __w );
   return true;
 }
      __x = std :: move ( * __v );
      * __v = * __p;
      return false;
    }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    atomic_compare_exchange_strong ( __shared_ptr < _Tp, _Lp > * __p,
       __shared_ptr < _Tp, _Lp > * __v,
       __shared_ptr < _Tp, _Lp > __w )
    {
      return std :: atomic_compare_exchange_strong_explicit ( __p, __v,
   std :: move ( __w ), memory_order_seq_cst, memory_order_seq_cst );
    }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    atomic_compare_exchange_weak_explicit ( __shared_ptr < _Tp, _Lp > * __p,
       __shared_ptr < _Tp, _Lp > * __v,
       __shared_ptr < _Tp, _Lp > __w,
       memory_order __success,
       memory_order __failure )
    {
      return std :: atomic_compare_exchange_strong_explicit ( __p, __v,
   std :: move ( __w ), __success, __failure );
    }
template < typename _Tp, _Lock_policy _Lp >
    inline bool
    atomic_compare_exchange_weak ( __shared_ptr < _Tp, _Lp > * __p,
     __shared_ptr < _Tp, _Lp > * __v,
     __shared_ptr < _Tp, _Lp > __w )
    {
      return std :: atomic_compare_exchange_weak_explicit ( __p, __v,
   std :: move ( __w ), memory_order_seq_cst, memory_order_seq_cst );
    }
}
namespace std
{
template < typename _Tp1 >
    struct auto_ptr_ref
    {
      _Tp1 * _M_ptr;
      explicit
      auto_ptr_ref ( _Tp1 * __p );
    } __attribute__ ( ( __deprecated__ ) );
template < typename _Tp >
    class auto_ptr
    {
    private :
      _Tp * _M_ptr;
    public :
      typedef _Tp element_type;
      explicit
      auto_ptr ( element_type * __p = 0 ) throw ( );
      auto_ptr ( auto_ptr & __a ) throw ( );
      template < typename _Tp1 >
        auto_ptr ( auto_ptr < _Tp1 > & __a ) throw ( ) : _M_ptr ( __a . release ( ) ) { }
      auto_ptr &
      operator = ( auto_ptr & __a ) throw ( )
      ;
      template < typename _Tp1 >
        auto_ptr &
        operator = ( auto_ptr < _Tp1 > & __a ) throw ( )
        {
   reset ( __a . release ( ) );
   return * this;
 }
      ~ auto_ptr ( );
      element_type &
      operator * ( ) const throw ( )
      ;
      element_type *
      operator -> ( ) const throw ( )
      ;
      element_type *
      get ( ) const throw ( );
      element_type *
      release ( ) throw ( )
      ;
      void
      reset ( element_type * __p = 0 ) throw ( )
      ;
      auto_ptr ( auto_ptr_ref < element_type > __ref ) throw ( )
      ;
      auto_ptr &
      operator = ( auto_ptr_ref < element_type > __ref ) throw ( )
      ;
      template < typename _Tp1 >
        operator auto_ptr_ref < _Tp1 > ( ) throw ( )
        { return auto_ptr_ref < _Tp1 > ( this -> release ( ) ); }
      template < typename _Tp1 >
        operator auto_ptr < _Tp1 > ( ) throw ( )
        { return auto_ptr < _Tp1 > ( this -> release ( ) ); }
    } __attribute__ ( ( __deprecated__ ) );
template<> class auto_ptr< void  > 
{
public: typedef void element_type;
};
template < _Lock_policy _Lp >
  template < typename _Tp >
    inline
    __shared_count < _Lp > :: __shared_count ( std :: auto_ptr < _Tp > && __r )
    : _M_pi ( new _Sp_counted_ptr < _Tp *, _Lp > ( __r . get ( ) ) )
    { __r . release ( ); }
template < typename _Tp, _Lock_policy _Lp >
  template < typename _Tp1 >
    inline
    __shared_ptr < _Tp, _Lp > :: __shared_ptr ( std :: auto_ptr < _Tp1 > && __r )
    : _M_ptr ( __r . get ( ) ), _M_refcount ( )
    {
      static_assert ( sizeof ( _Tp1 ) > 0, "incomplete type" );
      _Tp1 * __tmp = __r . get ( );
      _M_refcount = __shared_count < _Lp > ( std :: move ( __r ) );
      __enable_shared_from_this_helper ( _M_refcount, __tmp, __tmp );
    }
template < typename _Tp >
  template < typename _Tp1 >
    inline
    shared_ptr < _Tp > :: shared_ptr ( std :: auto_ptr < _Tp1 > && __r )
    : __shared_ptr < _Tp > ( std :: move ( __r ) ) { }
template < typename _Tp, typename _Dp >
  template < typename _Up, typename >
    inline
    unique_ptr < _Tp, _Dp > :: unique_ptr ( auto_ptr < _Up > && __u ) noexcept
    : _M_t ( __u . release ( ), deleter_type ( ) ) { }
}
namespace std
{

inline void * __attribute__((no_throw))  __attribute__((visibility("default"))) align(size_t __align,size_t __size,void *&__ptr,size_t &__space)
{
const auto __intptr = reinterpret_cast < uintptr_t  >  (__ptr);
const auto __aligned = __intptr - 1u + __align & -__align;
const auto __diff = __aligned - __intptr;
if (__size + __diff > __space) 
return (nullptr);
 else {
__space -= __diff;
return __ptr = (reinterpret_cast < void * >  (__aligned));
}
}
enum class pointer_safety {relaxed=0,preferred=1,strict=2} ;

inline void  __attribute__((visibility("default"))) declare_reachable(void *)
{
}
template < class T >
  inline T *
  undeclare_reachable ( T * __p ) { return __p; }

inline void  __attribute__((visibility("default"))) declare_no_pointers(char *,size_t )
{
}

inline void  __attribute__((visibility("default"))) undeclare_no_pointers(char *,size_t )
{
}

inline enum class pointer_safety  __attribute__((no_throw))  __attribute__((visibility("default"))) get_pointer_safety()
{
return pointer_safety(0);
}
}
namespace camp
{
template < typename T, typename ... Args >
constexpr
inline
std :: unique_ptr < T > make_unique ( Args && ... args )
{
    return std :: unique_ptr < T > ( new T ( std :: forward < Args > ( args ) ... ) );
}
}
namespace camp
{
namespace detail
{
template < typename Key, typename Val >
  Val lookup ( list < Key, Val > * );
template < typename >
  nil lookup ( ... );
template < typename Seq, typename = nil >
  struct lookup_table;
template < typename ... Keys, typename ... Values >
  struct lookup_table < list < list < Keys, Values > ... > > : list < Keys, Values > ... {
  };
}
template < typename Seq, typename Key >
struct at_key_s {
  using type =
      decltype ( detail :: lookup < Key > ( declptr < detail :: lookup_table < Seq >> ( ) ) );
};
template < typename Map, typename Key >
using at_key = typename at_key_s < Map, Key > :: type;
}
namespace camp
{
namespace test
{
template < typename T1, typename T2 >
  struct AssertSame {
    static_assert ( is_same < T1, T2 > :: value,
                  "is_same assertion failed <see below for more information>" );
    static bool constexpr value = is_same < T1, T2 > :: value;
  };
template < typename Assertion, idx_t i >
  struct AssertValue {
    static_assert ( Assertion :: value == i,
                  "value assertion failed <see below for more information>" );
    static bool const value = Assertion :: value == i;
  };
}
}
namespace camp
{
template < typename Seq >
struct flatten;
template < typename Seq, typename T >
struct append;
template < typename ... Elements, typename T >
struct append < list < Elements ... >, T > {
  using type = list < Elements ..., T >;
};
template < typename Seq, typename T >
struct prepend;
template < typename ... Elements, typename T >
struct prepend < list < Elements ... >, T > {
  using type = list < Elements ..., T >;
};
template < typename Seq, typename T >
struct extend;
template < typename ... Elements, typename ... NewElements >
struct extend < list < Elements ... >, list < NewElements ... > > {
  using type = list < Elements ..., NewElements ... >;
};
namespace detail
{
template < typename CurSeq, size_t N, typename ... Rest >
  struct flatten_impl;
template < typename CurSeq >
  struct flatten_impl < CurSeq, 0 > {
    using type = CurSeq;
  };
template < typename ... CurSeqElements,
            size_t N,
            typename First,
            typename ... Rest >
  struct flatten_impl < list < CurSeqElements ... >, N, First, Rest ... > {
    using type = typename flatten_impl < list < CurSeqElements ..., First >,
                                       N - 1,
                                       Rest ... > :: type;
  };
template < typename ... CurSeqElements,
            size_t N,
            typename ... FirstInnerElements,
            typename ... Rest >
  struct flatten_impl < list < CurSeqElements ... >,
                      N,
                      list < FirstInnerElements ... >,
                      Rest ... > {
    using first_inner_flat =
        typename flatten_impl < list < >,
                              sizeof ... ( FirstInnerElements ),
                              FirstInnerElements ... > :: type;
    using cur_and_first =
        typename extend < list < CurSeqElements ... >, first_inner_flat > :: type;
    using type = typename flatten_impl < cur_and_first, N - 1, Rest ... > :: type;
  };
}
template < typename ... Elements >
struct flatten < list < Elements ... > >
    : detail :: flatten_impl < list < >, sizeof ... ( Elements ), Elements ... > {
};
template < typename ... Seqs >
struct join;
template < typename Seq1, typename Seq2, typename ... Rest >
struct join < Seq1, Seq2, Rest ... > {
      using type = typename join < typename extend < Seq1, Seq2 > :: type, Rest ... > :: type;
};
template < typename Seq1 >
struct join < Seq1 > {
      using type = Seq1;
};
template<> struct join<   > 
{
using type = struct list<   > ;
};
template < template < typename ... > class Op, typename T >
struct transform;
template < template < typename ... > class Op, typename ... Elements >
struct transform < Op, list < Elements ... > > {
  using type = list < typename Op < Elements > :: type ... >;
};
namespace detail
{
template < template < typename ... > class Op, typename Current, typename ... Rest >
  struct accumulate_impl;
template < template < typename ... > class Op,
            typename Current,
            typename First,
            typename ... Rest >
  struct accumulate_impl < Op, Current, First, Rest ... > {
    using current = typename Op < Current, First > :: type;
    using type = typename accumulate_impl < Op, current, Rest ... > :: type;
  };
template < template < typename ... > class Op, typename Current >
  struct accumulate_impl < Op, Current > {
    using type = Current;
  };
}
template < template < typename ... > class Op, typename Initial, typename Seq >
struct accumulate;
template < template < typename ... > class Op,
          typename Initial,
          typename ... Elements >
struct accumulate < Op, Initial, list < Elements ... > > {
  using type = typename detail :: accumulate_impl < Op, Initial, Elements ... > :: type;
};
namespace detail
{
template < class, class >
  struct product_impl { };
template < class ... Xs, class ... Ys >
    struct product_impl < list < Xs ... >, list < Ys ... > > {
      using type = list < list < Xs ..., Ys > ... >;
    };
template < class, class >
  struct product { };
template < class ... Seqs, class ... vals >
    struct product < list < Seqs ... >, list < vals ... > > {
      using type = typename join < typename product_impl < Seqs, list < vals ... >> :: type ... > :: type;
    };
}
template < class ... Seqs >
using cartesian_product = typename accumulate < detail :: product, list < list < >>, list < Seqs ... >> :: type;
template < typename Lambda, typename ... Rest > struct accumulate_l { using type = typename accumulate < Lambda :: template expr, Rest ... > :: type; };
template < typename T, typename L >
struct index_of;
template < typename T, typename ... Elements >
struct index_of < T, list < Elements ... > > {
  template < typename Seq, typename Item >
  using inc_until =
      if_ < typename std :: is_same < T, Item > :: type,
          if_c < size < Seq > :: value == 1,
               typename prepend < Seq, num < first < Seq > :: value >> :: type,
               Seq >,
          list < num < first < Seq > :: value + 1 >>>;
  using indices =
      typename accumulate < inc_until, list < num < 0 >>, list < Elements ... >> :: type;
  using type =
      typename if_c < size < indices > :: value == 2, first < indices >, camp :: nil > :: type;
};
template < template < typename ... > class Op, typename Seq >
struct filter;
template < template < typename ... > class Op, typename ... Elements >
struct filter < Op, list < Elements ... > > {
  template < typename Seq, typename T >
  using append_if =
      if_ < typename Op < T > :: type, typename append < Seq, T > :: type, Seq >;
  using type = typename accumulate < append_if, list < >, list < Elements ... >> :: type;
};
template < typename Lambda, typename ... Rest > struct filter_l { using type = typename filter < Lambda :: template expr, Rest ... > :: type; };
template < typename T, T ... Args >
struct size < int_seq < T, Args ... > > {
  constexpr static idx_t value { sizeof ... ( Args ) };
  using type = num < sizeof ... ( Args ) >;
};
}
namespace camp
{
template < typename ... Rest >
struct tuple;
template < typename TagList, typename ... Elements >
class tagged_tuple;
template<> class tuple<   > ;
template < template < typename ... Ts > class Tup >
using is_tuple = typename std :: is_base_of < tuple < >, Tup < >> :: type;
template < typename Tuple >
struct tuple_size;
template < camp :: idx_t i, typename T >
struct tuple_element {
  using type = camp :: at_v < typename T :: TList, i >;
};
template < camp :: idx_t i, typename T >
using tuple_element_t = typename tuple_element < i, T > :: type;
template < typename T, typename Tuple >
using tuple_ebt_t =
    typename tuple_element < camp :: at_key < typename Tuple :: TMap, T > :: value,
                           Tuple > :: type;
namespace internal
{
template < class T >
  struct unwrap_refwrapper {
    using type = T;
  };
template < class T >
  struct unwrap_refwrapper < std :: reference_wrapper < T > > {
    using type = T &;
  };
template < class T >
  using special_decay_t =
      typename unwrap_refwrapper < typename std :: decay < T > :: type > :: type;
}
template < camp :: idx_t index, class Tuple >
 constexpr auto get ( const Tuple & t ) noexcept
    -> tuple_element_t < index, Tuple > const &;
template < camp :: idx_t index, class Tuple >
 constexpr auto get ( Tuple & t ) noexcept
    -> tuple_element_t < index, Tuple > &;
template < typename T, class Tuple >
 constexpr auto get ( const Tuple & t ) noexcept
    -> tuple_ebt_t < T, Tuple > const &;
template < typename T, class Tuple >
 constexpr auto get ( Tuple & t ) noexcept
    -> tuple_ebt_t < T, Tuple > &;
namespace internal
{
template < camp :: idx_t index, typename Type >
  struct tuple_storage {
    constexpr tuple_storage ( );
    template < typename T >
    constexpr tuple_storage ( T && v )
        : val ( std :: forward < T > ( v ) )
    {
    }
    constexpr const Type & get_inner ( ) const noexcept
    ;
    constexpr Type & get_inner ( ) noexcept;
  public :
    Type val;
  };
template < typename Indices, typename Typelist >
  struct tuple_helper;
template < typename ... Types, camp :: idx_t ... Indices >
  struct tuple_helper < camp :: idx_seq < Indices ... >, camp :: list < Types ... > >
      : public internal :: tuple_storage < Indices, Types > ... {
    tuple_helper & operator = ( const tuple_helper & rhs ) = default;
    constexpr tuple_helper ( ) = default;
    constexpr tuple_helper ( tuple_helper const & ) = default;
    constexpr tuple_helper ( tuple_helper && ) = default;
    template < typename ... Args >
    constexpr tuple_helper ( Args && ... args )
        : tuple_storage < Indices, Types > ( std :: forward < Args > ( args ) ) ...
    {
    }
    template < typename RTuple >
    tuple_helper & operator = ( const RTuple & rhs )
    {
      return ( camp :: sink ( ( this -> tuple_storage < Indices, Types > :: get_inner ( ) =
                              get < Indices > ( rhs ) ) ... ),
              * this );
    }
  };
template < typename Types, typename Indices >
  struct tag_map;
template < typename ... Types, camp :: idx_t ... Indices >
  struct tag_map < camp :: list < Types ... >, camp :: idx_seq < Indices ... > > {
    using type = camp :: list < camp :: list < Types, camp :: num < Indices >> ... >;
  };
template < typename T, camp :: idx_t I >
  using tpl_get_store = internal :: tuple_storage < I, tuple_element_t < I, T >>;
}
template < typename ... Elements >
struct tuple {
private :
  using Self = tuple;
  using Base = internal :: tuple_helper < camp :: make_idx_seq_t < sizeof ... ( Elements ) >,
                                      camp :: list < Elements ... >>;
  template < typename ... Ts >
  struct is_pack_this_tuple : false_type {
  };
  template < typename That >
  struct is_pack_this_tuple < That > : std :: is_same < tuple, decay < That >> {
  };
public :
  using TList = camp :: list < Elements ... >;
  using TMap = typename internal :: tag_map <
      camp :: list < Elements ... >,
      camp :: make_idx_seq_t < sizeof ... ( Elements ) >> :: type;
  using type = tuple;
private :
  Base base;
  template < camp :: idx_t index, class Tuple >
  constexpr friend auto get ( const Tuple & t ) noexcept
      -> tuple_element_t < index, Tuple > const &;
  template < camp :: idx_t index, class Tuple >
  constexpr friend auto get ( Tuple & t ) noexcept
      -> tuple_element_t < index, Tuple > &;
  template < typename T, class Tuple >
  constexpr friend auto get ( const Tuple & t ) noexcept
      -> tuple_ebt_t < T, Tuple > const &;
  template < typename T, class Tuple >
  constexpr friend auto get ( Tuple & t ) noexcept
      -> tuple_ebt_t < T, Tuple > &;
public :
  template < bool B = concepts :: metalib :: all_of <
                std :: is_default_constructible < Elements > :: value ... > :: value,
            typename std :: enable_if < B, void > :: type * = nullptr >
  constexpr tuple ( ) : base ( )
  {
  }
  constexpr tuple ( tuple const & o );
  constexpr tuple ( tuple && o );
  tuple & operator = ( tuple const & rhs )
  ;
  tuple & operator = ( tuple && rhs )
  ;
  template < typename ... Args,
            typename std :: enable_if <
                ! is_pack_this_tuple < Args ... > :: value > :: type * = nullptr >
  constexpr explicit tuple ( Args && ... rest )
      : base { std :: forward < Args > ( rest ) ... }
  {
  }
  template < typename ... RTypes >
  constexpr Self & operator = ( const tuple < RTypes ... > & rhs )
  {
    base . operator = ( rhs );
    return * this;
  }
};
template < typename TagList, typename ... Elements >
class tagged_tuple : public tuple < Elements ... >
{
  using Self = tagged_tuple;
  using Base = internal :: tuple_helper < camp :: make_idx_seq_t < sizeof ... ( Elements ) >,
                                      camp :: list < Elements ... >>;
  template < typename ... Ts >
  struct is_pack_this_tuple : false_type {
  };
  template < typename That >
  struct is_pack_this_tuple < That > : std :: is_same < tagged_tuple, decay < That >> {
  };
public :
  using TList = camp :: list < Elements ... >;
  using TMap = typename internal ::
      tag_map < TagList, camp :: make_idx_seq_t < sizeof ... ( Elements ) >> :: type;
  using type = tagged_tuple;
private :
  Base base;
  template < camp :: idx_t index, class Tuple >
  constexpr friend auto get ( const Tuple & t ) noexcept
      -> tuple_element_t < index, Tuple > const &;
  template < camp :: idx_t index, class Tuple >
  constexpr friend auto get ( Tuple & t ) noexcept
      -> tuple_element_t < index, Tuple > &;
  template < typename T, class Tuple >
  constexpr friend auto get ( const Tuple & t ) noexcept
      -> tuple_ebt_t < T, Tuple > const &;
  template < typename T, class Tuple >
  constexpr friend auto get ( Tuple & t ) noexcept
      -> tuple_ebt_t < T, Tuple > &;
public :
public :
  template < bool B = concepts :: metalib :: all_of <
                std :: is_default_constructible < Elements > :: value ... > :: value,
            typename std :: enable_if < B, void > :: type * = nullptr >
  constexpr tagged_tuple ( ) : base ( )
  {
  }
  constexpr tagged_tuple ( tagged_tuple const & o ) = default;
  constexpr tagged_tuple ( tagged_tuple && o ) = default;
  tagged_tuple & operator = ( tagged_tuple const & rhs )
  ;
  tagged_tuple & operator = ( tagged_tuple && rhs )
  ;
  template < typename ... Args,
            typename std :: enable_if <
                ! is_pack_this_tuple < Args ... > :: value > :: type * = nullptr >
  constexpr explicit tagged_tuple ( Args const & ... rest )
      : base { rest ... }
  {
  }
  template < template < typename ... > class T, typename ... RTypes >
  constexpr Self & operator = ( const T < RTypes ... > & rhs )
  {
    base . operator = ( rhs );
    return * this;
  }
};
template<> class tuple<   > 
{
using TList = struct list<   > ;
using TMap = TList ;
using type = class tuple<   > ;
};
template < typename ... Tags, typename ... Args >
struct as_list_s < tagged_tuple < camp :: list < Tags ... >, Args ... > > {
  using type = list < Args ... >;
};
template < camp :: idx_t index, class Tuple >
 constexpr auto get ( const Tuple & t ) noexcept
    -> tuple_element_t < index, Tuple > const &
{
  using internal :: tpl_get_store;
  static_assert ( tuple_size < Tuple > :: value > index, "index out of range" );
  return static_cast < tpl_get_store < Tuple, index > const & > ( t . base ) . get_inner ( );
}
template < camp :: idx_t index, class Tuple >
 constexpr auto get ( Tuple & t ) noexcept
    -> tuple_element_t < index, Tuple > &
{
  using internal :: tpl_get_store;
  static_assert ( tuple_size < Tuple > :: value > index, "index out of range" );
  return static_cast < tpl_get_store < Tuple, index > & > ( t . base ) . get_inner ( );
}
template < typename T, class Tuple >
 constexpr auto get ( const Tuple & t ) noexcept
    -> tuple_ebt_t < T, Tuple > const &
{
  using internal :: tpl_get_store;
  using index_type = camp :: at_key < typename Tuple :: TMap, T >;
  static_assert ( ! std :: is_same < camp :: nil, index_type > :: value,
                "invalid type index" );
  return static_cast < tpl_get_store < Tuple, index_type :: value > & > ( t . base )
      . get_inner ( );
}
template < typename T, class Tuple >
 constexpr auto get ( Tuple & t ) noexcept -> tuple_ebt_t < T, Tuple > &
{
  using internal :: tpl_get_store;
  using index_type = camp :: at_key < typename Tuple :: TMap, T >;
  static_assert ( ! std :: is_same < camp :: nil, index_type > :: value,
                "invalid type index" );
  return static_cast < tpl_get_store < Tuple, index_type :: value > & > ( t . base )
      . get_inner ( );
}
template < typename ... Args >
struct tuple_size < tuple < Args ... > > {
  static constexpr size_t value = sizeof ... ( Args );
};
template < typename ... Args >
struct tuple_size < tuple < Args ... > & > {
  static constexpr size_t value = sizeof ... ( Args );
};
template < typename L, typename ... Args >
struct tuple_size < tagged_tuple < L, Args ... > > {
  static constexpr size_t value = sizeof ... ( Args );
};
template < typename L, typename ... Args >
struct tuple_size < tagged_tuple < L, Args ... > & > {
  static constexpr size_t value = sizeof ... ( Args );
};
template < typename ... Args >
 constexpr auto make_tuple ( Args && ... args )
    -> tuple < internal :: special_decay_t < Args > ... >
{
  return tuple < internal :: special_decay_t < Args > ... > { std :: forward < Args > ( args ) ... };
}
template < typename TagList, typename ... Args >
 constexpr auto make_tagged_tuple ( Args && ... args )
    -> tagged_tuple < TagList, internal :: special_decay_t < Args > ... >
{
  return tagged_tuple < TagList, internal :: special_decay_t < Args > ... > {
      std :: forward < Args > ( args ) ... };
}
template < typename ... Args >
 constexpr auto forward_as_tuple ( Args && ... args ) noexcept
    -> tuple < Args && ... >
{
  return tuple < Args && ... > ( std :: forward < Args > ( args ) ... );
}
template < class ... Types >
 constexpr tuple < Types & ... > tie ( Types & ... args ) noexcept
{
  return tuple < Types & ... > { args ... };
}
template < typename ... Lelem,
          typename ... Relem,
          camp :: idx_t ... Lidx,
          camp :: idx_t ... Ridx >
 constexpr auto tuple_cat_pair ( tuple < Lelem ... > const & l,
                                               camp :: idx_seq < Lidx ... >,
                                               tuple < Relem ... > const & r,
                                               camp :: idx_seq < Ridx ... > ) noexcept
    -> tuple < camp :: at_v < camp :: list < Lelem ... >, Lidx > ...,
             camp :: at_v < camp :: list < Relem ... >, Ridx > ... >
{
  return make_tuple ( get < Lidx > ( l ) ..., get < Ridx > ( r ) ... );
}
template < typename L, typename R >
 constexpr auto tuple_cat_pair ( L const & l, R const & r ) noexcept
    -> decltype ( tuple_cat_pair ( l,
                               camp :: idx_seq_from_t < L > { },
                               r,
                               camp :: idx_seq_from_t < R > { } ) )
{
  return tuple_cat_pair ( l,
                        camp :: idx_seq_from_t < L > { },
                        r,
                        camp :: idx_seq_from_t < R > { } );
}
template < typename Fn, camp :: idx_t ... Sequence, typename TupleLike >
 constexpr auto invoke_with_order ( TupleLike && t,
                                                  Fn && f,
                                                  camp :: idx_seq < Sequence ... > )
    -> decltype ( f ( get < Sequence > ( t ) ... ) )
{
  return f ( get < Sequence > ( t ) ... );
}
template < typename Fn, typename TupleLike >
 constexpr auto invoke ( TupleLike && t, Fn && f ) -> decltype (
    invoke_with_order ( forward < TupleLike > ( t ),
                      forward < Fn > ( f ),
                      camp :: make_idx_seq_t < tuple_size < TupleLike > :: value > { } ) )
{
  return invoke_with_order (
      forward < TupleLike > ( t ),
      forward < Fn > ( f ),
      camp :: make_idx_seq_t < tuple_size < TupleLike > :: value > { } );
}
}
namespace internal
{
template < class Tuple, camp :: idx_t ... Idxs >
void print_tuple ( std :: ostream & os, Tuple const & t, camp :: idx_seq < Idxs ... > )
{
  camp :: sink ( ( void * ) & ( os << ( Idxs == 0 ? "" : ", " ) << camp :: get < Idxs > ( t ) ) ... );
}
}
template < class ... Args >
auto operator << ( std :: ostream & os, camp :: tuple < Args ... > const & t )
    -> std :: ostream &
{
  os << "(";
  internal :: print_tuple ( os, t, camp :: make_idx_seq_t < sizeof ... ( Args ) > { } );
  return os << ")";
}
namespace std
{
template < intmax_t _Pn >
    struct __static_sign
    : integral_constant < intmax_t, ( _Pn < 0 ) ? - 1 : 1 >
    { };
template < intmax_t _Pn >
    struct __static_abs
    : integral_constant < intmax_t, _Pn * __static_sign < _Pn > :: value >
    { };
template < intmax_t _Pn, intmax_t _Qn >
    struct __static_gcd
    : __static_gcd < _Qn, ( _Pn % _Qn ) >
    { };
template < intmax_t _Pn >
    struct __static_gcd < _Pn, 0 >
    : integral_constant < intmax_t, __static_abs < _Pn > :: value >
    { };
template < intmax_t _Qn >
    struct __static_gcd < 0, _Qn >
    : integral_constant < intmax_t, __static_abs < _Qn > :: value >
    { };
template < intmax_t _Pn, intmax_t _Qn >
    struct __safe_multiply
    {
    private :
      static const uintmax_t __c = uintmax_t ( 1 ) << ( sizeof ( intmax_t ) * 4 );
      static const uintmax_t __a0 = __static_abs < _Pn > :: value % __c;
      static const uintmax_t __a1 = __static_abs < _Pn > :: value / __c;
      static const uintmax_t __b0 = __static_abs < _Qn > :: value % __c;
      static const uintmax_t __b1 = __static_abs < _Qn > :: value / __c;
      static_assert ( __a1 == 0 || __b1 == 0,
      "overflow in multiplication" );
      static_assert ( __a0 * __b1 + __b0 * __a1 < ( __c >> 1 ),
      "overflow in multiplication" );
      static_assert ( __b0 * __a0 <= 0x7fffffffffffffffL,
      "overflow in multiplication" );
      static_assert ( ( __a0 * __b1 + __b0 * __a1 ) * __c
      <= 0x7fffffffffffffffL - __b0 * __a0,
      "overflow in multiplication" );
    public :
      static const intmax_t value = _Pn * _Qn;
    };
template < uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2 >
    struct __big_less
    : integral_constant < bool, ( __hi1 < __hi2
          || ( __hi1 == __hi2 && __lo1 < __lo2 ) ) >
    { };
template < uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2 >
    struct __big_add
    {
      static constexpr uintmax_t __lo = __lo1 + __lo2;
      static constexpr uintmax_t __hi = ( __hi1 + __hi2 +
      ( __lo1 + __lo2 < __lo1 ) );
    };
template < uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2 >
    struct __big_sub
    {
      static_assert ( ! __big_less < __hi1, __lo1, __hi2, __lo2 > :: value,
      "Internal library error" );
      static constexpr uintmax_t __lo = __lo1 - __lo2;
      static constexpr uintmax_t __hi = ( __hi1 - __hi2 -
      ( __lo1 < __lo2 ) );
    };
template < uintmax_t __x, uintmax_t __y >
    struct __big_mul
    {
    private :
      static constexpr uintmax_t __c = uintmax_t ( 1 ) << ( sizeof ( intmax_t ) * 4 );
      static constexpr uintmax_t __x0 = __x % __c;
      static constexpr uintmax_t __x1 = __x / __c;
      static constexpr uintmax_t __y0 = __y % __c;
      static constexpr uintmax_t __y1 = __y / __c;
      static constexpr uintmax_t __x0y0 = __x0 * __y0;
      static constexpr uintmax_t __x0y1 = __x0 * __y1;
      static constexpr uintmax_t __x1y0 = __x1 * __y0;
      static constexpr uintmax_t __x1y1 = __x1 * __y1;
      static constexpr uintmax_t __mix = __x0y1 + __x1y0;
      static constexpr uintmax_t __mix_lo = __mix * __c;
      static constexpr uintmax_t __mix_hi
      = __mix / __c + ( ( __mix < __x0y1 ) ? __c : 0 );
      typedef __big_add < __mix_hi, __mix_lo, __x1y1, __x0y0 > _Res;
    public :
      static constexpr uintmax_t __hi = _Res :: __hi;
      static constexpr uintmax_t __lo = _Res :: __lo;
    };
template < uintmax_t __n1, uintmax_t __n0, uintmax_t __d >
    struct __big_div_impl
    {
    private :
      static_assert ( __d >= ( uintmax_t ( 1 ) << ( sizeof ( intmax_t ) * 8 - 1 ) ),
      "Internal library error" );
      static_assert ( __n1 < __d, "Internal library error" );
      static constexpr uintmax_t __c = uintmax_t ( 1 ) << ( sizeof ( intmax_t ) * 4 );
      static constexpr uintmax_t __d1 = __d / __c;
      static constexpr uintmax_t __d0 = __d % __c;
      static constexpr uintmax_t __q1x = __n1 / __d1;
      static constexpr uintmax_t __r1x = __n1 % __d1;
      static constexpr uintmax_t __m = __q1x * __d0;
      static constexpr uintmax_t __r1y = __r1x * __c + __n0 / __c;
      static constexpr uintmax_t __r1z = __r1y + __d;
      static constexpr uintmax_t __r1
      = ( ( __r1y < __m ) ? ( ( __r1z >= __d ) && ( __r1z < __m ) )
  ? ( __r1z + __d ) : __r1z : __r1y ) - __m;
      static constexpr uintmax_t __q1
      = __q1x - ( ( __r1y < __m )
   ? ( ( __r1z >= __d ) && ( __r1z < __m ) ) ? 2 : 1 : 0 );
      static constexpr uintmax_t __q0x = __r1 / __d1;
      static constexpr uintmax_t __r0x = __r1 % __d1;
      static constexpr uintmax_t __n = __q0x * __d0;
      static constexpr uintmax_t __r0y = __r0x * __c + __n0 % __c;
      static constexpr uintmax_t __r0z = __r0y + __d;
      static constexpr uintmax_t __r0
      = ( ( __r0y < __n ) ? ( ( __r0z >= __d ) && ( __r0z < __n ) )
  ? ( __r0z + __d ) : __r0z : __r0y ) - __n;
      static constexpr uintmax_t __q0
      = __q0x - ( ( __r0y < __n ) ? ( ( __r0z >= __d )
      && ( __r0z < __n ) ) ? 2 : 1 : 0 );
    public :
      static constexpr uintmax_t __quot = __q1 * __c + __q0;
      static constexpr uintmax_t __rem = __r0;
    private :
      typedef __big_mul < __quot, __d > _Prod;
      typedef __big_add < _Prod :: __hi, _Prod :: __lo, 0, __rem > _Sum;
      static_assert ( _Sum :: __hi == __n1 && _Sum :: __lo == __n0,
      "Internal library error" );
  };
template < uintmax_t __n1, uintmax_t __n0, uintmax_t __d >
    struct __big_div
    {
    private :
      static_assert ( __d != 0, "Internal library error" );
      static_assert ( sizeof ( uintmax_t ) == sizeof ( unsigned long long ),
      "This library calls __builtin_clzll on uintmax_t, which is unsafe on your platform. Please complain to http://gcc.gnu.org/bugzill" "a/"
                                    );
      static constexpr int __shift = __builtin_clzll ( __d );
      static constexpr int __coshift_ = sizeof ( uintmax_t ) * 8 - __shift;
      static constexpr int __coshift = ( __shift != 0 ) ? __coshift_ : 0;
      static constexpr uintmax_t __c1 = uintmax_t ( 1 ) << __shift;
      static constexpr uintmax_t __c2 = uintmax_t ( 1 ) << __coshift;
      static constexpr uintmax_t __new_d = __d * __c1;
      static constexpr uintmax_t __new_n0 = __n0 * __c1;
      static constexpr uintmax_t __n1_shifted = ( __n1 % __d ) * __c1;
      static constexpr uintmax_t __n0_top = ( __shift != 0 ) ? ( __n0 / __c2 ) : 0;
      static constexpr uintmax_t __new_n1 = __n1_shifted + __n0_top;
      typedef __big_div_impl < __new_n1, __new_n0, __new_d > _Res;
    public :
      static constexpr uintmax_t __quot_hi = __n1 / __d;
      static constexpr uintmax_t __quot_lo = _Res :: __quot;
      static constexpr uintmax_t __rem = _Res :: __rem / __c1;
    private :
      typedef __big_mul < __quot_lo, __d > _P0;
      typedef __big_mul < __quot_hi, __d > _P1;
      typedef __big_add < _P0 :: __hi, _P0 :: __lo, _P1 :: __lo, __rem > _Sum;
      static_assert ( _P1 :: __hi == 0, "Internal library error" );
      static_assert ( _Sum :: __hi >= _P0 :: __hi, "Internal library error" );
      static_assert ( _Sum :: __hi == __n1 && _Sum :: __lo == __n0,
      "Internal library error" );
      static_assert ( __rem < __d, "Internal library error" );
    };
template < intmax_t _Num, intmax_t _Den = 1 >
    struct ratio
    {
      static_assert ( _Den != 0, "denominator cannot be zero" );
      static_assert ( _Num >= - 0x7fffffffffffffffL && _Den >= - 0x7fffffffffffffffL,
      "out of range" );
      static constexpr intmax_t num =
        _Num * __static_sign < _Den > :: value / __static_gcd < _Num, _Den > :: value;
      static constexpr intmax_t den =
        __static_abs < _Den > :: value / __static_gcd < _Num, _Den > :: value;
      typedef ratio < num, den > type;
    };
template < intmax_t _Num, intmax_t _Den >
    constexpr intmax_t ratio < _Num, _Den > :: num;
template < intmax_t _Num, intmax_t _Den >
    constexpr intmax_t ratio < _Num, _Den > :: den;
template < typename _R1, typename _R2 >
    struct __ratio_multiply
    {
    private :
      static const intmax_t __gcd1 =
        __static_gcd < _R1 :: num, _R2 :: den > :: value;
      static const intmax_t __gcd2 =
        __static_gcd < _R2 :: num, _R1 :: den > :: value;
    public :
      typedef ratio <
        __safe_multiply < ( _R1 :: num / __gcd1 ),
                        ( _R2 :: num / __gcd2 ) > :: value,
        __safe_multiply < ( _R1 :: den / __gcd2 ),
                        ( _R2 :: den / __gcd1 ) > :: value > type;
      static constexpr intmax_t num = type :: num;
      static constexpr intmax_t den = type :: den;
    };
template < typename _R1, typename _R2 >
    constexpr intmax_t __ratio_multiply < _R1, _R2 > :: num;
template < typename _R1, typename _R2 >
    constexpr intmax_t __ratio_multiply < _R1, _R2 > :: den;
template < typename _R1, typename _R2 >
    using ratio_multiply = typename __ratio_multiply < _R1, _R2 > :: type;
template < typename _R1, typename _R2 >
    struct __ratio_divide
    {
      static_assert ( _R2 :: num != 0, "division by 0" );
      typedef typename __ratio_multiply <
        _R1,
        ratio < _R2 :: den, _R2 :: num >> :: type type;
      static constexpr intmax_t num = type :: num;
      static constexpr intmax_t den = type :: den;
    };
template < typename _R1, typename _R2 >
    constexpr intmax_t __ratio_divide < _R1, _R2 > :: num;
template < typename _R1, typename _R2 >
    constexpr intmax_t __ratio_divide < _R1, _R2 > :: den;
template < typename _R1, typename _R2 >
    using ratio_divide = typename __ratio_divide < _R1, _R2 > :: type;
template < typename _R1, typename _R2 >
    struct ratio_equal
    : integral_constant < bool, _R1 :: num == _R2 :: num && _R1 :: den == _R2 :: den >
    { };
template < typename _R1, typename _R2 >
    struct ratio_not_equal
    : integral_constant < bool, ! ratio_equal < _R1, _R2 > :: value >
    { };
template < typename _R1, typename _R2,
           typename _Left = __big_mul < _R1 :: num, _R2 :: den >,
           typename _Right = __big_mul < _R2 :: num, _R1 :: den > >
    struct __ratio_less_impl_1
    : integral_constant < bool, __big_less < _Left :: __hi, _Left :: __lo,
           _Right :: __hi, _Right :: __lo > :: value >
    { };
template < typename _R1, typename _R2,
    bool = ( _R1 :: num == 0 || _R2 :: num == 0
     || ( __static_sign < _R1 :: num > :: value
         != __static_sign < _R2 :: num > :: value ) ),
    bool = ( __static_sign < _R1 :: num > :: value == - 1
     && __static_sign < _R2 :: num > :: value == - 1 ) >
    struct __ratio_less_impl
    : __ratio_less_impl_1 < _R1, _R2 > :: type
    { };
template < typename _R1, typename _R2 >
    struct __ratio_less_impl < _R1, _R2, true, false >
    : integral_constant < bool, _R1 :: num < _R2 :: num >
    { };
template < typename _R1, typename _R2 >
    struct __ratio_less_impl < _R1, _R2, false, true >
    : __ratio_less_impl_1 < ratio < - _R2 :: num, _R2 :: den >,
           ratio < - _R1 :: num, _R1 :: den > > :: type
    { };
template < typename _R1, typename _R2 >
    struct ratio_less
    : __ratio_less_impl < _R1, _R2 > :: type
    { };
template < typename _R1, typename _R2 >
    struct ratio_less_equal
    : integral_constant < bool, ! ratio_less < _R2, _R1 > :: value >
    { };
template < typename _R1, typename _R2 >
    struct ratio_greater
    : integral_constant < bool, ratio_less < _R2, _R1 > :: value >
    { };
template < typename _R1, typename _R2 >
    struct ratio_greater_equal
    : integral_constant < bool, ! ratio_less < _R1, _R2 > :: value >
    { };
template < typename _R1, typename _R2,
      bool = ( _R1 :: num >= 0 ),
      bool = ( _R2 :: num >= 0 ),
      bool = ratio_less < ratio < __static_abs < _R1 :: num > :: value, _R1 :: den >,
        ratio < __static_abs < _R2 :: num > :: value, _R2 :: den > > :: value >
    struct __ratio_add_impl
    {
    private :
      typedef typename __ratio_add_impl <
        ratio < - _R1 :: num, _R1 :: den >,
        ratio < - _R2 :: num, _R2 :: den > > :: type __t;
    public :
      typedef ratio < - __t :: num, __t :: den > type;
    };
template < typename _R1, typename _R2, bool __b >
    struct __ratio_add_impl < _R1, _R2, true, true, __b >
    {
    private :
      static constexpr uintmax_t __g = __static_gcd < _R1 :: den, _R2 :: den > :: value;
      static constexpr uintmax_t __d2 = _R2 :: den / __g;
      typedef __big_mul < _R1 :: den, __d2 > __d;
      typedef __big_mul < _R1 :: num, _R2 :: den / __g > __x;
      typedef __big_mul < _R2 :: num, _R1 :: den / __g > __y;
      typedef __big_add < __x :: __hi, __x :: __lo, __y :: __hi, __y :: __lo > __n;
      static_assert ( __n :: __hi >= __x :: __hi, "Internal library error" );
      typedef __big_div < __n :: __hi, __n :: __lo, __g > __ng;
      static constexpr uintmax_t __g2 = __static_gcd < __ng :: __rem, __g > :: value;
      typedef __big_div < __n :: __hi, __n :: __lo, __g2 > __n_final;
      static_assert ( __n_final :: __rem == 0, "Internal library error" );
      static_assert ( __n_final :: __quot_hi == 0 &&
        __n_final :: __quot_lo <= 0x7fffffffffffffffL, "overflow in addition" );
      typedef __big_mul < _R1 :: den / __g2, __d2 > __d_final;
      static_assert ( __d_final :: __hi == 0 &&
        __d_final :: __lo <= 0x7fffffffffffffffL, "overflow in addition" );
    public :
      typedef ratio < __n_final :: __quot_lo, __d_final :: __lo > type;
    };
template < typename _R1, typename _R2 >
    struct __ratio_add_impl < _R1, _R2, false, true, true >
    : __ratio_add_impl < _R2, _R1 >
    { };
template < typename _R1, typename _R2 >
    struct __ratio_add_impl < _R1, _R2, true, false, false >
    {
    private :
      static constexpr uintmax_t __g = __static_gcd < _R1 :: den, _R2 :: den > :: value;
      static constexpr uintmax_t __d2 = _R2 :: den / __g;
      typedef __big_mul < _R1 :: den, __d2 > __d;
      typedef __big_mul < _R1 :: num, _R2 :: den / __g > __x;
      typedef __big_mul < - _R2 :: num, _R1 :: den / __g > __y;
      typedef __big_sub < __x :: __hi, __x :: __lo, __y :: __hi, __y :: __lo > __n;
      typedef __big_div < __n :: __hi, __n :: __lo, __g > __ng;
      static constexpr uintmax_t __g2 = __static_gcd < __ng :: __rem, __g > :: value;
      typedef __big_div < __n :: __hi, __n :: __lo, __g2 > __n_final;
      static_assert ( __n_final :: __rem == 0, "Internal library error" );
      static_assert ( __n_final :: __quot_hi == 0 &&
        __n_final :: __quot_lo <= 0x7fffffffffffffffL, "overflow in addition" );
      typedef __big_mul < _R1 :: den / __g2, __d2 > __d_final;
      static_assert ( __d_final :: __hi == 0 &&
        __d_final :: __lo <= 0x7fffffffffffffffL, "overflow in addition" );
    public :
      typedef ratio < __n_final :: __quot_lo, __d_final :: __lo > type;
    };
template < typename _R1, typename _R2 >
    struct __ratio_add
    {
      typedef typename __ratio_add_impl < _R1, _R2 > :: type type;
      static constexpr intmax_t num = type :: num;
      static constexpr intmax_t den = type :: den;
    };
template < typename _R1, typename _R2 >
    constexpr intmax_t __ratio_add < _R1, _R2 > :: num;
template < typename _R1, typename _R2 >
    constexpr intmax_t __ratio_add < _R1, _R2 > :: den;
template < typename _R1, typename _R2 >
    using ratio_add = typename __ratio_add < _R1, _R2 > :: type;
template < typename _R1, typename _R2 >
    struct __ratio_subtract
    {
      typedef typename __ratio_add <
        _R1,
        ratio < - _R2 :: num, _R2 :: den >> :: type type;
      static constexpr intmax_t num = type :: num;
      static constexpr intmax_t den = type :: den;
    };
template < typename _R1, typename _R2 >
    constexpr intmax_t __ratio_subtract < _R1, _R2 > :: num;
template < typename _R1, typename _R2 >
    constexpr intmax_t __ratio_subtract < _R1, _R2 > :: den;
template < typename _R1, typename _R2 >
    using ratio_subtract = typename __ratio_subtract < _R1, _R2 > :: type;
typedef struct ratio< 1L , 1000000000000000000 > atto;
typedef struct ratio< 1L , 1000000000000000 > femto;
typedef struct ratio< 1L , 1000000000000 > pico;
typedef struct ratio< 1L , 1000000000 > nano;
typedef struct ratio< 1L , 1000000 > micro;
typedef struct ratio< 1L , 1000 > milli;
typedef struct ratio< 1L , 100 > centi;
typedef struct ratio< 1L , 10 > deci;
typedef struct ratio< 10 , 1L > deca;
typedef struct ratio< 100 , 1L > hecto;
typedef struct ratio< 1000 , 1L > kilo;
typedef struct ratio< 1000000 , 1L > mega;
typedef struct ratio< 1000000000 , 1L > giga;
typedef struct ratio< 1000000000000 , 1L > tera;
typedef struct ratio< 1000000000000000 , 1L > peta;
typedef struct ratio< 1000000000000000000 , 1L > exa;
}
namespace std
{
enum float_round_style {round_indeterminate=-1,round_toward_zero=0,round_to_nearest=1,round_toward_infinity=2,round_toward_neg_infinity=3} ;
enum float_denorm_style {denorm_indeterminate=-1,denorm_absent=0,denorm_present=1} ;

struct __numeric_limits_base 
{
constexpr static bool is_specialized = false;
constexpr static int digits = 0;
constexpr static int digits10 = 0;
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = false;
constexpr static bool is_integer = false;
constexpr static bool is_exact = false;
constexpr static int radix = 0;
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = false;
constexpr static bool is_modulo = false;
constexpr static bool traps = false;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
}
;
template < typename _Tp >
    struct numeric_limits : public __numeric_limits_base
    {
      static constexpr _Tp
      min ( ) noexcept;
      static constexpr _Tp
      max ( ) noexcept;
      static constexpr _Tp
      lowest ( ) noexcept;
      static constexpr _Tp
      epsilon ( ) noexcept;
      static constexpr _Tp
      round_error ( ) noexcept;
      static constexpr _Tp
      infinity ( ) noexcept;
      static constexpr _Tp
      quiet_NaN ( ) noexcept;
      static constexpr _Tp
      signaling_NaN ( ) noexcept;
      static constexpr _Tp
      denorm_min ( ) noexcept;
    };
template < typename _Tp >
    struct numeric_limits < const _Tp >
    : public numeric_limits < _Tp > { };
template < typename _Tp >
    struct numeric_limits < volatile _Tp >
    : public numeric_limits < _Tp > { };
template < typename _Tp >
    struct numeric_limits < const volatile _Tp >
    : public numeric_limits < _Tp > { };
template<> struct numeric_limits< bool  > 
{
constexpr static bool is_specialized = true;

constexpr inline static bool min()
{
return false;
}

constexpr inline static bool max()
{
return true;
}

constexpr inline static bool lowest()
{
return min();
}
constexpr static int digits = 1;
constexpr static int digits10 = 0;
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = false;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static bool epsilon()
{
return false;
}

constexpr inline static bool round_error()
{
return false;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static bool infinity()
{
return false;
}

constexpr inline static bool quiet_NaN()
{
return false;
}

constexpr inline static bool signaling_NaN()
{
return false;
}

constexpr inline static bool denorm_min()
{
return false;
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = false;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< char  > 
{
constexpr static bool is_specialized = true;

constexpr inline static char min()
{
return (((char )(- 1)) < 0?-((((char )(- 1)) < 0?((((char )1) << sizeof(char ) * 8 - (((char )(- 1)) < 0) - 1) - 1 << 1) + 1 : ~((char )0))) - 1 : ((char )0));
}

constexpr inline static char max()
{
return (((char )(- 1)) < 0?((((char )1) << sizeof(char ) * 8 - (((char )(- 1)) < 0) - 1) - 1 << 1) + 1 : ~((char )0));
}

constexpr inline static char lowest()
{
return min();
}
constexpr static int digits = (sizeof(char ) * 8 - (((char )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(char ) * 8 - (((char )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = ((char )(- 1)) < 0;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static char epsilon()
{
return 0;
}

constexpr inline static char round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static char infinity()
{
return char ();
}

constexpr inline static char quiet_NaN()
{
return char ();
}

constexpr inline static char signaling_NaN()
{
return char ();
}

constexpr inline static char denorm_min()
{
return static_cast < char  >  (0);
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = !is_signed;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< signed char  > 
{
constexpr static bool is_specialized = true;

constexpr inline static signed char min()
{
return (- 0x7f - 1);
}

constexpr inline static signed char max()
{
return 0x7f;
}

constexpr inline static signed char lowest()
{
return min();
}
constexpr static int digits = (sizeof(signed char ) * 8 - (((signed char )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(signed char ) * 8 - (((signed char )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = true;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static signed char epsilon()
{
return 0;
}

constexpr inline static signed char round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static signed char infinity()
{
return static_cast < signed char  >  (0);
}

constexpr inline static signed char quiet_NaN()
{
return static_cast < signed char  >  (0);
}

constexpr inline static signed char signaling_NaN()
{
return static_cast < signed char  >  (0);
}

constexpr inline static signed char denorm_min()
{
return static_cast < signed char  >  (0);
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = false;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< unsigned char  > 
{
constexpr static bool is_specialized = true;

constexpr inline static unsigned char min()
{
return 0;
}

constexpr inline static unsigned char max()
{
return (0x7f * 2U + 1);
}

constexpr inline static unsigned char lowest()
{
return min();
}
constexpr static int digits = (sizeof(unsigned char ) * 8 - (((unsigned char )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(unsigned char ) * 8 - (((unsigned char )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = false;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static unsigned char epsilon()
{
return 0;
}

constexpr inline static unsigned char round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static unsigned char infinity()
{
return static_cast < unsigned char  >  (0);
}

constexpr inline static unsigned char quiet_NaN()
{
return static_cast < unsigned char  >  (0);
}

constexpr inline static unsigned char signaling_NaN()
{
return static_cast < unsigned char  >  (0);
}

constexpr inline static unsigned char denorm_min()
{
return static_cast < unsigned char  >  (0);
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = true;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< wchar_t  > 
{
constexpr static bool is_specialized = true;

constexpr inline static wchar_t min()
{
return (((wchar_t )(- 1)) < 0?-((((wchar_t )(- 1)) < 0?((((wchar_t )1) << sizeof(wchar_t ) * 8 - (((wchar_t )(- 1)) < 0) - 1) - 1 << 1) + 1 : ~((wchar_t )0))) - 1 : ((wchar_t )0));
}

constexpr inline static wchar_t max()
{
return (((wchar_t )(- 1)) < 0?((((wchar_t )1) << sizeof(wchar_t ) * 8 - (((wchar_t )(- 1)) < 0) - 1) - 1 << 1) + 1 : ~((wchar_t )0));
}

constexpr inline static wchar_t lowest()
{
return min();
}
constexpr static int digits = (sizeof(wchar_t ) * 8 - (((wchar_t )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(wchar_t ) * 8 - (((wchar_t )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = ((wchar_t )(- 1)) < 0;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static wchar_t epsilon()
{
return 0;
}

constexpr inline static wchar_t round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static wchar_t infinity()
{
return wchar_t ();
}

constexpr inline static wchar_t quiet_NaN()
{
return wchar_t ();
}

constexpr inline static wchar_t signaling_NaN()
{
return wchar_t ();
}

constexpr inline static wchar_t denorm_min()
{
return wchar_t ();
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = !is_signed;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< char16_t  > 
{
constexpr static bool is_specialized = true;

constexpr inline static char16_t min()
{
return (((char16_t )(- 1)) < 0?-((((char16_t )(- 1)) < 0?((((char16_t )1) << sizeof(char16_t ) * 8 - (((char16_t )(- 1)) < 0) - 1) - 1 << 1) + 1 : ~((char16_t )0))) - 1 : ((char16_t )0));
}

constexpr inline static char16_t max()
{
return (((char16_t )(- 1)) < 0?((((char16_t )1) << sizeof(char16_t ) * 8 - (((char16_t )(- 1)) < 0) - 1) - 1 << 1) + 1 : ~((char16_t )0));
}

constexpr inline static char16_t lowest()
{
return min();
}
constexpr static int digits = (sizeof(char16_t ) * 8 - (((char16_t )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(char16_t ) * 8 - (((char16_t )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = ((char16_t )(- 1)) < 0;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static char16_t epsilon()
{
return 0;
}

constexpr inline static char16_t round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static char16_t infinity()
{
return char16_t ();
}

constexpr inline static char16_t quiet_NaN()
{
return char16_t ();
}

constexpr inline static char16_t signaling_NaN()
{
return char16_t ();
}

constexpr inline static char16_t denorm_min()
{
return char16_t ();
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = !is_signed;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< char32_t  > 
{
constexpr static bool is_specialized = true;

constexpr inline static char32_t min()
{
return (((char32_t )(- 1)) < 0?-((((char32_t )(- 1)) < 0?((((char32_t )1) << sizeof(char32_t ) * 8 - (((char32_t )(- 1)) < 0) - 1) - 1 << 1) + 1 : ~((char32_t )0))) - 1 : ((char32_t )0));
}

constexpr inline static char32_t max()
{
return (((char32_t )(- 1)) < 0?((((char32_t )1) << sizeof(char32_t ) * 8 - (((char32_t )(- 1)) < 0) - 1) - 1 << 1) + 1 : ~((char32_t )0));
}

constexpr inline static char32_t lowest()
{
return min();
}
constexpr static int digits = (sizeof(char32_t ) * 8 - (((char32_t )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(char32_t ) * 8 - (((char32_t )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = ((char32_t )(- 1)) < 0;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static char32_t epsilon()
{
return 0;
}

constexpr inline static char32_t round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static char32_t infinity()
{
return char32_t ();
}

constexpr inline static char32_t quiet_NaN()
{
return char32_t ();
}

constexpr inline static char32_t signaling_NaN()
{
return char32_t ();
}

constexpr inline static char32_t denorm_min()
{
return char32_t ();
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = !is_signed;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< short  > 
{
constexpr static bool is_specialized = true;

constexpr inline static short min()
{
return (- 0x7fff - 1);
}

constexpr inline static short max()
{
return 0x7fff;
}

constexpr inline static short lowest()
{
return min();
}
constexpr static int digits = (sizeof(short ) * 8 - (((short )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(short ) * 8 - (((short )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = true;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static short epsilon()
{
return 0;
}

constexpr inline static short round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static short infinity()
{
return short ();
}

constexpr inline static short quiet_NaN()
{
return short ();
}

constexpr inline static short signaling_NaN()
{
return short ();
}

constexpr inline static short denorm_min()
{
return short ();
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = false;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< unsigned short  > 
{
constexpr static bool is_specialized = true;

constexpr inline static unsigned short min()
{
return 0;
}

constexpr inline static unsigned short max()
{
return (0x7fff * 2U + 1);
}

constexpr inline static unsigned short lowest()
{
return min();
}
constexpr static int digits = (sizeof(unsigned short ) * 8 - (((unsigned short )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(unsigned short ) * 8 - (((unsigned short )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = false;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static unsigned short epsilon()
{
return 0;
}

constexpr inline static unsigned short round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static unsigned short infinity()
{
return static_cast < unsigned short  >  (0);
}

constexpr inline static unsigned short quiet_NaN()
{
return static_cast < unsigned short  >  (0);
}

constexpr inline static unsigned short signaling_NaN()
{
return static_cast < unsigned short  >  (0);
}

constexpr inline static unsigned short denorm_min()
{
return static_cast < unsigned short  >  (0);
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = true;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< int  > 
{
constexpr static bool is_specialized = true;

constexpr inline static int min()
{
return - 0x7fffffff - 1;
}

constexpr inline static int max()
{
return 0x7fffffff;
}

constexpr inline static int lowest()
{
return min();
}
constexpr static int digits = (sizeof(int ) * 8 - (((int )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(int ) * 8 - (((int )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = true;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static int epsilon()
{
return 0;
}

constexpr inline static int round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static int infinity()
{
return static_cast < int  >  (0);
}

constexpr inline static int quiet_NaN()
{
return static_cast < int  >  (0);
}

constexpr inline static int signaling_NaN()
{
return static_cast < int  >  (0);
}

constexpr inline static int denorm_min()
{
return static_cast < int  >  (0);
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = false;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< unsigned int  > 
{
constexpr static bool is_specialized = true;

constexpr inline static unsigned int min()
{
return 0;
}

constexpr inline static unsigned int max()
{
return 0x7fffffff * 2U + 1;
}

constexpr inline static unsigned int lowest()
{
return min();
}
constexpr static int digits = (sizeof(unsigned int ) * 8 - (((unsigned int )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(unsigned int ) * 8 - (((unsigned int )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = false;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static unsigned int epsilon()
{
return 0;
}

constexpr inline static unsigned int round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static unsigned int infinity()
{
return static_cast < unsigned int  >  (0);
}

constexpr inline static unsigned int quiet_NaN()
{
return static_cast < unsigned int  >  (0);
}

constexpr inline static unsigned int signaling_NaN()
{
return static_cast < unsigned int  >  (0);
}

constexpr inline static unsigned int denorm_min()
{
return static_cast < unsigned int  >  (0);
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = true;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< long  > 
{
constexpr static bool is_specialized = true;

constexpr inline static long min()
{
return - 0x7fffffffffffffffL - 1;
}

constexpr inline static long max()
{
return 0x7fffffffffffffffL;
}

constexpr inline static long lowest()
{
return min();
}
constexpr static int digits = (sizeof(long ) * 8 - (((long )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(long ) * 8 - (((long )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = true;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static long epsilon()
{
return 0;
}

constexpr inline static long round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static long infinity()
{
return static_cast < long  >  (0);
}

constexpr inline static long quiet_NaN()
{
return static_cast < long  >  (0);
}

constexpr inline static long signaling_NaN()
{
return static_cast < long  >  (0);
}

constexpr inline static long denorm_min()
{
return static_cast < long  >  (0);
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = false;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< unsigned long  > 
{
constexpr static bool is_specialized = true;

constexpr inline static unsigned long min()
{
return 0;
}

constexpr inline static unsigned long max()
{
return 0x7fffffffffffffffL * 2UL + 1;
}

constexpr inline static unsigned long lowest()
{
return min();
}
constexpr static int digits = (sizeof(unsigned long ) * 8 - (((unsigned long )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(unsigned long ) * 8 - (((unsigned long )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = false;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static unsigned long epsilon()
{
return 0;
}

constexpr inline static unsigned long round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static unsigned long infinity()
{
return static_cast < unsigned long  >  (0);
}

constexpr inline static unsigned long quiet_NaN()
{
return static_cast < unsigned long  >  (0);
}

constexpr inline static unsigned long signaling_NaN()
{
return static_cast < unsigned long  >  (0);
}

constexpr inline static unsigned long denorm_min()
{
return static_cast < unsigned long  >  (0);
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = true;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< long long  > 
{
constexpr static bool is_specialized = true;

constexpr inline static long long min()
{
return - 0x7fffffffffffffffLL - 1;
}

constexpr inline static long long max()
{
return 0x7fffffffffffffffLL;
}

constexpr inline static long long lowest()
{
return min();
}
constexpr static int digits = (sizeof(long long ) * 8 - (((long long )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(long long ) * 8 - (((long long )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = true;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static long long epsilon()
{
return 0;
}

constexpr inline static long long round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static long long infinity()
{
return static_cast < long long  >  (0);
}

constexpr inline static long long quiet_NaN()
{
return static_cast < long long  >  (0);
}

constexpr inline static long long signaling_NaN()
{
return static_cast < long long  >  (0);
}

constexpr inline static long long denorm_min()
{
return static_cast < long long  >  (0);
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = false;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< unsigned long long  > 
{
constexpr static bool is_specialized = true;

constexpr inline static unsigned long long min()
{
return 0;
}

constexpr inline static unsigned long long max()
{
return 0x7fffffffffffffffLL * 2ULL + 1;
}

constexpr inline static unsigned long long lowest()
{
return min();
}
constexpr static int digits = (sizeof(unsigned long long ) * 8 - (((unsigned long long )(- 1)) < 0));
constexpr static int digits10 = ((sizeof(unsigned long long ) * 8 - (((unsigned long long )(- 1)) < 0)) * 643L / 2136);
constexpr static int max_digits10 = 0;
constexpr static bool is_signed = false;
constexpr static bool is_integer = true;
constexpr static bool is_exact = true;
constexpr static int radix = 2;

constexpr inline static unsigned long long epsilon()
{
return 0;
}

constexpr inline static unsigned long long round_error()
{
return 0;
}
constexpr static int min_exponent = 0;
constexpr static int min_exponent10 = 0;
constexpr static int max_exponent = 0;
constexpr static int max_exponent10 = 0;
constexpr static bool has_infinity = false;
constexpr static bool has_quiet_NaN = false;
constexpr static bool has_signaling_NaN = false;
constexpr static enum float_denorm_style has_denorm = denorm_absent;
constexpr static bool has_denorm_loss = false;

constexpr inline static unsigned long long infinity()
{
return static_cast < unsigned long long  >  (0);
}

constexpr inline static unsigned long long quiet_NaN()
{
return static_cast < unsigned long long  >  (0);
}

constexpr inline static unsigned long long signaling_NaN()
{
return static_cast < unsigned long long  >  (0);
}

constexpr inline static unsigned long long denorm_min()
{
return static_cast < unsigned long long  >  (0);
}
constexpr static bool is_iec559 = false;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = true;
constexpr static bool traps = true;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_toward_zero;
};
template<> struct numeric_limits< float  > ;
template<> struct numeric_limits< float  > 
{
constexpr static bool is_specialized = true;

constexpr inline static float min()
{
return 1.17549435082228750797e-38F;
}

constexpr inline static float max()
{
return 3.40282346638528859812e+38F;
}

constexpr inline static float lowest()
{
return - 3.40282346638528859812e+38F;
}
constexpr static int digits = 24;
constexpr static int digits10 = 6;
constexpr static int max_digits10 = (2 + 24 * 643L / 2136);
constexpr static bool is_signed = true;
constexpr static bool is_integer = false;
constexpr static bool is_exact = false;
constexpr static int radix = 2;

constexpr inline static float epsilon()
{
return 1.19209289550781250000e-7F;
}

constexpr inline static float round_error()
{
return 0.5F;
}
constexpr static int min_exponent = - 125;
constexpr static int min_exponent10 = - 37;
constexpr static int max_exponent = 128;
constexpr static int max_exponent10 = 38;
constexpr static bool has_infinity = 1;
constexpr static bool has_quiet_NaN = 1;
constexpr static bool has_signaling_NaN = has_quiet_NaN;
constexpr static enum float_denorm_style has_denorm = denorm_present;
constexpr static bool has_denorm_loss = false;

constexpr inline static float infinity()
{
return __builtin_huge_valf();
}

constexpr inline static float quiet_NaN()
{
return __builtin_nanf("");
}

constexpr inline static float signaling_NaN()
{
return __builtin_nansf("");
}

constexpr inline static float denorm_min()
{
return 1.40129846432481707092e-45F;
}
constexpr static bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = false;
constexpr static bool traps = false;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_to_nearest;
};
template<> struct numeric_limits< double  > 
{
constexpr static bool is_specialized = true;

constexpr inline static double min()
{
return (double )2.22507385850720138309e-308L;
}

constexpr inline static double max()
{
return (double )1.79769313486231570815e+308L;
}

constexpr inline static double lowest()
{
return -((double )1.79769313486231570815e+308L);
}
constexpr static int digits = 53;
constexpr static int digits10 = 15;
constexpr static int max_digits10 = (2 + 53 * 643L / 2136);
constexpr static bool is_signed = true;
constexpr static bool is_integer = false;
constexpr static bool is_exact = false;
constexpr static int radix = 2;

constexpr inline static double epsilon()
{
return (double )2.22044604925031308085e-16L;
}

constexpr inline static double round_error()
{
return 0.5;
}
constexpr static int min_exponent = - 1021;
constexpr static int min_exponent10 = - 307;
constexpr static int max_exponent = 1024;
constexpr static int max_exponent10 = 308;
constexpr static bool has_infinity = 1;
constexpr static bool has_quiet_NaN = 1;
constexpr static bool has_signaling_NaN = has_quiet_NaN;
constexpr static enum float_denorm_style has_denorm = denorm_present;
constexpr static bool has_denorm_loss = false;

constexpr inline static double infinity()
{
return __builtin_huge_val();
}

constexpr inline static double quiet_NaN()
{
return __builtin_nan("");
}

constexpr inline static double signaling_NaN()
{
return __builtin_nans("");
}

constexpr inline static double denorm_min()
{
return (double )4.94065645841246544177e-324L;
}
constexpr static bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = false;
constexpr static bool traps = false;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_to_nearest;
};
template<> struct numeric_limits< long double  > 
{
constexpr static bool is_specialized = true;

constexpr inline static long double min()
{
return 3.36210314311209350626e-4932L;
}

constexpr inline static long double max()
{
return 1.18973149535723176502e+4932L;
}

constexpr inline static long double lowest()
{
return - 1.18973149535723176502e+4932L;
}
constexpr static int digits = 64;
constexpr static int digits10 = 18;
constexpr static int max_digits10 = (2 + 64 * 643L / 2136);
constexpr static bool is_signed = true;
constexpr static bool is_integer = false;
constexpr static bool is_exact = false;
constexpr static int radix = 2;

constexpr inline static long double epsilon()
{
return 1.08420217248550443401e-19L;
}

constexpr inline static long double round_error()
{
return 0.5L;
}
constexpr static int min_exponent = - 16381;
constexpr static int min_exponent10 = - 4931;
constexpr static int max_exponent = 16384;
constexpr static int max_exponent10 = 4932;
constexpr static bool has_infinity = 1;
constexpr static bool has_quiet_NaN = 1;
constexpr static bool has_signaling_NaN = has_quiet_NaN;
constexpr static enum float_denorm_style has_denorm = denorm_present;
constexpr static bool has_denorm_loss = false;

constexpr inline static long double infinity()
{
return __builtin_huge_vall();
}

constexpr inline static long double quiet_NaN()
{
return __builtin_nanl("");
}

constexpr inline static long double signaling_NaN()
{
return __builtin_nansl("");
}

constexpr inline static long double denorm_min()
{
return 3.64519953188247460253e-4951L;
}
constexpr static bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
constexpr static bool is_bounded = true;
constexpr static bool is_modulo = false;
constexpr static bool traps = false;
constexpr static bool tinyness_before = false;
constexpr static enum float_round_style round_style = round_to_nearest;
};
}
namespace std
{
using ::clock_t;
using ::time_t;
using ::tm;
using ::clock;
using ::difftime;
using ::mktime;
using ::time;
using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;
using ::strftime;
}
namespace std
{
namespace __parse_int
{
template < unsigned _Base, char _Dig >
    struct _Digit;
template < unsigned _Base >
    struct _Digit < _Base, '0' > : integral_constant < unsigned, 0 >
    {
      using __valid = true_type;
    };
template < unsigned _Base >
    struct _Digit < _Base, '1' > : integral_constant < unsigned, 1 >
    {
      using __valid = true_type;
    };
template < unsigned _Base, unsigned _Val >
    struct _Digit_impl : integral_constant < unsigned, _Val >
    {
      static_assert ( _Base > _Val, "invalid digit" );
      using __valid = true_type;
    };
template < unsigned _Base >
    struct _Digit < _Base, '2' > : _Digit_impl < _Base, 2 >
    { };
template < unsigned _Base >
    struct _Digit < _Base, '3' > : _Digit_impl < _Base, 3 >
    { };
template < unsigned _Base >
    struct _Digit < _Base, '4' > : _Digit_impl < _Base, 4 >
    { };
template < unsigned _Base >
    struct _Digit < _Base, '5' > : _Digit_impl < _Base, 5 >
    { };
template < unsigned _Base >
    struct _Digit < _Base, '6' > : _Digit_impl < _Base, 6 >
    { };
template < unsigned _Base >
    struct _Digit < _Base, '7' > : _Digit_impl < _Base, 7 >
    { };
template < unsigned _Base >
    struct _Digit < _Base, '8' > : _Digit_impl < _Base, 8 >
    { };
template < unsigned _Base >
    struct _Digit < _Base, '9' > : _Digit_impl < _Base, 9 >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'a' > : _Digit_impl < _Base, 0xa >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'A' > : _Digit_impl < _Base, 0xa >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'b' > : _Digit_impl < _Base, 0xb >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'B' > : _Digit_impl < _Base, 0xb >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'c' > : _Digit_impl < _Base, 0xc >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'C' > : _Digit_impl < _Base, 0xc >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'd' > : _Digit_impl < _Base, 0xd >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'D' > : _Digit_impl < _Base, 0xd >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'e' > : _Digit_impl < _Base, 0xe >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'E' > : _Digit_impl < _Base, 0xe >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'f' > : _Digit_impl < _Base, 0xf >
    { };
template < unsigned _Base >
    struct _Digit < _Base, 'F' > : _Digit_impl < _Base, 0xf >
    { };
template < unsigned _Base >
    struct _Digit < _Base, '\'' > : integral_constant < unsigned, 0 >
    {
      using __valid = false_type;
    };
template < unsigned long long _Val >
    using __ull_constant = integral_constant < unsigned long long, _Val >;
template < unsigned _Base, char _Dig, char ... _Digs >
    struct _Power_help
    {
      using __next = typename _Power_help < _Base, _Digs ... > :: type;
      using __valid_digit = typename _Digit < _Base, _Dig > :: __valid;
      using type
 = __ull_constant < __next :: value * ( __valid_digit { } ? _Base : 1ULL ) >;
    };
template < unsigned _Base, char _Dig >
    struct _Power_help < _Base, _Dig >
    {
      using __valid_digit = typename _Digit < _Base, _Dig > :: __valid;
      using type = __ull_constant < __valid_digit :: value >;
    };
template < unsigned _Base, char ... _Digs >
    struct _Power : _Power_help < _Base, _Digs ... > :: type
    { };
template < unsigned _Base >
    struct _Power < _Base > : __ull_constant < 0 >
    { };
template < unsigned _Base, unsigned long long _Pow, char _Dig, char ... _Digs >
    struct _Number_help
    {
      using __digit = _Digit < _Base, _Dig >;
      using __valid_digit = typename __digit :: __valid;
      using __next = _Number_help < _Base,
      __valid_digit :: value ? _Pow / _Base : _Pow,
      _Digs ... >;
      using type = __ull_constant < _Pow * __digit :: value + __next :: type :: value >;
      static_assert ( ( type :: value / _Pow ) == __digit :: value,
      "integer literal does not fit in unsigned long long" );
    };
template < unsigned _Base, unsigned long long _Pow, char _Dig >
    struct _Number_help < _Base, _Pow, _Dig >
    {
      using type = __ull_constant < _Digit < _Base, _Dig > :: value >;
    };
template < unsigned _Base, char ... _Digs >
    struct _Number
    : _Number_help < _Base, _Power < _Base, _Digs ... > :: value, _Digs ... > :: type
    { };
template < unsigned _Base >
    struct _Number < _Base >
    : __ull_constant < 0 >
    { };
template < char ... _Digs >
    struct _Parse_int;
template < char ... _Digs >
    struct _Parse_int < '0', 'b', _Digs ... >
    : _Number < 2U, _Digs ... > :: type
    { };
template < char ... _Digs >
    struct _Parse_int < '0', 'B', _Digs ... >
    : _Number < 2U, _Digs ... > :: type
    { };
template < char ... _Digs >
    struct _Parse_int < '0', 'x', _Digs ... >
    : _Number < 16U, _Digs ... > :: type
    { };
template < char ... _Digs >
    struct _Parse_int < '0', 'X', _Digs ... >
    : _Number < 16U, _Digs ... > :: type
    { };
template < char ... _Digs >
    struct _Parse_int < '0', _Digs ... >
    : _Number < 8U, _Digs ... > :: type
    { };
template < char ... _Digs >
    struct _Parse_int
    : _Number < 10U, _Digs ... > :: type
    { };
}
namespace __select_int
{
template < unsigned long long _Val, typename ... _Ints >
    struct _Select_int_base;
template < unsigned long long _Val, typename _IntType, typename ... _Ints >
    struct _Select_int_base < _Val, _IntType, _Ints ... >
    : conditional_t < ( _Val <= std :: numeric_limits < _IntType > :: max ( ) ),
      integral_constant < _IntType, _Val >,
      _Select_int_base < _Val, _Ints ... >>
    { };
template < unsigned long long _Val >
    struct _Select_int_base < _Val >
    { };
template < char ... _Digs >
    using _Select_int = typename _Select_int_base <
 __parse_int :: _Parse_int < _Digs ... > :: value,
 unsigned char,
 unsigned short,
 unsigned int,
 unsigned long,
 unsigned long long
      > :: type;
}
}
namespace std
{
namespace chrono
{
template < typename _Rep, typename _Period = ratio < 1 > >
      struct duration;
template < typename _Clock, typename _Dur = typename _Clock :: duration >
      struct time_point;
}
template < typename _CT, typename _Period1, typename _Period2 >
    struct __duration_common_type_wrapper
    {
    private :
      typedef __static_gcd < _Period1 :: num, _Period2 :: num > __gcd_num;
      typedef __static_gcd < _Period1 :: den, _Period2 :: den > __gcd_den;
      typedef typename _CT :: type __cr;
      typedef ratio < __gcd_num :: value,
        ( _Period1 :: den / __gcd_den :: value ) * _Period2 :: den > __r;
    public :
      typedef __success_type < chrono :: duration < __cr, __r >> type;
    };
template < typename _Period1, typename _Period2 >
    struct __duration_common_type_wrapper < __failure_type, _Period1, _Period2 >
    { typedef __failure_type type; };
template < typename _Rep1, typename _Period1, typename _Rep2, typename _Period2 >
    struct common_type < chrono :: duration < _Rep1, _Period1 >,
             chrono :: duration < _Rep2, _Period2 > >
    : public __duration_common_type_wrapper < typename __member_type_wrapper <
             common_type < _Rep1, _Rep2 >> :: type, _Period1, _Period2 > :: type
    { };
template < typename _CT, typename _Clock >
    struct __timepoint_common_type_wrapper
    {
      typedef __success_type < chrono :: time_point < _Clock, typename _CT :: type >>
        type;
    };
template < typename _Clock >
    struct __timepoint_common_type_wrapper < __failure_type, _Clock >
    { typedef __failure_type type; };
template < typename _Clock, typename _Duration1, typename _Duration2 >
    struct common_type < chrono :: time_point < _Clock, _Duration1 >,
             chrono :: time_point < _Clock, _Duration2 > >
    : public __timepoint_common_type_wrapper < typename __member_type_wrapper <
             common_type < _Duration1, _Duration2 >> :: type, _Clock > :: type
    { };
namespace chrono
{
template < typename _ToDur, typename _CF, typename _CR,
      bool _NumIsOne = false, bool _DenIsOne = false >
      struct __duration_cast_impl
      {
 template < typename _Rep, typename _Period >
   static constexpr _ToDur
   __cast ( const duration < _Rep, _Period > & __d )
   {
     typedef typename _ToDur :: rep __to_rep;
     return _ToDur ( static_cast < __to_rep > ( static_cast < _CR > ( __d . count ( ) )
       * static_cast < _CR > ( _CF :: num )
       / static_cast < _CR > ( _CF :: den ) ) );
   }
      };
template < typename _ToDur, typename _CF, typename _CR >
      struct __duration_cast_impl < _ToDur, _CF, _CR, true, true >
      {
 template < typename _Rep, typename _Period >
   static constexpr _ToDur
   __cast ( const duration < _Rep, _Period > & __d )
   {
     typedef typename _ToDur :: rep __to_rep;
     return _ToDur ( static_cast < __to_rep > ( __d . count ( ) ) );
   }
      };
template < typename _ToDur, typename _CF, typename _CR >
      struct __duration_cast_impl < _ToDur, _CF, _CR, true, false >
      {
 template < typename _Rep, typename _Period >
   static constexpr _ToDur
   __cast ( const duration < _Rep, _Period > & __d )
   {
     typedef typename _ToDur :: rep __to_rep;
     return _ToDur ( static_cast < __to_rep > (
       static_cast < _CR > ( __d . count ( ) ) / static_cast < _CR > ( _CF :: den ) ) );
   }
      };
template < typename _ToDur, typename _CF, typename _CR >
      struct __duration_cast_impl < _ToDur, _CF, _CR, false, true >
      {
 template < typename _Rep, typename _Period >
   static constexpr _ToDur
   __cast ( const duration < _Rep, _Period > & __d )
   {
     typedef typename _ToDur :: rep __to_rep;
     return _ToDur ( static_cast < __to_rep > (
       static_cast < _CR > ( __d . count ( ) ) * static_cast < _CR > ( _CF :: num ) ) );
   }
      };
template < typename _Tp >
      struct __is_duration
      : std :: false_type
      { };
template < typename _Rep, typename _Period >
      struct __is_duration < duration < _Rep, _Period > >
      : std :: true_type
      { };
template < typename _ToDur, typename _Rep, typename _Period >
      constexpr typename enable_if < __is_duration < _ToDur > :: value,
       _ToDur > :: type
      duration_cast ( const duration < _Rep, _Period > & __d )
      {
 typedef typename _ToDur :: period __to_period;
 typedef typename _ToDur :: rep __to_rep;
 typedef ratio_divide < _Period, __to_period > __cf;
 typedef typename common_type < __to_rep, _Rep, intmax_t > :: type
          __cr;
 typedef __duration_cast_impl < _ToDur, __cf, __cr,
          __cf :: num == 1, __cf :: den == 1 > __dc;
 return __dc :: __cast ( __d );
      }
template < typename _Rep >
      struct treat_as_floating_point
      : is_floating_point < _Rep >
      { };
template < typename _Rep >
      struct duration_values
      {
 static constexpr _Rep
 zero ( )
 ;
 static constexpr _Rep
 max ( )
 ;
 static constexpr _Rep
 min ( )
 ;
      };
template < typename _Tp >
      struct __is_ratio
      : std :: false_type
      { };
template < intmax_t _Num, intmax_t _Den >
      struct __is_ratio < ratio < _Num, _Den > >
      : std :: true_type
      { };
template < typename _Rep, typename _Period >
      struct duration
      {
 typedef _Rep rep;
 typedef _Period period;
 static_assert ( ! __is_duration < _Rep > :: value, "rep cannot be a duration" );
 static_assert ( __is_ratio < _Period > :: value,
        "period must be a specialization of ratio" );
 static_assert ( _Period :: num > 0, "period must be positive" );
 constexpr duration ( ) = default;
 duration ( const duration & ) = default;
 template < typename _Rep2, typename = typename
        enable_if < is_convertible < _Rep2, rep > :: value
    && ( treat_as_floating_point < rep > :: value
        || ! treat_as_floating_point < _Rep2 > :: value ) > :: type >
   constexpr explicit duration ( const _Rep2 & __rep )
   : __r ( static_cast < rep > ( __rep ) ) { }
 template < typename _Rep2, typename _Period2, typename = typename
        enable_if < treat_as_floating_point < rep > :: value
    || ( ratio_divide < _Period2, period > :: den == 1
        && ! treat_as_floating_point < _Rep2 > :: value ) > :: type >
   constexpr duration ( const duration < _Rep2, _Period2 > & __d )
   : __r ( duration_cast < duration > ( __d ) . count ( ) ) { }
 ~ duration ( ) = default;
 duration & operator = ( const duration & ) = default;
 constexpr rep
 count ( ) const
 ;
 constexpr duration
 operator + ( ) const
 ;
 constexpr duration
 operator - ( ) const
 ;
 duration &
 operator ++ ( )
 ;
 duration
 operator ++ ( int )
 ;
 duration &
 operator -- ( )
 ;
 duration
 operator -- ( int )
 ;
 duration &
 operator += ( const duration & __d )
 ;
 duration &
 operator -= ( const duration & __d )
 ;
 duration &
 operator *= ( const rep & __rhs )
 ;
 duration &
 operator /= ( const rep & __rhs )
 ;
 template < typename _Rep2 = rep >
   typename enable_if < ! treat_as_floating_point < _Rep2 > :: value,
        duration & > :: type
   operator %= ( const rep & __rhs )
   {
     __r %= __rhs;
     return * this;
   }
 template < typename _Rep2 = rep >
   typename enable_if < ! treat_as_floating_point < _Rep2 > :: value,
        duration & > :: type
   operator %= ( const duration & __d )
   {
     __r %= __d . count ( );
     return * this;
   }
 static constexpr duration
 zero ( )
 ;
 static constexpr duration
 min ( )
 ;
 static constexpr duration
 max ( )
 ;
      private :
 rep __r;
      };
template < typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2 >
      constexpr typename common_type < duration < _Rep1, _Period1 >,
         duration < _Rep2, _Period2 > > :: type
      operator + ( const duration < _Rep1, _Period1 > & __lhs,
  const duration < _Rep2, _Period2 > & __rhs )
      {
 typedef duration < _Rep1, _Period1 > __dur1;
 typedef duration < _Rep2, _Period2 > __dur2;
 typedef typename common_type < __dur1, __dur2 > :: type __cd;
 return __cd ( __cd ( __lhs ) . count ( ) + __cd ( __rhs ) . count ( ) );
      }
template < typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2 >
      constexpr typename common_type < duration < _Rep1, _Period1 >,
         duration < _Rep2, _Period2 > > :: type
      operator - ( const duration < _Rep1, _Period1 > & __lhs,
  const duration < _Rep2, _Period2 > & __rhs )
      {
 typedef duration < _Rep1, _Period1 > __dur1;
 typedef duration < _Rep2, _Period2 > __dur2;
 typedef typename common_type < __dur1, __dur2 > :: type __cd;
 return __cd ( __cd ( __lhs ) . count ( ) - __cd ( __rhs ) . count ( ) );
      }
template < typename _Rep1, typename _Rep2, bool =
      is_convertible < _Rep2,
       typename common_type < _Rep1, _Rep2 > :: type > :: value >
      struct __common_rep_type { };
template < typename _Rep1, typename _Rep2 >
      struct __common_rep_type < _Rep1, _Rep2, true >
      { typedef typename common_type < _Rep1, _Rep2 > :: type type; };
template < typename _Rep1, typename _Period, typename _Rep2 >
      constexpr
      duration < typename __common_rep_type < _Rep1, _Rep2 > :: type, _Period >
      operator * ( const duration < _Rep1, _Period > & __d, const _Rep2 & __s )
      {
 typedef duration < typename common_type < _Rep1, _Rep2 > :: type, _Period >
   __cd;
 return __cd ( __cd ( __d ) . count ( ) * __s );
      }
template < typename _Rep1, typename _Rep2, typename _Period >
      constexpr
      duration < typename __common_rep_type < _Rep2, _Rep1 > :: type, _Period >
      operator * ( const _Rep1 & __s, const duration < _Rep2, _Period > & __d )
      { return __d * __s; }
template < typename _Rep1, typename _Period, typename _Rep2 >
      constexpr duration < typename __common_rep_type < _Rep1, typename
 enable_if < ! __is_duration < _Rep2 > :: value, _Rep2 > :: type > :: type, _Period >
      operator / ( const duration < _Rep1, _Period > & __d, const _Rep2 & __s )
      {
 typedef duration < typename common_type < _Rep1, _Rep2 > :: type, _Period >
   __cd;
 return __cd ( __cd ( __d ) . count ( ) / __s );
      }
template < typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2 >
      constexpr typename common_type < _Rep1, _Rep2 > :: type
      operator / ( const duration < _Rep1, _Period1 > & __lhs,
  const duration < _Rep2, _Period2 > & __rhs )
      {
 typedef duration < _Rep1, _Period1 > __dur1;
 typedef duration < _Rep2, _Period2 > __dur2;
 typedef typename common_type < __dur1, __dur2 > :: type __cd;
 return __cd ( __lhs ) . count ( ) / __cd ( __rhs ) . count ( );
      }
template < typename _Rep1, typename _Period, typename _Rep2 >
      constexpr duration < typename __common_rep_type < _Rep1, typename
 enable_if < ! __is_duration < _Rep2 > :: value, _Rep2 > :: type > :: type, _Period >
      operator % ( const duration < _Rep1, _Period > & __d, const _Rep2 & __s )
      {
 typedef duration < typename common_type < _Rep1, _Rep2 > :: type, _Period >
   __cd;
 return __cd ( __cd ( __d ) . count ( ) % __s );
      }
template < typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2 >
      constexpr typename common_type < duration < _Rep1, _Period1 >,
         duration < _Rep2, _Period2 > > :: type
      operator % ( const duration < _Rep1, _Period1 > & __lhs,
  const duration < _Rep2, _Period2 > & __rhs )
      {
 typedef duration < _Rep1, _Period1 > __dur1;
 typedef duration < _Rep2, _Period2 > __dur2;
 typedef typename common_type < __dur1, __dur2 > :: type __cd;
 return __cd ( __cd ( __lhs ) . count ( ) % __cd ( __rhs ) . count ( ) );
      }
template < typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2 >
      constexpr bool
      operator == ( const duration < _Rep1, _Period1 > & __lhs,
   const duration < _Rep2, _Period2 > & __rhs )
      {
 typedef duration < _Rep1, _Period1 > __dur1;
 typedef duration < _Rep2, _Period2 > __dur2;
 typedef typename common_type < __dur1, __dur2 > :: type __ct;
 return __ct ( __lhs ) . count ( ) == __ct ( __rhs ) . count ( );
      }
template < typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2 >
      constexpr bool
      operator < ( const duration < _Rep1, _Period1 > & __lhs,
  const duration < _Rep2, _Period2 > & __rhs )
      {
 typedef duration < _Rep1, _Period1 > __dur1;
 typedef duration < _Rep2, _Period2 > __dur2;
 typedef typename common_type < __dur1, __dur2 > :: type __ct;
 return __ct ( __lhs ) . count ( ) < __ct ( __rhs ) . count ( );
      }
template < typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2 >
      constexpr bool
      operator != ( const duration < _Rep1, _Period1 > & __lhs,
   const duration < _Rep2, _Period2 > & __rhs )
      { return ! ( __lhs == __rhs ); }
template < typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2 >
      constexpr bool
      operator <= ( const duration < _Rep1, _Period1 > & __lhs,
   const duration < _Rep2, _Period2 > & __rhs )
      { return ! ( __rhs < __lhs ); }
template < typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2 >
      constexpr bool
      operator > ( const duration < _Rep1, _Period1 > & __lhs,
  const duration < _Rep2, _Period2 > & __rhs )
      { return __rhs < __lhs; }
template < typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2 >
      constexpr bool
      operator >= ( const duration < _Rep1, _Period1 > & __lhs,
   const duration < _Rep2, _Period2 > & __rhs )
      { return ! ( __lhs < __rhs ); }
typedef struct duration< int64_t  , nano  > nanoseconds;
typedef struct duration< int64_t  , micro  > microseconds;
typedef struct duration< int64_t  , milli  > milliseconds;
typedef struct duration< int64_t  , ratio< 1 , 1L >  > seconds;
typedef struct duration< int64_t  , ratio< 60 , 1L >  > minutes;
typedef struct duration< int64_t  , ratio< 3600 , 1L >  > hours;
template < typename _Clock, typename _Dur >
      struct time_point
      {
 typedef _Clock clock;
 typedef _Dur duration;
 typedef typename duration :: rep rep;
 typedef typename duration :: period period;
 constexpr time_point ( );
 constexpr explicit time_point ( const duration & __dur )
 ;
 template < typename _Dur2 >
   constexpr time_point ( const time_point < clock, _Dur2 > & __t )
   : __d ( __t . time_since_epoch ( ) )
   { }
 constexpr duration
 time_since_epoch ( ) const
 ;
 time_point &
 operator += ( const duration & __dur )
 ;
 time_point &
 operator -= ( const duration & __dur )
 ;
 static constexpr time_point
 min ( )
 ;
 static constexpr time_point
 max ( )
 ;
      private :
 duration __d;
      };
template < typename _ToDur, typename _Clock, typename _Dur >
      constexpr typename enable_if < __is_duration < _ToDur > :: value,
       time_point < _Clock, _ToDur > > :: type
      time_point_cast ( const time_point < _Clock, _Dur > & __t )
      {
 typedef time_point < _Clock, _ToDur > __time_point;
 return __time_point ( duration_cast < _ToDur > ( __t . time_since_epoch ( ) ) );
      }
template < typename _Clock, typename _Dur1,
      typename _Rep2, typename _Period2 >
      constexpr time_point < _Clock,
 typename common_type < _Dur1, duration < _Rep2, _Period2 > > :: type >
      operator + ( const time_point < _Clock, _Dur1 > & __lhs,
  const duration < _Rep2, _Period2 > & __rhs )
      {
 typedef duration < _Rep2, _Period2 > __dur2;
 typedef typename common_type < _Dur1, __dur2 > :: type __ct;
 typedef time_point < _Clock, __ct > __time_point;
 return __time_point ( __lhs . time_since_epoch ( ) + __rhs );
      }
template < typename _Rep1, typename _Period1,
      typename _Clock, typename _Dur2 >
      constexpr time_point < _Clock,
 typename common_type < duration < _Rep1, _Period1 >, _Dur2 > :: type >
      operator + ( const duration < _Rep1, _Period1 > & __lhs,
  const time_point < _Clock, _Dur2 > & __rhs )
      {
 typedef duration < _Rep1, _Period1 > __dur1;
 typedef typename common_type < __dur1, _Dur2 > :: type __ct;
 typedef time_point < _Clock, __ct > __time_point;
 return __time_point ( __rhs . time_since_epoch ( ) + __lhs );
      }
template < typename _Clock, typename _Dur1,
      typename _Rep2, typename _Period2 >
      constexpr time_point < _Clock,
 typename common_type < _Dur1, duration < _Rep2, _Period2 > > :: type >
      operator - ( const time_point < _Clock, _Dur1 > & __lhs,
  const duration < _Rep2, _Period2 > & __rhs )
      {
 typedef duration < _Rep2, _Period2 > __dur2;
 typedef typename common_type < _Dur1, __dur2 > :: type __ct;
 typedef time_point < _Clock, __ct > __time_point;
 return __time_point ( __lhs . time_since_epoch ( ) - __rhs );
      }
template < typename _Clock, typename _Dur1, typename _Dur2 >
      constexpr typename common_type < _Dur1, _Dur2 > :: type
      operator - ( const time_point < _Clock, _Dur1 > & __lhs,
  const time_point < _Clock, _Dur2 > & __rhs )
      { return __lhs . time_since_epoch ( ) - __rhs . time_since_epoch ( ); }
template < typename _Clock, typename _Dur1, typename _Dur2 >
      constexpr bool
      operator == ( const time_point < _Clock, _Dur1 > & __lhs,
   const time_point < _Clock, _Dur2 > & __rhs )
      { return __lhs . time_since_epoch ( ) == __rhs . time_since_epoch ( ); }
template < typename _Clock, typename _Dur1, typename _Dur2 >
      constexpr bool
      operator != ( const time_point < _Clock, _Dur1 > & __lhs,
   const time_point < _Clock, _Dur2 > & __rhs )
      { return ! ( __lhs == __rhs ); }
template < typename _Clock, typename _Dur1, typename _Dur2 >
      constexpr bool
      operator < ( const time_point < _Clock, _Dur1 > & __lhs,
  const time_point < _Clock, _Dur2 > & __rhs )
      { return __lhs . time_since_epoch ( ) < __rhs . time_since_epoch ( ); }
template < typename _Clock, typename _Dur1, typename _Dur2 >
      constexpr bool
      operator <= ( const time_point < _Clock, _Dur1 > & __lhs,
   const time_point < _Clock, _Dur2 > & __rhs )
      { return ! ( __rhs < __lhs ); }
template < typename _Clock, typename _Dur1, typename _Dur2 >
      constexpr bool
      operator > ( const time_point < _Clock, _Dur1 > & __lhs,
  const time_point < _Clock, _Dur2 > & __rhs )
      { return __rhs < __lhs; }
template < typename _Clock, typename _Dur1, typename _Dur2 >
      constexpr bool
      operator >= ( const time_point < _Clock, _Dur1 > & __lhs,
   const time_point < _Clock, _Dur2 > & __rhs )
      { return ! ( __lhs < __rhs ); }
inline namespace _V2
{
struct system_clock ;

struct system_clock 
{
typedef nanoseconds duration;
typedef duration< int64_t ,nano > ::rep rep;
typedef duration< int64_t ,nano > ::period period;
typedef struct time_point< system_clock  , duration  > time_point;
static_assert(-9223372036854775808L<0L,"a clock's minimum duration cannot be less than its epoch");
constexpr static bool is_steady = false;
static time_point now();

inline static time_t to_time_t(const time_point &__t)
{
return (time_t )(duration_cast< seconds  , int64_t  , nano  > ((__t . time_since_epoch())) . count());
}

inline static time_point from_time_t(time_t __t)
{
typedef struct time_point< system_clock  , seconds  > __from;
return time_point_cast< duration  , system_clock  , seconds  > (time_point< system_clock ,seconds > (duration< int64_t ,ratio< 1 , 1L > > (__t)));
}
}
;

struct steady_clock 
{
typedef nanoseconds duration;
typedef duration< int64_t ,nano > ::rep rep;
typedef duration< int64_t ,nano > ::period period;
typedef struct time_point< steady_clock  , duration  > time_point;
constexpr static bool is_steady = true;
static time_point now();
}
;
using high_resolution_clock = struct system_clock ;
}
}
namespace literals
{
inline namespace chrono_literals
{
template < typename _Rep, unsigned long long _Val >
      struct _Checked_integral_constant
      : integral_constant < _Rep, static_cast < _Rep > ( _Val ) >
      {
 static_assert ( _Checked_integral_constant :: value >= 0
        && _Checked_integral_constant :: value == _Val,
        "literal value cannot be represented by duration type" );
      };
template < typename _Dur, char ... _Digits >
      constexpr _Dur __check_overflow ( )
      {
 using _Val = __parse_int :: _Parse_int < _Digits ... >;
 using _Rep = typename _Dur :: rep;
 using _CheckedVal = _Checked_integral_constant < _Rep, _Val :: value >;
 return _Dur { _CheckedVal :: value };
      }

constexpr inline struct chrono::duration< long double  , ratio< 3600 , 1L >  >  __attribute__((visibility("default"))) operator "" h(long double __hours)
{
return chrono::duration< long double ,ratio< 3600 , 1L > > {__hours};
}
template < char ... _Digits >
      constexpr chrono :: hours
      operator ""h ( )
      { return __check_overflow < chrono :: hours, _Digits ... > ( ); }

constexpr inline struct chrono::duration< long double  , ratio< 60 , 1L >  >  __attribute__((visibility("default"))) operator "" min(long double __mins)
{
return chrono::duration< long double ,ratio< 60 , 1L > > {__mins};
}
template < char ... _Digits >
      constexpr chrono :: minutes
      operator ""min ( )
      { return __check_overflow < chrono :: minutes, _Digits ... > ( ); }

constexpr inline struct chrono::duration< long double  , ratio< 1 , 1L >  >  __attribute__((visibility("default"))) operator "" s(long double __secs)
{
return chrono::duration< long double ,ratio< 1 , 1L > > {__secs};
}
template < char ... _Digits >
      constexpr chrono :: seconds
      operator ""s ( )
      { return __check_overflow < chrono :: seconds, _Digits ... > ( ); }

constexpr inline struct chrono::duration< long double  , milli  >  __attribute__((visibility("default"))) operator "" ms(long double __msecs)
{
return chrono::duration< long double ,milli > {__msecs};
}
template < char ... _Digits >
      constexpr chrono :: milliseconds
      operator ""ms ( )
      { return __check_overflow < chrono :: milliseconds, _Digits ... > ( ); }

constexpr inline struct chrono::duration< long double  , micro  >  __attribute__((visibility("default"))) operator "" us(long double __usecs)
{
return chrono::duration< long double ,micro > {__usecs};
}
template < char ... _Digits >
      constexpr chrono :: microseconds
      operator ""us ( )
      { return __check_overflow < chrono :: microseconds, _Digits ... > ( ); }

constexpr inline struct chrono::duration< long double  , nano  >  __attribute__((visibility("default"))) operator "" ns(long double __nsecs)
{
return chrono::duration< long double ,nano > {__nsecs};
}
template < char ... _Digits >
      constexpr chrono :: nanoseconds
      operator ""ns ( )
      { return __check_overflow < chrono :: nanoseconds, _Digits ... > ( ); }
}
}
namespace chrono
{
using namespace literals::chrono_literals;
}
}
namespace std
{

class __mutex_base 
{
protected: typedef __gthread_mutex_t __native_type;
__native_type _M_mutex;
constexpr inline __mutex_base() = default;
inline __mutex_base(const class __mutex_base &) = delete;

inline __mutex_base &operator=(const class __mutex_base &)
{
}
}
;

class mutex : private __mutex_base
{
public: typedef __native_type *native_handle_type;
constexpr inline mutex() = default;

inline ~mutex()
{
}
inline mutex(const class mutex &) = delete;

inline mutex &operator=(const class mutex &)
{
}

inline void lock()
{
int __e = __gthread_mutex_lock(&(this) -> _M_mutex);
if (__e) 
__throw_system_error(__e);
}

inline bool try_lock()
{
return !(__gthread_mutex_trylock(&(this) -> _M_mutex));
}

inline void unlock()
{
__gthread_mutex_unlock(&(this) -> _M_mutex);
}

inline native_handle_type native_handle()
{
return &(this) -> _M_mutex;
}
}
;

struct defer_lock_t 
{
inline explicit defer_lock_t() = default;
}
;

struct try_to_lock_t 
{
inline explicit try_to_lock_t() = default;
}
;

struct adopt_lock_t 
{
inline explicit adopt_lock_t() = default;
}
;
constexpr struct defer_lock_t defer_lock();
constexpr struct try_to_lock_t try_to_lock();
constexpr struct adopt_lock_t adopt_lock();
template < typename _Mutex >
    class lock_guard
    {
    public :
      typedef _Mutex mutex_type;
      explicit lock_guard ( mutex_type & __m );
      lock_guard ( mutex_type & __m, adopt_lock_t );
      ~ lock_guard ( )
      ;
      lock_guard ( const lock_guard & ) = delete;
      lock_guard & operator = ( const lock_guard & ) = delete;
    private :
      mutex_type & _M_device;
    };
template < typename _Mutex >
    class unique_lock
    {
    public :
      typedef _Mutex mutex_type;
      unique_lock ( ) noexcept
      ;
      explicit unique_lock ( mutex_type & __m )
      ;
      unique_lock ( mutex_type & __m, defer_lock_t ) noexcept
      ;
      unique_lock ( mutex_type & __m, try_to_lock_t )
      ;
      unique_lock ( mutex_type & __m, adopt_lock_t )
      ;
      template < typename _Clock, typename _Duration >
 unique_lock ( mutex_type & __m,
      const chrono :: time_point < _Clock, _Duration > & __atime )
 : _M_device ( std :: __addressof ( __m ) ),
   _M_owns ( _M_device -> try_lock_until ( __atime ) )
 { }
      template < typename _Rep, typename _Period >
 unique_lock ( mutex_type & __m,
      const chrono :: duration < _Rep, _Period > & __rtime )
 : _M_device ( std :: __addressof ( __m ) ),
   _M_owns ( _M_device -> try_lock_for ( __rtime ) )
 { }
      ~ unique_lock ( )
      ;
      unique_lock ( const unique_lock & ) = delete;
      unique_lock & operator = ( const unique_lock & ) = delete;
      unique_lock ( unique_lock && __u ) noexcept
      ;
      unique_lock & operator = ( unique_lock && __u ) noexcept
      ;
      void
      lock ( )
      ;
      bool
      try_lock ( )
      ;
      template < typename _Clock, typename _Duration >
 bool
 try_lock_until ( const chrono :: time_point < _Clock, _Duration > & __atime )
 {
   if ( ! _M_device )
     __throw_system_error ( int ( errc :: operation_not_permitted ) );
   else if ( _M_owns )
     __throw_system_error ( int ( errc :: resource_deadlock_would_occur ) );
   else
     {
       _M_owns = _M_device -> try_lock_until ( __atime );
       return _M_owns;
     }
 }
      template < typename _Rep, typename _Period >
 bool
 try_lock_for ( const chrono :: duration < _Rep, _Period > & __rtime )
 {
   if ( ! _M_device )
     __throw_system_error ( int ( errc :: operation_not_permitted ) );
   else if ( _M_owns )
     __throw_system_error ( int ( errc :: resource_deadlock_would_occur ) );
   else
     {
       _M_owns = _M_device -> try_lock_for ( __rtime );
       return _M_owns;
     }
  }
      void
      unlock ( )
      ;
      void
      swap ( unique_lock & __u ) noexcept
      ;
      mutex_type *
      release ( ) noexcept
      ;
      bool
      owns_lock ( ) const noexcept
      ;
      explicit operator bool ( ) const noexcept
      ;
      mutex_type *
      mutex ( ) const noexcept
      ;
    private :
      mutex_type * _M_device;
      bool _M_owns;
    };
template < typename _Mutex >
    inline void
    swap ( unique_lock < _Mutex > & __x, unique_lock < _Mutex > & __y ) noexcept
    { __x . swap ( __y ); }
}
namespace std
{

class __recursive_mutex_base 
{
protected: typedef __gthread_recursive_mutex_t __native_type;
inline __recursive_mutex_base(const class __recursive_mutex_base &) = delete;

inline __recursive_mutex_base &operator=(const class __recursive_mutex_base &)
{
}
__native_type _M_mutex;
inline __recursive_mutex_base() = default;
}
;

class recursive_mutex : private __recursive_mutex_base
{
public: typedef __native_type *native_handle_type;
inline recursive_mutex() = default;

inline ~recursive_mutex()
{
}
inline recursive_mutex(const class recursive_mutex &) = delete;

inline recursive_mutex &operator=(const class recursive_mutex &)
{
}

inline void lock()
{
int __e = __gthread_recursive_mutex_lock(&(this) -> _M_mutex);
if (__e) 
__throw_system_error(__e);
}

inline bool try_lock()
{
return !(__gthread_recursive_mutex_trylock(&(this) -> _M_mutex));
}

inline void unlock()
{
__gthread_recursive_mutex_unlock(&(this) -> _M_mutex);
}

inline native_handle_type native_handle()
{
return &(this) -> _M_mutex;
}
}
;
template < typename _Derived >
    class __timed_mutex_impl
    {
    protected :
      typedef chrono :: high_resolution_clock __clock_t;
      template < typename _Rep, typename _Period >
 bool
 _M_try_lock_for ( const chrono :: duration < _Rep, _Period > & __rtime )
 {
   using chrono :: steady_clock;
   auto __rt = chrono :: duration_cast < steady_clock :: duration > ( __rtime );
   if ( ratio_greater < steady_clock :: period, _Period > ( ) )
     ++ __rt;
   return _M_try_lock_until ( steady_clock :: now ( ) + __rt );
 }
      template < typename _Duration >
 bool
 _M_try_lock_until ( const chrono :: time_point < __clock_t,
         _Duration > & __atime )
 {
   auto __s = chrono :: time_point_cast < chrono :: seconds > ( __atime );
   auto __ns = chrono :: duration_cast < chrono :: nanoseconds > ( __atime - __s );
   __gthread_time_t __ts = {
     static_cast < std :: time_t > ( __s . time_since_epoch ( ) . count ( ) ),
     static_cast < long > ( __ns . count ( ) )
   };
   return static_cast < _Derived * > ( this ) -> _M_timedlock ( __ts );
 }
      template < typename _Clock, typename _Duration >
 bool
 _M_try_lock_until ( const chrono :: time_point < _Clock, _Duration > & __atime )
 {
   auto __rtime = __atime - _Clock :: now ( );
   return _M_try_lock_until ( __clock_t :: now ( ) + __rtime );
 }
    };
class timed_mutex ;

class timed_mutex : private __mutex_base,public __timed_mutex_impl< timed_mutex  > 
{
public: typedef __native_type *native_handle_type;
inline timed_mutex() = default;

inline ~timed_mutex()
{
}
inline timed_mutex(const class timed_mutex &) = delete;

inline timed_mutex &operator=(const class timed_mutex &)
{
}

inline void lock()
{
int __e = __gthread_mutex_lock(&(this) -> _M_mutex);
if (__e) 
__throw_system_error(__e);
}

inline bool try_lock()
{
return !(__gthread_mutex_trylock(&(this) -> _M_mutex));
}
template < class _Rep, class _Period >
      bool
      try_lock_for ( const chrono :: duration < _Rep, _Period > & __rtime )
      { return _M_try_lock_for ( __rtime ); }
template < class _Clock, class _Duration >
      bool
      try_lock_until ( const chrono :: time_point < _Clock, _Duration > & __atime )
      { return _M_try_lock_until ( __atime ); }

inline void unlock()
{
__gthread_mutex_unlock(&(this) -> _M_mutex);
}

inline native_handle_type native_handle()
{
return &(this) -> _M_mutex;
}

private: inline bool _M_timedlock(const __gthread_time_t &__ts)
{
return !(__gthread_mutex_timedlock(&(this) -> _M_mutex,&__ts));
}
}
;
class recursive_timed_mutex ;

class recursive_timed_mutex : private __recursive_mutex_base,public __timed_mutex_impl< recursive_timed_mutex  > 
{
public: typedef __native_type *native_handle_type;
inline recursive_timed_mutex() = default;

inline ~recursive_timed_mutex()
{
}
inline recursive_timed_mutex(const class recursive_timed_mutex &) = delete;

inline recursive_timed_mutex &operator=(const class recursive_timed_mutex &)
{
}

inline void lock()
{
int __e = __gthread_recursive_mutex_lock(&(this) -> _M_mutex);
if (__e) 
__throw_system_error(__e);
}

inline bool try_lock()
{
return !(__gthread_recursive_mutex_trylock(&(this) -> _M_mutex));
}
template < class _Rep, class _Period >
      bool
      try_lock_for ( const chrono :: duration < _Rep, _Period > & __rtime )
      { return _M_try_lock_for ( __rtime ); }
template < class _Clock, class _Duration >
      bool
      try_lock_until ( const chrono :: time_point < _Clock, _Duration > & __atime )
      { return _M_try_lock_until ( __atime ); }

inline void unlock()
{
__gthread_recursive_mutex_unlock(&(this) -> _M_mutex);
}

inline native_handle_type native_handle()
{
return &(this) -> _M_mutex;
}

private: inline bool _M_timedlock(const __gthread_time_t &__ts)
{
return !(__gthread_recursive_mutex_timedlock(&(this) -> _M_mutex,&__ts));
}
}
;
template < typename _Lock >
    inline unique_lock < _Lock >
    __try_to_lock ( _Lock & __l )
    { return unique_lock < _Lock > { __l, try_to_lock }; }
template < int _Idx, bool _Continue = true >
    struct __try_lock_impl
    {
      template < typename ... _Lock >
 static void
 __do_try_lock ( tuple < _Lock & ... > & __locks, int & __idx )
 {
          __idx = _Idx;
          auto __lock = std :: __try_to_lock ( std :: get < _Idx > ( __locks ) );
          if ( __lock . owns_lock ( ) )
            {
       constexpr bool __cont = _Idx + 2 < sizeof ... ( _Lock );
       using __try_locker = __try_lock_impl < _Idx + 1, __cont >;
       __try_locker :: __do_try_lock ( __locks, __idx );
              if ( __idx == - 1 )
                __lock . release ( );
            }
 }
    };
template < int _Idx >
    struct __try_lock_impl < _Idx, false >
    {
      template < typename ... _Lock >
 static void
 __do_try_lock ( tuple < _Lock & ... > & __locks, int & __idx )
 {
          __idx = _Idx;
          auto __lock = std :: __try_to_lock ( std :: get < _Idx > ( __locks ) );
          if ( __lock . owns_lock ( ) )
            {
              __idx = - 1;
              __lock . release ( );
            }
 }
    };
template < typename _Lock1, typename _Lock2, typename ... _Lock3 >
    int
    try_lock ( _Lock1 & __l1, _Lock2 & __l2, _Lock3 & ... __l3 )
    {
      int __idx;
      auto __locks = std :: tie ( __l1, __l2, __l3 ... );
      __try_lock_impl < 0 > :: __do_try_lock ( __locks, __idx );
      return __idx;
    }
template < typename _L1, typename _L2, typename ... _L3 >
    void
    lock ( _L1 & __l1, _L2 & __l2, _L3 & ... __l3 )
    {
      while ( true )
        {
          using __try_locker = __try_lock_impl < 0, sizeof ... ( _L3 ) != 0 >;
          unique_lock < _L1 > __first ( __l1 );
          int __idx;
          auto __locks = std :: tie ( __l2, __l3 ... );
          __try_locker :: __do_try_lock ( __locks, __idx );
          if ( __idx == - 1 )
            {
              __first . release ( );
              return;
            }
        }
    }

struct once_flag 
{
typedef __gthread_once_t __native_type;
__native_type _M_once = 0;
constexpr inline once_flag() = default;
inline once_flag(const struct once_flag &) = delete;

inline once_flag &operator=(const struct once_flag &)
{
}
template < typename _Callable, typename ... _Args >
      friend void
      call_once ( once_flag & __once, _Callable && __f, _Args && ... __args );
}
;
extern void *__once_callable;
extern void (*__once_call)();
template < typename _Callable >
    inline void
    __once_call_impl ( )
    {
      ( * ( _Callable * ) __once_callable ) ( );
    }
extern "C" { void __once_proxy() __attribute__((visibility("default"))) ; }
template < typename _Callable, typename ... _Args >
    void
    call_once ( once_flag & __once, _Callable && __f, _Args && ... __args )
    {
      auto __bound_functor = std :: __bind_simple ( std :: forward < _Callable > ( __f ),
          std :: forward < _Args > ( __args ) ... );
      __once_callable = std :: __addressof ( __bound_functor );
      __once_call = & __once_call_impl < decltype ( __bound_functor ) >;
      int __e = __gthread_once ( & __once . _M_once, & __once_proxy );
      if ( __e )
 __throw_system_error ( __e );
    }
}
namespace camp
{
namespace resources
{
inline namespace v1
{
class Event ;

class Event 
{

public: inline Event()
{
}
template < typename T >
      Event ( T && value )
      {
        m_value . reset ( new EventModel < T > ( value ) );
      }

inline bool check() const
{
return (((this) -> m_value)) ->  check ();
}

inline void wait() const
{
(((this) -> m_value)) ->  wait ();
}
template < typename T >
      T * try_get ( )
      {
        auto result = dynamic_cast < EventModel < T > * > ( m_value . get ( ) );
        return result -> get ( );
      }
template < typename T >
      T get ( )
      {
        auto result = dynamic_cast < EventModel < T > * > ( m_value . get ( ) );
        if ( result == nullptr ) {
          throw std :: runtime_error ( "Incompatible Event type get cast." );
        }
        return * result -> get ( );
      }

private: class EventInterface 
{

public: virtual inline ~EventInterface()
{
}
virtual bool check() const = 0;
virtual void wait() const = 0;
}
;
private: 
template < typename T >
      class EventModel : public EventInterface
      {
      public :
        EventModel ( T const & modelVal );
        bool check ( ) const override;
        void wait ( ) const override;
        T * get ( );
      private :
        T m_modelVal;
      };
class std::shared_ptr< EventInterface  > m_value;
}
;
}
}
}
namespace camp
{
namespace resources
{
namespace v1
{
enum class Platform {undefined=0,host=1,cuda=2,omp_target=4,hip=8,sycl=16} ;
}
}
}
namespace camp
{
namespace resources
{
namespace v1
{

class HostEvent 
{

public: inline HostEvent()
{
}

inline bool check() const
{
return true;
}

inline void wait() const
{
}
}
;

class Host 
{

public: inline Host(int  = - 1)
{
}

inline Platform get_platform()
{
return Platform(1);
}

inline static Host &get_default()
{
static class Host h;
return h;
}

inline HostEvent get_event()
{
return HostEvent();
}

inline Event get_event_erased()
{
class Event e{HostEvent()};
return (e);
}

inline void wait()
{
}

inline void wait_for(class Event *e)
{
e ->  wait ();
}
template < typename T >
      T * allocate ( size_t n )
      {
        return ( T * ) malloc ( sizeof ( T ) * n );
      }

inline void *calloc(size_t size)
{
void *p = ((this) -> allocate< char  > (size));
(this) ->  memset (p,0,size);
return p;
}

inline void deallocate(void *p)
{
free(p);
}

inline void memcpy(void *dst,const void *src,size_t size)
{
::memcpy(dst,src,size);
}

inline void memset(void *p,int val,size_t size)
{
::memset(p,val,size);
}
}
;
}
}
}
namespace camp
{
namespace resources
{
namespace v1
{

class Resource 
{
public: inline Resource(class Resource &&) = default;
inline Resource(const class Resource &) = default;

inline Resource &operator=(class Resource &&)
{
}

inline Resource &operator=(const class Resource &)
{
}
template < typename T,
                typename = typename std :: enable_if <
                    ! std :: is_same < typename std :: decay < T > :: type,
                                  Resource > :: value > :: type >
      Resource ( T && value )
      {
        m_value . reset ( new ContextModel < type :: ref :: rem < T >> ( forward < T > ( value ) ) );
      }
template < typename T >
      T * try_get ( )
      {
        auto result = dynamic_cast < ContextModel < T > * > ( m_value . get ( ) );
        return result ? result -> get ( ) : nullptr;
      }
template < typename T >
      T get ( )
      {
        auto result = dynamic_cast < ContextModel < T > * > ( m_value . get ( ) );
        if ( result == nullptr ) {
          throw std :: runtime_error ( "Incompatible Resource type get cast." );
        }
        return * result -> get ( );
      }

inline Platform get_platform()
{
return ((this) -> m_value) ->  get_platform ();
}
template < typename T >
      T * allocate ( size_t size )
      {
        return ( T * ) m_value -> calloc ( size * sizeof ( T ) );
      }

inline void *calloc(size_t size)
{
return ((this) -> m_value) ->  calloc (size);
}

inline void deallocate(void *p)
{
((this) -> m_value) ->  deallocate (p);
}

inline void memcpy(void *dst,const void *src,size_t size)
{
((this) -> m_value) ->  memcpy (dst,src,size);
}

inline void memset(void *p,int val,size_t size)
{
((this) -> m_value) ->  memset (p,val,size);
}

inline Event get_event()
{
return ((this) -> m_value) ->  get_event ();
}

inline void wait_for(class Event *e)
{
((this) -> m_value) ->  wait_for (e);
}

private: class ContextInterface 
{

public: virtual inline ~ContextInterface()
{
}
virtual Platform get_platform() = 0;
virtual void *calloc(size_t size) = 0;
virtual void deallocate(void *p) = 0;
virtual void memcpy(void *dst,const void *src,size_t size) = 0;
virtual void memset(void *p,int val,size_t size) = 0;
virtual Event get_event() = 0;
virtual void wait_for(class Event *e) = 0;
}
;
private: 
template < typename T >
      class ContextModel : public ContextInterface
      {
      public :
        ContextModel ( T const & modelVal );
        Platform get_platform ( ) override;
        void * calloc ( size_t size ) override;
        void deallocate ( void * p ) override;
        void memcpy ( void * dst, const void * src, size_t size ) override
        ;
        void memset ( void * p, int val, size_t size ) override
        ;
        Event get_event ( ) override;
        void wait_for ( Event * e ) override;
        T * get ( );
      private :
        T m_modelVal;
      };
class std::shared_ptr< ContextInterface  > m_value;
}
;
template < Platform p >
    struct resource_from_platform;
template<> struct resource_from_platform< Platform(1) > 
{
using type = class Host ;
};
}
}
}
namespace RAJA
{
using camp::at_v;
using camp::get;
using camp::list;
using camp::idx_t;
using camp::make_tuple;
using camp::tuple;
using camp::resources::v1::Platform;
}
namespace RAJA
{
enum IndexOwnership {Unowned=0,Owned=1} ;
using Index_type = ::std::ptrdiff_t ;
const int UndefinedValue = - 9999999;
template < Index_type ... Sizes >
struct SizeList {
};
using Real_type = double ;
using Real_ptr = Real_type * __restrict__ ;
using const_Real_ptr = const Real_type * __restrict__ ;
using UnalignedReal_ptr = Real_type * __restrict__ ;
using const_UnalignedReal_ptr = const Real_type * __restrict__ ;
}
namespace RAJA
{
enum class Policy {undefined=0,sequential=1,loop=2,simd=3,openmp=4,target_openmp=5,cuda=6,hip=7,tbb=8} ;
enum class Pattern {undefined=0,forall=1,region=2,reduce=3,taskgraph=4,synchronize=5} ;
enum class Launch {undefined=0,sync=1,async=2} ;

struct PolicyBase 
{
}
;
template < Policy Policy_,
          Pattern Pattern_,
          Launch Launch_,
          Platform Platform_,
          typename ... Traits >
struct PolicyBaseT : PolicyBase {
  static constexpr Policy policy = Policy_;
  static constexpr Pattern pattern = Pattern_;
  static constexpr Launch launch = Launch_;
  static constexpr Platform platform = Platform_;
};
template < typename PolicyType >
struct policy_of {
  static constexpr Policy value = PolicyType :: policy;
};
template < typename PolicyType >
struct pattern_of {
  static constexpr Pattern value = PolicyType :: pattern;
};
template < typename PolicyType >
struct launch_of {
  static constexpr Launch value = PolicyType :: launch;
};
template < typename PolicyType >
struct platform_of {
  static constexpr Platform value = PolicyType :: platform;
};
template < typename PolicyType, RAJA :: Policy P_ >
struct policy_is : camp :: num < policy_of < camp :: decay < PolicyType >> :: value == P_ > {
};
template < typename PolicyType, RAJA :: Pattern P_ >
struct pattern_is
    : camp :: num < pattern_of < camp :: decay < PolicyType >> :: value == P_ > {
};
template < typename PolicyType, RAJA :: Launch L_ >
struct launch_is : camp :: num < launch_of < camp :: decay < PolicyType >> :: value == L_ > {
};
template < typename PolicyType, RAJA :: Platform P_ >
struct platform_is
    : camp :: num < platform_of < camp :: decay < PolicyType >> :: value == P_ > {
};
template < typename Inner >
struct wrapper {
  using inner = Inner;
};
namespace reduce
{

struct ordered 
{
}
;
}
template < Policy Pol, Pattern Pat, typename ... Args >
using make_policy_pattern_t =
    PolicyBaseT < Pol, Pat, Launch :: undefined, Platform :: undefined, Args ... >;
template < Policy Policy_,
          Pattern Pattern_,
          Launch Launch_,
          Platform Platform_,
          typename ... Args >
using make_policy_pattern_launch_platform_t =
    PolicyBaseT < Policy_, Pattern_, Launch_, Platform_, Args ... >;
template < Policy Policy_, Pattern Pattern_, Launch Launch_, typename ... Args >
using make_policy_pattern_launch_t =
    PolicyBaseT < Policy_, Pattern_, Launch_, Platform :: undefined, Args ... >;
namespace concepts
{
template < typename Pol >
struct ExecutionPolicy
    :
     decltype ( ___valid_expr___ (
     :: RAJA :: concepts :: has_type < :: RAJA :: Policy > ( camp :: decay < decltype ( Pol :: policy ) > ( ) ), :: RAJA :: concepts :: has_type < :: RAJA :: Pattern > ( camp :: decay < decltype ( Pol :: pattern ) > ( ) ), :: RAJA :: concepts :: has_type < :: RAJA :: Launch > ( camp :: decay < decltype ( Pol :: launch ) > ( ) ), :: RAJA :: concepts :: has_type < :: RAJA :: Platform > ( camp :: decay < decltype ( Pol :: platform ) > ( ) )
     ) )
                                                                {
};
}
namespace type_traits
{
template < typename Pol >
struct is_sequential_policy : RAJA :: policy_is < Pol, RAJA :: Policy :: sequential > {
};
template < typename Pol >
struct is_loop_policy : RAJA :: policy_is < Pol, RAJA :: Policy :: loop > {
};
template < typename Pol >
struct is_simd_policy : RAJA :: policy_is < Pol, RAJA :: Policy :: simd > {
};
template < typename Pol >
struct is_openmp_policy : RAJA :: policy_is < Pol, RAJA :: Policy :: openmp > {
};
template < typename Pol >
struct is_tbb_policy : RAJA :: policy_is < Pol, RAJA :: Policy :: tbb > {
};
template < typename Pol >
struct is_target_openmp_policy
    : RAJA :: policy_is < Pol, RAJA :: Policy :: target_openmp > {
};
template < typename Pol >
struct is_cuda_policy : RAJA :: policy_is < Pol, RAJA :: Policy :: cuda > {
};
template < typename Pol >
struct is_hip_policy : RAJA :: policy_is < Pol, RAJA :: Policy :: hip > {
};
template < typename ... Args > struct
is_execution_policy
: camp :: concepts :: requires_ <
RAJA :: concepts :: ExecutionPolicy
, Args ... > { };
}
}
namespace RAJA
{
namespace detail
{
template < typename Op, typename ... Rest >
struct foldl_impl;
template < typename Op, typename Arg1 >
struct foldl_impl < Op, Arg1 > {
  using Ret = Arg1;
};
template < typename Op, typename Arg1, typename Arg2 >
struct foldl_impl < Op, Arg1, Arg2 > {
  using Ret = typename std :: result_of < Op ( Arg1, Arg2 ) > :: type;
};
template < typename Op,
          typename Arg1,
          typename Arg2,
          typename Arg3,
          typename ... Rest >
struct foldl_impl < Op, Arg1, Arg2, Arg3, Rest ... > {
  using Ret = typename foldl_impl <
      Op,
      typename std :: result_of < Op ( typename std :: result_of < Op ( Arg1, Arg2 ) > :: type,
                                 Arg3 ) > :: type,
      Rest ... > :: Ret;
};
}
template < typename Op, typename Arg1 >
 inline __attribute__ ( ( always_inline ) ) constexpr auto foldl (
    Op &&,
    Arg1 && arg ) -> typename detail :: foldl_impl < Op, Arg1 > :: Ret
{
  return camp :: forward < Arg1 > ( arg );
}
template < typename Op, typename Arg1, typename Arg2 >
 inline __attribute__ ( ( always_inline ) ) constexpr auto foldl ( Op && operation,
                                                  Arg1 && arg1,
                                                  Arg2 && arg2 ) ->
    typename detail :: foldl_impl < Op, Arg1, Arg2 > :: Ret
{
  return camp :: forward < Op > ( operation ) ( camp :: forward < Arg1 > ( arg1 ),
                                      camp :: forward < Arg2 > ( arg2 ) );
}
template < typename Op,
          typename Arg1,
          typename Arg2,
          typename Arg3,
          typename ... Rest >
 inline __attribute__ ( ( always_inline ) ) constexpr auto foldl ( Op && operation,
                                                  Arg1 && arg1,
                                                  Arg2 && arg2,
                                                  Arg3 && arg3,
                                                  Rest && ... rest ) ->
    typename detail :: foldl_impl < Op, Arg1, Arg2, Arg3, Rest ... > :: Ret
{
  return foldl ( camp :: forward < Op > ( operation ),
               camp :: forward < Op > ( operation ) (
                   camp :: forward < Op > ( operation ) ( camp :: forward < Arg1 > ( arg1 ),
                                                camp :: forward < Arg2 > ( arg2 ) ),
                   camp :: forward < Arg3 > ( arg3 ) ),
               camp :: forward < Rest > ( rest ) ... );
}
template < typename Result, typename ... Args >
 inline __attribute__ ( ( always_inline ) ) constexpr Result sum ( Args ... args )
{
  return foldl ( RAJA :: operators :: plus < Result > ( ), args ... );
}
template < typename Result, typename ... Args >
 inline __attribute__ ( ( always_inline ) ) constexpr Result product ( Args ... args )
{
  return foldl ( RAJA :: operators :: multiplies < Result > ( ), args ... );
}
template < typename Result, typename ... Args >
 inline __attribute__ ( ( always_inline ) ) constexpr Result max ( Args ... args )
{
  return foldl ( RAJA :: operators :: maximum < Result > ( ), args ... );
}
template < typename Result, typename ... Args >
 inline __attribute__ ( ( always_inline ) ) constexpr Result min ( Args ... args )
{
  return foldl ( RAJA :: operators :: minimum < Result > ( ), args ... );
}
}
namespace RAJA
{
template < typename IterType, typename IndexType >
struct Span {
  using element_type = typename std :: iterator_traits < IterType > :: value_type;
  using value_type = camp :: decay < element_type >;
  using size_type = IndexType;
  using difference_type = std :: ptrdiff_t;
  using reference = element_type &;
  using const_reference = const element_type &;
  using iterator = IterType;
  using const_iterator = IterType;
  static_assert ( type_traits :: is_integral < IndexType > :: value,
                "IndexType must model Integral" );
  static_assert ( type_traits :: is_random_access_iterator < IterType > :: value,
                "IterType must model RandomAccessIterator" );
  Span ( iterator begin, iterator end )
      ;
  Span ( iterator begin, size_type size )
      ;
  inline __attribute__ ( ( always_inline ) ) iterator begin ( ) const;
  inline __attribute__ ( ( always_inline ) ) iterator end ( ) const;
  inline __attribute__ ( ( always_inline ) ) const_iterator cbegin ( ) const;
  inline __attribute__ ( ( always_inline ) ) const_iterator cend ( ) const;
  inline __attribute__ ( ( always_inline ) ) reference front ( ) const;
  inline __attribute__ ( ( always_inline ) ) reference back ( ) const;
  inline __attribute__ ( ( always_inline ) ) reference operator [ ] ( size_type i ) const;
  inline __attribute__ ( ( always_inline ) ) iterator data ( ) const;
  inline __attribute__ ( ( always_inline ) ) size_type size ( ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool empty ( ) const
  ;
  inline __attribute__ ( ( always_inline ) ) Span first ( size_type count ) const
  ;
  inline __attribute__ ( ( always_inline ) ) Span last ( size_type count ) const
  ;
  inline __attribute__ ( ( always_inline ) ) Span subspan ( size_type begin,
                                            size_type length ) const
  ;
  inline __attribute__ ( ( always_inline ) ) Span slice ( size_type begin,
                                          size_type length ) const
  ;
private :
  iterator m_begin;
  iterator m_end;
};
template < typename IterType, typename IndexType >
 inline __attribute__ ( ( always_inline ) ) Span < IterType, IndexType > make_span (
    IterType begin,
    IndexType size )
{
  return Span < IterType, IndexType > ( begin, size );
}
}
namespace RAJA
{
template < typename T >
class TypedListSegment
{
  static constexpr bool Has_GPU = false;
  struct TrivialCopy {
  };
  struct BlockCopy {
  };
  using GPU_memory = std :: integral_constant < bool, true >;
  using CPU_memory = std :: integral_constant < bool, false >;
  void deallocate ( GPU_memory );
  void allocate ( GPU_memory )
  ;
  void deallocate ( CPU_memory );
  void allocate ( CPU_memory );
  template < typename Container >
  void copy ( Container && source, TrivialCopy )
  {
    auto dest = m_data;
    auto src = source . begin ( );
    auto const end = source . end ( );
    while ( src != end ) {
      * dest = * src;
      ++ dest;
      ++ src;
    }
  }
  template < bool GPU, typename Container >
  void allocate_and_copy ( Container && src )
  {
    allocate ( std :: integral_constant < bool, GPU > ( ) );
    static constexpr bool use_gpu =
        GPU && std :: is_pointer < decltype ( src . begin ( ) ) > :: value &&
        std :: is_same < type_traits :: IterableValue < Container >, value_type > :: value;
    using TagType =
        typename std :: conditional < use_gpu, BlockCopy, TrivialCopy > :: type;
    copy ( src, TagType ( ) );
  }
public :
  using value_type = T;
  using iterator = T *;
  using IndexType = RAJA :: Index_type;
  TypedListSegment ( ) = delete;
  TypedListSegment ( const value_type * values,
                   Index_type length,
                   camp :: resources :: Resource & resource,
                   IndexOwnership owned = Owned )
    ;
  template < typename Container >
  TypedListSegment ( const Container & container,
                   camp :: resources :: Resource & resource )
    : m_resource ( resource ), m_use_resource ( true ),
      m_owned ( Unowned ), m_data ( nullptr ), m_size ( container . size ( ) )
  {
    using namespace camp :: resources;
    if ( m_size > 0 ) {
      Resource host_res { Host ( ) };
      value_type * tmp = host_res . allocate < value_type > ( m_size );
      auto dest = tmp;
      auto src = container . begin ( );
      auto const end = container . end ( );
      while ( src != end ) {
        * dest = * src;
        ++ dest;
        ++ src;
      }
      m_data = m_resource . allocate < value_type > ( m_size );
      m_resource . memcpy ( m_data, tmp, sizeof ( value_type ) * m_size );
      m_owned = Owned;
      host_res . deallocate ( tmp );
    }
  }
  TypedListSegment ( const value_type * values,
                   Index_type length,
                   IndexOwnership owned = Owned )
    ;
  template < typename Container >
  explicit TypedListSegment ( const Container & container )
    : m_resource ( camp :: resources :: Resource { camp :: resources :: Host ( ) } ),
      m_use_resource ( false ),
      m_owned ( Unowned ), m_data ( nullptr ), m_size ( container . size ( ) )
  {
    if ( m_size > 0 ) {
      allocate_and_copy < Has_GPU > ( container );
      m_owned = Owned;
    }
  }
  TypedListSegment ( const TypedListSegment & other )
    ;
  TypedListSegment ( TypedListSegment && rhs )
    ;
  ~ TypedListSegment ( )
  ;
  void swap ( TypedListSegment & other )
  ;
  iterator end ( ) const;
  iterator begin ( ) const;
  Index_type size ( ) const;
  IndexOwnership getIndexOwnership ( ) const;
  bool indicesEqual ( const value_type * container,
                                     Index_type len ) const
  ;
  bool operator == ( const TypedListSegment & other ) const
  ;
  bool operator != ( const TypedListSegment & other ) const
  ;
private :
  void initIndexData ( bool use_resource,
                     const value_type * container,
                     Index_type len,
                     IndexOwnership container_own )
  ;
  camp :: resources :: Resource m_resource;
  bool m_use_resource;
  IndexOwnership m_owned;
  value_type *  m_data;
  Index_type m_size;
};
using ListSegment = class TypedListSegment< Index_type  > ;
}
namespace std
{
template < typename T >
inline __attribute__ ( ( always_inline ) ) void swap ( RAJA :: TypedListSegment < T > & a,
                      RAJA :: TypedListSegment < T > & b )
{
  a . swap ( b );
}
}
namespace RAJA
{

struct IndexValueBase 
{
}
;
template < typename TYPE, typename VALUE = RAJA :: Index_type >
struct IndexValue : public IndexValueBase {
  using value_type = VALUE;
  inline __attribute__ ( ( always_inline ) ) constexpr IndexValue ( );
  inline __attribute__ ( ( always_inline ) ) constexpr explicit IndexValue ( value_type v )
      ;
  inline __attribute__ ( ( always_inline ) ) value_type & operator * ( );
  inline __attribute__ ( ( always_inline ) ) const value_type & operator * ( ) const
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator ++ ( int )
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE & operator ++ ( )
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator -- ( int )
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE & operator -- ( )
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator + ( value_type a ) const
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator + ( TYPE a ) const
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator - ( value_type a ) const
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator - ( TYPE a ) const
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator * ( value_type a ) const
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator * ( TYPE a ) const
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator / ( value_type a ) const
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator / ( TYPE a ) const
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator % ( value_type a ) const
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE operator % ( TYPE a ) const
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE & operator += ( value_type x )
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE & operator += ( TYPE x )
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE & operator -= ( value_type x )
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE & operator -= ( TYPE x )
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE & operator *= ( value_type x )
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE & operator *= ( TYPE x )
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE & operator /= ( value_type x )
  ;
  inline __attribute__ ( ( always_inline ) ) TYPE & operator /= ( TYPE x )
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator < ( value_type x ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator < ( TYPE x ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator <= ( value_type x ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator <= ( TYPE x ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator > ( value_type x ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator > ( TYPE x ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator >= ( value_type x ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator >= ( TYPE x ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator == ( value_type x ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator == ( TYPE x ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator != ( value_type x ) const
  ;
  inline __attribute__ ( ( always_inline ) ) bool operator != ( TYPE x ) const
  ;
  static std :: string getName ( );
protected :
  value_type value;
};
namespace internal
{
template < typename TO, typename FROM >
constexpr inline __attribute__ ( ( always_inline ) ) TO convertIndex_helper ( FROM const val )
{
  return TO ( val );
}
template < typename TO, typename FROM >
constexpr inline __attribute__ ( ( always_inline ) ) TO
convertIndex_helper ( typename FROM :: IndexValueType const val )
{
  return static_cast < TO > ( * val );
}
}
template < typename TO, typename FROM >
constexpr inline __attribute__ ( ( always_inline ) ) TO convertIndex ( FROM const val )
{
  return internal :: convertIndex_helper < TO, FROM > ( val );
}
template < typename FROM >
constexpr inline __attribute__ ( ( always_inline ) )
    typename std :: enable_if < std :: is_base_of < IndexValueBase, FROM > :: value,
                            typename FROM :: value_type > :: type
    stripIndexType ( FROM const val )
{
  return * val;
}
template < typename FROM >
constexpr inline __attribute__ ( ( always_inline ) )
    typename std :: enable_if < ! std :: is_base_of < IndexValueBase, FROM > :: value,
                            FROM > :: type
    stripIndexType ( FROM const val )
{
  return val;
}
namespace internal
{
template < typename FROM, typename Enable = void >
struct StripIndexTypeT { };
template < typename FROM >
struct StripIndexTypeT < FROM, typename std :: enable_if < std :: is_base_of < IndexValueBase, FROM > :: value > :: type >
{
    using type = typename FROM :: value_type;
};
template < typename FROM >
struct StripIndexTypeT < FROM, typename std :: enable_if < ! std :: is_base_of < IndexValueBase, FROM > :: value > :: type >
{
    using type = FROM;
};
}
template < typename FROM >
using strip_index_type_t = typename internal :: StripIndexTypeT < FROM > :: type;
template < typename FROM >
using make_signed_t = typename std :: conditional <
                                  std :: is_floating_point < FROM > :: value,
                                    std :: common_type < FROM >,
                                    std :: make_signed < FROM >
                               > :: type :: type;
}
namespace RAJA
{
namespace Iterators
{
template < typename Type = Index_type,
             typename DifferenceType = Type,
             typename PointerType = Type * >
               class numeric_iterator
               {
                 public :
                   using value_type = Type;
                   using stripped_value_type = strip_index_type_t < Type >;
                   using difference_type = DifferenceType;
                   using pointer = PointerType;
                   using reference = value_type &;
                   using iterator_category = std :: random_access_iterator_tag;
                   constexpr numeric_iterator ( );
                   constexpr numeric_iterator ( const numeric_iterator & rhs )
                     ;
                   constexpr numeric_iterator ( numeric_iterator && rhs )
                     ;
                   numeric_iterator & operator = ( const numeric_iterator & rhs )
                   ;
                   numeric_iterator & operator = ( numeric_iterator && rhs )
                   ;
                   constexpr numeric_iterator ( const stripped_value_type & rhs )
                     ;
                   inline DifferenceType get_stride ( ) const;
                   inline bool operator == ( const numeric_iterator & rhs ) const
                   ;
                   inline bool operator != ( const numeric_iterator & rhs ) const
                   ;
                   inline bool operator > ( const numeric_iterator & rhs ) const
                   ;
                   inline bool operator < ( const numeric_iterator & rhs ) const
                   ;
                   inline bool operator >= ( const numeric_iterator & rhs ) const
                   ;
                   inline bool operator <= ( const numeric_iterator & rhs ) const
                   ;
                   inline numeric_iterator & operator ++ ( )
                   ;
                   inline numeric_iterator & operator -- ( )
                   ;
                   inline numeric_iterator operator ++ ( int )
                   ;
                   inline numeric_iterator operator -- ( int )
                   ;
                   inline numeric_iterator & operator += (
                       const difference_type & rhs )
                   ;
                   inline numeric_iterator & operator -= (
                       const difference_type & rhs )
                   ;
                   inline numeric_iterator & operator += (
                       const numeric_iterator & rhs )
                   ;
                   inline numeric_iterator & operator -= (
                       const numeric_iterator & rhs )
                   ;
                   inline stripped_value_type operator + (
                       const numeric_iterator & rhs ) const
                   ;
                   inline stripped_value_type operator - (
                       const numeric_iterator & rhs ) const
                   ;
                   inline numeric_iterator operator + (
                       const difference_type & rhs ) const
                   ;
                   inline numeric_iterator operator - (
                       const difference_type & rhs ) const
                   ;
                   friend constexpr numeric_iterator operator + (
                       difference_type lhs,
                       const numeric_iterator & rhs );
                   friend constexpr numeric_iterator operator - (
                       difference_type lhs,
                       const numeric_iterator & rhs );
                   inline value_type operator * ( ) const
                   ;
                   inline value_type operator -> ( ) const
                   ;
                   constexpr value_type operator [ ] ( difference_type rhs ) const
                   ;
                 private :
                   stripped_value_type val = 0;
               };
template < typename Type = Index_type,
             typename DifferenceType = Type,
             typename PointerType = Type * >
               class strided_numeric_iterator
               {
                 public :
                   using value_type = Type;
                   using stripped_value_type = strip_index_type_t < Type >;
                   using difference_type = DifferenceType;
                   using pointer = DifferenceType *;
                   using reference = DifferenceType &;
                   using iterator_category = std :: random_access_iterator_tag;
                   constexpr strided_numeric_iterator ( );
                   constexpr strided_numeric_iterator (
                       const strided_numeric_iterator & rhs )
                     ;
                   constexpr strided_numeric_iterator ( strided_numeric_iterator && rhs )
                     ;
                   strided_numeric_iterator & operator = (
                       const strided_numeric_iterator & rhs )
                   ;
                   strided_numeric_iterator & operator = (
                       strided_numeric_iterator && rhs )
                   ;
                   constexpr strided_numeric_iterator (
                       stripped_value_type rhs,
                       DifferenceType stride_ = DifferenceType ( 1 ) )
                     ;
                   inline DifferenceType get_stride ( ) const;
                   inline strided_numeric_iterator & operator ++ ( )
                   ;
                   inline strided_numeric_iterator & operator -- ( )
                   ;
                   inline strided_numeric_iterator & operator += (
                       const difference_type & rhs )
                   ;
                   inline strided_numeric_iterator & operator -= (
                       const difference_type & rhs )
                   ;
                   inline difference_type operator + (
                       const strided_numeric_iterator & rhs ) const
                   ;
                   inline difference_type operator - (
                       const strided_numeric_iterator & rhs ) const
                   ;
                   inline strided_numeric_iterator operator + (
                       const difference_type & rhs ) const
                   ;
                   inline strided_numeric_iterator operator - (
                       const difference_type & rhs ) const
                   ;
                   inline bool operator != (
                       const strided_numeric_iterator & rhs ) const
                   ;
                   inline bool operator == (
                       const strided_numeric_iterator & rhs ) const
                   ;
                   inline bool operator > (
                       const strided_numeric_iterator & rhs ) const
                   ;
                   inline bool operator < (
                       const strided_numeric_iterator & rhs ) const
                   ;
                   inline bool operator >= (
                       const strided_numeric_iterator & rhs ) const
                   ;
                   inline bool operator <= (
                       const strided_numeric_iterator & rhs ) const
                   ;
                   inline value_type operator * ( ) const
                   ;
                   inline value_type operator -> ( ) const
                   ;
                   constexpr value_type operator [ ] ( difference_type rhs ) const
                   ;
                 private :
                   stripped_value_type val = 0;
                   DifferenceType stride = 1;
               };
}
}
namespace RAJA
{
template < typename StorageT, typename DiffT = make_signed_t < strip_index_type_t < StorageT > > >
    struct TypedRangeSegment {
      static_assert ( std :: is_signed < DiffT > :: value, "TypedRangeSegment DiffT requires signed type." );
      static_assert ( ! std :: is_floating_point < StorageT > :: value, "TypedRangeStrideSegment Type must be non floating point." );
      using iterator = Iterators :: numeric_iterator < StorageT, DiffT >;
      using value_type = StorageT;
      using IndexType = DiffT;
      using StripStorageT = strip_index_type_t < StorageT >;
      constexpr TypedRangeSegment ( StripStorageT begin, StripStorageT end )
        ;
      TypedRangeSegment ( ) = delete;
      constexpr TypedRangeSegment ( TypedRangeSegment && o )
        ;
      constexpr TypedRangeSegment ( TypedRangeSegment const & o )
        ;
      inline __attribute__ ( ( always_inline ) ) TypedRangeSegment & operator = (
          TypedRangeSegment const & o )
      ;
      inline __attribute__ ( ( always_inline ) ) ~ TypedRangeSegment ( );
      inline __attribute__ ( ( always_inline ) ) void swap ( TypedRangeSegment & other )
      ;
      inline __attribute__ ( ( always_inline ) ) iterator begin ( ) const;
      inline __attribute__ ( ( always_inline ) ) iterator end ( ) const;
      inline __attribute__ ( ( always_inline ) ) DiffT size ( ) const;
      inline __attribute__ ( ( always_inline ) ) TypedRangeSegment slice ( StorageT begin,
          DiffT length ) const
      ;
      inline __attribute__ ( ( always_inline ) ) bool operator == ( TypedRangeSegment const & o ) const
      ;
      inline __attribute__ ( ( always_inline ) ) bool operator != ( TypedRangeSegment const & o ) const
      ;
      private :
      iterator m_begin;
      iterator m_end;
    };
template < typename StorageT, typename DiffT = make_signed_t < strip_index_type_t < StorageT > > >
    struct TypedRangeStrideSegment {
      static_assert ( std :: is_signed < DiffT > :: value, "TypedRangeStrideSegment DiffT requires signed type." );
      static_assert ( ! std :: is_floating_point < StorageT > :: value, "TypedRangeStrideSegment Type must be non floating point." );
      using iterator = Iterators :: strided_numeric_iterator < StorageT, DiffT >;
      using value_type = StorageT;
      using IndexType = DiffT;
      using StripStorageT = strip_index_type_t < StorageT >;
      TypedRangeStrideSegment ( StripStorageT begin,
          StripStorageT end,
          DiffT stride )
        ;
      TypedRangeStrideSegment ( ) = delete;
      TypedRangeStrideSegment ( TypedRangeStrideSegment && o )
        ;
      TypedRangeStrideSegment ( TypedRangeStrideSegment const & o )
        ;
      TypedRangeStrideSegment & operator = (
          TypedRangeStrideSegment const & o )
      ;
      ~ TypedRangeStrideSegment ( );
      void swap ( TypedRangeStrideSegment & other )
      ;
      iterator begin ( ) const;
      iterator end ( ) const;
      DiffT size ( ) const;
      TypedRangeStrideSegment slice ( StorageT begin,
          DiffT length ) const
      ;
      bool operator == ( TypedRangeStrideSegment const & o ) const
      ;
      private :
      iterator m_begin;
      iterator m_end;
      DiffT m_size;
    };
using RangeSegment = struct TypedRangeSegment< Index_type  , make_signed_t< strip_index_type_t< Index_type  >  >  > ;
using RangeStrideSegment = struct TypedRangeStrideSegment< Index_type  , make_signed_t< strip_index_type_t< Index_type  >  >  > ;
namespace detail
{
template < typename T, typename ... Rest >
      struct common_type
      : std :: common_type < T, typename std :: common_type < Rest ... > :: type > {
      };
template < typename T >
      struct common_type < T > {
        using type = T;
      };
template < typename ... Ts >
      using common_type_t = typename common_type < Ts ... > :: type;
}
template < typename BeginT,
           typename EndT,
           typename Common = detail :: common_type_t < BeginT, EndT > >
             TypedRangeSegment < Common > make_range ( BeginT && begin,
                 EndT && end )
             {
               return { begin, end };
             }
template < typename BeginT,
           typename EndT,
           typename StrideT,
           typename Common = detail :: common_type_t < BeginT, EndT > >
             TypedRangeStrideSegment < Common > make_strided_range (
                 BeginT && begin,
                 EndT && end,
                 StrideT && stride )
             {
               static_assert ( std :: is_signed < StrideT > :: value, "make_strided_segment : stride must be signed." );
               static_assert ( std :: is_same < make_signed_t < EndT >, StrideT > :: value, "make_stride_segment : stride and end must be of similar types." );
               return { begin, end, stride };
             }
namespace concepts
{
template < typename T, typename U >
      struct RangeConstructible
      :
        decltype ( ___valid_expr___ (
              camp :: val < RAJA :: detail :: common_type_t < T, U >> ( )
              ) )
    {
    };
template < typename T, typename U, typename V >
      struct RangeStrideConstructible
      :
        decltype ( ___valid_expr___ (
              camp :: val < RAJA :: detail :: common_type_t < T, U, V >> ( )
              ) )
    {
    };
}
namespace type_traits
{
template < typename ... Args > struct
      is_range_constructible
      : camp :: concepts :: requires_ <
        RAJA :: concepts :: RangeConstructible
        , Args ... > { };
template < typename ... Args > struct
      is_range_stride_constructible
      : camp :: concepts :: requires_ <
        RAJA :: concepts :: RangeStrideConstructible
        , Args ... > { };
}
}
namespace std
{
template < typename T >
 inline __attribute__ ( ( always_inline ) ) void swap ( RAJA :: TypedRangeSegment < T > & a,
                                       RAJA :: TypedRangeSegment < T > & b )
{
  a . swap ( b );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) void swap ( RAJA :: TypedRangeStrideSegment < T > & a,
                                       RAJA :: TypedRangeStrideSegment < T > & b )
{
  a . swap ( b );
}
}
namespace RAJA
{

inline void *allocate_aligned(size_t alignment,size_t size)
{
void *ret = (nullptr);
int err = posix_memalign(&ret,alignment,size);
return err?(nullptr) : ret;
}
template < typename T >
inline T * allocate_aligned_type ( size_t alignment, size_t size )
{
  return reinterpret_cast < T * > ( allocate_aligned ( alignment, size ) );
}

inline void free_aligned(void *ptr)
{
free(ptr);
}
}
namespace RAJA
{
template < typename T, typename allocator_type = std :: allocator < T > >
class RAJAVec
{
public :
  using iterator = T *;
  explicit RAJAVec ( size_t init_cap = 0,
                   const allocator_type & a = allocator_type ( ) )
      ;
  RAJAVec ( const RAJAVec < T > & other )
      ;
  void swap ( RAJAVec < T > & other )
  ;
  RAJAVec < T > & operator = ( const RAJAVec < T > & rhs )
  ;
  ~ RAJAVec ( )
  ;
  T * data ( ) const;
  iterator end ( ) const;
  iterator begin ( ) const;
  bool empty ( ) const;
  size_t size ( ) const;
  inline __attribute__ ( ( always_inline ) )
  void resize ( size_t new_size )
  ;
  inline __attribute__ ( ( always_inline ) )
  void resize ( size_t new_size, T const & new_value )
  ;
  const T & operator [ ] ( size_t i ) const;
  T & operator [ ] ( size_t i );
  void push_back ( const T & item );
  void push_front ( const T & item );
private :
  void copy ( const RAJAVec < T > & other )
  ;
  static constexpr const size_t s_init_cap = 8;
  static constexpr const double s_grow_fac = (1.5);
  size_t nextCap ( size_t current_cap )
  ;
  void grow_cap ( size_t target_size )
  ;
  void push_back_private ( const T & item )
  ;
  void push_front_private ( const T & item )
  ;
  T * m_data;
  allocator_type m_allocator;
  size_t m_capacity;
  size_t m_size;
};
}
namespace RAJA
{
enum PushEnd {PUSH_FRONT=0,PUSH_BACK=1} ;
enum PushCopy {PUSH_COPY=0,PUSH_NOCOPY=1} ;
template < typename ... TALL >
class TypedIndexSet;
namespace policy
{
namespace indexset
{
template < typename SEG_ITER_POLICY_T, typename SEG_EXEC_POLICY_T = void >
struct ExecPolicy
    : public RAJA :: make_policy_pattern_t < SEG_EXEC_POLICY_T :: policy,
                                         RAJA :: Pattern :: forall > {
  using seg_it = SEG_ITER_POLICY_T;
  using seg_exec = SEG_EXEC_POLICY_T;
};
}
}
using RAJA::policy::indexset::ExecPolicy;
template < typename T0, typename ... TREST >
class TypedIndexSet < T0, TREST ... > : public TypedIndexSet < TREST ... >
{
  using PARENT = TypedIndexSet < TREST ... >;
  static const int T0_TypeId = sizeof ... ( TREST );
public :
  using value_type = typename T0 :: value_type;
  static_assert ( std :: is_same < value_type, typename PARENT :: value_type > :: value ||
                    T0_TypeId == 0,
                "All segments must have the same value_type" );
  inline __attribute__ ( ( always_inline ) ) TypedIndexSet ( );
  inline __attribute__ ( ( always_inline ) )
  TypedIndexSet ( TypedIndexSet < T0, TREST ... > const & c )
      ;
  TypedIndexSet < T0, TREST ... > & operator = ( const TypedIndexSet < T0, TREST ... > & rhs )
  ;
  inline __attribute__ ( ( always_inline ) ) ~ TypedIndexSet ( )
  ;
  void swap ( TypedIndexSet < T0, TREST ... > & other )
  ;
  template < typename P0, typename ... PREST >
  inline __attribute__ ( ( always_inline ) ) bool compareSegmentById (
      size_t segid,
      const TypedIndexSet < P0, PREST ... > & other ) const
  {
    if ( getSegmentTypes ( ) [ segid ] != T0_TypeId ) {
      return PARENT :: compareSegmentById ( segid, other );
    }
    if ( ! other . template checkSegmentType < T0 > ( segid ) ) {
      return false;
    }
    Index_type offset = getSegmentOffsets ( ) [ segid ];
    return * data [ offset ] == other . template getSegment < T0 > ( segid );
  }
  template < typename P0 >
  inline __attribute__ ( ( always_inline ) ) bool checkSegmentType ( size_t segid ) const
  {
    if ( getSegmentTypes ( ) [ segid ] == T0_TypeId ) {
      return std :: is_same < T0, P0 > :: value;
    }
    return PARENT :: template checkSegmentType < P0 > ( segid );
  }
  template < typename P0 >
  inline __attribute__ ( ( always_inline ) ) P0 & getSegment ( size_t segid )
  {
    if ( getSegmentTypes ( ) [ segid ] == T0_TypeId ) {
      Index_type offset = getSegmentOffsets ( ) [ segid ];
      return * reinterpret_cast < P0 const * > ( data [ offset ] );
    }
    return PARENT :: template getSegment < P0 > ( segid );
  }
  template < typename P0 >
  inline __attribute__ ( ( always_inline ) ) P0 const & getSegment ( size_t segid ) const
  {
    if ( getSegmentTypes ( ) [ segid ] == T0_TypeId ) {
      Index_type offset = getSegmentOffsets ( ) [ segid ];
      return * reinterpret_cast < P0 const * > ( data [ offset ] );
    }
    return PARENT :: template getSegment < P0 > ( segid );
  }
  inline __attribute__ ( ( always_inline ) )
  constexpr size_t getNumTypes ( ) const;
private :
  template < typename ... CALL >
  inline __attribute__ ( ( always_inline ) ) void push_into ( TypedIndexSet < CALL ... > & c,
                             PushEnd pend = PUSH_BACK,
                             PushCopy pcopy = PUSH_COPY )
  {
    Index_type num = getNumSegments ( );
    if ( pend == PUSH_BACK ) {
      for ( Index_type i = 0; i < num; ++ i ) {
        segment_push_into ( i, c, pend, pcopy );
      }
    } else {
      for ( Index_type i = num - 1; i > - 1; -- i ) {
        segment_push_into ( i, c, pend, pcopy );
      }
    }
  }
  static constexpr int value_for ( PushEnd end, PushCopy copy )
  ;
public :
  template < typename ... CALL >
  inline __attribute__ ( ( always_inline ) ) void segment_push_into ( size_t segid,
                                     TypedIndexSet < CALL ... > & c,
                                     PushEnd pend = PUSH_BACK,
                                     PushCopy pcopy = PUSH_COPY )
  {
    if ( getSegmentTypes ( ) [ segid ] != T0_TypeId ) {
      PARENT :: segment_push_into ( segid, c, pend, pcopy );
      return;
    }
    Index_type offset = getSegmentOffsets ( ) [ segid ];
    switch ( value_for ( pend, pcopy ) ) {
      case value_for ( PUSH_BACK, PUSH_COPY ) :
        c . push_back ( * data [ offset ] );
        break;
      case value_for ( PUSH_BACK, PUSH_NOCOPY ) :
        c . push_back_nocopy ( data [ offset ] );
        break;
      case value_for ( PUSH_FRONT, PUSH_COPY ) :
        c . push_front ( * data [ offset ] );
        break;
      case value_for ( PUSH_FRONT, PUSH_NOCOPY ) :
        c . push_front_nocopy ( data [ offset ] );
        break;
    }
  }
  template < typename Tnew >
  inline __attribute__ ( ( always_inline ) ) void push_back_nocopy ( Tnew * val )
  {
    push_internal ( val, PUSH_BACK, PUSH_NOCOPY );
  }
  template < typename Tnew >
  inline __attribute__ ( ( always_inline ) ) void push_front_nocopy ( Tnew * val )
  {
    push_internal ( val, PUSH_FRONT, PUSH_NOCOPY );
  }
  template < typename Tnew >
  inline __attribute__ ( ( always_inline ) ) void push_back ( Tnew const & val )
  {
    push_internal ( new Tnew ( val ), PUSH_BACK, PUSH_COPY );
  }
  template < typename Tnew >
  inline __attribute__ ( ( always_inline ) ) void push_front ( Tnew const & val )
  {
    push_internal ( new Tnew ( val ), PUSH_FRONT, PUSH_COPY );
  }
  inline __attribute__ ( ( always_inline ) ) size_t getLength ( ) const
  ;
  inline __attribute__ ( ( always_inline ) ) constexpr size_t getNumSegments ( ) const
  ;
  template < typename BODY, typename ... ARGS >
  void segmentCall ( size_t segid,
                                    BODY && body,
                                    ARGS && ... args ) const
  {
    if ( getSegmentTypes ( ) [ segid ] != T0_TypeId ) {
      PARENT :: segmentCall ( segid,
                          std :: forward < BODY > ( body ),
                          std :: forward < ARGS > ( args ) ... );
      return;
    }
    Index_type offset = getSegmentOffsets ( ) [ segid ];
    body ( * data [ offset ], std :: forward < ARGS > ( args ) ... );
  }
protected :
  template < typename Tnew >
  inline __attribute__ ( ( always_inline ) ) void push_internal ( Tnew * val,
                                 PushEnd pend = PUSH_BACK,
                                 PushCopy pcopy = PUSH_COPY )
  {
    static_assert ( sizeof ... ( TREST ) > 0, "Invalid type for this TypedIndexSet" );
    PARENT :: push_internal ( val, pend, pcopy );
  }
  inline __attribute__ ( ( always_inline ) ) void push_internal ( T0 * val,
                                 PushEnd pend = PUSH_BACK,
                                 PushCopy pcopy = PUSH_COPY )
  ;
  inline __attribute__ ( ( always_inline ) ) Index_type & getTotalLength ( );
  inline __attribute__ ( ( always_inline ) ) void setTotalLength ( int n );
  inline __attribute__ ( ( always_inline ) ) void increaseTotalLength ( int n )
  ;
public :
  using iterator = Iterators :: numeric_iterator < Index_type >;
  iterator end ( ) const;
  iterator begin ( ) const;
  Index_type size ( ) const;
  TypedIndexSet < T0, TREST ... > createSlice ( int begin, int end )
  ;
  TypedIndexSet < T0, TREST ... > createSlice ( const int * segIds, int len )
  ;
  template < typename T >
  TypedIndexSet < T0, TREST ... > createSlice ( const T & segIds )
  {
    TypedIndexSet < T0, TREST ... > retVal;
    int numSeg = getNumSegments ( );
    for ( auto & seg : segIds ) {
      if ( seg >= 0 && seg < numSeg ) {
        segment_push_into ( seg, retVal, PUSH_BACK, PUSH_NOCOPY );
      }
    }
    return retVal;
  }
  void setSegmentInterval ( size_t interval_id, int begin, int end )
  ;
  int getSegmentIntervalBegin ( size_t interval_id ) const
  ;
  int getSegmentIntervalEnd ( size_t interval_id ) const
  ;
protected :
  inline __attribute__ ( ( always_inline ) ) RAJA :: RAJAVec < Index_type > & getSegmentTypes ( )
  ;
  inline __attribute__ ( ( always_inline ) ) RAJA :: RAJAVec < Index_type > const & getSegmentTypes ( ) const
  ;
  inline __attribute__ ( ( always_inline ) ) RAJA :: RAJAVec < Index_type > & getSegmentOffsets ( )
  ;
  inline __attribute__ ( ( always_inline ) ) RAJA :: RAJAVec < Index_type > const & getSegmentOffsets ( ) const
  ;
  inline __attribute__ ( ( always_inline ) ) RAJA :: RAJAVec < Index_type > & getSegmentIcounts ( )
  ;
  inline __attribute__ ( ( always_inline ) ) RAJA :: RAJAVec < Index_type > const & getSegmentIcounts ( ) const
  ;
public :
  template < typename P0, typename ... PREST >
  inline __attribute__ ( ( always_inline ) ) bool operator == ( const TypedIndexSet < P0, PREST ... > & other ) const
  {
    size_t num_seg = getNumSegments ( );
    if ( num_seg != other . getNumSegments ( ) ) return false;
    for ( size_t segid = 0; segid < num_seg; ++ segid ) {
      if ( ! compareSegmentById ( segid, other ) ) {
        return false;
      }
    }
    return true;
  }
  template < typename P0, typename ... PREST >
  inline __attribute__ ( ( always_inline ) ) bool operator != ( const TypedIndexSet < P0, PREST ... > & other ) const
  {
    return ( ! ( * this == other ) );
  }
private :
  RAJA :: RAJAVec < T0 * > data;
  RAJA :: RAJAVec < Index_type > owner;
  RAJA :: RAJAVec < Index_type > m_seg_interval_begin;
  RAJA :: RAJAVec < Index_type > m_seg_interval_end;
};
template<> class TypedIndexSet<   > 
{
using value_type = Index_type ;

public: inline TypedIndexSet() : m_len(0)
{
}

inline ~TypedIndexSet()
{
}

inline TypedIndexSet(const class TypedIndexSet<   > &c)
{
(this) -> segment_types = c . segment_types;
(this) -> segment_offsets = c . segment_offsets;
(this) -> segment_icounts = c . segment_icounts;
(this) -> m_len = c . m_len;
}

inline void swap(class TypedIndexSet<   > &other)
{
using std::swap;
::std::swap((this) -> segment_types,other . segment_types);
::std::swap((this) -> segment_offsets,other . segment_offsets);
::std::swap((this) -> segment_icounts,other . segment_icounts);
::std::swap((this) -> m_len,other . m_len);
}

protected: inline static size_t getNumTypes()
{
return 0;
}
template < typename T >
  inline __attribute__ ( ( always_inline ) ) constexpr bool isValidSegmentType ( T const & ) const
  {
    return false;
  }

inline static int getNumSegments()
{
return 0;
}

inline static size_t getLength()
{
return 0;
}
template < typename BODY, typename ... ARGS >
  inline __attribute__ ( ( always_inline ) ) void segmentCall ( size_t, BODY, ARGS ... ) const
  {
  }

inline class RAJAVec< Index_type  , class ::std::allocator< Index_type  >  > &getSegmentTypes()
{
return (this) -> segment_types;
}

inline const class RAJAVec< Index_type  , class ::std::allocator< Index_type  >  > &getSegmentTypes() const
{
return (this) -> segment_types;
}

inline class RAJAVec< Index_type  , class ::std::allocator< Index_type  >  > &getSegmentOffsets()
{
return (this) -> segment_offsets;
}

inline const class RAJAVec< Index_type  , class ::std::allocator< Index_type  >  > &getSegmentOffsets() const
{
return (this) -> segment_offsets;
}

inline class RAJAVec< Index_type  , class ::std::allocator< Index_type  >  > &getSegmentIcounts()
{
return (this) -> segment_icounts;
}

inline const class RAJAVec< Index_type  , class ::std::allocator< Index_type  >  > &getSegmentIcounts() const
{
return (this) -> segment_icounts;
}

inline Index_type &getTotalLength()
{
return (this) -> m_len;
}

inline void setTotalLength(int n)
{
(this) -> m_len = n;
}

inline void increaseTotalLength(int n)
{
(this) -> m_len += n;
}
template < typename P0, typename ... PREST >
  inline __attribute__ ( ( always_inline ) ) bool compareSegmentById ( size_t,
                                      const TypedIndexSet < P0, PREST ... > & ) const
  {
    return false;
  }
template < typename P0 >
  inline __attribute__ ( ( always_inline ) ) bool checkSegmentType ( size_t ) const
  {
    return false;
  }
template < typename P0 >
  inline __attribute__ ( ( always_inline ) ) P0 & getSegment ( size_t )
  {
    return * ( ( P0 * ) ( this - this ) );
  }
template < typename P0 >
  inline __attribute__ ( ( always_inline ) ) P0 const & getSegment ( size_t ) const
  {
    return * ( ( P0 * ) ( this - this ) );
  }
template < typename ... CALL >
  inline __attribute__ ( ( always_inline ) ) void push_into ( TypedIndexSet < CALL ... > &, PushEnd, PushCopy ) const
  {
  }
template < typename ... CALL >
  inline __attribute__ ( ( always_inline ) ) void segment_push_into ( size_t,
                                     TypedIndexSet < CALL ... > &,
                                     PushEnd,
                                     PushCopy ) const
  {
  }
template < typename Tnew >
  inline __attribute__ ( ( always_inline ) ) void push ( Tnew const &, PushEnd, PushCopy )
  {
  }
using iterator = class Iterators::numeric_iterator< Index_type  , Index_type  , Index_type * > ;

public: inline int getStartingIcount(int segid)
{
return ((this) -> segment_icounts[segid]);
}

inline int getStartingIcount(int segid) const
{
return ((this) -> segment_icounts[segid]);
}

inline iterator end() const
{
return Iterators::numeric_iterator< Index_type ,Index_type ,Index_type *> (((Iterators::numeric_iterator< Index_type ,Index_type ,Index_type *> ::stripped_value_type )(getNumSegments())));
}

inline iterator begin() const
{
return Iterators::numeric_iterator< Index_type ,Index_type ,Index_type *> (0);
}

inline Index_type size() const
{
return (getNumSegments());
}
private: class RAJAVec< Index_type  , class ::std::allocator< Index_type  >  > segment_types;
class RAJAVec< Index_type  , class ::std::allocator< Index_type  >  > segment_offsets;
class RAJAVec< Index_type  , class ::std::allocator< Index_type  >  > segment_icounts;
Index_type m_len;
};
namespace type_traits
{
template < typename T >
struct is_index_set
    : :: RAJA :: type_traits :: SpecializationOf < RAJA :: TypedIndexSet, typename std :: decay < T > :: type > {
};
template < typename T >
struct is_indexset_policy
    : :: RAJA :: type_traits :: SpecializationOf < RAJA :: ExecPolicy, typename std :: decay < T > :: type > {
};
}
}
namespace RAJA
{
namespace internal
{
template < typename T >
class has_privatizer
{
private :
  template < typename C >
  static auto Test ( void * )
      -> decltype ( camp :: val < typename C :: privatizer > ( ), camp :: true_type { } );
  template < typename >
  static camp :: false_type Test ( ... );
public :
  static bool const value = decltype ( Test < T > ( 0 ) ) :: value;
};
}
namespace RAJA
{
namespace internal
{
template < typename Policy, typename Types >
struct StatementExecutor;
template < typename ... Stmts >
using StatementList = camp :: list < Stmts ... >;
template < camp :: idx_t idx, camp :: idx_t N, typename StmtList, typename Types >
struct StatementListExecutor;
template < camp :: idx_t statement_index,
          camp :: idx_t num_statements,
          typename StmtList, typename Types >
struct StatementListExecutor {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data && data )
  {
    using statement = camp :: at_v < StmtList, statement_index >;
    StatementExecutor < statement, Types > :: exec ( std :: forward < Data > ( data ) );
    StatementListExecutor < statement_index + 1, num_statements, StmtList, Types > :: exec (
        std :: forward < Data > ( data ) );
  }
};
template < camp :: idx_t num_statements, typename StmtList, typename Types >
struct StatementListExecutor < num_statements, num_statements, StmtList, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data && )
  {
  }
};
template < typename StmtList, typename Types, typename Data >
inline __attribute__ ( ( always_inline ) ) void execute_statement_list ( Data && data )
{
  StatementListExecutor < 0, camp :: size < StmtList > :: value, StmtList, Types > :: exec (
      std :: forward < Data > ( data ) );
}
}
}
namespace RAJA
{
namespace internal
{

struct ForList 
{
}
;

struct ForBase 
{
}
;

struct CollapseBase 
{
}
;
template < camp :: idx_t ArgumentId, typename Policy >
  struct ForTraitBase : public ForBase {
    constexpr static camp :: idx_t index_val = ArgumentId;
    using index = camp :: num < ArgumentId >;
    using index_type = camp :: nil;
    using policy_type = Policy;
    using type = ForTraitBase;
  };
template < typename Iterator >
struct iterable_difftype_getter {
  using type = typename std :: iterator_traits <
      typename Iterator :: iterator > :: difference_type;
};
template < typename Segments >
using difftype_list_from_segments =
    typename camp :: transform < iterable_difftype_getter, Segments > :: type;
template < typename Segments >
using difftype_tuple_from_segments =
    typename camp :: apply_l < camp :: lambda < camp :: tuple >,
                           difftype_list_from_segments < Segments >> :: type;
template < typename Iterator >
struct iterable_value_type_getter {
  using type =
      typename std :: iterator_traits < typename Iterator :: iterator > :: value_type;
};
template < typename Segments >
using value_type_list_from_segments =
    typename camp :: transform < iterable_value_type_getter, Segments > :: type;
template < typename Segments >
using index_tuple_from_segments =
    typename camp :: apply_l < camp :: lambda < camp :: tuple >,
                           value_type_list_from_segments < Segments >> :: type;
template < typename SegmentTuple,
          typename ParamTuple,
          typename ... Bodies >
struct LoopData {
  using Self = LoopData < SegmentTuple, ParamTuple, Bodies ... >;
  using offset_tuple_t =
      difftype_tuple_from_segments < typename SegmentTuple :: TList >;
  using index_tuple_t = index_tuple_from_segments < typename SegmentTuple :: TList >;
  using segment_tuple_t = SegmentTuple;
  SegmentTuple segment_tuple;
  using param_tuple_t = ParamTuple;
  ParamTuple param_tuple;
  using BodiesTuple = camp :: tuple < Bodies ... >;
  const BodiesTuple bodies;
  offset_tuple_t offset_tuple;
  inline __attribute__ ( ( always_inline ) )
  LoopData ( SegmentTuple const & s, ParamTuple const & p, Bodies const & ... b )
      ;
  template < typename SegmentTuple0,
            typename ParamTuple0,
            typename ... Bodies0 >
  inline __attribute__ ( ( always_inline ) ) constexpr LoopData (
      LoopData < SegmentTuple0, ParamTuple0, Bodies0 ... > & c )
      : segment_tuple ( c . segment_tuple ),
        param_tuple ( c . param_tuple ),
        bodies ( c . bodies ),
        offset_tuple ( c . offset_tuple )
  {
  }
  template < camp :: idx_t Idx, typename IndexT >
  inline __attribute__ ( ( always_inline ) ) void assign_offset ( IndexT const & i )
  {
    camp :: get < Idx > ( offset_tuple ) = i;
  }
  template < typename ParamId, typename IndexT >
  inline __attribute__ ( ( always_inline ) ) void assign_param ( IndexT const & i )
  {
    using param_t = camp :: at_v < typename param_tuple_t :: TList, ParamId :: param_idx >;
    camp :: get < ParamId :: param_idx > ( param_tuple ) = param_t ( i );
  }
  template < typename ParamId >
  inline __attribute__ ( ( always_inline ) )
  auto get_param ( ) ->
    camp :: at_v < typename param_tuple_t :: TList, ParamId :: param_idx >
  {
    return camp :: get < ParamId :: param_idx > ( param_tuple );
  }
};
template < camp :: idx_t ArgumentId, typename Data >
inline __attribute__ ( ( always_inline ) ) auto segment_length ( Data const & data ) ->
    typename std :: iterator_traits <
        typename camp :: at_v < typename Data :: segment_tuple_t :: TList,
                            ArgumentId > :: iterator > :: difference_type
{
  return camp :: get < ArgumentId > ( data . segment_tuple ) . end ( ) -
         camp :: get < ArgumentId > ( data . segment_tuple ) . begin ( );
}
template < typename Data, typename Types, typename ... EnclosedStmts >
struct GenericWrapper : GenericWrapperBase {
  using data_t = camp :: decay < Data >;
  data_t & data;
  inline __attribute__ ( ( always_inline ) )
  constexpr explicit GenericWrapper ( data_t & d );
  inline __attribute__ ( ( always_inline ) )
  void exec ( );
};
template < typename T >
struct NestedPrivatizer {
  using data_t = typename T :: data_t;
  using value_type = camp :: decay < T >;
  using reference_type = value_type &;
  data_t privatized_data;
  value_type privatized_wrapper;
  inline __attribute__ ( ( always_inline ) )
  constexpr NestedPrivatizer ( const T & o )
      ;
  inline __attribute__ ( ( always_inline ) )
  reference_type get_priv ( );
};
}
}
namespace RAJA
{
namespace internal
{
namespace detail
{
template < typename T, camp :: idx_t >
struct SeqToType
{
  using type = T;
};
template < typename T, typename SEQ >
struct ListOfNHelper;
template < typename T, camp :: idx_t ... SEQ >
struct ListOfNHelper < T, camp :: idx_seq < SEQ ... > >
{
  using type = camp :: list < typename SeqToType < T, SEQ > :: type ... >;
};
}
template < typename T, camp :: idx_t N >
using list_of_n = typename detail :: ListOfNHelper < T, camp :: make_idx_seq_t < N >> :: type;
template < typename SegmentTypes,
          typename OffsetTypes >
struct LoopTypes;
template < typename ... SegmentTypes,
          typename ... OffsetTypes >
struct LoopTypes < camp :: list < SegmentTypes ... >, camp :: list < OffsetTypes ... > > {
  using Self = LoopTypes < camp :: list < SegmentTypes ... >, camp :: list < OffsetTypes ... >>;
  static constexpr size_t s_num_segments = sizeof ... ( SegmentTypes );
  static_assert ( s_num_segments == sizeof ... ( OffsetTypes ),
      "Number of segments and offsets must match" );
  using segment_types_t = camp :: list < SegmentTypes ... >;
  using offset_types_t = camp :: list < OffsetTypes ... >;
};
template < typename Data >
using makeInitialLoopTypes =
    LoopTypes < list_of_n < void, camp :: tuple_size < typename Data :: segment_tuple_t > :: value >,
              list_of_n < void, camp :: tuple_size < typename Data :: segment_tuple_t > :: value >>;
template < typename Types, camp :: idx_t Segment, typename T, typename Seq >
struct SetSegmentTypeHelper;
template < typename Types,
         camp :: idx_t Segment,
         typename T,
         camp :: idx_t ... SEQ >
struct SetSegmentTypeHelper < Types, Segment, T, camp :: idx_seq < SEQ ... > >
{
    using segment_list = typename Types :: segment_types_t;
    using offset_list = typename Types :: offset_types_t;
    static_assert ( std :: is_same < camp :: at_v < segment_list, Segment >, void > :: value,
        "Segment was already assigned: Probably looping over same segment in loop nest" );
    using type = LoopTypes <
        camp :: list < typename std :: conditional < SEQ == Segment, T, camp :: at_v < segment_list, SEQ >> :: type ... >,
        camp :: list < typename std :: conditional < SEQ == Segment, T, camp :: at_v < segment_list, SEQ >> :: type ... >>;
};
template < typename Types, camp :: idx_t Segment, typename T >
using setSegmentType =
    typename SetSegmentTypeHelper < Types, Segment, T, camp :: make_idx_seq_t < Types :: s_num_segments >> :: type;
template < typename Types, camp :: idx_t Segment, typename Data >
using setSegmentTypeFromData =
    setSegmentType < Types, Segment, camp :: at_v < typename camp :: decay < Data > :: index_tuple_t :: TList, Segment >>;
}
}
namespace RAJA
{
namespace internal
{
template < typename ExecPolicy, typename ... EnclosedStmts >
struct Statement {
  Statement ( ) = delete;
  using enclosed_statements_t = StatementList < EnclosedStmts ... >;
  using execution_policy_t = ExecPolicy;
};
template < typename Policy, typename Types >
struct StatementExecutor;
}
}
namespace RAJA
{
namespace policy
{
namespace multi
{
template < typename Selector, typename ... Policies >
class MultiPolicy;
}
}
namespace detail
{

struct max_platform 
{

constexpr inline camp::resources::v1::Platform operator()(const enum class camp::resources::v1::Platform &l,const enum class camp::resources::v1::Platform &r) const
{
return l > r?l : r;
}
}
;
template < typename T, typename = void >
struct get_platform {
  static constexpr Platform value = Platform :: undefined;
};
template < typename ... Policies >
struct get_platform_from_list {
  static constexpr Platform value =
      foldl ( max_platform ( ), get_platform < Policies > :: value ... );
};
template<> struct ::RAJA::detail::get_platform_from_list<   > 
{
constexpr static enum class camp::resources::v1::Platform value = camp::resources::v1::Platform(0);
};
template < typename T >
struct get_platform < T,
                    typename std ::
                        enable_if < std :: is_base_of < RAJA :: PolicyBase, T > :: value
                                  && ! RAJA :: type_traits :: is_indexset_policy < T > ::
                                         value > :: type > {
  static constexpr Platform value = T :: platform;
};
template < typename SEG, typename EXEC >
struct get_platform < RAJA :: ExecPolicy < SEG, EXEC > >
    : public get_platform_from_list < SEG, EXEC > {
};
template < typename T >
struct get_statement_platform {
  static constexpr Platform value =
      get_platform_from_list < typename T :: execution_policy_t,
                             typename T :: enclosed_statements_t > :: value;
};
template < typename ... Stmts >
struct get_platform < RAJA :: internal :: StatementList < Stmts ... > > {
  static constexpr Platform value =
      foldl ( max_platform ( ), get_statement_platform < Stmts > :: value ... );
};
template<> struct ::RAJA::detail::get_platform< internal::StatementList<   >  , void  > 
{
constexpr static enum class camp::resources::v1::Platform value = camp::resources::v1::Platform(0);
};
template < typename SELECTOR, typename ... POLICIES >
struct get_platform < RAJA :: policy :: multi :: MultiPolicy < SELECTOR, POLICIES ... > > {
  static constexpr Platform value = Platform :: undefined;
};
}
}
namespace RAJA
{
namespace util
{

struct PluginContext 
{

inline PluginContext(const enum class camp::resources::v1::Platform p) : platform(p)
{
}
enum class camp::resources::v1::Platform platform;
}
;
template < typename Policy >
PluginContext make_context ( )
{
  return PluginContext { detail :: get_platform < Policy > :: value };
}
}
}
namespace RAJA
{
namespace util
{
template < typename T >
  class RegistryEntry {
    std :: string Name, Desc;
    std :: shared_ptr < T > object;
  public :
    RegistryEntry ( const std :: string & N, const std :: string & D,
        std :: shared_ptr < T > ( * C ) ( ) )
        ;
    const std :: string & getName ( ) const;
    const std :: string & getDesc ( ) const;
    std :: shared_ptr < T > get ( ) const;
  };
template < typename T >
  class Registry {
  public :
    using type = T;
    using entry = RegistryEntry < T >;
    class node;
    class iterator;
  private :
    Registry ( ) = delete;
    friend class node;
    static node * Head, * Tail;
  public :
    class node {
      friend class iterator;
      friend Registry < T >;
      node * Next;
      const entry & Val;
    public :
      node ( const entry & V );
    };
    static void add_node ( node * N );
    class iterator {
      const node * Cur;
    public :
      explicit iterator ( const node * N );
      bool operator == ( const iterator & That ) const;
      bool operator != ( const iterator & That ) const;
      iterator & operator ++ ( );
      const entry & operator * ( ) const;
      const entry * operator -> ( ) const;
    };
    static iterator begin ( );
    static iterator end ( );
    template < typename V >
    class Add {
      entry Entry;
      node Node;
      static std :: shared_ptr < T > CtorFn ( );
    public :
      Add ( const std :: string & Name, const std :: string & Desc )
          ;
    };
  };
}
}
namespace RAJA
{
namespace util
{

class PluginStrategy 
{
public: PluginStrategy();

virtual inline ~PluginStrategy()
{
}
virtual void preLaunch(struct PluginContext p) = 0;
virtual void postLaunch(struct PluginContext p) = 0;
}
;
using PluginRegistry = class Registry< PluginStrategy  > ;
}
}
namespace RAJA
{
namespace util
{

inline void  __attribute__((no_throw)) callPreLaunchPlugins(struct PluginContext p)
{
for (auto plugin = Registry< PluginStrategy > ::begin(); plugin != Registry< PluginStrategy > ::end();  ++ plugin) {
(( * plugin) . get()) ->  preLaunch (p);
}
}

inline void  __attribute__((no_throw)) callPostLaunchPlugins(struct PluginContext p)
{
for (auto plugin = Registry< PluginStrategy > ::begin(); plugin != Registry< PluginStrategy > ::end();  ++ plugin) {
(( * plugin) . get()) ->  postLaunch (p);
}
}
}
}
namespace RAJA
{
namespace policy
{
namespace sequential
{
struct seq_region ;

struct seq_region : public PolicyBaseT< Policy(1) , Pattern(2) , Launch(1) , camp::resources::v1::Platform(1) > 
{
}
;
struct seq_exec ;

struct seq_exec : public PolicyBaseT< Policy(1) , Pattern(1) , Launch(0) , camp::resources::v1::Platform(1) > 
{
}
;
using seq_segit = struct seq_exec ;

struct seq_reduce : public PolicyBaseT< Policy(1) , Pattern(1) , Launch(0) , camp::resources::v1::Platform(1) > 
{
}
;
}
}
using RAJA::RAJA::policy::sequential::seq_exec;
using RAJA::RAJA::policy::sequential::seq_reduce;
using RAJA::RAJA::policy::sequential::seq_region;
using RAJA::RAJA::policy::sequential::seq_segit;
}
namespace RAJA
{
namespace policy
{
namespace sequential
{
template < typename Iterable, typename Func >
        inline __attribute__ ( ( always_inline ) ) void forall_impl ( const seq_exec &, Iterable && iter, Func && body )
        {
          using std :: begin; using std :: end; using std :: distance; auto begin_it = begin ( iter ); auto end_it = end ( iter ); auto distance_it = distance ( begin_it, end_it );
          for ( decltype ( distance_it ) i = 0; i < distance_it; ++ i ) {
            body ( * ( begin_it + i ) );
          }
        }
}
}
}
namespace RAJA
{
namespace internal
{
template < typename T >
auto trigger_updates_before ( T && item ) -> typename std :: remove_reference < T > :: type
{
  return item;
}
}
namespace detail
{
template < typename Range, typename Body, typename IndexT >
struct icount_adapter {
  using index_type = typename std :: decay < IndexT > :: type;
  typename std :: decay < Body > :: type body;
  using container_type = typename std :: decay < Range > :: type;
  typename container_type :: iterator begin_it;
  Index_type icount;
  icount_adapter ( Range const & r, Body const & b, IndexT icount_ )
      ;
  template < typename T >
  void operator ( ) ( T const & i ) const
  {
    body ( static_cast < index_type > ( i + icount ), begin_it [ i ] );
  }
};

struct CallForall 
{
template < typename T, typename ExecPol, typename Body >
  inline __attribute__ ( ( always_inline ) ) void operator ( ) ( T const &, ExecPol, Body ) const;
}
;

struct CallForallIcount 
{
constexpr inline CallForallIcount(int s);
template < typename T, typename ExecPol, typename Body >
  inline __attribute__ ( ( always_inline ) ) void operator ( ) ( T const &, ExecPol, Body ) const;
const int start;
}
;
}
namespace wrap
{
template < typename ExecutionPolicy, typename Container, typename LoopBody >
inline __attribute__ ( ( always_inline ) ) concepts :: enable_if <
    concepts :: negate < type_traits :: is_indexset_policy < ExecutionPolicy > >,
    type_traits :: is_range < Container > >
forall ( ExecutionPolicy && p, Container && c, LoopBody && loop_body )
{
  using RAJA :: internal :: trigger_updates_before;
  auto body = trigger_updates_before ( loop_body );
  forall_impl ( std :: forward < ExecutionPolicy > ( p ),
              std :: forward < Container > ( c ),
              body );
}
template < typename ExecutionPolicy,
          typename Container,
          typename IndexType,
          typename LoopBody >
inline __attribute__ ( ( always_inline ) ) void forall_Icount ( ExecutionPolicy && p,
                               Container && c,
                               IndexType && icount,
                               LoopBody && loop_body )
{
  using RAJA :: internal :: trigger_updates_before;
  auto body = trigger_updates_before ( loop_body );
  using std :: begin;
  using std :: distance;
  using std :: end;
  auto range = RangeSegment ( 0, distance ( begin ( c ), end ( c ) ) );
  detail :: icount_adapter < Container, LoopBody, IndexType > adapted ( c,
                                                                 body,
                                                                 icount );
  using policy :: sequential :: forall_impl;
  forall_impl ( std :: forward < ExecutionPolicy > ( p ), range, adapted );
}
template < typename SegmentIterPolicy,
          typename SegmentExecPolicy,
          typename ... SegmentTypes,
          typename LoopBody >
inline __attribute__ ( ( always_inline ) ) void forall_Icount ( ExecPolicy < SegmentIterPolicy, SegmentExecPolicy >,
                               const TypedIndexSet < SegmentTypes ... > & iset,
                               LoopBody loop_body )
{
  using RAJA :: internal :: trigger_updates_before;
  auto body = trigger_updates_before ( loop_body );
  wrap :: forall ( SegmentIterPolicy ( ), iset, [ = ] ( int segID ) {
    iset . segmentCall ( segID,
                     detail :: CallForallIcount ( iset . getStartingIcount ( segID ) ),
                     SegmentExecPolicy ( ),
                     body );
  } );
}
template < typename SegmentIterPolicy,
          typename SegmentExecPolicy,
          typename LoopBody,
          typename ... SegmentTypes >
inline __attribute__ ( ( always_inline ) ) void forall ( ExecPolicy < SegmentIterPolicy, SegmentExecPolicy >,
                        const TypedIndexSet < SegmentTypes ... > & iset,
                        LoopBody loop_body )
{
  using RAJA :: internal :: trigger_updates_before;
  auto body = trigger_updates_before ( loop_body );
  wrap :: forall ( SegmentIterPolicy ( ), iset, [ = ] ( int segID ) {
    iset . segmentCall ( segID, detail :: CallForall { }, SegmentExecPolicy ( ), body );
  } );
}
}
template < typename ExecutionPolicy, typename IdxSet, typename LoopBody >
inline __attribute__ ( ( always_inline ) ) void forall_Icount ( ExecutionPolicy && p,
                               IdxSet && c,
                               LoopBody && loop_body )
{
  static_assert ( type_traits :: is_index_set < IdxSet > :: value,
                "Expected a TypedIndexSet but did not get one. Are you using a TypedIndexSet policy by mistake\?"
                                                    );
  util :: PluginContext context { util :: make_context < ExecutionPolicy > ( ) };
  util :: callPreLaunchPlugins ( context );
  wrap :: forall_Icount ( std :: forward < ExecutionPolicy > ( p ),
                      std :: forward < IdxSet > ( c ),
                      std :: forward < LoopBody > ( loop_body ) );
  util :: callPostLaunchPlugins ( context );
}
template < typename ExecutionPolicy, typename IdxSet, typename LoopBody >
inline __attribute__ ( ( always_inline ) ) concepts :: enable_if <
    type_traits :: is_indexset_policy < ExecutionPolicy > >
forall ( ExecutionPolicy && p, IdxSet && c, LoopBody && loop_body )
{
  static_assert ( type_traits :: is_index_set < IdxSet > :: value,
                "Expected a TypedIndexSet but did not get one. Are you using a TypedIndexSet policy by mistake\?"
                                                    );
  util :: PluginContext context { util :: make_context < ExecutionPolicy > ( ) };
  util :: callPreLaunchPlugins ( context );
  wrap :: forall ( std :: forward < ExecutionPolicy > ( p ),
               std :: forward < IdxSet > ( c ),
               std :: forward < LoopBody > ( loop_body ) );
  util :: callPostLaunchPlugins ( context );
}
template < typename ExecutionPolicy,
          typename Container,
          typename IndexType,
          typename LoopBody >
inline __attribute__ ( ( always_inline ) ) concepts :: enable_if < type_traits :: is_range < Container >,
                                type_traits :: is_integral < IndexType > >
forall_Icount ( ExecutionPolicy && p,
              Container && c,
              IndexType icount,
              LoopBody && loop_body )
{
  static_assert ( type_traits :: is_random_access_range < Container > :: value,
                "Container does not model RandomAccessIterator" );
  util :: PluginContext context { util :: make_context < ExecutionPolicy > ( ) };
  util :: callPreLaunchPlugins ( context );
  wrap :: forall_Icount ( std :: forward < ExecutionPolicy > ( p ),
                      std :: forward < Container > ( c ),
                      icount,
                      std :: forward < LoopBody > ( loop_body ) );
  util :: callPostLaunchPlugins ( context );
}
template < typename ExecutionPolicy, typename Container, typename LoopBody >
inline __attribute__ ( ( always_inline ) ) concepts :: enable_if <
    concepts :: negate < type_traits :: is_indexset_policy < ExecutionPolicy > >,
    type_traits :: is_range < Container > >
forall ( ExecutionPolicy && p, Container && c, LoopBody && loop_body )
{
  static_assert ( type_traits :: is_random_access_range < Container > :: value,
                "Container does not model RandomAccessIterator" );
  util :: PluginContext context { util :: make_context < ExecutionPolicy > ( ) };
  util :: callPreLaunchPlugins ( context );
  wrap :: forall ( std :: forward < ExecutionPolicy > ( p ),
               std :: forward < Container > ( c ),
               std :: forward < LoopBody > ( loop_body ) );
  util :: callPostLaunchPlugins ( context );
}
template < typename ExecutionPolicy,
          typename ArrayIdxType,
          typename IndexType,
          typename LoopBody >
inline __attribute__ ( ( always_inline ) ) concepts :: enable_if <
    type_traits :: is_integral < IndexType >,
    concepts :: negate < type_traits :: is_iterator < IndexType > > >
forall ( ExecutionPolicy && p,
       const ArrayIdxType * idx,
       const IndexType len,
       LoopBody && loop_body )
{
  util :: PluginContext context { util :: make_context < ExecutionPolicy > ( ) };
  util :: callPreLaunchPlugins ( context );
  wrap :: forall ( std :: forward < ExecutionPolicy > ( p ),
               TypedListSegment < ArrayIdxType > ( idx, len, Unowned ),
               std :: forward < LoopBody > ( loop_body ) );
  util :: callPostLaunchPlugins ( context );
}
template < typename ExecutionPolicy,
          typename ArrayIdxType,
          typename IndexType,
          typename OffsetType,
          typename LoopBody >
inline __attribute__ ( ( always_inline ) ) concepts :: enable_if <
    type_traits :: is_integral < IndexType >,
    concepts :: negate < type_traits :: is_iterator < IndexType > >,
    type_traits :: is_integral < OffsetType >,
    concepts :: negate < type_traits :: is_iterator < OffsetType > >,
    type_traits :: is_integral < ArrayIdxType >,
    concepts :: negate < type_traits :: is_iterator < ArrayIdxType > > >
forall_Icount ( ExecutionPolicy && p,
              const ArrayIdxType * idx,
              const IndexType len,
              const OffsetType icount,
              LoopBody && loop_body )
{
  util :: PluginContext context { util :: make_context < ExecutionPolicy > ( ) };
  util :: callPreLaunchPlugins ( context );
  forall_Icount ( std :: forward < ExecutionPolicy > ( p ),
                TypedListSegment < ArrayIdxType > ( idx, len, Unowned ),
                icount,
                std :: forward < LoopBody > ( loop_body ) );
  util :: callPostLaunchPlugins ( context );
}
template < typename ExecutionPolicy, typename ... Args >
inline __attribute__ ( ( always_inline ) ) void forall ( Args && ... args )
{
  util :: PluginContext context { util :: make_context < ExecutionPolicy > ( ) };
  util :: callPreLaunchPlugins ( context );
  wrap :: forall ( ExecutionPolicy ( ), std :: forward < Args > ( args ) ... );
  util :: callPostLaunchPlugins ( context );
}
template < typename ExecutionPolicy, typename ... Args >
inline __attribute__ ( ( always_inline ) ) void forall_Icount ( Args && ... args )
{
  util :: PluginContext context { util :: make_context < ExecutionPolicy > ( ) };
  util :: callPreLaunchPlugins ( context );
  forall_Icount ( ExecutionPolicy ( ), std :: forward < Args > ( args ) ... );
  util :: callPostLaunchPlugins ( context );
}
namespace detail
{
template < typename T, typename ExecutionPolicy, typename LoopBody >
inline __attribute__ ( ( always_inline ) ) void CallForall :: operator ( ) ( T const & segment,
                                        ExecutionPolicy,
                                        LoopBody body ) const
{
  using policy :: sequential :: forall_impl;
  forall_impl ( ExecutionPolicy ( ), segment, body );
}

constexpr inline ::RAJA::detail::CallForallIcount::CallForallIcount(int s) : start(s)
{
}
template < typename T, typename ExecutionPolicy, typename LoopBody >
inline __attribute__ ( ( always_inline ) ) void CallForallIcount :: operator ( ) ( T const & segment,
                                              ExecutionPolicy,
                                              LoopBody body ) const
{
  wrap :: forall_Icount ( ExecutionPolicy ( ), segment, start, body );
}
}
}
namespace RAJA
{
template < typename ... Stmts >
using KernelPolicy = internal :: StatementList < Stmts ... >;
template < camp :: idx_t ... ArgumentId >
using ArgList = camp :: idx_seq < ArgumentId ... >;
template < typename T >
struct IterableWrapperTuple;
template < typename ... Ts >
struct IterableWrapperTuple < camp :: tuple < Ts ... > > {
  using type =
      camp :: tuple < RAJA :: Span < typename camp :: decay < Ts > :: iterator,
                             typename camp :: decay < Ts > :: IndexType > ... >;
};
namespace internal
{
template < class Tuple, camp :: idx_t ... I >
inline __attribute__ ( ( always_inline ) ) constexpr auto make_wrapped_tuple_impl ( Tuple && t,
                                                   camp :: idx_seq < I ... > )
    -> camp :: tuple < RAJA :: Span <
        typename camp :: decay <
            camp :: tuple_element_t < I, camp :: decay < Tuple > > > :: iterator,
        typename camp :: decay <
            camp :: tuple_element_t < I, camp :: decay < Tuple > > > :: IndexType > ... >
{
  return camp :: make_tuple (
      RAJA :: Span <
          typename camp :: decay <
              camp :: tuple_element_t < I, camp :: decay < Tuple >>> :: iterator,
          typename camp :: decay < camp :: tuple_element_t < I, camp :: decay < Tuple >>> ::
              IndexType > { camp :: get < I > ( std :: forward < Tuple > ( t ) ) . begin ( ),
                         camp :: get < I > ( std :: forward < Tuple > ( t ) ) . end ( ) } ... );
}
}
template < class Tuple >
inline __attribute__ ( ( always_inline ) ) constexpr auto make_wrapped_tuple ( Tuple && t )
    -> decltype ( internal :: make_wrapped_tuple_impl (
        std :: forward < Tuple > ( t ),
        camp :: make_idx_seq_t < camp :: tuple_size < camp :: decay < Tuple > > :: value > { } ) )
{
  return internal :: make_wrapped_tuple_impl (
      std :: forward < Tuple > ( t ),
      camp :: make_idx_seq_t < camp :: tuple_size < camp :: decay < Tuple >> :: value > { } );
}
template < typename PolicyType,
          typename SegmentTuple,
          typename ParamTuple,
          typename ... Bodies >
inline __attribute__ ( ( always_inline ) ) void kernel_param ( SegmentTuple && segments,
                              ParamTuple && params,
                              Bodies && ... bodies )
{
  util :: PluginContext context { util :: make_context < PolicyType > ( ) };
  util :: callPreLaunchPlugins ( context );
  using segment_tuple_t =
      typename IterableWrapperTuple < camp :: decay < SegmentTuple >> :: type;
  using param_tuple_t = camp :: decay < ParamTuple >;
  using loop_data_t = internal :: LoopData < segment_tuple_t,
                                         param_tuple_t,
                                         camp :: decay < Bodies > ... >;
  loop_data_t loop_data ( make_wrapped_tuple (
                            std :: forward < SegmentTuple > ( segments ) ),
                        std :: forward < ParamTuple > ( params ),
                        std :: forward < Bodies > ( bodies ) ... );
  using loop_types_t = internal :: makeInitialLoopTypes < loop_data_t >;
  internal :: execute_statement_list < PolicyType, loop_types_t > ( loop_data );
  util :: callPostLaunchPlugins ( context );
}
template < typename PolicyType, typename SegmentTuple, typename ... Bodies >
inline __attribute__ ( ( always_inline ) ) void kernel ( SegmentTuple && segments, Bodies && ... bodies )
{
  RAJA :: kernel_param < PolicyType > ( std :: forward < SegmentTuple > ( segments ),
                                 RAJA :: make_tuple ( ),
                                 std :: forward < Bodies > ( bodies ) ... );
}
}
namespace RAJA
{
namespace statement
{
template < typename ExecPolicy, typename ForList, typename ... EnclosedStmts >
struct Collapse : public internal :: ForList,
                  public internal :: CollapseBase,
                  public internal :: Statement < ExecPolicy, EnclosedStmts ... > {
};
}
}
namespace RAJA
{
namespace statement
{
template < typename Condition, typename ... EnclosedStmts >
struct If : public internal :: Statement < camp :: nil, EnclosedStmts ... > {
};
template < long value >
struct Value {
  template < typename Data >
  inline __attribute__ ( ( always_inline ) ) static long eval ( Data const & )
  {
    return value;
  }
};
template < typename L, typename R >
struct Equals {
  template < typename Data >
  inline __attribute__ ( ( always_inline ) ) static bool eval ( Data const & data )
  {
    return L :: eval ( data ) == R :: eval ( data );
  }
};
template < typename L, typename R >
struct NotEquals {
  template < typename Data >
  inline __attribute__ ( ( always_inline ) ) static bool eval ( Data const & data )
  {
    return L :: eval ( data ) != R :: eval ( data );
  }
};
template < typename L, typename R >
struct Or {
  template < typename Data >
  inline __attribute__ ( ( always_inline ) ) static bool eval ( Data const & data )
  {
    return L :: eval ( data ) || R :: eval ( data );
  }
};
template < typename L, typename R >
struct And {
  template < typename Data >
  inline __attribute__ ( ( always_inline ) ) static bool eval ( Data const & data )
  {
    return L :: eval ( data ) && R :: eval ( data );
  }
};
template < typename L, typename R >
struct LessThan {
  template < typename Data >
  inline __attribute__ ( ( always_inline ) ) static bool eval ( Data const & data )
  {
    return L :: eval ( data ) < R :: eval ( data );
  }
};
template < typename L, typename R >
struct LessThanEq {
  template < typename Data >
  inline __attribute__ ( ( always_inline ) ) static bool eval ( Data const & data )
  {
    return L :: eval ( data ) <= R :: eval ( data );
  }
};
template < typename L, typename R >
struct GreaterThan {
  template < typename Data >
  inline __attribute__ ( ( always_inline ) ) static bool eval ( Data const & data )
  {
    return L :: eval ( data ) > R :: eval ( data );
  }
};
template < typename L, typename R >
struct GreaterThanEq {
  template < typename Data >
  inline __attribute__ ( ( always_inline ) ) static bool eval ( Data const & data )
  {
    return L :: eval ( data ) >= R :: eval ( data );
  }
};
template < typename L >
struct Not {
  template < typename Data >
  inline __attribute__ ( ( always_inline ) ) static bool eval ( Data const & data )
  {
    return ! ( L :: eval ( data ) );
  }
};
}
namespace internal
{
template < typename Condition, typename ... EnclosedStmts, typename Types >
struct StatementExecutor < statement :: If < Condition, EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data && data )
  {
    if ( Condition :: eval ( data ) ) {
      execute_statement_list < camp :: list < EnclosedStmts ... >, Types > (
          std :: forward < Data > ( data ) );
    }
  }
};
}
}
namespace RAJA
{
namespace statement
{
template < camp :: idx_t ArgumentId,
          typename ExecPolicy = camp :: nil,
          typename ... EnclosedStmts >
struct For : public internal :: ForList,
             public internal :: ForTraitBase < ArgumentId, ExecPolicy >,
             public internal :: Statement < ExecPolicy, EnclosedStmts ... > {
  using execution_policy_t = ExecPolicy;
};
}
namespace internal
{
template < camp :: idx_t ArgumentId, typename Data, typename Types, typename ... EnclosedStmts >
struct ForWrapper : public GenericWrapper < Data, Types, EnclosedStmts ... > {
  using Base = GenericWrapper < Data, Types, EnclosedStmts ... >;
  using Base :: Base;
  using privatizer = NestedPrivatizer < ForWrapper >;
  template < typename InIndexType >
  inline __attribute__ ( ( always_inline ) ) void operator ( ) ( InIndexType i )
  {
    Base :: data . template assign_offset < ArgumentId > ( i );
    Base :: exec ( );
  }
};
template < camp :: idx_t ArgumentId,
          typename ExecPolicy,
          typename ... EnclosedStmts,
          typename Types >
struct StatementExecutor <
    statement :: For < ArgumentId, ExecPolicy, EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data && data )
  {
    using NewTypes = setSegmentTypeFromData < Types, ArgumentId, Data >;
    ForWrapper < ArgumentId, Data, NewTypes, EnclosedStmts ... > for_wrapper ( data );
    auto len = segment_length < ArgumentId > ( data );
    using len_t = decltype ( len );
    forall_impl ( ExecPolicy { }, TypedRangeSegment < len_t > ( 0, len ), for_wrapper );
  }
};
}
}
namespace RAJA
{
namespace internal
{

struct ParamBase 
{
}
;
}
namespace statement
{
template < camp :: idx_t ParamId >
struct Param : public internal :: ParamBase {
  constexpr static camp :: idx_t param_idx = ParamId;
  template < typename Data >
  inline __attribute__ ( ( always_inline ) ) static auto eval ( Data const & data )
      -> decltype ( camp :: get < ParamId > ( data . param_tuple ) )
  {
    return camp :: get < ParamId > ( data . param_tuple );
  }
};
}
}
namespace RAJA
{
namespace statement
{
template < camp :: idx_t ArgumentId,
          typename ParamId,
          typename ExecPolicy = camp :: nil,
          typename ... EnclosedStmts >
struct ForICount : public internal :: ForList,
             public internal :: ForTraitBase < ArgumentId, ExecPolicy >,
             public internal :: Statement < ExecPolicy, EnclosedStmts ... > {
  static_assert ( std :: is_base_of < internal :: ParamBase, ParamId > :: value,
                "Inappropriate ParamId, ParamId must be of type RAJA::Statement::Param< # >"
                                             );
  using execution_policy_t = ExecPolicy;
};
}
namespace internal
{
template < camp :: idx_t ArgumentId, typename ParamId, typename Data, typename Types,
          typename ... EnclosedStmts >
struct ForICountWrapper : public GenericWrapper < Data, Types, EnclosedStmts ... > {
  using Base = GenericWrapper < Data, Types, EnclosedStmts ... >;
  using Base :: Base;
  using privatizer = NestedPrivatizer < ForICountWrapper >;
  template < typename InIndexType >
  inline __attribute__ ( ( always_inline ) ) void operator ( ) ( InIndexType i )
  {
    Base :: data . template assign_offset < ArgumentId > ( i );
    Base :: data . template assign_param < ParamId > ( i );
    Base :: exec ( );
  }
};
template < camp :: idx_t ArgumentId,
          typename ParamId,
          typename ExecPolicy,
          typename ... EnclosedStmts,
          typename Types >
struct StatementExecutor <
    statement :: ForICount < ArgumentId, ParamId, ExecPolicy, EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data && data )
  {
    using NewTypes = setSegmentTypeFromData < Types, ArgumentId, Data >;
    ForICountWrapper < ArgumentId, ParamId, Data, NewTypes,
                     EnclosedStmts ... > for_wrapper ( data );
    auto len = segment_length < ArgumentId > ( data );
    using len_t = decltype ( len );
    forall_impl ( ExecPolicy { }, TypedRangeSegment < len_t > ( 0, len ), for_wrapper );
  }
};
}
}
namespace RAJA
{
namespace statement
{
template < camp :: idx_t HpArgumentId,
          typename HpExecPolicy,
          typename ArgList,
          typename ExecPolicy,
          typename ... EnclosedStmts >
struct Hyperplane
    : public internal :: Statement < ExecPolicy,
                                 EnclosedStmts ... > {
};
}
namespace internal
{
template < camp :: idx_t HpArgumentId, typename ArgList, typename ... EnclosedStmts >
struct HyperplaneInner
    : public internal :: Statement < camp :: nil, EnclosedStmts ... > {
};
template < camp :: idx_t HpArgumentId,
          typename HpExecPolicy,
          camp :: idx_t ... Args,
          typename ExecPolicy,
          typename ... EnclosedStmts,
          typename Types >
struct StatementExecutor < statement :: Hyperplane < HpArgumentId,
                                               HpExecPolicy,
                                               ArgList < Args ... >,
                                               ExecPolicy,
                                               EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data & data )
  {
    using data_t = camp :: decay < Data >;
    using idx_t =
        camp :: tuple_element_t < HpArgumentId, typename data_t :: offset_tuple_t >;
    using NewTypes = setSegmentTypeFromData < Types, HpArgumentId, Data >;
    using kernel_policy = statement :: Collapse <
        ExecPolicy,
        ArgList < Args ... >,
        HyperplaneInner < HpArgumentId, ArgList < Args ... >, EnclosedStmts ... >>;
    ForWrapper < HpArgumentId, Data, NewTypes, kernel_policy > outer_wrapper ( data );
    idx_t hp_len = segment_length < HpArgumentId > ( data ) +
                   foldl ( RAJA :: operators :: plus < idx_t > ( ),
                                 segment_length < Args > ( data ) ... );
    forall_impl ( HpExecPolicy { },
                TypedRangeSegment < idx_t > ( 0, hp_len ),
                outer_wrapper );
  }
};
template < camp :: idx_t HpArgumentId,
          camp :: idx_t ... Args,
          typename ... EnclosedStmts,
          typename Types >
struct StatementExecutor <
    HyperplaneInner < HpArgumentId, ArgList < Args ... >, EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data & data )
  {
    auto h = camp :: get < HpArgumentId > ( data . offset_tuple );
    using idx_t = decltype ( h );
    idx_t i = h - foldl ( RAJA :: operators :: plus < idx_t > ( ),
                                camp :: get < Args > ( data . offset_tuple ) ... );
    auto len = segment_length < HpArgumentId > ( data );
    if ( i >= 0 && i < len ) {
      data . template assign_offset < HpArgumentId > ( i );
      execute_statement_list < StatementList < EnclosedStmts ... >, Types > ( data );
      data . template assign_offset < HpArgumentId > ( h );
    }
  }
};
}
}
namespace RAJA
{
struct cpu_tile_mem ;
namespace statement
{
template < typename Pol, typename Indices, typename ... EnclosedStmts >
struct InitLocalMem : public internal :: Statement < camp :: nil > {
};
template < camp :: idx_t ... Indices, typename ... EnclosedStmts >
struct InitLocalMem < RAJA :: cpu_tile_mem, camp :: idx_seq < Indices ... >, EnclosedStmts ... > : public internal :: Statement < camp :: nil > {
};
}
namespace internal
{
template < camp :: idx_t ... Indices, typename ... EnclosedStmts, typename Types >
struct StatementExecutor < statement :: InitLocalMem < RAJA :: cpu_tile_mem, camp :: idx_seq < Indices ... >, EnclosedStmts ... >, Types > {
  template < class Data >
  static void inline __attribute__ ( ( always_inline ) ) initMem ( Data && data )
  {
    execute_statement_list < camp :: list < EnclosedStmts ... >, Types > ( data );
  }
  template < camp :: idx_t Pos, camp :: idx_t ... others, class Data >
  static void inline __attribute__ ( ( always_inline ) ) initMem ( Data && data )
  {
    using varType = typename camp :: tuple_element_t < Pos, typename camp :: decay < Data > :: param_tuple_t > :: element_t;
    const camp :: idx_t NumElem = camp :: tuple_element_t < Pos, typename camp :: decay < Data > :: param_tuple_t > :: NumElem;
    varType Array [ NumElem ];
    camp :: get < Pos > ( data . param_tuple ) . m_arrayPtr = Array;
    initMem < others ... > ( data );
  }
  template < class Data >
  static void inline __attribute__ ( ( always_inline ) ) setPtrToNull ( Data && ) { }
  template < camp :: idx_t Pos, camp :: idx_t ... others, class Data >
  static void inline __attribute__ ( ( always_inline ) ) setPtrToNull ( Data && data )
  {
    camp :: get < Pos > ( data . param_tuple ) . m_arrayPtr = nullptr;
    setPtrToNull < others ... > ( data );
  }
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data && data )
  {
    initMem < Indices ... > ( data );
    setPtrToNull < Indices ... > ( data );
  }
};
}
}
namespace RAJA
{
namespace internal
{

struct lambda_arg_seg_t 
{
}
;

struct lambda_arg_param_t 
{
}
;

struct lambda_arg_offset_t 
{
}
;
template < typename T >
struct lambda_arg_value_t
{
    using type = T;
};
template < typename T, camp :: idx_t >
struct LambdaArg
{
};
}
template < camp :: idx_t ... args >
using Segs = camp :: list < internal :: LambdaArg < internal :: lambda_arg_seg_t, args > ... >;
template < camp :: idx_t ... args >
using Offsets = camp :: list < internal :: LambdaArg < internal :: lambda_arg_offset_t, args > ... >;
template < camp :: idx_t ... args >
using Params = camp :: list < internal :: LambdaArg < internal :: lambda_arg_param_t, args > ... >;
template < typename T, camp :: idx_t ... values >
using ValuesT = camp :: list < internal :: LambdaArg < internal :: lambda_arg_value_t < T >, values > ... >;
namespace statement
{
template < camp :: idx_t BodyIdx, typename ... Args >
struct Lambda : internal :: Statement < camp :: nil > {
  static const camp :: idx_t loop_body_index = BodyIdx;
};
}
namespace internal
{
template < camp :: idx_t LoopIndex,
          typename Types,
          camp :: idx_t ... OffsetIdx,
          camp :: idx_t ... ParamIdx,
          typename Data >
 inline __attribute__ ( ( always_inline ) ) void invoke_lambda_expanded (
    camp :: idx_seq < OffsetIdx ... > const &,
    camp :: idx_seq < ParamIdx ... > const &,
    Data && data )
{
  using segment_types = typename Types :: segment_types_t;
  static_assert (
      foldl ( RAJA :: operators :: bit_and < bool > ( ), ( ! std :: is_same < camp :: at_v < segment_types, OffsetIdx >, void > :: value ) ... ),
      "Not all segments have been used in a loop:  Either add more loop statements, or use the Lambda<N, Args..> form" );
  camp :: get < LoopIndex > ( data . bodies )
    ( ( camp :: at_v < segment_types, OffsetIdx > ) ( camp :: get < OffsetIdx > ( data . segment_tuple ) . begin ( ) [ camp :: get < OffsetIdx > ( data . offset_tuple ) ] ) ...,
     camp :: get < ParamIdx > ( data . param_tuple ) ... );
}
template < camp :: idx_t LoopIndex, typename Types, typename Data >
inline __attribute__ ( ( always_inline ) ) void invoke_lambda ( Data && data )
{
  using Data_t = camp :: decay < Data >;
  using offset_tuple_t = typename Data_t :: offset_tuple_t;
  using param_tuple_t = typename Data_t :: param_tuple_t;
  invoke_lambda_expanded < LoopIndex, Types > (
      camp :: make_idx_seq_t < camp :: tuple_size < offset_tuple_t > :: value > { },
      camp :: make_idx_seq_t < camp :: tuple_size < param_tuple_t > :: value > { },
      std :: forward < Data > ( data ) );
}
template < camp :: idx_t LambdaIndex, typename Types >
struct StatementExecutor < statement :: Lambda < LambdaIndex >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data && data )
  {
    invoke_lambda < LambdaIndex, Types > ( std :: forward < Data > ( data ) );
  }
};
template < typename Types, typename T >
struct LambdaArgExtractor;
template < typename Types, camp :: idx_t id >
struct LambdaArgExtractor < Types, LambdaArg < lambda_arg_offset_t, id > >
{
  using type = camp :: at_v < typename Types :: offset_types_t, id >;
  static_assert ( ! std :: is_same < type, void > :: value,
      "Offset not assigned, but used in Lambda with Offsets<> argument" );
  template < typename Data >
  inline __attribute__ ( ( always_inline ) )
  constexpr
  static type extract_arg ( Data && data )
  {
    return type ( camp :: get < id > ( data . offset_tuple ) );
  }
};
template < typename Types, camp :: idx_t id >
struct LambdaArgExtractor < Types, LambdaArg < lambda_arg_seg_t, id > >
{
  using type = camp :: at_v < typename Types :: segment_types_t, id >;
  static_assert ( ! std :: is_same < type, void > :: value,
      "Segment not assigned, but used in Lambda with Segs<> argument" );
  template < typename Data >
  inline __attribute__ ( ( always_inline ) )
  constexpr
  static type extract_arg ( Data && data )
  {
    return type ( camp :: get < id > ( data . segment_tuple ) . begin ( ) [ camp :: get < id > ( data . offset_tuple ) ] );
  }
};
template < typename Types, camp :: idx_t id >
struct LambdaArgExtractor < Types, LambdaArg < lambda_arg_param_t, id > >
{
  template < typename Data >
  inline __attribute__ ( ( always_inline ) )
  constexpr
  static auto extract_arg ( Data && data ) ->
    typename std :: add_lvalue_reference < camp :: tuple_element_t < id, typename camp :: decay < Data > :: param_tuple_t >> :: type
  {
    return camp :: get < id > ( data . param_tuple );
  }
};
template < typename Types, typename T, camp :: idx_t value >
struct LambdaArgExtractor < Types, LambdaArg < lambda_arg_value_t < T >, value > >
{
  template < typename Data >
  inline __attribute__ ( ( always_inline ) )
  constexpr
  static T extract_arg ( Data && )
  {
    return T ( value );
  }
};
template < camp :: idx_t LoopIndex, typename Types, typename Data, typename ... targLists >
inline __attribute__ ( ( always_inline ) ) void invoke_lambda_with_args ( Data && data,
                                                       camp :: list < targLists ... > const & )
{
  camp :: get < LoopIndex > ( data . bodies ) ( LambdaArgExtractor < Types, targLists > :: extract_arg ( data ) ... );
}
template < camp :: idx_t LambdaIndex, typename ... Args, typename Types >
struct StatementExecutor < statement :: Lambda < LambdaIndex, Args ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data && data )
  {
    using targList = typename camp :: flatten < camp :: list < Args ... >> :: type;
    invoke_lambda_with_args < LambdaIndex, Types > ( std :: forward < Data > ( data ), targList { } );
  }
};
}
}
namespace RAJA
{
namespace statement
{
template < typename ReducePolicy,
          template < typename ... > class ReduceOperator,
          typename ParamId,
          typename ... EnclosedStmts >
struct Reduce : public internal :: Statement < camp :: nil, EnclosedStmts ... > {
  static_assert ( std :: is_base_of < internal :: ParamBase, ParamId > :: value,
                "Inappropriate ParamId, ParamId must be of type RAJA::Statement::Param< # >"
                                             );
  using execution_policy_t = camp :: nil;
};
}
}
namespace RAJA
{
namespace policy
{
namespace sequential
{
template < typename Func >
inline __attribute__ ( ( always_inline ) ) void region_impl ( const seq_region &, Func && body )
{
  body ( );
}
}
}
}
namespace RAJA
{
template < typename ExecutionPolicy, typename LoopBody >
void region ( LoopBody && loop_body )
{
  region_impl ( ExecutionPolicy ( ), loop_body );
}
template < typename ExecutionPolicy, typename OuterBody, typename InnerBody >
void region ( OuterBody && outer_body, InnerBody && inner_body )
{
  region_impl ( ExecutionPolicy ( ), outer_body, inner_body );
}
}
namespace RAJA
{
namespace policy
{
namespace omp
{

struct Parallel 
{
}
;

struct Collapse 
{
}
;

struct For 
{
}
;

struct NoWait 
{
}
;
template < unsigned int ChunkSize >
struct Static : std :: integral_constant < unsigned int, ChunkSize > {
};
struct omp_parallel_region ;

struct omp_parallel_region : public PolicyBaseT< Policy(4) , Pattern(2) , Launch(0) , camp::resources::v1::Platform(1) > 
{
}
;
struct omp_for_exec ;

struct omp_for_exec : public PolicyBaseT< Policy(4) , Pattern(1) , Launch(0) , camp::resources::v1::Platform(0) , For  > 
{
}
;
struct omp_for_nowait_exec ;

struct omp_for_nowait_exec : public PolicyBaseT< Policy(4) , Pattern(1) , Launch(0) , camp::resources::v1::Platform(1) , For  , NoWait  > 
{
}
;
template < unsigned int N >
struct omp_for_static : make_policy_pattern_launch_platform_t < Policy :: openmp,
                                                              Pattern :: forall,
                                                              Launch :: undefined,
                                                              Platform :: host,
                                                              omp :: For,
                                                              omp :: Static < N >> {
};
template < typename InnerPolicy >
struct omp_parallel_exec
    : make_policy_pattern_launch_platform_t < Policy :: openmp,
                                            Pattern :: forall,
                                            Launch :: undefined,
                                            Platform :: host,
                                            omp :: Parallel,
                                            wrapper < InnerPolicy >> {
};
struct omp_parallel_for_exec ;

struct omp_parallel_for_exec : public omp_parallel_exec< omp_for_exec  > 
{
}
;
template < unsigned int N >
struct omp_parallel_for_static : omp_parallel_exec < omp_for_static < N >> {
};
using omp_parallel_for_segit = struct omp_parallel_for_exec ;
using omp_parallel_segit = omp_parallel_for_segit ;
struct omp_taskgraph_segit ;

struct omp_taskgraph_segit : public PolicyBaseT< Policy(4) , Pattern(4) , Launch(0) , camp::resources::v1::Platform(0) , Parallel  > 
{
}
;

struct omp_taskgraph_interval_segit : public PolicyBaseT< Policy(4) , Pattern(4) , Launch(0) , camp::resources::v1::Platform(0) , Parallel  > 
{
}
;
struct omp_reduce ;

struct omp_reduce : public PolicyBaseT< Policy(4) , Pattern(3) , Launch(0) , camp::resources::v1::Platform(0) > 
{
}
;
struct omp_reduce_ordered ;

struct omp_reduce_ordered : public PolicyBaseT< Policy(4) , Pattern(3) , Launch(0) , camp::resources::v1::Platform(0) , class ::RAJA::reduce::ordered  > 
{
}
;
struct omp_synchronize ;

struct omp_synchronize : public PolicyBaseT< Policy(4) , Pattern(5) , Launch(1) , camp::resources::v1::Platform(0) > 
{
}
;
}
}
using RAJA::RAJA::policy::omp::omp_for_exec;
using RAJA::RAJA::policy::omp::omp_for_nowait_exec;
using RAJA::RAJA::policy::omp::omp_for_static;
using RAJA::RAJA::policy::omp::omp_parallel_exec;
using RAJA::RAJA::policy::omp::omp_parallel_for_exec;
using RAJA::RAJA::policy::omp::omp_parallel_for_segit;
using RAJA::RAJA::policy::omp::omp_parallel_region;
using RAJA::RAJA::policy::omp::omp_parallel_segit;
using RAJA::RAJA::policy::omp::omp_reduce;
using RAJA::RAJA::policy::omp::omp_reduce_ordered;
using RAJA::RAJA::policy::omp::omp_synchronize;
}
namespace RAJA
{
namespace statement
{
template < typename RegionPolicy, typename ... EnclosedStmts >
struct Region : public internal :: Statement < camp :: nil > {
};
}
namespace internal
{
template < typename RegionPolicy, typename ... EnclosedStmts, typename Types >
struct StatementExecutor < statement :: Region < RegionPolicy, EnclosedStmts ... >, Types > {
template < typename Data >
static inline __attribute__ ( ( always_inline ) ) void exec ( Data && data )
{
  RAJA :: region < RegionPolicy > ( [ & ] ( ) {
      using data_t = camp :: decay < Data >;
      execute_statement_list < camp :: list < EnclosedStmts ... >, Types > ( data_t ( data ) );
    } );
}
};
}
}
namespace RAJA
{
namespace statement
{
template < camp :: idx_t ArgumentId,
          typename TilePolicy,
          typename ExecPolicy,
          typename ... EnclosedStmts >
struct Tile : public internal :: Statement < ExecPolicy, EnclosedStmts ... > {
  using tile_policy_t = TilePolicy;
  using exec_policy_t = ExecPolicy;
};
}
template < camp :: idx_t chunk_size_ >
struct tile_fixed {
  static constexpr camp :: idx_t chunk_size = chunk_size_;
};
namespace internal
{
template < camp :: idx_t ArgumentId, typename Data, typename Types, typename ... EnclosedStmts >
struct TileWrapper : public GenericWrapper < Data, Types, EnclosedStmts ... > {
  using Base = GenericWrapper < Data, Types, EnclosedStmts ... >;
  using Base :: Base;
  using privatizer = NestedPrivatizer < TileWrapper >;
  template < typename InSegmentIndexType >
  inline __attribute__ ( ( always_inline ) ) void operator ( ) ( InSegmentIndexType si )
  {
    camp :: get < ArgumentId > ( Base :: data . segment_tuple ) = si . s;
    Base :: exec ( );
  }
};
template < typename Iterable >
struct IterableTiler {
  using value_type = camp :: decay < Iterable >;
  struct iterate
  {
    value_type s;
    Index_type i;
  };
  class iterator
  {
    const IterableTiler itiler;
    const Index_type block_id;
  public :
    using value_type = iterate;
    using difference_type = camp :: idx_t;
    using pointer = value_type *;
    using reference = value_type &;
    using iterator_category = std :: random_access_iterator_tag;
    inline __attribute__ ( ( always_inline ) )
    constexpr iterator ( IterableTiler const & itiler_, Index_type block_id_ )
        ;
    inline __attribute__ ( ( always_inline ) )
    value_type operator * ( )
    ;
    inline __attribute__ ( ( always_inline ) ) difference_type operator - ( const iterator & rhs ) const
    ;
    inline __attribute__ ( ( always_inline ) ) iterator operator - ( const difference_type & rhs ) const
    ;
    inline __attribute__ ( ( always_inline ) ) iterator operator + ( const difference_type & rhs ) const
    ;
    inline __attribute__ ( ( always_inline ) ) value_type operator [ ] ( difference_type rhs ) const
    ;
    inline __attribute__ ( ( always_inline ) ) bool operator != ( const IterableTiler & rhs ) const
    ;
    inline __attribute__ ( ( always_inline ) ) bool operator < ( const IterableTiler & rhs ) const
    ;
  };
  inline __attribute__ ( ( always_inline ) )
  IterableTiler ( const Iterable & it_, camp :: idx_t block_size_ )
      ;
  inline __attribute__ ( ( always_inline ) )
  iterator begin ( ) const;
  inline __attribute__ ( ( always_inline ) )
  iterator end ( ) const;
  value_type it;
  camp :: idx_t block_size;
  camp :: idx_t num_blocks;
  camp :: idx_t dist;
};
template < camp :: idx_t ArgumentId,
          typename TPol,
          typename EPol,
          typename ... EnclosedStmts,
          typename Types >
struct StatementExecutor <
    statement :: Tile < ArgumentId, TPol, EPol, EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data & data )
  {
    auto const & segment = camp :: get < ArgumentId > ( data . segment_tuple );
    auto chunk_size = TPol :: chunk_size;
    IterableTiler < decltype ( segment ) > tiled_iterable ( segment, chunk_size );
    TileWrapper < ArgumentId, Data, Types,
                EnclosedStmts ... > tile_wrapper ( data );
    forall_impl ( EPol { }, tiled_iterable, tile_wrapper );
    camp :: get < ArgumentId > ( data . segment_tuple ) = tiled_iterable . it;
  }
};
}
}
namespace RAJA
{
namespace statement
{
template < camp :: idx_t ArgumentId,
          typename ParamId,
          typename TilePolicy,
          typename ExecPolicy,
          typename ... EnclosedStmts >
struct TileTCount : public internal :: Statement < ExecPolicy, EnclosedStmts ... > {
  static_assert ( std :: is_base_of < internal :: ParamBase, ParamId > :: value,
                "Inappropriate ParamId, ParamId must be of type RAJA::Statement::Param< # >"
                                             );
  using tile_policy_t = TilePolicy;
  using exec_policy_t = ExecPolicy;
};
}
namespace internal
{
template < camp :: idx_t ArgumentId, typename ParamId, typename Data, typename Types,
          typename ... EnclosedStmts >
struct TileTCountWrapper : public GenericWrapper < Data, Types, EnclosedStmts ... > {
  using Base = GenericWrapper < Data, Types, EnclosedStmts ... >;
  using Base :: Base;
  using privatizer = NestedPrivatizer < TileTCountWrapper >;
  template < typename InSegmentIndexType >
  inline __attribute__ ( ( always_inline ) ) void operator ( ) ( InSegmentIndexType si )
  {
    camp :: get < ArgumentId > ( Base :: data . segment_tuple ) = si . s;
    Base :: data . template assign_param < ParamId > ( si . i );
    Base :: exec ( );
  }
};
template < camp :: idx_t ArgumentId,
          typename ParamId,
          typename TPol,
          typename EPol,
          typename ... EnclosedStmts,
          typename Types >
struct StatementExecutor <
    statement :: TileTCount < ArgumentId, ParamId, TPol, EPol, EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data & data )
  {
    auto const & segment = camp :: get < ArgumentId > ( data . segment_tuple );
    auto chunk_size = TPol :: chunk_size;
    IterableTiler < decltype ( segment ) > tiled_iterable ( segment, chunk_size );
    TileTCountWrapper < ArgumentId, ParamId, Data, Types,
                      EnclosedStmts ... > tile_wrapper ( data );
    forall_impl ( EPol { }, tiled_iterable, tile_wrapper );
    camp :: get < ArgumentId > ( data . segment_tuple ) = tiled_iterable . it;
  }
};
}
}
namespace RAJA
{

struct seq_atomic 
{
}
;
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicAdd ( seq_atomic, T volatile * acc, T value )
{
  T ret = * acc;
  * acc += value;
  return ret;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicSub ( seq_atomic, T volatile * acc, T value )
{
  T ret = * acc;
  * acc -= value;
  return ret;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicMin ( seq_atomic, T volatile * acc, T value )
{
  T ret = * acc;
  * acc = ret < value ? ret : value;
  return ret;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicMax ( seq_atomic, T volatile * acc, T value )
{
  T ret = * acc;
  * acc = ret > value ? ret : value;
  return ret;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicInc ( seq_atomic, T volatile * acc )
{
  T ret = * acc;
  ( * acc ) += 1;
  return ret;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicInc ( seq_atomic, T volatile * acc, T val )
{
  T old = * acc;
  ( * acc ) = ( ( old >= val ) ? 0 : ( old + 1 ) );
  return old;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicDec ( seq_atomic, T volatile * acc )
{
  T ret = * acc;
  ( * acc ) -= 1;
  return ret;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicDec ( seq_atomic, T volatile * acc, T val )
{
  T old = * acc;
  ( * acc ) = ( ( ( old == 0 ) | ( old > val ) ) ? val : ( old - 1 ) );
  return old;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicAnd ( seq_atomic, T volatile * acc, T value )
{
  T ret = * acc;
  * acc &= value;
  return ret;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicOr ( seq_atomic, T volatile * acc, T value )
{
  T ret = * acc;
  * acc |= value;
  return ret;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicXor ( seq_atomic, T volatile * acc, T value )
{
  T ret = * acc;
  * acc ^= value;
  return ret;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicExchange ( seq_atomic, T volatile * acc, T value )
{
  T ret = * acc;
  * acc = value;
  return ret;
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicCAS ( seq_atomic, T volatile * acc, T compare, T value )
{
  T ret = * acc;
  * acc = ret == compare ? value : ret;
  return ret;
}
}
namespace RAJA
{
namespace internal
{
template < typename ... EnclosedStmts, typename Types >
struct StatementExecutor <
    statement :: Collapse < seq_exec, ArgList < >, EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data & data )
  {
    execute_statement_list < camp :: list < EnclosedStmts ... >, Types > ( data );
  }
};
template < camp :: idx_t Arg0, camp :: idx_t ... ArgRest, typename ... EnclosedStmts, typename Types >
struct StatementExecutor < statement :: Collapse < seq_exec,
                                             ArgList < Arg0, ArgRest ... >,
                                             EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data & data )
  {
    using NewTypes = setSegmentTypeFromData < Types, Arg0, Data >;
    using next_loop_t = StatementExecutor <
        statement :: Collapse < seq_exec, ArgList < ArgRest ... >, EnclosedStmts ... >, NewTypes >;
    auto len0 = segment_length < Arg0 > ( data );
    for ( auto i0 = 0; i0 < len0; ++ i0 ) {
      data . template assign_offset < Arg0 > ( i0 );
      next_loop_t :: exec ( data );
    }
  }
};
}
}
namespace RAJA
{
namespace internal
{
template < template < typename ... > class ReduceOperator,
          typename ParamId,
          typename ... EnclosedStmts,
          typename Types >
struct StatementExecutor <
    statement :: Reduce < seq_reduce, ReduceOperator, ParamId, EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data && data )
  {
    execute_statement_list < camp :: list < EnclosedStmts ... >, Types > ( data );
  }
};
}
}
namespace RAJA
{
namespace reduce
{
namespace detail
{
template < typename T, template < typename ... > class Op >
struct op_adapter : private Op < T, T, T > {
  using operator_type = Op < T, T, T >;
  static constexpr T identity ( )
  ;
  inline __attribute__ ( ( always_inline ) ) void operator ( ) ( T & val, const T v ) const
  ;
};
}
template < typename T >
struct sum : detail :: op_adapter < T, RAJA :: operators :: plus > {
};
template < typename T >
struct min : detail :: op_adapter < T, RAJA :: operators :: minimum > {
};
template < typename T >
struct max : detail :: op_adapter < T, RAJA :: operators :: maximum > {
};
namespace detail
{
template < typename T, bool = std :: is_integral < T > :: value >
struct DefaultLoc { };
template < typename T >
struct DefaultLoc < T, false >
{
  constexpr T value ( ) const;
};
template < typename T >
struct DefaultLoc < T, true >
{
  constexpr T value ( ) const;
};
template < typename T, typename IndexType, bool doing_min = true >
class ValueLoc
{
public :
  T val = doing_min ? operators :: limits < T > :: max ( ) : operators :: limits < T > :: min ( );
  IndexType loc = DefaultLoc < IndexType > ( ) . value ( );
  constexpr ValueLoc ( ) = default;
  constexpr ValueLoc ( ValueLoc const & other ) = default;
  ValueLoc & operator = ( ValueLoc const & other ) = default;
  constexpr ValueLoc ( T const & val );
  constexpr ValueLoc ( T const & val, IndexType const & loc )
      ;
  operator T ( ) const;
  IndexType getLoc ( );
  bool operator < ( ValueLoc const & rhs ) const
  ;
  bool operator > ( ValueLoc const & rhs ) const
  ;
};
}
}
namespace operators
{
template < typename T, typename IndexType, bool B >
struct limits < :: RAJA :: reduce :: detail :: ValueLoc < T, IndexType, B > > : limits < T > {
};
}
namespace reduce
{
namespace detail
{
template < typename T,
          template < typename >
          class Reduce_,
          template < typename, typename >
          class Combiner_ >
class BaseReduce
{
  using Reduce = Reduce_ < T >;
  using Combiner_t = Combiner_ < T, Reduce >;
  Combiner_t mutable c;
public :
  using value_type = T;
  using reduce_type = Reduce;
  BaseReduce ( );
  BaseReduce ( T init_val, T identity_ = Reduce :: identity ( ) )
      ;
  void reset ( T val, T identity_ = Reduce :: identity ( ) )
  ;
  BaseReduce & operator = ( const BaseReduce & ) = delete;
  BaseReduce ( const BaseReduce & copy );
  inline __attribute__ ( ( always_inline ) )
  BaseReduce ( BaseReduce && copy );
  BaseReduce & operator = ( BaseReduce && ) = default;
  void combine ( T const & other ) const;
  T & local ( ) const;
  operator T ( ) const;
  T get ( ) const;
};
template < typename T, typename Reduce, typename Derived >
class BaseCombinable
{
protected :
  BaseCombinable const * parent = nullptr;
  T identity;
  T mutable my_data;
public :
  constexpr BaseCombinable ( );
  constexpr BaseCombinable ( T init_val, T identity_ = T ( ) )
      ;
  void reset ( T init_val, T identity_ )
  ;
  constexpr BaseCombinable ( BaseCombinable const & other )
      ;
  ~ BaseCombinable ( )
  ;
  void combine ( T const & other );
  T get ( ) const;
  T & local ( ) const;
  T get_combined ( ) const;
private :
  const Derived & derived ( ) const
  ;
  Derived & derived ( );
};
template < typename T, template < typename, typename > class Combiner >
class BaseReduceMin : public BaseReduce < T, RAJA :: reduce :: min, Combiner >
{
public :
  using Base = BaseReduce < T, RAJA :: reduce :: min, Combiner >;
  using Base :: Base;
  const BaseReduceMin & min ( T rhs ) const
  ;
};
template < typename T, typename IndexType, template < typename, typename > class Combiner >
class BaseReduceMinLoc
    : public BaseReduce < ValueLoc < T, IndexType >, RAJA :: reduce :: min, Combiner >
{
public :
  using Base = BaseReduce < ValueLoc < T, IndexType >, RAJA :: reduce :: min, Combiner >;
  using value_type = typename Base :: value_type;
  using reduce_type = typename Base :: reduce_type;
  using Base :: Base;
  constexpr BaseReduceMinLoc ( );
  constexpr BaseReduceMinLoc ( T init_val, IndexType init_idx,
                             T identity_ = reduce_type :: identity ( ) )
    ;
  const BaseReduceMinLoc & minloc ( T rhs, IndexType loc ) const
  ;
  void reset ( T init_val, IndexType init_idx = DefaultLoc < IndexType > ( ) . value ( ),
             T identity_ = reduce_type :: identity ( ) )
  ;
  IndexType getLoc ( ) const;
  operator T ( ) const;
};
template < typename T, template < typename, typename > class Combiner >
class BaseReduceMax : public BaseReduce < T, RAJA :: reduce :: max, Combiner >
{
public :
  using Base = BaseReduce < T, RAJA :: reduce :: max, Combiner >;
  using Base :: Base;
  const BaseReduceMax & max ( T rhs ) const
  ;
};
template < typename T, template < typename, typename > class Combiner >
class BaseReduceSum : public BaseReduce < T, RAJA :: reduce :: sum, Combiner >
{
public :
  using Base = BaseReduce < T, RAJA :: reduce :: sum, Combiner >;
  using Base :: Base;
  const BaseReduceSum & operator += ( T rhs ) const
  ;
};
template < typename T, typename IndexType, template < typename, typename > class Combiner >
class BaseReduceMaxLoc
    : public BaseReduce < ValueLoc < T, IndexType, false >, RAJA :: reduce :: max, Combiner >
{
public :
  using Base = BaseReduce < ValueLoc < T, IndexType, false >, RAJA :: reduce :: max, Combiner >;
  using value_type = typename Base :: value_type;
  using reduce_type = typename Base :: reduce_type;
  using Base :: Base;
  constexpr BaseReduceMaxLoc ( );
  constexpr BaseReduceMaxLoc ( T init_val, IndexType init_idx,
                             T identity_ = reduce_type :: identity ( ) )
    ;
  const BaseReduceMaxLoc & maxloc ( T rhs, IndexType loc ) const
  ;
  void reset ( T init_val, IndexType init_idx = DefaultLoc < IndexType > ( ) . value ( ),
             T identity_ = reduce_type :: identity ( ) )
  ;
  IndexType getLoc ( ) const;
  operator T ( ) const;
};
}
}
}
namespace RAJA
{
template < typename REDUCE_POLICY_T, typename T >
class ReduceMin;
template < typename REDUCE_POLICY_T, typename T, typename IndexType = Index_type >
class ReduceMinLoc;
template < typename REDUCE_POLICY_T, typename T >
class ReduceMax;
template < typename REDUCE_POLICY_T, typename T, typename IndexType = Index_type >
class ReduceMaxLoc;
template < typename REDUCE_POLICY_T, typename T >
class ReduceSum;
}
namespace RAJA
{
namespace detail
{
template < typename T, typename Reduce >
class ReduceSeq
    : public reduce :: detail :: BaseCombinable < T, Reduce, ReduceSeq < T, Reduce >>
{
  using Base = reduce :: detail :: BaseCombinable < T, Reduce, ReduceSeq < T, Reduce >>;
public :
  ReduceSeq ( ) = delete;
  using Base :: Base;
};
}
template < typename T > class ReduceSum < seq_reduce, T > : public reduce :: detail :: BaseReduceSum < T, detail :: ReduceSeq > { public : using Base = reduce :: detail :: BaseReduceSum < T, detail :: ReduceSeq >; using Base :: Base; };
template < typename T > class ReduceMin < seq_reduce, T > : public reduce :: detail :: BaseReduceMin < T, detail :: ReduceSeq > { public : using Base = reduce :: detail :: BaseReduceMin < T, detail :: ReduceSeq >; using Base :: Base; };
template < typename T > class ReduceMax < seq_reduce, T > : public reduce :: detail :: BaseReduceMax < T, detail :: ReduceSeq > { public : using Base = reduce :: detail :: BaseReduceMax < T, detail :: ReduceSeq >; using Base :: Base; };
template < typename T, typename IndexType > class ReduceMinLoc < seq_reduce, T, IndexType > : public reduce :: detail :: BaseReduceMinLoc < T, IndexType, detail :: ReduceSeq > { public : using Base = reduce :: detail :: BaseReduceMinLoc < T, IndexType, detail :: ReduceSeq >; using Base :: Base; };
template < typename T, typename IndexType > class ReduceMaxLoc < seq_reduce, T, IndexType > : public reduce :: detail :: BaseReduceMaxLoc < T, IndexType, detail :: ReduceSeq > { public : using Base = reduce :: detail :: BaseReduceMaxLoc < T, IndexType, detail :: ReduceSeq >; using Base :: Base; };
}
namespace std
{
template < typename _IIter, typename _Predicate >
    bool
    all_of ( _IIter, _IIter, _Predicate );
template < typename _IIter, typename _Predicate >
    bool
    any_of ( _IIter, _IIter, _Predicate );
template < typename _FIter, typename _Tp >
    bool
    binary_search ( _FIter, _FIter, const _Tp & );
template < typename _FIter, typename _Tp, typename _Compare >
    bool
    binary_search ( _FIter, _FIter, const _Tp &, _Compare );
template < typename _IIter, typename _OIter >
    _OIter
    copy ( _IIter, _IIter, _OIter );
template < typename _BIter1, typename _BIter2 >
    _BIter2
    copy_backward ( _BIter1, _BIter1, _BIter2 );
template < typename _IIter, typename _OIter, typename _Predicate >
    _OIter
    copy_if ( _IIter, _IIter, _OIter, _Predicate );
template < typename _IIter, typename _Size, typename _OIter >
    _OIter
    copy_n ( _IIter, _Size, _OIter );
template < typename _FIter, typename _Tp >
    pair < _FIter, _FIter >
    equal_range ( _FIter, _FIter, const _Tp & );
template < typename _FIter, typename _Tp, typename _Compare >
    pair < _FIter, _FIter >
    equal_range ( _FIter, _FIter, const _Tp &, _Compare );
template < typename _FIter, typename _Tp >
    void
    fill ( _FIter, _FIter, const _Tp & );
template < typename _OIter, typename _Size, typename _Tp >
    _OIter
    fill_n ( _OIter, _Size, const _Tp & );
template < typename _FIter1, typename _FIter2 >
    _FIter1
    find_end ( _FIter1, _FIter1, _FIter2, _FIter2 );
template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
    _FIter1
    find_end ( _FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate );
template < typename _IIter, typename _Predicate >
    _IIter
    find_if_not ( _IIter, _IIter, _Predicate );
template < typename _IIter1, typename _IIter2 >
    bool
    includes ( _IIter1, _IIter1, _IIter2, _IIter2 );
template < typename _IIter1, typename _IIter2, typename _Compare >
    bool
    includes ( _IIter1, _IIter1, _IIter2, _IIter2, _Compare );
template < typename _BIter >
    void
    inplace_merge ( _BIter, _BIter, _BIter );
template < typename _BIter, typename _Compare >
    void
    inplace_merge ( _BIter, _BIter, _BIter, _Compare );
template < typename _RAIter >
    bool
    is_heap ( _RAIter, _RAIter );
template < typename _RAIter, typename _Compare >
    bool
    is_heap ( _RAIter, _RAIter, _Compare );
template < typename _RAIter >
    _RAIter
    is_heap_until ( _RAIter, _RAIter );
template < typename _RAIter, typename _Compare >
    _RAIter
    is_heap_until ( _RAIter, _RAIter, _Compare );
template < typename _IIter, typename _Predicate >
    bool
    is_partitioned ( _IIter, _IIter, _Predicate );
template < typename _FIter1, typename _FIter2 >
    bool
    is_permutation ( _FIter1, _FIter1, _FIter2 );
template < typename _FIter1, typename _FIter2,
    typename _BinaryPredicate >
    bool
    is_permutation ( _FIter1, _FIter1, _FIter2, _BinaryPredicate );
template < typename _FIter >
    bool
    is_sorted ( _FIter, _FIter );
template < typename _FIter, typename _Compare >
    bool
    is_sorted ( _FIter, _FIter, _Compare );
template < typename _FIter >
    _FIter
    is_sorted_until ( _FIter, _FIter );
template < typename _FIter, typename _Compare >
    _FIter
    is_sorted_until ( _FIter, _FIter, _Compare );
template < typename _FIter1, typename _FIter2 >
    void
    iter_swap ( _FIter1, _FIter2 );
template < typename _FIter, typename _Tp >
    _FIter
    lower_bound ( _FIter, _FIter, const _Tp & );
template < typename _FIter, typename _Tp, typename _Compare >
    _FIter
    lower_bound ( _FIter, _FIter, const _Tp &, _Compare );
template < typename _RAIter >
    void
    make_heap ( _RAIter, _RAIter );
template < typename _RAIter, typename _Compare >
    void
    make_heap ( _RAIter, _RAIter, _Compare );
template < typename _Tp >
    constexpr
    const _Tp &
    max ( const _Tp &, const _Tp & );
template < typename _Tp, typename _Compare >
    constexpr
    const _Tp &
    max ( const _Tp &, const _Tp &, _Compare );
template < typename _Tp >
    constexpr
    const _Tp &
    min ( const _Tp &, const _Tp & );
template < typename _Tp, typename _Compare >
    constexpr
    const _Tp &
    min ( const _Tp &, const _Tp &, _Compare );
template < typename _Tp >
    constexpr
    pair < const _Tp &, const _Tp & >
    minmax ( const _Tp &, const _Tp & );
template < typename _Tp, typename _Compare >
    constexpr
    pair < const _Tp &, const _Tp & >
    minmax ( const _Tp &, const _Tp &, _Compare );
template < typename _FIter >
    constexpr
    pair < _FIter, _FIter >
    minmax_element ( _FIter, _FIter );
template < typename _FIter, typename _Compare >
    constexpr
    pair < _FIter, _FIter >
    minmax_element ( _FIter, _FIter, _Compare );
template < typename _Tp >
    constexpr
    _Tp
    min ( initializer_list < _Tp > );
template < typename _Tp, typename _Compare >
    constexpr
    _Tp
    min ( initializer_list < _Tp >, _Compare );
template < typename _Tp >
    constexpr
    _Tp
    max ( initializer_list < _Tp > );
template < typename _Tp, typename _Compare >
    constexpr
    _Tp
    max ( initializer_list < _Tp >, _Compare );
template < typename _Tp >
    constexpr
    pair < _Tp, _Tp >
    minmax ( initializer_list < _Tp > );
template < typename _Tp, typename _Compare >
    constexpr
    pair < _Tp, _Tp >
    minmax ( initializer_list < _Tp >, _Compare );
template < typename _BIter >
    bool
    next_permutation ( _BIter, _BIter );
template < typename _BIter, typename _Compare >
    bool
    next_permutation ( _BIter, _BIter, _Compare );
template < typename _IIter, typename _Predicate >
    bool
    none_of ( _IIter, _IIter, _Predicate );
template < typename _IIter, typename _RAIter >
    _RAIter
    partial_sort_copy ( _IIter, _IIter, _RAIter, _RAIter );
template < typename _IIter, typename _RAIter, typename _Compare >
    _RAIter
    partial_sort_copy ( _IIter, _IIter, _RAIter, _RAIter, _Compare );
template < typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate >
    pair < _OIter1, _OIter2 >
    partition_copy ( _IIter, _IIter, _OIter1, _OIter2, _Predicate );
template < typename _FIter, typename _Predicate >
    _FIter
    partition_point ( _FIter, _FIter, _Predicate );
template < typename _RAIter >
    void
    pop_heap ( _RAIter, _RAIter );
template < typename _RAIter, typename _Compare >
    void
    pop_heap ( _RAIter, _RAIter, _Compare );
template < typename _BIter >
    bool
    prev_permutation ( _BIter, _BIter );
template < typename _BIter, typename _Compare >
    bool
    prev_permutation ( _BIter, _BIter, _Compare );
template < typename _RAIter >
    void
    push_heap ( _RAIter, _RAIter );
template < typename _RAIter, typename _Compare >
    void
    push_heap ( _RAIter, _RAIter, _Compare );
template < typename _FIter, typename _Tp >
    _FIter
    remove ( _FIter, _FIter, const _Tp & );
template < typename _FIter, typename _Predicate >
    _FIter
    remove_if ( _FIter, _FIter, _Predicate );
template < typename _IIter, typename _OIter, typename _Tp >
    _OIter
    remove_copy ( _IIter, _IIter, _OIter, const _Tp & );
template < typename _IIter, typename _OIter, typename _Predicate >
    _OIter
    remove_copy_if ( _IIter, _IIter, _OIter, _Predicate );
template < typename _IIter, typename _OIter, typename _Tp >
    _OIter
    replace_copy ( _IIter, _IIter, _OIter, const _Tp &, const _Tp & );
template < typename _Iter, typename _OIter, typename _Predicate, typename _Tp >
    _OIter
    replace_copy_if ( _Iter, _Iter, _OIter, _Predicate, const _Tp & );
template < typename _BIter >
    void
    reverse ( _BIter, _BIter );
template < typename _BIter, typename _OIter >
    _OIter
    reverse_copy ( _BIter, _BIter, _OIter );
namespace _V2
{
template < typename _FIter >
      _FIter
      rotate ( _FIter, _FIter, _FIter );
}
template < typename _FIter, typename _OIter >
    _OIter
    rotate_copy ( _FIter, _FIter, _FIter, _OIter );
template < typename _RAIter, typename _UGenerator >
    void
    shuffle ( _RAIter, _RAIter, _UGenerator && );
template < typename _RAIter >
    void
    sort_heap ( _RAIter, _RAIter );
template < typename _RAIter, typename _Compare >
    void
    sort_heap ( _RAIter, _RAIter, _Compare );
template < typename _BIter, typename _Predicate >
    _BIter
    stable_partition ( _BIter, _BIter, _Predicate );
template < typename _FIter1, typename _FIter2 >
    _FIter2
    swap_ranges ( _FIter1, _FIter1, _FIter2 );
template < typename _FIter >
    _FIter
    unique ( _FIter, _FIter );
template < typename _FIter, typename _BinaryPredicate >
    _FIter
    unique ( _FIter, _FIter, _BinaryPredicate );
template < typename _FIter, typename _Tp >
    _FIter
    upper_bound ( _FIter, _FIter, const _Tp & );
template < typename _FIter, typename _Tp, typename _Compare >
    _FIter
    upper_bound ( _FIter, _FIter, const _Tp &, _Compare );
template < typename _FIter >
    _FIter
    adjacent_find ( _FIter, _FIter );
template < typename _FIter, typename _BinaryPredicate >
    _FIter
    adjacent_find ( _FIter, _FIter, _BinaryPredicate );
template < typename _IIter, typename _Tp >
    typename iterator_traits < _IIter > :: difference_type
    count ( _IIter, _IIter, const _Tp & );
template < typename _IIter, typename _Predicate >
    typename iterator_traits < _IIter > :: difference_type
    count_if ( _IIter, _IIter, _Predicate );
template < typename _IIter1, typename _IIter2 >
    bool
    equal ( _IIter1, _IIter1, _IIter2 );
template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
    bool
    equal ( _IIter1, _IIter1, _IIter2, _BinaryPredicate );
template < typename _IIter, typename _Tp >
    _IIter
    find ( _IIter, _IIter, const _Tp & );
template < typename _FIter1, typename _FIter2 >
    _FIter1
    find_first_of ( _FIter1, _FIter1, _FIter2, _FIter2 );
template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
    _FIter1
    find_first_of ( _FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate );
template < typename _IIter, typename _Predicate >
    _IIter
    find_if ( _IIter, _IIter, _Predicate );
template < typename _IIter, typename _Funct >
    _Funct
    for_each ( _IIter, _IIter, _Funct );
template < typename _FIter, typename _Generator >
    void
    generate ( _FIter, _FIter, _Generator );
template < typename _OIter, typename _Size, typename _Generator >
    _OIter
    generate_n ( _OIter, _Size, _Generator );
template < typename _IIter1, typename _IIter2 >
    bool
    lexicographical_compare ( _IIter1, _IIter1, _IIter2, _IIter2 );
template < typename _IIter1, typename _IIter2, typename _Compare >
    bool
    lexicographical_compare ( _IIter1, _IIter1, _IIter2, _IIter2, _Compare );
template < typename _FIter >
    constexpr
    _FIter
    max_element ( _FIter, _FIter );
template < typename _FIter, typename _Compare >
    constexpr
    _FIter
    max_element ( _FIter, _FIter, _Compare );
template < typename _IIter1, typename _IIter2, typename _OIter >
    _OIter
    merge ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter );
template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare >
    _OIter
    merge ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare );
template < typename _FIter >
    constexpr
    _FIter
    min_element ( _FIter, _FIter );
template < typename _FIter, typename _Compare >
    constexpr
    _FIter
    min_element ( _FIter, _FIter, _Compare );
template < typename _IIter1, typename _IIter2 >
    pair < _IIter1, _IIter2 >
    mismatch ( _IIter1, _IIter1, _IIter2 );
template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
    pair < _IIter1, _IIter2 >
    mismatch ( _IIter1, _IIter1, _IIter2, _BinaryPredicate );
template < typename _RAIter >
    void
    nth_element ( _RAIter, _RAIter, _RAIter );
template < typename _RAIter, typename _Compare >
    void
    nth_element ( _RAIter, _RAIter, _RAIter, _Compare );
template < typename _RAIter >
    void
    partial_sort ( _RAIter, _RAIter, _RAIter );
template < typename _RAIter, typename _Compare >
    void
    partial_sort ( _RAIter, _RAIter, _RAIter, _Compare );
template < typename _BIter, typename _Predicate >
    _BIter
    partition ( _BIter, _BIter, _Predicate );
template < typename _RAIter >
    void
    random_shuffle ( _RAIter, _RAIter );
template < typename _RAIter, typename _Generator >
    void
    random_shuffle ( _RAIter, _RAIter,
     _Generator && );
template < typename _FIter, typename _Tp >
    void
    replace ( _FIter, _FIter, const _Tp &, const _Tp & );
template < typename _FIter, typename _Predicate, typename _Tp >
    void
    replace_if ( _FIter, _FIter, _Predicate, const _Tp & );
template < typename _FIter1, typename _FIter2 >
    _FIter1
    search ( _FIter1, _FIter1, _FIter2, _FIter2 );
template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
    _FIter1
    search ( _FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate );
template < typename _FIter, typename _Size, typename _Tp >
    _FIter
    search_n ( _FIter, _FIter, _Size, const _Tp & );
template < typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate >
    _FIter
    search_n ( _FIter, _FIter, _Size, const _Tp &, _BinaryPredicate );
template < typename _IIter1, typename _IIter2, typename _OIter >
    _OIter
    set_difference ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter );
template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare >
    _OIter
    set_difference ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare );
template < typename _IIter1, typename _IIter2, typename _OIter >
    _OIter
    set_intersection ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter );
template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare >
    _OIter
    set_intersection ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare );
template < typename _IIter1, typename _IIter2, typename _OIter >
    _OIter
    set_symmetric_difference ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter );
template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare >
    _OIter
    set_symmetric_difference ( _IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare );
template < typename _IIter1, typename _IIter2, typename _OIter >
    _OIter
    set_union ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter );
template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare >
    _OIter
    set_union ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare );
template < typename _RAIter >
    void
    sort ( _RAIter, _RAIter );
template < typename _RAIter, typename _Compare >
    void
    sort ( _RAIter, _RAIter, _Compare );
template < typename _RAIter >
    void
    stable_sort ( _RAIter, _RAIter );
template < typename _RAIter, typename _Compare >
    void
    stable_sort ( _RAIter, _RAIter, _Compare );
template < typename _IIter, typename _OIter, typename _UnaryOperation >
    _OIter
    transform ( _IIter, _IIter, _OIter, _UnaryOperation );
template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation >
    _OIter
    transform ( _IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation );
template < typename _IIter, typename _OIter >
    _OIter
    unique_copy ( _IIter, _IIter, _OIter );
template < typename _IIter, typename _OIter, typename _BinaryPredicate >
    _OIter
    unique_copy ( _IIter, _IIter, _OIter, _BinaryPredicate );
}
}
namespace std
{
template < typename _RandomAccessIterator, typename _Distance,
    typename _Compare >
    _Distance
    __is_heap_until ( _RandomAccessIterator __first, _Distance __n,
      _Compare __comp )
    {
      _Distance __parent = 0;
      for ( _Distance __child = 1; __child < __n; ++ __child )
 {
   if ( __comp ( __first + __parent, __first + __child ) )
     return __child;
   if ( ( __child & 1 ) == 0 )
     ++ __parent;
 }
      return __n;
    }
template < typename _RandomAccessIterator, typename _Distance >
    inline bool
    __is_heap ( _RandomAccessIterator __first, _Distance __n )
    {
      return std :: __is_heap_until ( __first, __n,
   __gnu_cxx :: __ops :: __iter_less_iter ( ) ) == __n;
    }
template < typename _RandomAccessIterator, typename _Compare,
    typename _Distance >
    inline bool
    __is_heap ( _RandomAccessIterator __first, _Compare __comp, _Distance __n )
    {
      return std :: __is_heap_until ( __first, __n,
 __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) ) == __n;
    }
template < typename _RandomAccessIterator >
    inline bool
    __is_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last )
    { return std :: __is_heap ( __first, std :: distance ( __first, __last ) ); }
template < typename _RandomAccessIterator, typename _Compare >
    inline bool
    __is_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp )
    { return std :: __is_heap ( __first, __comp, std :: distance ( __first, __last ) ); }
template < typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare >
    void
    __push_heap ( _RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare __comp )
    {
      _Distance __parent = ( __holeIndex - 1 ) / 2;
      while ( __holeIndex > __topIndex && __comp ( __first + __parent, __value ) )
 {
   * ( __first + __holeIndex ) = std :: move ( * ( __first + __parent ) );
   __holeIndex = __parent;
   __parent = ( __holeIndex - 1 ) / 2;
 }
      * ( __first + __holeIndex ) = std :: move ( __value );
    }
template < typename _RandomAccessIterator >
    inline void
    push_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last )
    {
      typedef typename iterator_traits < _RandomAccessIterator > :: value_type
   _ValueType;
      typedef typename iterator_traits < _RandomAccessIterator > :: difference_type
   _DistanceType;
      ;
      ;
      ;
      _ValueType __value = std :: move ( * ( __last - 1 ) );
      std :: __push_heap ( __first, _DistanceType ( ( __last - __first ) - 1 ),
         _DistanceType ( 0 ), std :: move ( __value ),
         __gnu_cxx :: __ops :: __iter_less_val ( ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    push_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp )
    {
      typedef typename iterator_traits < _RandomAccessIterator > :: value_type
   _ValueType;
      typedef typename iterator_traits < _RandomAccessIterator > :: difference_type
   _DistanceType;
      ;
      ;
      ;
      _ValueType __value = std :: move ( * ( __last - 1 ) );
      std :: __push_heap ( __first, _DistanceType ( ( __last - __first ) - 1 ),
         _DistanceType ( 0 ), std :: move ( __value ),
         __gnu_cxx :: __ops :: __iter_comp_val ( __comp ) );
    }
template < typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare >
    void
    __adjust_heap ( _RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp )
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while ( __secondChild < ( __len - 1 ) / 2 )
 {
   __secondChild = 2 * ( __secondChild + 1 );
   if ( __comp ( __first + __secondChild,
       __first + ( __secondChild - 1 ) ) )
     __secondChild --;
   * ( __first + __holeIndex ) = std :: move ( * ( __first + __secondChild ) );
   __holeIndex = __secondChild;
 }
      if ( ( __len & 1 ) == 0 && __secondChild == ( __len - 2 ) / 2 )
 {
   __secondChild = 2 * ( __secondChild + 1 );
   * ( __first + __holeIndex ) = std :: move ( * ( __first + ( __secondChild - 1 ) ) )
                                  ;
   __holeIndex = __secondChild - 1;
 }
      std :: __push_heap ( __first, __holeIndex, __topIndex,
         std :: move ( __value ),
         __gnu_cxx :: __ops :: __iter_comp_val ( __comp ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    __pop_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp )
    {
      typedef typename iterator_traits < _RandomAccessIterator > :: value_type
 _ValueType;
      typedef typename iterator_traits < _RandomAccessIterator > :: difference_type
 _DistanceType;
      _ValueType __value = std :: move ( * __result );
      * __result = std :: move ( * __first );
      std :: __adjust_heap ( __first, _DistanceType ( 0 ),
    _DistanceType ( __last - __first ),
    std :: move ( __value ), __comp );
    }
template < typename _RandomAccessIterator >
    inline void
    pop_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last )
    {
      ;
      ;
      ;
      ;
      if ( __last - __first > 1 )
 {
   -- __last;
   std :: __pop_heap ( __first, __last, __last,
     __gnu_cxx :: __ops :: __iter_less_iter ( ) );
 }
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    pop_heap ( _RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp )
    {
      ;
      ;
      ;
      ;
      if ( __last - __first > 1 )
 {
   -- __last;
   std :: __pop_heap ( __first, __last, __last,
     __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
 }
    }
template < typename _RandomAccessIterator, typename _Compare >
    void
    __make_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp )
    {
      typedef typename iterator_traits < _RandomAccessIterator > :: value_type
   _ValueType;
      typedef typename iterator_traits < _RandomAccessIterator > :: difference_type
   _DistanceType;
      if ( __last - __first < 2 )
 return;
      const _DistanceType __len = __last - __first;
      _DistanceType __parent = ( __len - 2 ) / 2;
      while ( true )
 {
   _ValueType __value = std :: move ( * ( __first + __parent ) );
   std :: __adjust_heap ( __first, __parent, __len, std :: move ( __value ),
        __comp );
   if ( __parent == 0 )
     return;
   __parent --;
 }
    }
template < typename _RandomAccessIterator >
    inline void
    make_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last )
    {
      ;
      ;
      std :: __make_heap ( __first, __last,
         __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    make_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp )
    {
      ;
      ;
      std :: __make_heap ( __first, __last,
         __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    void
    __sort_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp )
    {
      while ( __last - __first > 1 )
 {
   -- __last;
   std :: __pop_heap ( __first, __last, __last, __comp );
 }
    }
template < typename _RandomAccessIterator >
    inline void
    sort_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last )
    {
      ;
      ;
      ;
      std :: __sort_heap ( __first, __last,
         __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    sort_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp )
    {
      ;
      ;
      ;
      std :: __sort_heap ( __first, __last,
         __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _RandomAccessIterator >
    inline _RandomAccessIterator
    is_heap_until ( _RandomAccessIterator __first, _RandomAccessIterator __last )
    {
      ;
      ;
      return __first +
 std :: __is_heap_until ( __first, std :: distance ( __first, __last ),
        __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline _RandomAccessIterator
    is_heap_until ( _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp )
    {
      ;
      ;
      return __first
 + std :: __is_heap_until ( __first, std :: distance ( __first, __last ),
          __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _RandomAccessIterator >
    inline bool
    is_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last )
    { return std :: is_heap_until ( __first, __last ) == __last; }
template < typename _RandomAccessIterator, typename _Compare >
    inline bool
    is_heap ( _RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp )
    { return std :: is_heap_until ( __first, __last, __comp ) == __last; }
}
namespace std
{
namespace __detail
{
template < typename _Tp >
      inline bool
      _Power_of_2 ( _Tp __x )
      {
 return ( ( __x - 1 ) & __x ) == 0;
      }
}
template < typename _IntType = int >
    class uniform_int_distribution
    {
      static_assert ( std :: is_integral < _IntType > :: value,
      "template argument not an integral type" );
    public :
      typedef _IntType result_type;
      struct param_type
      {
 typedef uniform_int_distribution < _IntType > distribution_type;
 explicit
 param_type ( _IntType __a = 0,
     _IntType __b = std :: numeric_limits < _IntType > :: max ( ) )
 ;
 result_type
 a ( ) const
 ;
 result_type
 b ( ) const
 ;
 friend bool
 operator == ( const param_type & __p1, const param_type & __p2 );
      private :
 _IntType _M_a;
 _IntType _M_b;
      };
    public :
      explicit
      uniform_int_distribution ( _IntType __a = 0,
      _IntType __b = std :: numeric_limits < _IntType > :: max ( ) )
      ;
      explicit
      uniform_int_distribution ( const param_type & __p )
      ;
      void
      reset ( );
      result_type
      a ( ) const
      ;
      result_type
      b ( ) const
      ;
      param_type
      param ( ) const
      ;
      void
      param ( const param_type & __param )
      ;
      result_type
      min ( ) const
      ;
      result_type
      max ( ) const
      ;
      template < typename _UniformRandomNumberGenerator >
 result_type
 operator ( ) ( _UniformRandomNumberGenerator & __urng )
        { return this -> operator ( ) ( __urng, _M_param ); }
      template < typename _UniformRandomNumberGenerator >
 result_type
 operator ( ) ( _UniformRandomNumberGenerator & __urng,
     const param_type & __p );
      template < typename _ForwardIterator,
        typename _UniformRandomNumberGenerator >
 void
 __generate ( _ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator & __urng )
 { this -> __generate ( __f, __t, __urng, _M_param ); }
      template < typename _ForwardIterator,
        typename _UniformRandomNumberGenerator >
 void
 __generate ( _ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator & __urng,
     const param_type & __p )
 { this -> __generate_impl ( __f, __t, __urng, __p ); }
      template < typename _UniformRandomNumberGenerator >
 void
 __generate ( result_type * __f, result_type * __t,
     _UniformRandomNumberGenerator & __urng,
     const param_type & __p )
 { this -> __generate_impl ( __f, __t, __urng, __p ); }
      friend bool
      operator == ( const uniform_int_distribution & __d1,
   const uniform_int_distribution & __d2 );
    private :
      template < typename _ForwardIterator,
        typename _UniformRandomNumberGenerator >
 void
 __generate_impl ( _ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator & __urng,
   const param_type & __p );
      param_type _M_param;
    };
template < typename _IntType >
    template < typename _UniformRandomNumberGenerator >
      typename uniform_int_distribution < _IntType > :: result_type
      uniform_int_distribution < _IntType > ::
      operator ( ) ( _UniformRandomNumberGenerator & __urng,
   const param_type & __param )
      {
 typedef typename _UniformRandomNumberGenerator :: result_type
   _Gresult_type;
 typedef typename std :: make_unsigned < result_type > :: type __utype;
 typedef typename std :: common_type < _Gresult_type, __utype > :: type
   __uctype;
 const __uctype __urngmin = __urng . min ( );
 const __uctype __urngmax = __urng . max ( );
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype ( __param . b ( ) ) - __uctype ( __param . a ( ) );
 __uctype __ret;
 if ( __urngrange > __urange )
   {
     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype ( __urng ( ) ) - __urngmin;
     while ( __ret >= __past );
     __ret /= __scaling;
   }
 else if ( __urngrange < __urange )
   {
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = ( __uerngrange * operator ( )
    ( __urng, param_type ( 0, __urange / __uerngrange ) ) );
  __ret = __tmp + ( __uctype ( __urng ( ) ) - __urngmin );
       }
     while ( __ret > __urange || __ret < __tmp );
   }
 else
   __ret = __uctype ( __urng ( ) ) - __urngmin;
 return __ret + __param . a ( );
      }
template < typename _IntType >
    template < typename _ForwardIterator,
      typename _UniformRandomNumberGenerator >
      void
      uniform_int_distribution < _IntType > ::
      __generate_impl ( _ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator & __urng,
        const param_type & __param )
      {
 typedef typename _UniformRandomNumberGenerator :: result_type
   _Gresult_type;
 typedef typename std :: make_unsigned < result_type > :: type __utype;
 typedef typename std :: common_type < _Gresult_type, __utype > :: type
   __uctype;
 const __uctype __urngmin = __urng . min ( );
 const __uctype __urngmax = __urng . max ( );
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype ( __param . b ( ) ) - __uctype ( __param . a ( ) );
 __uctype __ret;
 if ( __urngrange > __urange )
   {
     if ( __detail :: _Power_of_2 ( __urngrange + 1 )
  && __detail :: _Power_of_2 ( __urange + 1 ) )
       {
  while ( __f != __t )
    {
      __ret = __uctype ( __urng ( ) ) - __urngmin;
      * __f ++ = ( __ret & __urange ) + __param . a ( );
    }
       }
     else
       {
  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while ( __f != __t )
    {
      do
        __ret = __uctype ( __urng ( ) ) - __urngmin;
      while ( __ret >= __past );
      * __f ++ = __ret / __scaling + __param . a ( );
    }
       }
   }
 else if ( __urngrange < __urange )
   {
     __uctype __tmp;
     while ( __f != __t )
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = ( __uerngrange * operator ( )
        ( __urng, param_type ( 0, __urange / __uerngrange ) ) );
      __ret = __tmp + ( __uctype ( __urng ( ) ) - __urngmin );
    }
  while ( __ret > __urange || __ret < __tmp );
  * __f ++ = __ret;
       }
   }
 else
   while ( __f != __t )
     * __f ++ = __uctype ( __urng ( ) ) - __urngmin + __param . a ( );
      }
}
namespace std
{
template < typename _Iterator, typename _Compare >
    void
    __move_median_to_first ( _Iterator __result, _Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp )
    {
      if ( __comp ( __a, __b ) )
 {
   if ( __comp ( __b, __c ) )
     std :: iter_swap ( __result, __b );
   else if ( __comp ( __a, __c ) )
     std :: iter_swap ( __result, __c );
   else
     std :: iter_swap ( __result, __a );
 }
      else if ( __comp ( __a, __c ) )
 std :: iter_swap ( __result, __a );
      else if ( __comp ( __b, __c ) )
 std :: iter_swap ( __result, __c );
      else
 std :: iter_swap ( __result, __b );
    }
template < typename _InputIterator, typename _Predicate >
    inline _InputIterator
    __find_if ( _InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag )
    {
      while ( __first != __last && ! __pred ( __first ) )
 ++ __first;
      return __first;
    }
template < typename _RandomAccessIterator, typename _Predicate >
    _RandomAccessIterator
    __find_if ( _RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag )
    {
      typename iterator_traits < _RandomAccessIterator > :: difference_type
 __trip_count = ( __last - __first ) >> 2;
      for (; __trip_count > 0; -- __trip_count )
 {
   if ( __pred ( __first ) )
     return __first;
   ++ __first;
   if ( __pred ( __first ) )
     return __first;
   ++ __first;
   if ( __pred ( __first ) )
     return __first;
   ++ __first;
   if ( __pred ( __first ) )
     return __first;
   ++ __first;
 }
      switch ( __last - __first )
 {
 case 3 :
   if ( __pred ( __first ) )
     return __first;
   ++ __first;
 case 2 :
   if ( __pred ( __first ) )
     return __first;
   ++ __first;
 case 1 :
   if ( __pred ( __first ) )
     return __first;
   ++ __first;
 case 0 :
 default :
   return __last;
 }
    }
template < typename _Iterator, typename _Predicate >
    inline _Iterator
    __find_if ( _Iterator __first, _Iterator __last, _Predicate __pred )
    {
      return __find_if ( __first, __last, __pred,
         std :: __iterator_category ( __first ) );
    }
template < typename _InputIterator, typename _Predicate >
    inline _InputIterator
    __find_if_not ( _InputIterator __first, _InputIterator __last,
    _Predicate __pred )
    {
      return std :: __find_if ( __first, __last,
       __gnu_cxx :: __ops :: __negate ( __pred ),
       std :: __iterator_category ( __first ) );
    }
template < typename _InputIterator, typename _Predicate, typename _Distance >
    _InputIterator
    __find_if_not_n ( _InputIterator __first, _Distance & __len, _Predicate __pred )
    {
      for (; __len; -- __len, ++ __first )
 if ( ! __pred ( __first ) )
   break;
      return __first;
    }
template < typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate >
    _ForwardIterator1
    __search ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate )
    {
      if ( __first1 == __last1 || __first2 == __last2 )
 return __first1;
      _ForwardIterator2 __p1 ( __first2 );
      if ( ++ __p1 == __last2 )
 return std :: __find_if ( __first1, __last1,
  __gnu_cxx :: __ops :: __iter_comp_iter ( __predicate, __first2 ) );
      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;
      for (;; )
 {
   __first1 =
     std :: __find_if ( __first1, __last1,
  __gnu_cxx :: __ops :: __iter_comp_iter ( __predicate, __first2 ) );
   if ( __first1 == __last1 )
     return __last1;
   __p = __p1;
   __current = __first1;
   if ( ++ __current == __last1 )
     return __last1;
   while ( __predicate ( __current, __p ) )
     {
       if ( ++ __p == __last2 )
  return __first1;
       if ( ++ __current == __last1 )
  return __last1;
     }
   ++ __first1;
 }
      return __first1;
    }
template < typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate >
    _ForwardIterator
    __search_n_aux ( _ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std :: forward_iterator_tag )
    {
      __first = std :: __find_if ( __first, __last, __unary_pred );
      while ( __first != __last )
 {
   typename iterator_traits < _ForwardIterator > :: difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++ __i;
   while ( __i != __last && __n != 1 && __unary_pred ( __i ) )
     {
       ++ __i;
       -- __n;
     }
   if ( __n == 1 )
     return __first;
   if ( __i == __last )
     return __last;
   __first = std :: __find_if ( ++ __i, __last, __unary_pred );
 }
      return __last;
    }
template < typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate >
    _RandomAccessIter
    __search_n_aux ( _RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std :: random_access_iterator_tag )
    {
      typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type
 _DistanceType;
      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;
      while ( __remainder <= __tailSize )
 {
   __first += __remainder;
   __tailSize -= __remainder;
   _RandomAccessIter __backTrack = __first;
   while ( __unary_pred ( -- __backTrack ) )
     {
       if ( -- __remainder == 0 )
  return ( __first - __count );
     }
   __remainder = __count + 1 - ( __first - __backTrack );
 }
      return __last;
    }
template < typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate >
    _ForwardIterator
    __search_n ( _ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred )
    {
      if ( __count <= 0 )
 return __first;
      if ( __count == 1 )
 return std :: __find_if ( __first, __last, __unary_pred );
      return std :: __search_n_aux ( __first, __last, __count, __unary_pred,
     std :: __iterator_category ( __first ) );
    }
template < typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate >
    _ForwardIterator1
    __find_end ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp )
    {
      if ( __first2 == __last2 )
 return __last1;
      _ForwardIterator1 __result = __last1;
      while ( 1 )
 {
   _ForwardIterator1 __new_result
     = std :: __search ( __first1, __last1, __first2, __last2, __comp );
   if ( __new_result == __last1 )
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++ __first1;
     }
 }
    }
template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate >
    _BidirectionalIterator1
    __find_end ( _BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp )
    {
      typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1;
      typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2;
      _RevIterator1 __rlast1 ( __first1 );
      _RevIterator2 __rlast2 ( __first2 );
      _RevIterator1 __rresult = std :: __search ( _RevIterator1 ( __last1 ), __rlast1,
           _RevIterator2 ( __last2 ), __rlast2,
           __comp );
      if ( __rresult == __rlast1 )
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult . base ( );
   std :: advance ( __result, - std :: distance ( __first2, __last2 ) );
   return __result;
 }
    }
template < typename _ForwardIterator1, typename _ForwardIterator2 >
    inline _ForwardIterator1
    find_end ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2 )
    {
      ;
      ;
      return std :: __find_end ( __first1, __last1, __first2, __last2,
        std :: __iterator_category ( __first1 ),
        std :: __iterator_category ( __first2 ),
        __gnu_cxx :: __ops :: __iter_equal_to_iter ( ) );
    }
template < typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate >
    inline _ForwardIterator1
    find_end ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp )
    {
      ;
      ;
      return std :: __find_end ( __first1, __last1, __first2, __last2,
        std :: __iterator_category ( __first1 ),
        std :: __iterator_category ( __first2 ),
        __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _InputIterator, typename _Predicate >
    inline bool
    all_of ( _InputIterator __first, _InputIterator __last, _Predicate __pred )
    { return __last == std :: find_if_not ( __first, __last, __pred ); }
template < typename _InputIterator, typename _Predicate >
    inline bool
    none_of ( _InputIterator __first, _InputIterator __last, _Predicate __pred )
    { return __last == std :: find_if ( __first, __last, __pred ); }
template < typename _InputIterator, typename _Predicate >
    inline bool
    any_of ( _InputIterator __first, _InputIterator __last, _Predicate __pred )
    { return ! std :: none_of ( __first, __last, __pred ); }
template < typename _InputIterator, typename _Predicate >
    inline _InputIterator
    find_if_not ( _InputIterator __first, _InputIterator __last,
  _Predicate __pred )
    {
      ;
      return std :: __find_if_not ( __first, __last,
    __gnu_cxx :: __ops :: __pred_iter ( __pred ) );
    }
template < typename _InputIterator, typename _Predicate >
    inline bool
    is_partitioned ( _InputIterator __first, _InputIterator __last,
     _Predicate __pred )
    {
      __first = std :: find_if_not ( __first, __last, __pred );
      return std :: none_of ( __first, __last, __pred );
    }
template < typename _ForwardIterator, typename _Predicate >
    _ForwardIterator
    partition_point ( _ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred )
    {
      ;
      typedef typename iterator_traits < _ForwardIterator > :: difference_type
 _DistanceType;
      _DistanceType __len = std :: distance ( __first, __last );
      _DistanceType __half;
      _ForwardIterator __middle;
      while ( __len > 0 )
 {
   __half = __len >> 1;
   __middle = __first;
   std :: advance ( __middle, __half );
   if ( __pred ( * __middle ) )
     {
       __first = __middle;
       ++ __first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
template < typename _InputIterator, typename _OutputIterator,
    typename _Predicate >
    _OutputIterator
    __remove_copy_if ( _InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred )
    {
      for (; __first != __last; ++ __first )
 if ( ! __pred ( __first ) )
   {
     * __result = * __first;
     ++ __result;
   }
      return __result;
    }
template < typename _InputIterator, typename _OutputIterator, typename _Tp >
    inline _OutputIterator
    remove_copy ( _InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp & __value )
    {
      ;
      return std :: __remove_copy_if ( __first, __last, __result,
 __gnu_cxx :: __ops :: __iter_equals_val ( __value ) );
    }
template < typename _InputIterator, typename _OutputIterator,
    typename _Predicate >
    inline _OutputIterator
    remove_copy_if ( _InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred )
    {
      ;
      return std :: __remove_copy_if ( __first, __last, __result,
       __gnu_cxx :: __ops :: __pred_iter ( __pred ) );
    }
template < typename _InputIterator, typename _OutputIterator,
    typename _Predicate >
    _OutputIterator
    copy_if ( _InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred )
    {
      ;
      for (; __first != __last; ++ __first )
 if ( __pred ( * __first ) )
   {
     * __result = * __first;
     ++ __result;
   }
      return __result;
    }
template < typename _InputIterator, typename _Size, typename _OutputIterator >
    _OutputIterator
    __copy_n ( _InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag )
    {
      if ( __n > 0 )
 {
   while ( true )
     {
       * __result = * __first;
       ++ __result;
       if ( -- __n > 0 )
  ++ __first;
       else
  break;
     }
 }
      return __result;
    }
template < typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator >
    inline _OutputIterator
    __copy_n ( _RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag )
    { return std :: copy ( __first, __first + __n, __result ); }
template < typename _InputIterator, typename _Size, typename _OutputIterator >
    inline _OutputIterator
    copy_n ( _InputIterator __first, _Size __n, _OutputIterator __result )
    {
      return std :: __copy_n ( __first, __n, __result,
      std :: __iterator_category ( __first ) );
    }
template < typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate >
    pair < _OutputIterator1, _OutputIterator2 >
    partition_copy ( _InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred )
    {
      ;
      for (; __first != __last; ++ __first )
 if ( __pred ( * __first ) )
   {
     * __out_true = * __first;
     ++ __out_true;
   }
 else
   {
     * __out_false = * __first;
     ++ __out_false;
   }
      return pair < _OutputIterator1, _OutputIterator2 > ( __out_true, __out_false );
    }
template < typename _ForwardIterator, typename _Predicate >
    _ForwardIterator
    __remove_if ( _ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred )
    {
      __first = std :: __find_if ( __first, __last, __pred );
      if ( __first == __last )
 return __first;
      _ForwardIterator __result = __first;
      ++ __first;
      for (; __first != __last; ++ __first )
 if ( ! __pred ( __first ) )
   {
     * __result = std :: move ( * __first );
     ++ __result;
   }
      return __result;
    }
template < typename _ForwardIterator, typename _Tp >
    inline _ForwardIterator
    remove ( _ForwardIterator __first, _ForwardIterator __last,
    const _Tp & __value )
    {
      ;
      return std :: __remove_if ( __first, __last,
  __gnu_cxx :: __ops :: __iter_equals_val ( __value ) );
    }
template < typename _ForwardIterator, typename _Predicate >
    inline _ForwardIterator
    remove_if ( _ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred )
    {
      ;
      return std :: __remove_if ( __first, __last,
         __gnu_cxx :: __ops :: __pred_iter ( __pred ) );
    }
template < typename _ForwardIterator, typename _BinaryPredicate >
    _ForwardIterator
    __adjacent_find ( _ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred )
    {
      if ( __first == __last )
 return __last;
      _ForwardIterator __next = __first;
      while ( ++ __next != __last )
 {
   if ( __binary_pred ( __first, __next ) )
     return __first;
   __first = __next;
 }
      return __last;
    }
template < typename _ForwardIterator, typename _BinaryPredicate >
    _ForwardIterator
    __unique ( _ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred )
    {
      __first = std :: __adjacent_find ( __first, __last, __binary_pred );
      if ( __first == __last )
 return __last;
      _ForwardIterator __dest = __first;
      ++ __first;
      while ( ++ __first != __last )
 if ( ! __binary_pred ( __dest, __first ) )
   * ++ __dest = std :: move ( * __first );
      return ++ __dest;
    }
template < typename _ForwardIterator >
    inline _ForwardIterator
    unique ( _ForwardIterator __first, _ForwardIterator __last )
    {
      ;
      return std :: __unique ( __first, __last,
      __gnu_cxx :: __ops :: __iter_equal_to_iter ( ) );
    }
template < typename _ForwardIterator, typename _BinaryPredicate >
    inline _ForwardIterator
    unique ( _ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred )
    {
      ;
      return std :: __unique ( __first, __last,
      __gnu_cxx :: __ops :: __iter_comp_iter ( __binary_pred ) );
    }
template < typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate >
    _OutputIterator
    __unique_copy ( _ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag )
    {
      _ForwardIterator __next = __first;
      * __result = * __first;
      while ( ++ __next != __last )
 if ( ! __binary_pred ( __first, __next ) )
   {
     __first = __next;
     * ++ __result = * __first;
   }
      return ++ __result;
    }
template < typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate >
    _OutputIterator
    __unique_copy ( _InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag )
    {
      typename iterator_traits < _InputIterator > :: value_type __value = * __first;
      decltype ( __gnu_cxx :: __ops :: __iter_comp_val ( __binary_pred ) )
 __rebound_pred
 = __gnu_cxx :: __ops :: __iter_comp_val ( __binary_pred );
      * __result = __value;
      while ( ++ __first != __last )
 if ( ! __rebound_pred ( __first, __value ) )
   {
     __value = * __first;
     * ++ __result = __value;
   }
      return ++ __result;
    }
template < typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate >
    _ForwardIterator
    __unique_copy ( _InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag )
    {
      * __result = * __first;
      while ( ++ __first != __last )
 if ( ! __binary_pred ( __result, __first ) )
   * ++ __result = * __first;
      return ++ __result;
    }
template < typename _BidirectionalIterator >
    void
    __reverse ( _BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag )
    {
      while ( true )
 if ( __first == __last || __first == -- __last )
   return;
 else
   {
     std :: iter_swap ( __first, __last );
     ++ __first;
   }
    }
template < typename _RandomAccessIterator >
    void
    __reverse ( _RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag )
    {
      if ( __first == __last )
 return;
      -- __last;
      while ( __first < __last )
 {
   std :: iter_swap ( __first, __last );
   ++ __first;
   -- __last;
 }
    }
template < typename _BidirectionalIterator >
    inline void
    reverse ( _BidirectionalIterator __first, _BidirectionalIterator __last )
    {
      ;
      std :: __reverse ( __first, __last, std :: __iterator_category ( __first ) );
    }
template < typename _BidirectionalIterator, typename _OutputIterator >
    _OutputIterator
    reverse_copy ( _BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result )
    {
      ;
      while ( __first != __last )
 {
   -- __last;
   * __result = * __last;
   ++ __result;
 }
      return __result;
    }
template < typename _EuclideanRingElement >
    _EuclideanRingElement
    __gcd ( _EuclideanRingElement __m, _EuclideanRingElement __n )
    {
      while ( __n != 0 )
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }
namespace _V2
{
template < typename _ForwardIterator >
    _ForwardIterator
    __rotate ( _ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag )
    {
      if ( __first == __middle )
 return __last;
      else if ( __last == __middle )
 return __first;
      _ForwardIterator __first2 = __middle;
      do
 {
   std :: iter_swap ( __first, __first2 );
   ++ __first;
   ++ __first2;
   if ( __first == __middle )
     __middle = __first2;
 }
      while ( __first2 != __last );
      _ForwardIterator __ret = __first;
      __first2 = __middle;
      while ( __first2 != __last )
 {
   std :: iter_swap ( __first, __first2 );
   ++ __first;
   ++ __first2;
   if ( __first == __middle )
     __middle = __first2;
   else if ( __first2 == __last )
     __first2 = __middle;
 }
      return __ret;
    }
template < typename _BidirectionalIterator >
    _BidirectionalIterator
    __rotate ( _BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag )
    {
      if ( __first == __middle )
 return __last;
      else if ( __last == __middle )
 return __first;
      std :: __reverse ( __first, __middle, bidirectional_iterator_tag ( ) );
      std :: __reverse ( __middle, __last, bidirectional_iterator_tag ( ) );
      while ( __first != __middle && __middle != __last )
 {
   std :: iter_swap ( __first, -- __last );
   ++ __first;
 }
      if ( __first == __middle )
 {
   std :: __reverse ( __middle, __last, bidirectional_iterator_tag ( ) );
   return __last;
 }
      else
 {
   std :: __reverse ( __first, __middle, bidirectional_iterator_tag ( ) );
   return __first;
 }
    }
template < typename _RandomAccessIterator >
    _RandomAccessIterator
    __rotate ( _RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag )
    {
      if ( __first == __middle )
 return __last;
      else if ( __last == __middle )
 return __first;
      typedef typename iterator_traits < _RandomAccessIterator > :: difference_type
 _Distance;
      typedef typename iterator_traits < _RandomAccessIterator > :: value_type
 _ValueType;
      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;
      if ( __k == __n - __k )
 {
   std :: swap_ranges ( __first, __middle, __middle );
   return __middle;
 }
      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + ( __last - __middle );
      for (;; )
 {
   if ( __k < __n - __k )
     {
       if ( __is_pod ( _ValueType ) && __k == 1 )
  {
    _ValueType __t = std :: move ( * __p );
    std :: move ( __p + 1, __p + __n, __p );
    * ( __p + __n - 1 ) = std :: move ( __t );
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for ( _Distance __i = 0; __i < __n - __k; ++ __i )
  {
    std :: iter_swap ( __p, __q );
    ++ __p;
    ++ __q;
  }
       __n %= __k;
       if ( __n == 0 )
  return __ret;
       std :: swap ( __n, __k );
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if ( __is_pod ( _ValueType ) && __k == 1 )
  {
    _ValueType __t = std :: move ( * ( __p + __n - 1 ) );
    std :: move_backward ( __p, __p + __n - 1, __p + __n );
    * __p = std :: move ( __t );
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for ( _Distance __i = 0; __i < __n - __k; ++ __i )
  {
    -- __p;
    -- __q;
    std :: iter_swap ( __p, __q );
  }
       __n %= __k;
       if ( __n == 0 )
  return __ret;
       std :: swap ( __n, __k );
     }
 }
    }
template < typename _ForwardIterator >
    inline _ForwardIterator
    rotate ( _ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last )
    {
      ;
      ;
      return std :: __rotate ( __first, __middle, __last,
      std :: __iterator_category ( __first ) );
    }
}
template < typename _ForwardIterator, typename _OutputIterator >
    inline _OutputIterator
    rotate_copy ( _ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result )
    {
      ;
      ;
      return std :: copy ( __first, __middle,
         std :: copy ( __middle, __last, __result ) );
    }
template < typename _ForwardIterator, typename _Predicate >
    _ForwardIterator
    __partition ( _ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag )
    {
      if ( __first == __last )
 return __first;
      while ( __pred ( * __first ) )
 if ( ++ __first == __last )
   return __first;
      _ForwardIterator __next = __first;
      while ( ++ __next != __last )
 if ( __pred ( * __next ) )
   {
     std :: iter_swap ( __first, __next );
     ++ __first;
   }
      return __first;
    }
template < typename _BidirectionalIterator, typename _Predicate >
    _BidirectionalIterator
    __partition ( _BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag )
    {
      while ( true )
 {
   while ( true )
     if ( __first == __last )
       return __first;
     else if ( __pred ( * __first ) )
       ++ __first;
     else
       break;
   -- __last;
   while ( true )
     if ( __first == __last )
       return __first;
     else if ( ! bool ( __pred ( * __last ) ) )
       -- __last;
     else
       break;
   std :: iter_swap ( __first, __last );
   ++ __first;
 }
    }
template < typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance >
    _ForwardIterator
    __stable_partition_adaptive ( _ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size )
    {
      if ( __len == 1 )
 return __first;
      if ( __len <= __buffer_size )
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   * __result2 = std :: move ( * __first );
   ++ __result2;
   ++ __first;
   for (; __first != __last; ++ __first )
     if ( __pred ( __first ) )
       {
  * __result1 = std :: move ( * __first );
  ++ __result1;
       }
     else
       {
  * __result2 = std :: move ( * __first );
  ++ __result2;
       }
   std :: move ( __buffer, __result2, __result1 );
   return __result1;
 }
      _ForwardIterator __middle = __first;
      std :: advance ( __middle, __len / 2 );
      _ForwardIterator __left_split =
 std :: __stable_partition_adaptive ( __first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size );
      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std :: __find_if_not_n ( __middle, __right_len, __pred );
      if ( __right_len )
 __right_split =
   std :: __stable_partition_adaptive ( __right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size );
      std :: rotate ( __left_split, __middle, __right_split );
      std :: advance ( __left_split, std :: distance ( __middle, __right_split ) );
      return __left_split;
    }
template < typename _ForwardIterator, typename _Predicate >
    _ForwardIterator
    __stable_partition ( _ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred )
    {
      __first = std :: __find_if_not ( __first, __last, __pred );
      if ( __first == __last )
 return __first;
      typedef typename iterator_traits < _ForwardIterator > :: value_type
 _ValueType;
      typedef typename iterator_traits < _ForwardIterator > :: difference_type
 _DistanceType;
      _Temporary_buffer < _ForwardIterator, _ValueType > __buf ( __first, __last );
      return
 std :: __stable_partition_adaptive ( __first, __last, __pred,
      _DistanceType ( __buf . requested_size ( ) ),
      __buf . begin ( ),
      _DistanceType ( __buf . size ( ) ) );
    }
template < typename _ForwardIterator, typename _Predicate >
    inline _ForwardIterator
    stable_partition ( _ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred )
    {
      ;
      return std :: __stable_partition ( __first, __last,
         __gnu_cxx :: __ops :: __pred_iter ( __pred ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    void
    __heap_select ( _RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp )
    {
      std :: __make_heap ( __first, __middle, __comp );
      for ( _RandomAccessIterator __i = __middle; __i < __last; ++ __i )
 if ( __comp ( __i, __first ) )
   std :: __pop_heap ( __first, __middle, __i, __comp );
    }
template < typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare >
    _RandomAccessIterator
    __partial_sort_copy ( _InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp )
    {
      typedef typename iterator_traits < _InputIterator > :: value_type
 _InputValueType;
      typedef iterator_traits < _RandomAccessIterator > _RItTraits;
      typedef typename _RItTraits :: difference_type _DistanceType;
      if ( __result_first == __result_last )
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while ( __first != __last && __result_real_last != __result_last )
 {
   * __result_real_last = * __first;
   ++ __result_real_last;
   ++ __first;
 }
      std :: __make_heap ( __result_first, __result_real_last, __comp );
      while ( __first != __last )
 {
   if ( __comp ( __first, __result_first ) )
     std :: __adjust_heap ( __result_first, _DistanceType ( 0 ),
          _DistanceType ( __result_real_last
          - __result_first ),
          _InputValueType ( * __first ), __comp );
   ++ __first;
 }
      std :: __sort_heap ( __result_first, __result_real_last, __comp );
      return __result_real_last;
    }
template < typename _InputIterator, typename _RandomAccessIterator >
    inline _RandomAccessIterator
    partial_sort_copy ( _InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last )
    {
      ;
      ;
      ;
      return std :: __partial_sort_copy ( __first, __last,
          __result_first, __result_last,
          __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare >
    inline _RandomAccessIterator
    partial_sort_copy ( _InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp )
    {
      ;
      ;
      ;
      return std :: __partial_sort_copy ( __first, __last,
          __result_first, __result_last,
    __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    void
    __unguarded_linear_insert ( _RandomAccessIterator __last,
         _Compare __comp )
    {
      typename iterator_traits < _RandomAccessIterator > :: value_type
 __val = std :: move ( * __last );
      _RandomAccessIterator __next = __last;
      -- __next;
      while ( __comp ( __val, __next ) )
 {
   * __last = std :: move ( * __next );
   __last = __next;
   -- __next;
 }
      * __last = std :: move ( __val );
    }
template < typename _RandomAccessIterator, typename _Compare >
    void
    __insertion_sort ( _RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp )
    {
      if ( __first == __last ) return;
      for ( _RandomAccessIterator __i = __first + 1; __i != __last; ++ __i )
 {
   if ( __comp ( __i, __first ) )
     {
       typename iterator_traits < _RandomAccessIterator > :: value_type
  __val = std :: move ( * __i );
       std :: move_backward ( __first, __i, __i + 1 );
       * __first = std :: move ( __val );
     }
   else
     std :: __unguarded_linear_insert ( __i,
    __gnu_cxx :: __ops :: __val_comp_iter ( __comp ) );
 }
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    __unguarded_insertion_sort ( _RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp )
    {
      for ( _RandomAccessIterator __i = __first; __i != __last; ++ __i )
 std :: __unguarded_linear_insert ( __i,
    __gnu_cxx :: __ops :: __val_comp_iter ( __comp ) );
    }
enum __anonymous_0x9745250 {_S_threshold=16} ;
template < typename _RandomAccessIterator, typename _Compare >
    void
    __final_insertion_sort ( _RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp )
    {
      if ( __last - __first > int ( _S_threshold ) )
 {
   std :: __insertion_sort ( __first, __first + int ( _S_threshold ), __comp );
   std :: __unguarded_insertion_sort ( __first + int ( _S_threshold ), __last,
       __comp );
 }
      else
 std :: __insertion_sort ( __first, __last, __comp );
    }
template < typename _RandomAccessIterator, typename _Compare >
    _RandomAccessIterator
    __unguarded_partition ( _RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp )
    {
      while ( true )
 {
   while ( __comp ( __first, __pivot ) )
     ++ __first;
   -- __last;
   while ( __comp ( __pivot, __last ) )
     -- __last;
   if ( ! ( __first < __last ) )
     return __first;
   std :: iter_swap ( __first, __last );
   ++ __first;
 }
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline _RandomAccessIterator
    __unguarded_partition_pivot ( _RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp )
    {
      _RandomAccessIterator __mid = __first + ( __last - __first ) / 2;
      std :: __move_median_to_first ( __first, __first + 1, __mid, __last - 1,
      __comp );
      return std :: __unguarded_partition ( __first + 1, __last, __first, __comp );
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    __partial_sort ( _RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp )
    {
      std :: __heap_select ( __first, __middle, __last, __comp );
      std :: __sort_heap ( __first, __middle, __comp );
    }
template < typename _RandomAccessIterator, typename _Size, typename _Compare >
    void
    __introsort_loop ( _RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp )
    {
      while ( __last - __first > int ( _S_threshold ) )
 {
   if ( __depth_limit == 0 )
     {
       std :: __partial_sort ( __first, __last, __last, __comp );
       return;
     }
   -- __depth_limit;
   _RandomAccessIterator __cut =
     std :: __unguarded_partition_pivot ( __first, __last, __comp );
   std :: __introsort_loop ( __cut, __last, __depth_limit, __comp );
   __last = __cut;
 }
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    __sort ( _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp )
    {
      if ( __first != __last )
 {
   std :: __introsort_loop ( __first, __last,
    std :: __lg ( __last - __first ) * 2,
    __comp );
   std :: __final_insertion_sort ( __first, __last, __comp );
 }
    }
template < typename _RandomAccessIterator, typename _Size, typename _Compare >
    void
    __introselect ( _RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp )
    {
      while ( __last - __first > 3 )
 {
   if ( __depth_limit == 0 )
     {
       std :: __heap_select ( __first, __nth + 1, __last, __comp );
       std :: iter_swap ( __first, __nth );
       return;
     }
   -- __depth_limit;
   _RandomAccessIterator __cut =
     std :: __unguarded_partition_pivot ( __first, __last, __comp );
   if ( __cut <= __nth )
     __first = __cut;
   else
     __last = __cut;
 }
      std :: __insertion_sort ( __first, __last, __comp );
    }
template < typename _ForwardIterator, typename _Tp, typename _Compare >
    inline _ForwardIterator
    lower_bound ( _ForwardIterator __first, _ForwardIterator __last,
  const _Tp & __val, _Compare __comp )
    {
                    ;
      ;
      return std :: __lower_bound ( __first, __last, __val,
    __gnu_cxx :: __ops :: __iter_comp_val ( __comp ) );
    }
template < typename _ForwardIterator, typename _Tp, typename _Compare >
    _ForwardIterator
    __upper_bound ( _ForwardIterator __first, _ForwardIterator __last,
    const _Tp & __val, _Compare __comp )
    {
      typedef typename iterator_traits < _ForwardIterator > :: difference_type
 _DistanceType;
      _DistanceType __len = std :: distance ( __first, __last );
      while ( __len > 0 )
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std :: advance ( __middle, __half );
   if ( __comp ( __val, __middle ) )
     __len = __half;
   else
     {
       __first = __middle;
       ++ __first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
template < typename _ForwardIterator, typename _Tp >
    inline _ForwardIterator
    upper_bound ( _ForwardIterator __first, _ForwardIterator __last,
  const _Tp & __val )
    {
      ;
      ;
      return std :: __upper_bound ( __first, __last, __val,
    __gnu_cxx :: __ops :: __val_less_iter ( ) );
    }
template < typename _ForwardIterator, typename _Tp, typename _Compare >
    inline _ForwardIterator
    upper_bound ( _ForwardIterator __first, _ForwardIterator __last,
  const _Tp & __val, _Compare __comp )
    {
                    ;
      ;
      return std :: __upper_bound ( __first, __last, __val,
    __gnu_cxx :: __ops :: __val_comp_iter ( __comp ) );
    }
template < typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt >
    pair < _ForwardIterator, _ForwardIterator >
    __equal_range ( _ForwardIterator __first, _ForwardIterator __last,
    const _Tp & __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it )
    {
      typedef typename iterator_traits < _ForwardIterator > :: difference_type
 _DistanceType;
      _DistanceType __len = std :: distance ( __first, __last );
      while ( __len > 0 )
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std :: advance ( __middle, __half );
   if ( __comp_it_val ( __middle, __val ) )
     {
       __first = __middle;
       ++ __first;
       __len = __len - __half - 1;
     }
   else if ( __comp_val_it ( __val, __middle ) )
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std :: __lower_bound ( __first, __middle, __val, __comp_it_val );
       std :: advance ( __first, __len );
       _ForwardIterator __right
  = std :: __upper_bound ( ++ __middle, __first, __val, __comp_val_it );
       return pair < _ForwardIterator, _ForwardIterator > ( __left, __right );
     }
 }
      return pair < _ForwardIterator, _ForwardIterator > ( __first, __first );
    }
template < typename _ForwardIterator, typename _Tp >
    inline pair < _ForwardIterator, _ForwardIterator >
    equal_range ( _ForwardIterator __first, _ForwardIterator __last,
  const _Tp & __val )
    {
      ;
      ;
      ;
      return std :: __equal_range ( __first, __last, __val,
    __gnu_cxx :: __ops :: __iter_less_val ( ),
    __gnu_cxx :: __ops :: __val_less_iter ( ) );
    }
template < typename _ForwardIterator, typename _Tp, typename _Compare >
    inline pair < _ForwardIterator, _ForwardIterator >
    equal_range ( _ForwardIterator __first, _ForwardIterator __last,
  const _Tp & __val, _Compare __comp )
    {
                    ;
                    ;
      ;
      return std :: __equal_range ( __first, __last, __val,
    __gnu_cxx :: __ops :: __iter_comp_val ( __comp ),
    __gnu_cxx :: __ops :: __val_comp_iter ( __comp ) );
    }
template < typename _ForwardIterator, typename _Tp >
    bool
    binary_search ( _ForwardIterator __first, _ForwardIterator __last,
    const _Tp & __val )
    {
      ;
      ;
      ;
      _ForwardIterator __i
 = std :: __lower_bound ( __first, __last, __val,
        __gnu_cxx :: __ops :: __iter_less_val ( ) );
      return __i != __last && ! ( __val < * __i );
    }
template < typename _ForwardIterator, typename _Tp, typename _Compare >
    bool
    binary_search ( _ForwardIterator __first, _ForwardIterator __last,
    const _Tp & __val, _Compare __comp )
    {
                    ;
                    ;
      ;
      _ForwardIterator __i
 = std :: __lower_bound ( __first, __last, __val,
        __gnu_cxx :: __ops :: __iter_comp_val ( __comp ) );
      return __i != __last && ! bool ( __comp ( __val, * __i ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare >
    void
    __move_merge_adaptive ( _InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp )
    {
      while ( __first1 != __last1 && __first2 != __last2 )
 {
   if ( __comp ( __first2, __first1 ) )
     {
       * __result = std :: move ( * __first2 );
       ++ __first2;
     }
   else
     {
       * __result = std :: move ( * __first1 );
       ++ __first1;
     }
   ++ __result;
 }
      if ( __first1 != __last1 )
 std :: move ( __first1, __last1, __result );
    }
template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare >
    void
    __move_merge_adaptive_backward ( _BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp )
    {
      if ( __first1 == __last1 )
 {
   std :: move_backward ( __first2, __last2, __result );
   return;
 }
      else if ( __first2 == __last2 )
 return;
      -- __last1;
      -- __last2;
      while ( true )
 {
   if ( __comp ( __last2, __last1 ) )
     {
       * -- __result = std :: move ( * __last1 );
       if ( __first1 == __last1 )
  {
    std :: move_backward ( __first2, ++ __last2, __result );
    return;
  }
       -- __last1;
     }
   else
     {
       * -- __result = std :: move ( * __last2 );
       if ( __first2 == __last2 )
  return;
       -- __last2;
     }
 }
    }
template < typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance >
    _BidirectionalIterator1
    __rotate_adaptive ( _BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size )
    {
      _BidirectionalIterator2 __buffer_end;
      if ( __len1 > __len2 && __len2 <= __buffer_size )
 {
   if ( __len2 )
     {
       __buffer_end = std :: move ( __middle, __last, __buffer );
       std :: move_backward ( __first, __middle, __last );
       return std :: move ( __buffer, __buffer_end, __first );
     }
   else
     return __first;
 }
      else if ( __len1 <= __buffer_size )
 {
   if ( __len1 )
     {
       __buffer_end = std :: move ( __first, __middle, __buffer );
       std :: move ( __middle, __last, __first );
       return std :: move_backward ( __buffer, __buffer_end, __last );
     }
   else
     return __last;
 }
      else
 {
   std :: rotate ( __first, __middle, __last );
   std :: advance ( __first, std :: distance ( __middle, __last ) );
   return __first;
 }
    }
template < typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare >
    void
    __merge_adaptive ( _BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp )
    {
      if ( __len1 <= __len2 && __len1 <= __buffer_size )
 {
   _Pointer __buffer_end = std :: move ( __first, __middle, __buffer );
   std :: __move_merge_adaptive ( __buffer, __buffer_end, __middle, __last,
         __first, __comp );
 }
      else if ( __len2 <= __buffer_size )
 {
   _Pointer __buffer_end = std :: move ( __middle, __last, __buffer );
   std :: __move_merge_adaptive_backward ( __first, __middle, __buffer,
           __buffer_end, __last, __comp );
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if ( __len1 > __len2 )
     {
       __len11 = __len1 / 2;
       std :: advance ( __first_cut, __len11 );
       __second_cut
  = std :: __lower_bound ( __middle, __last, * __first_cut,
         __gnu_cxx :: __ops :: __iter_comp_val ( __comp ) );
       __len22 = std :: distance ( __middle, __second_cut );
     }
   else
     {
       __len22 = __len2 / 2;
       std :: advance ( __second_cut, __len22 );
       __first_cut
  = std :: __upper_bound ( __first, __middle, * __second_cut,
         __gnu_cxx :: __ops :: __val_comp_iter ( __comp ) );
       __len11 = std :: distance ( __first, __first_cut );
     }
   _BidirectionalIterator __new_middle
     = std :: __rotate_adaptive ( __first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size );
   std :: __merge_adaptive ( __first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp );
   std :: __merge_adaptive ( __new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp );
 }
    }
template < typename _BidirectionalIterator, typename _Distance,
    typename _Compare >
    void
    __merge_without_buffer ( _BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp )
    {
      if ( __len1 == 0 || __len2 == 0 )
 return;
      if ( __len1 + __len2 == 2 )
 {
   if ( __comp ( __middle, __first ) )
     std :: iter_swap ( __first, __middle );
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if ( __len1 > __len2 )
 {
   __len11 = __len1 / 2;
   std :: advance ( __first_cut, __len11 );
   __second_cut
     = std :: __lower_bound ( __middle, __last, * __first_cut,
     __gnu_cxx :: __ops :: __iter_comp_val ( __comp ) );
   __len22 = std :: distance ( __middle, __second_cut );
 }
      else
 {
   __len22 = __len2 / 2;
   std :: advance ( __second_cut, __len22 );
   __first_cut
     = std :: __upper_bound ( __first, __middle, * __second_cut,
     __gnu_cxx :: __ops :: __val_comp_iter ( __comp ) );
   __len11 = std :: distance ( __first, __first_cut );
 }
      std :: rotate ( __first_cut, __middle, __second_cut );
      _BidirectionalIterator __new_middle = __first_cut;
      std :: advance ( __new_middle, std :: distance ( __middle, __second_cut ) );
      std :: __merge_without_buffer ( __first, __first_cut, __new_middle,
      __len11, __len22, __comp );
      std :: __merge_without_buffer ( __new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp );
    }
template < typename _BidirectionalIterator, typename _Compare >
    void
    __inplace_merge ( _BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp )
    {
      typedef typename iterator_traits < _BidirectionalIterator > :: value_type
   _ValueType;
      typedef typename iterator_traits < _BidirectionalIterator > :: difference_type
   _DistanceType;
      if ( __first == __middle || __middle == __last )
 return;
      const _DistanceType __len1 = std :: distance ( __first, __middle );
      const _DistanceType __len2 = std :: distance ( __middle, __last );
      typedef _Temporary_buffer < _BidirectionalIterator, _ValueType > _TmpBuf;
      _TmpBuf __buf ( __first, __last );
      if ( __buf . begin ( ) == 0 )
 std :: __merge_without_buffer
   ( __first, __middle, __last, __len1, __len2, __comp );
      else
 std :: __merge_adaptive
   ( __first, __middle, __last, __len1, __len2, __buf . begin ( ),
    _DistanceType ( __buf . size ( ) ), __comp );
    }
template < typename _BidirectionalIterator >
    inline void
    inplace_merge ( _BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last )
    {
      ;
      ;
      ;
      std :: __inplace_merge ( __first, __middle, __last,
      __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _BidirectionalIterator, typename _Compare >
    inline void
    inplace_merge ( _BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp )
    {
      ;
      ;
      ;
      std :: __inplace_merge ( __first, __middle, __last,
      __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _InputIterator, typename _OutputIterator,
    typename _Compare >
    _OutputIterator
    __move_merge ( _InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp )
    {
      while ( __first1 != __last1 && __first2 != __last2 )
 {
   if ( __comp ( __first2, __first1 ) )
     {
       * __result = std :: move ( * __first2 );
       ++ __first2;
     }
   else
     {
       * __result = std :: move ( * __first1 );
       ++ __first1;
     }
   ++ __result;
 }
      return std :: move ( __first2, __last2, std :: move ( __first1, __last1, __result ) )
                  ;
    }
template < typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare >
    void
    __merge_sort_loop ( _RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp )
    {
      const _Distance __two_step = 2 * __step_size;
      while ( __last - __first >= __two_step )
 {
   __result = std :: __move_merge ( __first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp );
   __first += __two_step;
 }
      __step_size = std :: min ( _Distance ( __last - __first ), __step_size );
      std :: __move_merge ( __first, __first + __step_size,
   __first + __step_size, __last, __result, __comp );
    }
template < typename _RandomAccessIterator, typename _Distance,
    typename _Compare >
    void
    __chunk_insertion_sort ( _RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp )
    {
      while ( __last - __first >= __chunk_size )
 {
   std :: __insertion_sort ( __first, __first + __chunk_size, __comp );
   __first += __chunk_size;
 }
      std :: __insertion_sort ( __first, __last, __comp );
    }
enum __anonymous_0x983f760 {_S_chunk_size=7} ;
template < typename _RandomAccessIterator, typename _Pointer, typename _Compare >
    void
    __merge_sort_with_buffer ( _RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp )
    {
      typedef typename iterator_traits < _RandomAccessIterator > :: difference_type
 _Distance;
      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;
      _Distance __step_size = _S_chunk_size;
      std :: __chunk_insertion_sort ( __first, __last, __step_size, __comp );
      while ( __step_size < __len )
 {
   std :: __merge_sort_loop ( __first, __last, __buffer,
     __step_size, __comp );
   __step_size *= 2;
   std :: __merge_sort_loop ( __buffer, __buffer_last, __first,
     __step_size, __comp );
   __step_size *= 2;
 }
    }
template < typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare >
    void
    __stable_sort_adaptive ( _RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp )
    {
      const _Distance __len = ( __last - __first + 1 ) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if ( __len > __buffer_size )
 {
   std :: __stable_sort_adaptive ( __first, __middle, __buffer,
          __buffer_size, __comp );
   std :: __stable_sort_adaptive ( __middle, __last, __buffer,
          __buffer_size, __comp );
 }
      else
 {
   std :: __merge_sort_with_buffer ( __first, __middle, __buffer, __comp );
   std :: __merge_sort_with_buffer ( __middle, __last, __buffer, __comp );
 }
      std :: __merge_adaptive ( __first, __middle, __last,
       _Distance ( __middle - __first ),
       _Distance ( __last - __middle ),
       __buffer, __buffer_size,
       __comp );
    }
template < typename _RandomAccessIterator, typename _Compare >
    void
    __inplace_stable_sort ( _RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp )
    {
      if ( __last - __first < 15 )
 {
   std :: __insertion_sort ( __first, __last, __comp );
   return;
 }
      _RandomAccessIterator __middle = __first + ( __last - __first ) / 2;
      std :: __inplace_stable_sort ( __first, __middle, __comp );
      std :: __inplace_stable_sort ( __middle, __last, __comp );
      std :: __merge_without_buffer ( __first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _Compare >
    bool
    __includes ( _InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp )
    {
      while ( __first1 != __last1 && __first2 != __last2 )
 if ( __comp ( __first2, __first1 ) )
   return false;
 else if ( __comp ( __first1, __first2 ) )
   ++ __first1;
 else
   {
     ++ __first1;
     ++ __first2;
   }
      return __first2 == __last2;
    }
template < typename _InputIterator1, typename _InputIterator2 >
    inline bool
    includes ( _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2 )
    {
      ;
      ;
      ;
      ;
      return std :: __includes ( __first1, __last1, __first2, __last2,
        __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _Compare >
    inline bool
    includes ( _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp )
    {
      ;
      ;
      ;
      ;
      return std :: __includes ( __first1, __last1, __first2, __last2,
        __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _BidirectionalIterator, typename _Compare >
    bool
    __next_permutation ( _BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp )
    {
      if ( __first == __last )
 return false;
      _BidirectionalIterator __i = __first;
      ++ __i;
      if ( __i == __last )
 return false;
      __i = __last;
      -- __i;
      for (;; )
 {
   _BidirectionalIterator __ii = __i;
   -- __i;
   if ( __comp ( __i, __ii ) )
     {
       _BidirectionalIterator __j = __last;
       while ( ! __comp ( __i, -- __j ) )
  { }
       std :: iter_swap ( __i, __j );
       std :: __reverse ( __ii, __last,
        std :: __iterator_category ( __first ) );
       return true;
     }
   if ( __i == __first )
     {
       std :: __reverse ( __first, __last,
        std :: __iterator_category ( __first ) );
       return false;
     }
 }
    }
template < typename _BidirectionalIterator >
    inline bool
    next_permutation ( _BidirectionalIterator __first,
       _BidirectionalIterator __last )
    {
      ;
      ;
      return std :: __next_permutation
 ( __first, __last, __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _BidirectionalIterator, typename _Compare >
    inline bool
    next_permutation ( _BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp )
    {
      ;
      ;
      return std :: __next_permutation
 ( __first, __last, __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _BidirectionalIterator, typename _Compare >
    bool
    __prev_permutation ( _BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp )
    {
      if ( __first == __last )
 return false;
      _BidirectionalIterator __i = __first;
      ++ __i;
      if ( __i == __last )
 return false;
      __i = __last;
      -- __i;
      for (;; )
 {
   _BidirectionalIterator __ii = __i;
   -- __i;
   if ( __comp ( __ii, __i ) )
     {
       _BidirectionalIterator __j = __last;
       while ( ! __comp ( -- __j, __i ) )
  { }
       std :: iter_swap ( __i, __j );
       std :: __reverse ( __ii, __last,
        std :: __iterator_category ( __first ) );
       return true;
     }
   if ( __i == __first )
     {
       std :: __reverse ( __first, __last,
        std :: __iterator_category ( __first ) );
       return false;
     }
 }
    }
template < typename _BidirectionalIterator >
    inline bool
    prev_permutation ( _BidirectionalIterator __first,
       _BidirectionalIterator __last )
    {
      ;
      ;
      return std :: __prev_permutation ( __first, __last,
         __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _BidirectionalIterator, typename _Compare >
    inline bool
    prev_permutation ( _BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp )
    {
      ;
      ;
      return std :: __prev_permutation ( __first, __last,
    __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp >
    _OutputIterator
    __replace_copy_if ( _InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp & __new_value )
    {
      for (; __first != __last; ++ __first, ( void ) ++ __result )
 if ( __pred ( __first ) )
   * __result = __new_value;
 else
   * __result = * __first;
      return __result;
    }
template < typename _InputIterator, typename _OutputIterator, typename _Tp >
    inline _OutputIterator
    replace_copy ( _InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp & __old_value, const _Tp & __new_value )
    {
      ;
      return std :: __replace_copy_if ( __first, __last, __result,
   __gnu_cxx :: __ops :: __iter_equals_val ( __old_value ),
           __new_value );
    }
template < typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp >
    inline _OutputIterator
    replace_copy_if ( _InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp & __new_value )
    {
      ;
      return std :: __replace_copy_if ( __first, __last, __result,
    __gnu_cxx :: __ops :: __pred_iter ( __pred ),
           __new_value );
    }
template < typename _InputIterator, typename _Predicate >
    typename iterator_traits < _InputIterator > :: difference_type
    __count_if ( _InputIterator __first, _InputIterator __last, _Predicate __pred )
    {
      typename iterator_traits < _InputIterator > :: difference_type __n = 0;
      for (; __first != __last; ++ __first )
 if ( __pred ( __first ) )
   ++ __n;
      return __n;
    }
template < typename _ForwardIterator >
    inline bool
    is_sorted ( _ForwardIterator __first, _ForwardIterator __last )
    { return std :: is_sorted_until ( __first, __last ) == __last; }
template < typename _ForwardIterator, typename _Compare >
    inline bool
    is_sorted ( _ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp )
    { return std :: is_sorted_until ( __first, __last, __comp ) == __last; }
template < typename _ForwardIterator, typename _Compare >
    _ForwardIterator
    __is_sorted_until ( _ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp )
    {
      if ( __first == __last )
 return __last;
      _ForwardIterator __next = __first;
      for ( ++ __next; __next != __last; __first = __next, ( void ) ++ __next )
 if ( __comp ( __next, __first ) )
   return __next;
      return __next;
    }
template < typename _ForwardIterator >
    inline _ForwardIterator
    is_sorted_until ( _ForwardIterator __first, _ForwardIterator __last )
    {
      ;
      ;
      return std :: __is_sorted_until ( __first, __last,
        __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _ForwardIterator, typename _Compare >
    inline _ForwardIterator
    is_sorted_until ( _ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp )
    {
      ;
      ;
      return std :: __is_sorted_until ( __first, __last,
        __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _Tp >
    constexpr
    inline pair < const _Tp &, const _Tp & >
    minmax ( const _Tp & __a, const _Tp & __b )
    {
      return __b < __a ? pair < const _Tp &, const _Tp & > ( __b, __a )
         : pair < const _Tp &, const _Tp & > ( __a, __b );
    }
template < typename _Tp, typename _Compare >
    constexpr
    inline pair < const _Tp &, const _Tp & >
    minmax ( const _Tp & __a, const _Tp & __b, _Compare __comp )
    {
      return __comp ( __b, __a ) ? pair < const _Tp &, const _Tp & > ( __b, __a )
         : pair < const _Tp &, const _Tp & > ( __a, __b );
    }
template < typename _ForwardIterator, typename _Compare >
    constexpr
    pair < _ForwardIterator, _ForwardIterator >
    __minmax_element ( _ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp )
    {
      _ForwardIterator __next = __first;
      if ( __first == __last
   || ++ __next == __last )
 return std :: make_pair ( __first, __first );
      _ForwardIterator __min { }, __max { };
      if ( __comp ( __next, __first ) )
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }
      __first = __next;
      ++ __first;
      while ( __first != __last )
 {
   __next = __first;
   if ( ++ __next == __last )
     {
       if ( __comp ( __first, __min ) )
  __min = __first;
       else if ( ! __comp ( __first, __max ) )
  __max = __first;
       break;
     }
   if ( __comp ( __next, __first ) )
     {
       if ( __comp ( __next, __min ) )
  __min = __next;
       if ( ! __comp ( __first, __max ) )
  __max = __first;
     }
   else
     {
       if ( __comp ( __first, __min ) )
  __min = __first;
       if ( ! __comp ( __next, __max ) )
  __max = __next;
     }
   __first = __next;
   ++ __first;
 }
      return std :: make_pair ( __min, __max );
    }
template < typename _ForwardIterator >
    constexpr
    inline pair < _ForwardIterator, _ForwardIterator >
    minmax_element ( _ForwardIterator __first, _ForwardIterator __last )
    {
      ;
      ;
      return std :: __minmax_element ( __first, __last,
       __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _ForwardIterator, typename _Compare >
    constexpr
    inline pair < _ForwardIterator, _ForwardIterator >
    minmax_element ( _ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp )
    {
      ;
      ;
      return std :: __minmax_element ( __first, __last,
       __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _Tp >
    constexpr
    inline _Tp
    min ( initializer_list < _Tp > __l )
    { return * std :: min_element ( __l . begin ( ), __l . end ( ) ); }
template < typename _Tp, typename _Compare >
    constexpr
    inline _Tp
    min ( initializer_list < _Tp > __l, _Compare __comp )
    { return * std :: min_element ( __l . begin ( ), __l . end ( ), __comp ); }
template < typename _Tp >
    constexpr
    inline _Tp
    max ( initializer_list < _Tp > __l )
    { return * std :: max_element ( __l . begin ( ), __l . end ( ) ); }
template < typename _Tp, typename _Compare >
    constexpr
    inline _Tp
    max ( initializer_list < _Tp > __l, _Compare __comp )
    { return * std :: max_element ( __l . begin ( ), __l . end ( ), __comp ); }
template < typename _Tp >
    constexpr
    inline pair < _Tp, _Tp >
    minmax ( initializer_list < _Tp > __l )
    {
      pair < const _Tp *, const _Tp * > __p =
 std :: minmax_element ( __l . begin ( ), __l . end ( ) );
      return std :: make_pair ( * __p . first, * __p . second );
    }
template < typename _Tp, typename _Compare >
    constexpr
    inline pair < _Tp, _Tp >
    minmax ( initializer_list < _Tp > __l, _Compare __comp )
    {
      pair < const _Tp *, const _Tp * > __p =
 std :: minmax_element ( __l . begin ( ), __l . end ( ), __comp );
      return std :: make_pair ( * __p . first, * __p . second );
    }
template < typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate >
    bool
    __is_permutation ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred )
    {
      for (; __first1 != __last1; ++ __first1, ( void ) ++ __first2 )
 if ( ! __pred ( __first1, __first2 ) )
   break;
      if ( __first1 == __last1 )
 return true;
      _ForwardIterator2 __last2 = __first2;
      std :: advance ( __last2, std :: distance ( __first1, __last1 ) );
      for ( _ForwardIterator1 __scan = __first1; __scan != __last1; ++ __scan )
 {
   if ( __scan != std :: __find_if ( __first1, __scan,
     __gnu_cxx :: __ops :: __iter_comp_iter ( __pred, __scan ) ) )
     continue;
   auto __matches
     = std :: __count_if ( __first2, __last2,
   __gnu_cxx :: __ops :: __iter_comp_iter ( __pred, __scan ) );
   if ( 0 == __matches ||
       std :: __count_if ( __scan, __last1,
   __gnu_cxx :: __ops :: __iter_comp_iter ( __pred, __scan ) )
       != __matches )
     return false;
 }
      return true;
    }
template < typename _ForwardIterator1, typename _ForwardIterator2 >
    inline bool
    is_permutation ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2 )
    {
      ;
      return std :: __is_permutation ( __first1, __last1, __first2,
       __gnu_cxx :: __ops :: __iter_equal_to_iter ( ) );
    }
template < typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate >
    inline bool
    is_permutation ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred )
    {
      ;
      return std :: __is_permutation ( __first1, __last1, __first2,
       __gnu_cxx :: __ops :: __iter_comp_iter ( __pred ) );
    }
template < typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate >
    bool
    __is_permutation ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred )
    {
      using _Cat1
 = typename iterator_traits < _ForwardIterator1 > :: iterator_category;
      using _Cat2
 = typename iterator_traits < _ForwardIterator2 > :: iterator_category;
      using _It1_is_RA = is_same < _Cat1, random_access_iterator_tag >;
      using _It2_is_RA = is_same < _Cat2, random_access_iterator_tag >;
      constexpr bool __ra_iters = _It1_is_RA ( ) && _It2_is_RA ( );
      if ( __ra_iters )
 {
   auto __d1 = std :: distance ( __first1, __last1 );
   auto __d2 = std :: distance ( __first2, __last2 );
   if ( __d1 != __d2 )
     return false;
 }
      for (; __first1 != __last1 && __first2 != __last2;
   ++ __first1, ( void ) ++ __first2 )
 if ( ! __pred ( __first1, __first2 ) )
   break;
      if ( __ra_iters )
 {
   if ( __first1 == __last1 )
     return true;
 }
      else
 {
   auto __d1 = std :: distance ( __first1, __last1 );
   auto __d2 = std :: distance ( __first2, __last2 );
   if ( __d1 == 0 && __d2 == 0 )
     return true;
   if ( __d1 != __d2 )
     return false;
 }
      for ( _ForwardIterator1 __scan = __first1; __scan != __last1; ++ __scan )
 {
   if ( __scan != std :: __find_if ( __first1, __scan,
   __gnu_cxx :: __ops :: __iter_comp_iter ( __pred, __scan ) ) )
     continue;
   auto __matches = std :: __count_if ( __first2, __last2,
  __gnu_cxx :: __ops :: __iter_comp_iter ( __pred, __scan ) );
   if ( 0 == __matches
       || std :: __count_if ( __scan, __last1,
   __gnu_cxx :: __ops :: __iter_comp_iter ( __pred, __scan ) )
       != __matches )
     return false;
 }
      return true;
    }
template < typename _ForwardIterator1, typename _ForwardIterator2 >
    inline bool
    is_permutation ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2 )
    {
      ;
      ;
      return
 std :: __is_permutation ( __first1, __last1, __first2, __last2,
         __gnu_cxx :: __ops :: __iter_equal_to_iter ( ) );
    }
template < typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate >
    inline bool
    is_permutation ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred )
    {
      ;
      ;
      return std :: __is_permutation ( __first1, __last1, __first2, __last2,
       __gnu_cxx :: __ops :: __iter_comp_iter ( __pred ) );
    }
template < typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator >
    void
    shuffle ( _RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator && __g )
    {
      ;
      if ( __first == __last )
 return;
      typedef typename iterator_traits < _RandomAccessIterator > :: difference_type
 _DistanceType;
      typedef typename std :: make_unsigned < _DistanceType > :: type __ud_type;
      typedef typename std :: uniform_int_distribution < __ud_type > __distr_type;
      typedef typename __distr_type :: param_type __p_type;
      __distr_type __d;
      for ( _RandomAccessIterator __i = __first + 1; __i != __last; ++ __i )
 std :: iter_swap ( __i, __first + __d ( __g, __p_type ( 0, __i - __first ) ) );
    }
template < typename _InputIterator, typename _Function >
    _Function
    for_each ( _InputIterator __first, _InputIterator __last, _Function __f )
    {
      ;
      for (; __first != __last; ++ __first )
 __f ( * __first );
      return std :: move ( __f );
    }
template < typename _InputIterator, typename _Tp >
    inline _InputIterator
    find ( _InputIterator __first, _InputIterator __last,
  const _Tp & __val )
    {
      ;
      return std :: __find_if ( __first, __last,
       __gnu_cxx :: __ops :: __iter_equals_val ( __val ) );
    }
template < typename _InputIterator, typename _Predicate >
    inline _InputIterator
    find_if ( _InputIterator __first, _InputIterator __last,
     _Predicate __pred )
    {
      ;
      return std :: __find_if ( __first, __last,
       __gnu_cxx :: __ops :: __pred_iter ( __pred ) );
    }
template < typename _InputIterator, typename _ForwardIterator >
    _InputIterator
    find_first_of ( _InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2 )
    {
      ;
      ;
      for (; __first1 != __last1; ++ __first1 )
 for ( _ForwardIterator __iter = __first2; __iter != __last2; ++ __iter )
   if ( * __first1 == * __iter )
     return __first1;
      return __last1;
    }
template < typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate >
    _InputIterator
    find_first_of ( _InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp )
    {
      ;
      ;
      for (; __first1 != __last1; ++ __first1 )
 for ( _ForwardIterator __iter = __first2; __iter != __last2; ++ __iter )
   if ( __comp ( * __first1, * __iter ) )
     return __first1;
      return __last1;
    }
template < typename _ForwardIterator >
    inline _ForwardIterator
    adjacent_find ( _ForwardIterator __first, _ForwardIterator __last )
    {
      ;
      return std :: __adjacent_find ( __first, __last,
      __gnu_cxx :: __ops :: __iter_equal_to_iter ( ) );
    }
template < typename _ForwardIterator, typename _BinaryPredicate >
    inline _ForwardIterator
    adjacent_find ( _ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred )
    {
      ;
      return std :: __adjacent_find ( __first, __last,
   __gnu_cxx :: __ops :: __iter_comp_iter ( __binary_pred ) );
    }
template < typename _InputIterator, typename _Tp >
    inline typename iterator_traits < _InputIterator > :: difference_type
    count ( _InputIterator __first, _InputIterator __last, const _Tp & __value )
    {
      ;
      return std :: __count_if ( __first, __last,
        __gnu_cxx :: __ops :: __iter_equals_val ( __value ) );
    }
template < typename _InputIterator, typename _Predicate >
    inline typename iterator_traits < _InputIterator > :: difference_type
    count_if ( _InputIterator __first, _InputIterator __last, _Predicate __pred )
    {
      ;
      return std :: __count_if ( __first, __last,
        __gnu_cxx :: __ops :: __pred_iter ( __pred ) );
    }
template < typename _ForwardIterator1, typename _ForwardIterator2 >
    inline _ForwardIterator1
    search ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2 )
    {
      ;
      ;
      return std :: __search ( __first1, __last1, __first2, __last2,
      __gnu_cxx :: __ops :: __iter_equal_to_iter ( ) );
    }
template < typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate >
    inline _ForwardIterator1
    search ( _ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate )
    {
      ;
      ;
      return std :: __search ( __first1, __last1, __first2, __last2,
      __gnu_cxx :: __ops :: __iter_comp_iter ( __predicate ) );
    }
template < typename _ForwardIterator, typename _Integer, typename _Tp >
    inline _ForwardIterator
    search_n ( _ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp & __val )
    {
      ;
      return std :: __search_n ( __first, __last, __count,
        __gnu_cxx :: __ops :: __iter_equals_val ( __val ) );
    }
template < typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate >
    inline _ForwardIterator
    search_n ( _ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp & __val,
      _BinaryPredicate __binary_pred )
    {
      ;
      return std :: __search_n ( __first, __last, __count,
  __gnu_cxx :: __ops :: __iter_comp_val ( __binary_pred, __val ) );
    }
template < typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation >
    _OutputIterator
    transform ( _InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op )
    {
      ;
      for (; __first != __last; ++ __first, ( void ) ++ __result )
 * __result = __unary_op ( * __first );
      return __result;
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation >
    _OutputIterator
    transform ( _InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op )
    {
      ;
      for (; __first1 != __last1; ++ __first1, ( void ) ++ __first2, ++ __result )
 * __result = __binary_op ( * __first1, * __first2 );
      return __result;
    }
template < typename _ForwardIterator, typename _Tp >
    void
    replace ( _ForwardIterator __first, _ForwardIterator __last,
     const _Tp & __old_value, const _Tp & __new_value )
    {
      ;
      for (; __first != __last; ++ __first )
 if ( * __first == __old_value )
   * __first = __new_value;
    }
template < typename _ForwardIterator, typename _Predicate, typename _Tp >
    void
    replace_if ( _ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp & __new_value )
    {
      ;
      for (; __first != __last; ++ __first )
 if ( __pred ( * __first ) )
   * __first = __new_value;
    }
template < typename _ForwardIterator, typename _Generator >
    void
    generate ( _ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen )
    {
      ;
      for (; __first != __last; ++ __first )
 * __first = __gen ( );
    }
template < typename _OutputIterator, typename _Size, typename _Generator >
    _OutputIterator
    generate_n ( _OutputIterator __first, _Size __n, _Generator __gen )
    {
      for ( decltype ( __n + 0 ) __niter = __n;
    __niter > 0; -- __niter, ++ __first )
 * __first = __gen ( );
      return __first;
    }
template < typename _InputIterator, typename _OutputIterator >
    inline _OutputIterator
    unique_copy ( _InputIterator __first, _InputIterator __last,
  _OutputIterator __result )
    {
      ;
      if ( __first == __last )
 return __result;
      return std :: __unique_copy ( __first, __last, __result,
    __gnu_cxx :: __ops :: __iter_equal_to_iter ( ),
    std :: __iterator_category ( __first ),
    std :: __iterator_category ( __result ) );
    }
template < typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate >
    inline _OutputIterator
    unique_copy ( _InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred )
    {
      ;
      if ( __first == __last )
 return __result;
      return std :: __unique_copy ( __first, __last, __result,
   __gnu_cxx :: __ops :: __iter_comp_iter ( __binary_pred ),
    std :: __iterator_category ( __first ),
    std :: __iterator_category ( __result ) );
    }
template < typename _RandomAccessIterator >
    inline void
    random_shuffle ( _RandomAccessIterator __first, _RandomAccessIterator __last )
    {
      ;
      if ( __first != __last )
 for ( _RandomAccessIterator __i = __first + 1; __i != __last; ++ __i )
   {
     _RandomAccessIterator __j = __first
     + std :: rand ( ) % ( ( __i - __first ) + 1 );
     if ( __i != __j )
       std :: iter_swap ( __i, __j );
   }
    }
template < typename _RandomAccessIterator, typename _RandomNumberGenerator >
    void
    random_shuffle ( _RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator && __rand )
    {
      ;
      if ( __first == __last )
 return;
      for ( _RandomAccessIterator __i = __first + 1; __i != __last; ++ __i )
 {
   _RandomAccessIterator __j = __first + __rand ( ( __i - __first ) + 1 );
   if ( __i != __j )
     std :: iter_swap ( __i, __j );
 }
    }
template < typename _ForwardIterator, typename _Predicate >
    inline _ForwardIterator
    partition ( _ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred )
    {
      ;
      return std :: __partition ( __first, __last, __pred,
         std :: __iterator_category ( __first ) );
    }
template < typename _RandomAccessIterator >
    inline void
    partial_sort ( _RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last )
    {
      ;
      ;
      ;
      std :: __partial_sort ( __first, __middle, __last,
     __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    partial_sort ( _RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp )
    {
      ;
      ;
      ;
      std :: __partial_sort ( __first, __middle, __last,
     __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _RandomAccessIterator >
    inline void
    nth_element ( _RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last )
    {
      ;
      ;
      ;
      if ( __first == __last || __nth == __last )
 return;
      std :: __introselect ( __first, __nth, __last,
    std :: __lg ( __last - __first ) * 2,
    __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    nth_element ( _RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp )
    {
      ;
      ;
      ;
      if ( __first == __last || __nth == __last )
 return;
      std :: __introselect ( __first, __nth, __last,
    std :: __lg ( __last - __first ) * 2,
    __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _RandomAccessIterator >
    inline void
    sort ( _RandomAccessIterator __first, _RandomAccessIterator __last )
    {
      ;
      ;
      std :: __sort ( __first, __last, __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    sort ( _RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp )
    {
      ;
      ;
      std :: __sort ( __first, __last, __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare >
    _OutputIterator
    __merge ( _InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp )
    {
      while ( __first1 != __last1 && __first2 != __last2 )
 {
   if ( __comp ( __first2, __first1 ) )
     {
       * __result = * __first2;
       ++ __first2;
     }
   else
     {
       * __result = * __first1;
       ++ __first1;
     }
   ++ __result;
 }
      return std :: copy ( __first2, __last2,
         std :: copy ( __first1, __last1, __result ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator >
    inline _OutputIterator
    merge ( _InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result )
    {
      ;
      ;
      ;
      ;
      return std :: __merge ( __first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare >
    inline _OutputIterator
    merge ( _InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp )
    {
      ;
      ;
      ;
      ;
      return std :: __merge ( __first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    __stable_sort ( _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp )
    {
      typedef typename iterator_traits < _RandomAccessIterator > :: value_type
 _ValueType;
      typedef typename iterator_traits < _RandomAccessIterator > :: difference_type
 _DistanceType;
      typedef _Temporary_buffer < _RandomAccessIterator, _ValueType > _TmpBuf;
      _TmpBuf __buf ( __first, __last );
      if ( __buf . begin ( ) == 0 )
 std :: __inplace_stable_sort ( __first, __last, __comp );
      else
 std :: __stable_sort_adaptive ( __first, __last, __buf . begin ( ),
        _DistanceType ( __buf . size ( ) ), __comp );
    }
template < typename _RandomAccessIterator >
    inline void
    stable_sort ( _RandomAccessIterator __first, _RandomAccessIterator __last )
    {
      ;
      ;
      std :: __stable_sort ( __first, __last,
        __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _RandomAccessIterator, typename _Compare >
    inline void
    stable_sort ( _RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp )
    {
      ;
      ;
      std :: __stable_sort ( __first, __last,
        __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare >
    _OutputIterator
    __set_union ( _InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp )
    {
      while ( __first1 != __last1 && __first2 != __last2 )
 {
   if ( __comp ( __first1, __first2 ) )
     {
       * __result = * __first1;
       ++ __first1;
     }
   else if ( __comp ( __first2, __first1 ) )
     {
       * __result = * __first2;
       ++ __first2;
     }
   else
     {
       * __result = * __first1;
       ++ __first1;
       ++ __first2;
     }
   ++ __result;
 }
      return std :: copy ( __first2, __last2,
         std :: copy ( __first1, __last1, __result ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator >
    inline _OutputIterator
    set_union ( _InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result )
    {
      ;
      ;
      ;
      ;
      return std :: __set_union ( __first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare >
    inline _OutputIterator
    set_union ( _InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp )
    {
      ;
      ;
      ;
      ;
      return std :: __set_union ( __first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare >
    _OutputIterator
    __set_intersection ( _InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp )
    {
      while ( __first1 != __last1 && __first2 != __last2 )
 if ( __comp ( __first1, __first2 ) )
   ++ __first1;
 else if ( __comp ( __first2, __first1 ) )
   ++ __first2;
 else
   {
     * __result = * __first1;
     ++ __first1;
     ++ __first2;
     ++ __result;
   }
      return __result;
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator >
    inline _OutputIterator
    set_intersection ( _InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result )
    {
      ;
      ;
      ;
      ;
      return std :: __set_intersection ( __first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare >
    inline _OutputIterator
    set_intersection ( _InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp )
    {
      ;
      ;
      ;
      ;
      return std :: __set_intersection ( __first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare >
    _OutputIterator
    __set_difference ( _InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp )
    {
      while ( __first1 != __last1 && __first2 != __last2 )
 if ( __comp ( __first1, __first2 ) )
   {
     * __result = * __first1;
     ++ __first1;
     ++ __result;
   }
 else if ( __comp ( __first2, __first1 ) )
   ++ __first2;
 else
   {
     ++ __first1;
     ++ __first2;
   }
      return std :: copy ( __first1, __last1, __result );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator >
    inline _OutputIterator
    set_difference ( _InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result )
    {
      ;
      ;
      ;
      ;
      return std :: __set_difference ( __first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare >
    inline _OutputIterator
    set_difference ( _InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp )
    {
      ;
      ;
      ;
      ;
      return std :: __set_difference ( __first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare >
    _OutputIterator
    __set_symmetric_difference ( _InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp )
    {
      while ( __first1 != __last1 && __first2 != __last2 )
 if ( __comp ( __first1, __first2 ) )
   {
     * __result = * __first1;
     ++ __first1;
     ++ __result;
   }
 else if ( __comp ( __first2, __first1 ) )
   {
     * __result = * __first2;
     ++ __first2;
     ++ __result;
   }
 else
   {
     ++ __first1;
     ++ __first2;
   }
      return std :: copy ( __first2, __last2,
         std :: copy ( __first1, __last1, __result ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator >
    inline _OutputIterator
    set_symmetric_difference ( _InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result )
    {
      ;
      ;
      ;
      ;
      return std :: __set_symmetric_difference ( __first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare >
    inline _OutputIterator
    set_symmetric_difference ( _InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp )
    {
      ;
      ;
      ;
      ;
      return std :: __set_symmetric_difference ( __first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _ForwardIterator, typename _Compare >
    constexpr
    _ForwardIterator
    __min_element ( _ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp )
    {
      if ( __first == __last )
 return __first;
      _ForwardIterator __result = __first;
      while ( ++ __first != __last )
 if ( __comp ( __first, __result ) )
   __result = __first;
      return __result;
    }
template < typename _ForwardIterator >
    constexpr
    _ForwardIterator
    inline min_element ( _ForwardIterator __first, _ForwardIterator __last )
    {
      ;
      ;
      return std :: __min_element ( __first, __last,
    __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _ForwardIterator, typename _Compare >
    constexpr
    inline _ForwardIterator
    min_element ( _ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp )
    {
      ;
      ;
      return std :: __min_element ( __first, __last,
    __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
template < typename _ForwardIterator, typename _Compare >
    constexpr
    _ForwardIterator
    __max_element ( _ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp )
    {
      if ( __first == __last ) return __first;
      _ForwardIterator __result = __first;
      while ( ++ __first != __last )
 if ( __comp ( __result, __first ) )
   __result = __first;
      return __result;
    }
template < typename _ForwardIterator >
    constexpr
    inline _ForwardIterator
    max_element ( _ForwardIterator __first, _ForwardIterator __last )
    {
      ;
      ;
      return std :: __max_element ( __first, __last,
    __gnu_cxx :: __ops :: __iter_less_iter ( ) );
    }
template < typename _ForwardIterator, typename _Compare >
    constexpr
    inline _ForwardIterator
    max_element ( _ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp )
    {
      ;
      ;
      return std :: __max_element ( __first, __last,
    __gnu_cxx :: __ops :: __iter_comp_iter ( __comp ) );
    }
}
namespace RAJA
{
namespace impl
{
namespace scan
{
template < typename ExecPolicy, typename Iter, typename BinFn >
concepts :: enable_if < type_traits :: is_sequential_policy < ExecPolicy > >
inclusive_inplace ( const ExecPolicy &, Iter begin, Iter end, BinFn f )
{
  auto agg = * begin;
  for ( Iter i = ++ begin; i != end; ++ i ) {
    agg = f ( * i, agg );
    * i = agg;
  }
}
template < typename ExecPolicy, typename Iter, typename BinFn, typename T >
concepts :: enable_if < type_traits :: is_sequential_policy < ExecPolicy > >
exclusive_inplace ( const ExecPolicy &, Iter begin, Iter end, BinFn f, T v )
{
  const int n = end - begin;
  decltype ( * begin ) agg = v;
  for ( int i = 0; i < n; ++ i ) {
    auto t = * ( begin + i );
    * ( begin + i ) = agg;
    agg = f ( agg, t );
  }
}
template < typename ExecPolicy, typename Iter, typename OutIter, typename BinFn >
concepts :: enable_if < type_traits :: is_sequential_policy < ExecPolicy > > inclusive (
    const ExecPolicy &,
    const Iter begin,
    const Iter end,
    OutIter out,
    BinFn f )
{
  auto agg = * begin;
  * out ++ = agg;
  for ( Iter i = begin + 1; i != end; ++ i ) {
    agg = f ( agg, * i );
    * out ++ = agg;
  }
}
template < typename ExecPolicy,
          typename Iter,
          typename OutIter,
          typename BinFn,
          typename T >
concepts :: enable_if < type_traits :: is_sequential_policy < ExecPolicy > > exclusive (
    const ExecPolicy &,
    const Iter begin,
    const Iter end,
    OutIter out,
    BinFn f,
    T v )
{
  decltype ( * begin ) agg = v;
  OutIter o = out;
  * o ++ = v;
  for ( Iter i = begin; i != end - 1; ++ i, ++ o ) {
    agg = f ( * i, agg );
    * o = agg;
  }
}
}
}
}
namespace RAJA
{
using loop_atomic = struct seq_atomic ;
}
namespace RAJA
{
namespace policy
{
namespace loop
{
struct loop_exec ;

struct loop_exec : public PolicyBaseT< Policy(2) , Pattern(1) , Launch(0) , camp::resources::v1::Platform(1) > 
{
}
;
using loop_segit = struct loop_exec ;
using loop_reduce = struct RAJA::policy::sequential::seq_reduce ;
}
}
using RAJA::policy::loop::loop_exec;
using RAJA::policy::loop::loop_reduce;
using RAJA::policy::loop::loop_segit;
}
using camp::concepts::enable_if;
namespace RAJA
{
namespace policy
{
namespace loop
{
template < typename Iterable, typename Func >
        inline __attribute__ ( ( always_inline ) ) void forall_impl ( const loop_exec &, Iterable && iter, Func && body )
        {
          using std :: begin; using std :: end; using std :: distance; auto begin_it = begin ( iter ); auto end_it = end ( iter ); auto distance_it = distance ( begin_it, end_it );
          for ( decltype ( distance_it ) i = 0; i < distance_it; ++ i ) {
            body ( * ( begin_it + i ) );
          }
        }
}
}
}
namespace RAJA
{
namespace internal
{
template < typename ... EnclosedStmts, typename Types >
struct StatementExecutor <
    statement :: Collapse < loop_exec, ArgList < >, EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data & data )
  {
    execute_statement_list < camp :: list < EnclosedStmts ... >, Types > ( data );
  }
};
template < camp :: idx_t Arg0, camp :: idx_t ... ArgRest, typename ... EnclosedStmts, typename Types >
struct StatementExecutor < statement :: Collapse < loop_exec,
                                             ArgList < Arg0, ArgRest ... >,
                                             EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data & data )
  {
    using NewTypes = setSegmentTypeFromData < Types, Arg0, Data >;
    using next_loop_t = StatementExecutor <
        statement :: Collapse < loop_exec, ArgList < ArgRest ... >, EnclosedStmts ... >, NewTypes >;
    auto len0 = segment_length < Arg0 > ( data );
    for ( auto i0 = 0; i0 < len0; ++ i0 ) {
      data . template assign_offset < Arg0 > ( i0 );
      next_loop_t :: exec ( data );
    }
  }
};
}
}
namespace RAJA
{
namespace impl
{
namespace scan
{
template < typename ExecPolicy, typename Iter, typename BinFn >
concepts :: enable_if < type_traits :: is_loop_policy < ExecPolicy > > inclusive_inplace (
    const ExecPolicy &,
    Iter begin,
    Iter end,
    BinFn f )
{
  auto agg = * begin;
  for ( Iter i = ++ begin; i != end; ++ i ) {
    agg = f ( * i, agg );
    * i = agg;
  }
}
template < typename ExecPolicy, typename Iter, typename BinFn, typename T >
concepts :: enable_if < type_traits :: is_loop_policy < ExecPolicy > > exclusive_inplace (
    const ExecPolicy &,
    Iter begin,
    Iter end,
    BinFn f,
    T v )
{
  const int n = end - begin;
  decltype ( * begin ) agg = v;
  for ( int i = 0; i < n; ++ i ) {
    auto t = * ( begin + i );
    * ( begin + i ) = agg;
    agg = f ( agg, t );
  }
}
template < typename ExecPolicy, typename Iter, typename OutIter, typename BinFn >
concepts :: enable_if < type_traits :: is_loop_policy < ExecPolicy > > inclusive (
    const ExecPolicy &,
    const Iter begin,
    const Iter end,
    OutIter out,
    BinFn f )
{
  auto agg = * begin;
  * out ++ = agg;
  for ( Iter i = begin + 1; i != end; ++ i ) {
    agg = f ( agg, * i );
    * out ++ = agg;
  }
}
template < typename ExecPolicy,
          typename Iter,
          typename OutIter,
          typename BinFn,
          typename T >
concepts :: enable_if < type_traits :: is_loop_policy < ExecPolicy > > exclusive (
    const ExecPolicy &,
    const Iter begin,
    const Iter end,
    OutIter out,
    BinFn f,
    T v )
{
  decltype ( * begin ) agg = v;
  OutIter o = out;
  * o ++ = v;
  for ( Iter i = begin; i != end - 1; ++ i, ++ o ) {
    agg = f ( * i, agg );
    * o = agg;
  }
}
}
}
}
namespace RAJA
{
namespace policy
{
namespace simd
{

struct simd_exec : public PolicyBaseT< Policy(1) , Pattern(1) , Launch(0) , camp::resources::v1::Platform(1) > 
{
}
;
}
}
using RAJA::policy::simd::simd_exec;
}
namespace RAJA
{
namespace policy
{
namespace simd
{
template < typename Iterable, typename Func >
inline __attribute__ ( ( always_inline ) ) void forall_impl ( const simd_exec &,
                             Iterable && iter,
                             Func && loop_body )
{
  auto begin = std :: begin ( iter );
  auto end = std :: end ( iter );
  auto distance = std :: distance ( begin, end );
#pragma GCC ivdep
  for ( decltype ( distance ) i = 0; i < distance; ++ i ) {
    loop_body ( * ( begin + i ) );
  }
}
}
}
}
namespace RAJA
{
namespace internal
{
template < class T >
struct TypeIsLambda {
  static const bool value = false;
};
template < camp :: idx_t BodyIdx, typename ... Args >
struct TypeIsLambda < RAJA :: statement :: Lambda < BodyIdx, Args ... > > {
  static const bool value = true;
};
template < typename Types, class ... Statements >
struct Invoke_all_Lambda;
template < typename Types >
struct Invoke_all_Lambda < Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void lambda_special ( Data && )
  {
  }
};
template < typename Types, class Statement, class ... StatementRest >
struct Invoke_all_Lambda < Types, Statement, StatementRest ... > {
  static const bool value = TypeIsLambda < camp :: decay < Statement >> :: value;
  static_assert ( value, "Lambdas are only supported post RAJA::simd_exec" );
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void lambda_special ( Data && data )
  {
    StatementExecutor < Statement, Types > :: exec ( data );
    Invoke_all_Lambda < Types, StatementRest ... > :: lambda_special ( data );
  }
};
template < camp :: idx_t ArgumentId, typename ... EnclosedStmts, typename Types >
struct StatementExecutor <
    statement :: For < ArgumentId, RAJA :: simd_exec, EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data && data )
  {
    using NewTypes = setSegmentTypeFromData < Types, ArgumentId, Data >;
    auto iter = get < ArgumentId > ( data . segment_tuple );
    auto begin = std :: begin ( iter );
    auto end = std :: end ( iter );
    auto distance = std :: distance ( begin, end );
#pragma GCC ivdep
    for ( decltype ( distance ) i = 0; i < distance; ++ i ) {
      using RAJA :: internal :: thread_privatize;
      auto privatizer = thread_privatize ( data );
      auto & private_data = privatizer . get_priv ( );
      private_data . template assign_offset < ArgumentId > ( i );
      Invoke_all_Lambda < NewTypes, EnclosedStmts ... > :: lambda_special ( private_data );
    }
  }
};
}
}
namespace RAJA
{
namespace internal
{
template < camp :: idx_t ArgumentId, typename ParamId,
          typename ... EnclosedStmts, typename Types >
struct StatementExecutor <
    statement :: ForICount < ArgumentId, ParamId, RAJA :: simd_exec,
                         EnclosedStmts ... >, Types > {
  template < typename Data >
  static inline __attribute__ ( ( always_inline ) ) void exec ( Data && data )
  {
    using NewTypes = setSegmentTypeFromData < Types, ArgumentId, Data >;
    auto iter = get < ArgumentId > ( data . segment_tuple );
    auto begin = std :: begin ( iter );
    auto end = std :: end ( iter );
    auto distance = std :: distance ( begin, end );
#pragma GCC ivdep
    for ( decltype ( distance ) i = 0; i < distance; ++ i ) {
      data . template assign_offset < ArgumentId > ( i );
      data . template assign_param < ParamId > ( i );
      using RAJA :: internal :: thread_privatize;
      auto privatizer = thread_privatize ( data );
      auto & private_data = privatizer . get_priv ( );
      Invoke_all_Lambda < NewTypes, EnclosedStmts ... > :: lambda_special ( private_data );
    }
  }
};
}
}
namespace RAJA
{
namespace detail
{
template < size_t index, size_t size, typename Policy, typename ... rest >
struct policy_invoker;
}
namespace policy
{
namespace multi
{
template < typename Selector, typename ... Policies >
class MultiPolicy
{
  Selector s;
public :
  MultiPolicy ( ) = delete;
  MultiPolicy ( Selector s );
  MultiPolicy ( Selector s, Policies ... policies );
  MultiPolicy ( const MultiPolicy & p );
  template < typename Iterable, typename Body >
  int invoke ( Iterable && i, Body && b )
  {
    size_t index = s ( i );
    _policies . invoke ( index, i, b );
    return s ( i );
  }
  detail ::
      policy_invoker < sizeof ... ( Policies ) - 1, sizeof ... ( Policies ), Policies ... >
          _policies;
};
template < typename Iterable,
          typename Body,
          typename Selector,
          typename ... Policies >
inline __attribute__ ( ( always_inline ) ) void forall_impl ( MultiPolicy < Selector, Policies ... > p,
                             Iterable && iter,
                             Body && body )
{
  p . invoke ( iter, body );
}
}
}
using RAJA::RAJA::policy::multi::MultiPolicy;
namespace detail
{
template < camp :: idx_t ... Indices, typename ... Policies, typename Selector >
auto make_multi_policy ( camp :: idx_seq < Indices ... >,
                       Selector s,
                       std :: tuple < Policies ... > policies )
    -> MultiPolicy < Selector, Policies ... >
{
  return MultiPolicy < Selector, Policies ... > ( s, std :: get < Indices > ( policies ) ... );
}
}
template < typename ... Policies, typename Selector >
auto make_multi_policy ( Selector s ) -> MultiPolicy < Selector, Policies ... >
{
  return MultiPolicy < Selector, Policies ... > ( s, Policies { } ... );
}
template < typename ... Policies, typename Selector >
auto make_multi_policy ( std :: tuple < Policies ... > policies, Selector s )
    -> MultiPolicy < Selector, Policies ... >
{
  return detail :: make_multi_policy (
      camp :: make_idx_seq_t < sizeof ... ( Policies ) > { }, s, policies );
}
namespace detail
{
template < size_t index, size_t size, typename Policy, typename ... rest >
struct policy_invoker : public policy_invoker < index - 1, size, rest ... > {
  static_assert ( index < size, "index must be in the range of possibilities" );
  Policy _p;
  using NextInvoker = policy_invoker < index - 1, size, rest ... >;
  policy_invoker ( Policy p, rest ... args );
  template < typename Iterable, typename Body >
  void invoke ( int offset, Iterable && iter, Body && body )
  {
    if ( offset == size - index - 1 ) {
      using policy :: multi :: forall_impl;
      forall_impl ( _p, iter, body );
    } else {
      NextInvoker :: invoke ( offset, iter, body );
    }
  }
};
template < size_t size, typename Policy, typename ... rest >
struct policy_invoker < 0, size, Policy, rest ... > {
  Policy _p;
  policy_invoker ( Policy p, rest ... );
  template < typename Iterable, typename Body >
  void invoke ( int offset, Iterable && iter, Body && body )
  {
    if ( offset == size - 1 ) {
      util :: PluginContext context { util :: make_context < Policy > ( ) };
      util :: callPreLaunchPlugins ( context );
      using policy :: multi :: forall_impl;
      forall_impl ( _p, iter, body );
      util :: callPostLaunchPlugins ( context );
    } else {
      throw std :: runtime_error ( "unknown offset invoked" );
    }
  }
};
}
}
namespace RAJA
{
template < typename Indices >
struct as_array;
template < camp :: idx_t ... Indices >
struct as_array < camp :: idx_seq < Indices ... > > {
  static constexpr std :: array < Index_type, sizeof ... ( Indices ) > get ( )
  ;
};
using PERM_I = camp::idx_seq<   > ;
using PERM_IJ = camp::idx_seq<   > ;
using PERM_JI = camp::idx_seq<   > ;
using PERM_IJK = camp::idx_seq<   > ;
using PERM_IKJ = camp::idx_seq<   > ;
using PERM_JIK = camp::idx_seq<   > ;
using PERM_JKI = camp::idx_seq<   > ;
using PERM_KIJ = camp::idx_seq<   > ;
using PERM_KJI = camp::idx_seq<   > ;
using PERM_IJKL = camp::idx_seq<   > ;
using PERM_IJLK = camp::idx_seq<   > ;
using PERM_IKJL = camp::idx_seq<   > ;
using PERM_IKLJ = camp::idx_seq<   > ;
using PERM_ILJK = camp::idx_seq<   > ;
using PERM_ILKJ = camp::idx_seq<   > ;
using PERM_JIKL = camp::idx_seq<   > ;
using PERM_JILK = camp::idx_seq<   > ;
using PERM_JKIL = camp::idx_seq<   > ;
using PERM_JKLI = camp::idx_seq<   > ;
using PERM_JLIK = camp::idx_seq<   > ;
using PERM_JLKI = camp::idx_seq<   > ;
using PERM_KIJL = camp::idx_seq<   > ;
using PERM_KILJ = camp::idx_seq<   > ;
using PERM_KJIL = camp::idx_seq<   > ;
using PERM_KJLI = camp::idx_seq<   > ;
using PERM_KLIJ = camp::idx_seq<   > ;
using PERM_KLJI = camp::idx_seq<   > ;
using PERM_LIJK = camp::idx_seq<   > ;
using PERM_LIKJ = camp::idx_seq<   > ;
using PERM_LJIK = camp::idx_seq<   > ;
using PERM_LJKI = camp::idx_seq<   > ;
using PERM_LKIJ = camp::idx_seq<   > ;
using PERM_LKJI = camp::idx_seq<   > ;
using PERM_IJKLM = camp::idx_seq<   > ;
using PERM_IJKML = camp::idx_seq<   > ;
using PERM_IJLKM = camp::idx_seq<   > ;
using PERM_IJLMK = camp::idx_seq<   > ;
using PERM_IJMKL = camp::idx_seq<   > ;
using PERM_IJMLK = camp::idx_seq<   > ;
using PERM_IKJLM = camp::idx_seq<   > ;
using PERM_IKJML = camp::idx_seq<   > ;
using PERM_IKLJM = camp::idx_seq<   > ;
using PERM_IKLMJ = camp::idx_seq<   > ;
using PERM_IKMJL = camp::idx_seq<   > ;
using PERM_IKMLJ = camp::idx_seq<   > ;
using PERM_ILJKM = camp::idx_seq<   > ;
using PERM_ILJMK = camp::idx_seq<   > ;
using PERM_ILKJM = camp::idx_seq<   > ;
using PERM_ILKMJ = camp::idx_seq<   > ;
using PERM_ILMJK = camp::idx_seq<   > ;
using PERM_ILMKJ = camp::idx_seq<   > ;
using PERM_IMJKL = camp::idx_seq<   > ;
using PERM_IMJLK = camp::idx_seq<   > ;
using PERM_IMKJL = camp::idx_seq<   > ;
using PERM_IMKLJ = camp::idx_seq<   > ;
using PERM_IMLJK = camp::idx_seq<   > ;
using PERM_IMLKJ = camp::idx_seq<   > ;
using PERM_JIKLM = camp::idx_seq<   > ;
using PERM_JIKML = camp::idx_seq<   > ;
using PERM_JILKM = camp::idx_seq<   > ;
using PERM_JILMK = camp::idx_seq<   > ;
using PERM_JIMKL = camp::idx_seq<   > ;
using PERM_JIMLK = camp::idx_seq<   > ;
using PERM_JKILM = camp::idx_seq<   > ;
using PERM_JKIML = camp::idx_seq<   > ;
using PERM_JKLIM = camp::idx_seq<   > ;
using PERM_JKLMI = camp::idx_seq<   > ;
using PERM_JKMIL = camp::idx_seq<   > ;
using PERM_JKMLI = camp::idx_seq<   > ;
using PERM_JLIKM = camp::idx_seq<   > ;
using PERM_JLIMK = camp::idx_seq<   > ;
using PERM_JLKIM = camp::idx_seq<   > ;
using PERM_JLKMI = camp::idx_seq<   > ;
using PERM_JLMIK = camp::idx_seq<   > ;
using PERM_JLMKI = camp::idx_seq<   > ;
using PERM_JMIKL = camp::idx_seq<   > ;
using PERM_JMILK = camp::idx_seq<   > ;
using PERM_JMKIL = camp::idx_seq<   > ;
using PERM_JMKLI = camp::idx_seq<   > ;
using PERM_JMLIK = camp::idx_seq<   > ;
using PERM_JMLKI = camp::idx_seq<   > ;
using PERM_KIJLM = camp::idx_seq<   > ;
using PERM_KIJML = camp::idx_seq<   > ;
using PERM_KILJM = camp::idx_seq<   > ;
using PERM_KILMJ = camp::idx_seq<   > ;
using PERM_KIMJL = camp::idx_seq<   > ;
using PERM_KIMLJ = camp::idx_seq<   > ;
using PERM_KJILM = camp::idx_seq<   > ;
using PERM_KJIML = camp::idx_seq<   > ;
using PERM_KJLIM = camp::idx_seq<   > ;
using PERM_KJLMI = camp::idx_seq<   > ;
using PERM_KJMIL = camp::idx_seq<   > ;
using PERM_KJMLI = camp::idx_seq<   > ;
using PERM_KLIJM = camp::idx_seq<   > ;
using PERM_KLIMJ = camp::idx_seq<   > ;
using PERM_KLJIM = camp::idx_seq<   > ;
using PERM_KLJMI = camp::idx_seq<   > ;
using PERM_KLMIJ = camp::idx_seq<   > ;
using PERM_KLMJI = camp::idx_seq<   > ;
using PERM_KMIJL = camp::idx_seq<   > ;
using PERM_KMILJ = camp::idx_seq<   > ;
using PERM_KMJIL = camp::idx_seq<   > ;
using PERM_KMJLI = camp::idx_seq<   > ;
using PERM_KMLIJ = camp::idx_seq<   > ;
using PERM_KMLJI = camp::idx_seq<   > ;
using PERM_LIJKM = camp::idx_seq<   > ;
using PERM_LIJMK = camp::idx_seq<   > ;
using PERM_LIKJM = camp::idx_seq<   > ;
using PERM_LIKMJ = camp::idx_seq<   > ;
using PERM_LIMJK = camp::idx_seq<   > ;
using PERM_LIMKJ = camp::idx_seq<   > ;
using PERM_LJIKM = camp::idx_seq<   > ;
using PERM_LJIMK = camp::idx_seq<   > ;
using PERM_LJKIM = camp::idx_seq<   > ;
using PERM_LJKMI = camp::idx_seq<   > ;
using PERM_LJMIK = camp::idx_seq<   > ;
using PERM_LJMKI = camp::idx_seq<   > ;
using PERM_LKIJM = camp::idx_seq<   > ;
using PERM_LKIMJ = camp::idx_seq<   > ;
using PERM_LKJIM = camp::idx_seq<   > ;
using PERM_LKJMI = camp::idx_seq<   > ;
using PERM_LKMIJ = camp::idx_seq<   > ;
using PERM_LKMJI = camp::idx_seq<   > ;
using PERM_LMIJK = camp::idx_seq<   > ;
using PERM_LMIKJ = camp::idx_seq<   > ;
using PERM_LMJIK = camp::idx_seq<   > ;
using PERM_LMJKI = camp::idx_seq<   > ;
using PERM_LMKIJ = camp::idx_seq<   > ;
using PERM_LMKJI = camp::idx_seq<   > ;
using PERM_MIJKL = camp::idx_seq<   > ;
using PERM_MIJLK = camp::idx_seq<   > ;
using PERM_MIKJL = camp::idx_seq<   > ;
using PERM_MIKLJ = camp::idx_seq<   > ;
using PERM_MILJK = camp::idx_seq<   > ;
using PERM_MILKJ = camp::idx_seq<   > ;
using PERM_MJIKL = camp::idx_seq<   > ;
using PERM_MJILK = camp::idx_seq<   > ;
using PERM_MJKIL = camp::idx_seq<   > ;
using PERM_MJKLI = camp::idx_seq<   > ;
using PERM_MJLIK = camp::idx_seq<   > ;
using PERM_MJLKI = camp::idx_seq<   > ;
using PERM_MKIJL = camp::idx_seq<   > ;
using PERM_MKILJ = camp::idx_seq<   > ;
using PERM_MKJIL = camp::idx_seq<   > ;
using PERM_MKJLI = camp::idx_seq<   > ;
using PERM_MKLIJ = camp::idx_seq<   > ;
using PERM_MKLJI = camp::idx_seq<   > ;
using PERM_MLIJK = camp::idx_seq<   > ;
using PERM_MLIKJ = camp::idx_seq<   > ;
using PERM_MLJIK = camp::idx_seq<   > ;
using PERM_MLJKI = camp::idx_seq<   > ;
using PERM_MLKIJ = camp::idx_seq<   > ;
using PERM_MLKJI = camp::idx_seq<   > ;
namespace internal
{
template < camp :: idx_t I, camp :: idx_t J, camp :: idx_t N, typename Perm >
struct CalcInversePermutationElem
{
  static constexpr camp :: idx_t value =
    camp :: seq_at < J, Perm > :: value == I ? J : CalcInversePermutationElem < I, J + 1, N, Perm > :: value;
};
template < camp :: idx_t I, camp :: idx_t N, typename Perm >
struct CalcInversePermutationElem < I, N, N, Perm >
{
  static constexpr camp :: idx_t value = I;
};
template < typename Range, typename Perm >
struct InversePermutationHelper;
template < camp :: idx_t ... Range, camp :: idx_t ... Perm >
struct InversePermutationHelper < camp :: idx_seq < Range ... >,
                                camp :: idx_seq < Perm ... > >
{
  static_assert ( sizeof ... ( Range ) == sizeof ... ( Perm ), "Fatal Error" );
  using type = camp :: idx_seq <
    CalcInversePermutationElem < Range, 0, sizeof ... ( Range ), camp :: idx_seq < Perm ... >> :: value ...
  >;
};
}
template < typename Perm >
using invert_permutation = typename internal :: InversePermutationHelper < camp :: make_idx_seq_t < camp :: size < Perm > :: value >, Perm > :: type;
}
namespace RAJA
{
namespace detail
{
template < ptrdiff_t i, ptrdiff_t exclude_i >
struct ConditionalMultiply {
  template < typename A, typename B >
  static inline __attribute__ ( ( always_inline ) ) constexpr A multiply ( A a, B b )
  {
    return a * b;
  }
};
template < ptrdiff_t i >
struct ConditionalMultiply < i, i > {
  template < typename A, typename B >
  static inline __attribute__ ( ( always_inline ) ) constexpr A multiply ( A a, B )
  {
    return a;
  }
};
template < typename Range,
          typename IdxLin = Index_type,
          ptrdiff_t StrideOneDim = - 1 >
struct LayoutBase_impl;
template < size_t j, size_t n_dims, typename IdxLin = Index_type >
struct stride_calculator {
  inline __attribute__ ( ( always_inline ) ) constexpr IdxLin operator ( ) (
      IdxLin cur_stride,
      IdxLin const ( & sizes ) [ n_dims ] ) const
  ;
};
template < size_t n_dims, typename IdxLin >
struct stride_calculator < n_dims, n_dims, IdxLin > {
  inline __attribute__ ( ( always_inline ) ) constexpr IdxLin operator ( ) (
      IdxLin cur_stride,
      IdxLin const ( & ) [ n_dims ] ) const
  ;
};
template < camp :: idx_t ... RangeInts, typename IdxLin, ptrdiff_t StrideOneDim >
struct LayoutBase_impl < camp :: idx_seq < RangeInts ... >, IdxLin, StrideOneDim > {
public :
  using IndexLinear = IdxLin;
  using IndexRange = camp :: make_idx_seq_t < sizeof ... ( RangeInts ) >;
  static constexpr size_t n_dims = sizeof ... ( RangeInts );
  static constexpr IdxLin limit = RAJA :: operators :: limits < IdxLin > :: max ( );
  static constexpr ptrdiff_t stride1_dim = StrideOneDim;
  IdxLin sizes [ n_dims ];
  IdxLin strides [ n_dims ];
  IdxLin inv_strides [ n_dims ];
  IdxLin inv_mods [ n_dims ];
  inline __attribute__ ( ( always_inline ) ) constexpr LayoutBase_impl ( )
      ;
  template < typename ... Types >
  inline __attribute__ ( ( always_inline ) ) constexpr LayoutBase_impl ( Types ... ns )
      : sizes { static_cast < IdxLin > ( stripIndexType ( ns ) ) ... },
        strides { ( detail :: stride_calculator < RangeInts + 1, n_dims, IdxLin > { } (
            sizes [ RangeInts ] ? IdxLin ( 1 ) : IdxLin ( 0 ),
            sizes ) ) ... },
        inv_strides { ( strides [ RangeInts ] ? strides [ RangeInts ] : IdxLin ( 1 ) ) ... },
        inv_mods { ( sizes [ RangeInts ] ? sizes [ RangeInts ] : IdxLin ( 1 ) ) ... }
  {
    static_assert ( n_dims == sizeof ... ( Types ),
                  "number of dimensions must match" );
  }
  template < typename CIdxLin, ptrdiff_t CStrideOneDim >
  constexpr inline __attribute__ ( ( always_inline ) ) LayoutBase_impl (
      const LayoutBase_impl < camp :: idx_seq < RangeInts ... >, CIdxLin, CStrideOneDim >
          & rhs )
      : sizes { static_cast < IdxLin > ( rhs . sizes [ RangeInts ] ) ... },
        strides { static_cast < IdxLin > ( rhs . strides [ RangeInts ] ) ... },
        inv_strides { static_cast < IdxLin > ( rhs . inv_strides [ RangeInts ] ) ... },
        inv_mods { static_cast < IdxLin > ( rhs . inv_mods [ RangeInts ] ) ... }
  {
  }
  template < typename ... Types >
  inline __attribute__ ( ( always_inline ) ) constexpr LayoutBase_impl (
      const std :: array < IdxLin, n_dims > & sizes_in,
      const std :: array < IdxLin, n_dims > & strides_in )
      : sizes { sizes_in [ RangeInts ] ... },
        strides { strides_in [ RangeInts ] ... },
        inv_strides { ( strides [ RangeInts ] ? strides [ RangeInts ] : IdxLin ( 1 ) ) ... },
        inv_mods { ( sizes [ RangeInts ] ? sizes [ RangeInts ] : IdxLin ( 1 ) ) ... }
  {
  }
  template < camp :: idx_t N, typename Idx >
  inline __attribute__ ( ( always_inline ) ) void BoundsCheckError ( Idx idx ) const
  {
    printf ( "Error at index %d, value %ld is not within bounds [0, %ld] \n",
           static_cast < int > ( N ), static_cast < long int > ( idx ), static_cast < long int > ( sizes [ N ] - 1 ) );
    RAJA_ABORT_OR_THROW ( "Out of bounds error \n" );
  }
  template < camp :: idx_t N >
  inline __attribute__ ( ( always_inline ) ) void BoundsCheck ( ) const
  {
  }
  template < camp :: idx_t N, typename Idx, typename ... Indices >
  inline __attribute__ ( ( always_inline ) ) void BoundsCheck ( Idx idx, Indices ... indices ) const
  {
    if ( sizes [ N ] > 0 && ! ( 0 <= idx && idx < static_cast < Idx > ( sizes [ N ] ) ) )
    {
      BoundsCheckError < N > ( idx );
    }
    RAJA_UNUSED_VAR ( idx );
    BoundsCheck < N + 1 > ( indices ... );
  }
  template < typename ... Indices >
  inline __attribute__ ( ( always_inline ) ) constexpr IdxLin operator ( ) (
      Indices ... indices ) const
  {
    return sum < IdxLin >
      ( ( ( IdxLin ) detail :: ConditionalMultiply < RangeInts, stride1_dim > :: multiply ( IdxLin ( indices ), strides [ RangeInts ] ) ) ... );
  }
  template < typename ... Indices >
  inline __attribute__ ( ( always_inline ) ) void toIndices ( IdxLin linear_index,
                                              Indices && ... indices ) const
  {
    camp :: sink ( ( indices = ( camp :: decay < Indices > ) ( ( linear_index / inv_strides [ RangeInts ] ) %
                                   inv_mods [ RangeInts ] ) ) ... );
  }
  inline __attribute__ ( ( always_inline ) ) constexpr IdxLin size ( ) const
  ;
};
template < camp :: idx_t ... RangeInts, typename IdxLin, ptrdiff_t StrideOneDim >
constexpr size_t
    LayoutBase_impl < camp :: idx_seq < RangeInts ... >, IdxLin, StrideOneDim > :: n_dims;
template < camp :: idx_t ... RangeInts, typename IdxLin, ptrdiff_t StrideOneDim >
constexpr IdxLin
    LayoutBase_impl < camp :: idx_seq < RangeInts ... >, IdxLin, StrideOneDim > :: limit;
}
template < size_t n_dims, typename IdxLin = Index_type, ptrdiff_t StrideOne = - 1 >
using Layout =
    detail :: LayoutBase_impl < camp :: make_idx_seq_t < n_dims >, IdxLin, StrideOne >;
template < typename IdxLin, typename DimTuple, ptrdiff_t StrideOne = - 1 >
struct TypedLayout;
template < typename IdxLin, typename ... DimTypes, ptrdiff_t StrideOne >
struct TypedLayout < IdxLin, camp :: tuple < DimTypes ... >, StrideOne >
    : public Layout < sizeof ... ( DimTypes ), strip_index_type_t < IdxLin >, StrideOne > {
  using StrippedIdxLin = strip_index_type_t < IdxLin >;
  using Self = TypedLayout < IdxLin, camp :: tuple < DimTypes ... >, StrideOne >;
  using Base = Layout < sizeof ... ( DimTypes ), StrippedIdxLin, StrideOne >;
  using DimArr = std :: array < StrippedIdxLin, sizeof ... ( DimTypes ) >;
  using Base :: Base;
  inline __attribute__ ( ( always_inline ) ) constexpr IdxLin operator ( ) (
      DimTypes ... indices ) const
  ;
  inline __attribute__ ( ( always_inline ) ) void toIndices ( IdxLin linear_index,
                                              DimTypes & ... indices ) const
  ;
private :
  template < typename ... Indices, camp :: idx_t ... RangeInts >
  inline __attribute__ ( ( always_inline ) ) void toIndicesHelper ( camp :: idx_seq < RangeInts ... >,
                                                    IdxLin linear_index,
                                                    Indices & ... indices ) const
  {
    Index_type locals [ sizeof ... ( DimTypes ) ];
    Base :: toIndices ( stripIndexType ( linear_index ), locals [ RangeInts ] ... );
  camp :: sink ( ( indices = Indices { static_cast < Indices > ( locals [ RangeInts ] ) } ) ... );
  }
};
template < ptrdiff_t s1_dim, size_t n_dims, typename IdxLin >
inline __attribute__ ( ( always_inline ) ) Layout < n_dims, IdxLin, s1_dim > make_stride_one (
    Layout < n_dims, IdxLin > const & l )
{
  return Layout < n_dims, IdxLin, s1_dim > ( l );
}
template < ptrdiff_t s1_dim, typename IdxLin, typename IdxTuple >
inline __attribute__ ( ( always_inline ) ) TypedLayout < IdxLin, IdxTuple, s1_dim > make_stride_one (
    TypedLayout < IdxLin, IdxTuple > const & l )
{
  using Base = typename TypedLayout < IdxLin, IdxTuple > :: Base;
  Base const & b = ( Base const & ) l;
  return TypedLayout < IdxLin, IdxTuple, s1_dim > ( b );
}
}
namespace RAJA
{
template < size_t Rank, typename IdxLin = Index_type >
auto make_permuted_layout ( std :: array < IdxLin, Rank > sizes,
                          std :: array < camp :: idx_t, Rank > permutation )
    -> Layout < Rank, IdxLin >
{
  std :: array < IdxLin, Rank > strides;
  std :: array < IdxLin, Rank > folded_strides;
  for ( size_t i = 0; i < Rank; ++ i ) {
    folded_strides [ i ] = sizes [ permutation [ i ] ] ? 1 : 0;
    for ( size_t j = i + 1; j < Rank; ++ j ) {
      folded_strides [ i ] *= sizes [ permutation [ j ] ] ? sizes [ permutation [ j ] ] : 1;
    }
  }
  for ( size_t i = 0; i < Rank; ++ i ) {
    strides [ permutation [ i ] ] = folded_strides [ i ];
  }
  auto ret = Layout < Rank, IdxLin > ( );
  for ( size_t i = 0; i < Rank; ++ i ) {
    ret . sizes [ i ] = sizes [ i ];
    ret . strides [ i ] = strides [ i ];
    ret . inv_strides [ i ] = strides [ i ] ? strides [ i ] : 1;
    ret . inv_mods [ i ] = sizes [ i ] ? sizes [ i ] : 1;
  }
  return ret;
}
template < camp :: idx_t ... Ints >
using Perm = camp :: idx_seq < Ints ... >;
template < camp :: idx_t N >
using MakePerm = typename camp :: make_idx_seq < N > :: type;
}
namespace RAJA
{
namespace internal
{
template < typename Range, typename IdxLin >
struct OffsetLayout_impl;
template < camp :: idx_t ... RangeInts, typename IdxLin >
struct OffsetLayout_impl < camp :: idx_seq < RangeInts ... >, IdxLin > {
  using Self = OffsetLayout_impl < camp :: idx_seq < RangeInts ... >, IdxLin >;
  using IndexRange = camp :: idx_seq < RangeInts ... >;
  using Base = RAJA :: detail :: LayoutBase_impl < IndexRange, IdxLin >;
  Base base_;
  static constexpr size_t n_dims = sizeof ... ( RangeInts );
  IdxLin offsets [ n_dims ] = { 0 };
  constexpr inline __attribute__ ( ( always_inline ) ) OffsetLayout_impl (
      std :: array < IdxLin, sizeof ... ( RangeInts ) > lower,
      std :: array < IdxLin, sizeof ... ( RangeInts ) > upper )
      ;
  constexpr inline __attribute__ ( ( always_inline ) ) OffsetLayout_impl ( Self const & c )
      ;
  void shift ( std :: array < IdxLin, sizeof ... ( RangeInts ) > shift )
  ;
  template < camp :: idx_t N, typename Idx >
  inline __attribute__ ( ( always_inline ) ) void BoundsCheckError ( Idx idx ) const
  {
    printf ( "Error at index %d, value %ld is not within bounds [%ld, %ld] \n",
           static_cast < int > ( N ), static_cast < long int > ( idx ),
           static_cast < long int > ( offsets [ N ] ), static_cast < long int > ( offsets [ N ] + base_ . sizes [ N ] - 1 ) );
    RAJA_ABORT_OR_THROW ( "Out of bounds error \n" );
  }
  template < camp :: idx_t N >
  inline __attribute__ ( ( always_inline ) ) void BoundsCheck ( ) const
  {
  }
  template < camp :: idx_t N, typename Idx, typename ... Indices >
  inline __attribute__ ( ( always_inline ) ) void BoundsCheck ( Idx idx, Indices ... indices ) const
  {
    if ( ! ( offsets [ N ] <= idx && idx < offsets [ N ] + base_ . sizes [ N ] ) )
    {
      BoundsCheckError < N > ( idx );
    }
    RAJA_UNUSED_VAR ( idx );
    BoundsCheck < N + 1 > ( indices ... );
  }
  template < typename ... Indices >
  inline __attribute__ ( ( always_inline ) ) constexpr IdxLin operator ( ) (
      Indices ... indices ) const
  {
    return base_ ( ( indices - offsets [ RangeInts ] ) ... );
  }
  static inline __attribute__ ( ( always_inline ) ) OffsetLayout_impl < IndexRange, IdxLin >
  from_layout_and_offsets (
      const std :: array < IdxLin, sizeof ... ( RangeInts ) > & offsets_in,
      const Layout < sizeof ... ( RangeInts ), IdxLin > & rhs )
  ;
  constexpr inline __attribute__ ( ( always_inline ) )
  OffsetLayout_impl ( const Layout < sizeof ... ( RangeInts ), IdxLin > & rhs )
      ;
};
}
template < size_t n_dims = 1, typename IdxLin = Index_type >
struct OffsetLayout
    : public internal :: OffsetLayout_impl < camp :: make_idx_seq_t < n_dims >, IdxLin > {
  using Base =
      internal :: OffsetLayout_impl < camp :: make_idx_seq_t < n_dims >, IdxLin >;
  using internal :: OffsetLayout_impl < camp :: make_idx_seq_t < n_dims >,
                                    IdxLin > :: OffsetLayout_impl;
  constexpr inline __attribute__ ( ( always_inline ) ) OffsetLayout (
      const internal :: OffsetLayout_impl < camp :: make_idx_seq_t < n_dims >, IdxLin > &
          rhs )
      ;
};
template < typename IdxLin, typename DimTuple >
struct TypedOffsetLayout;
template < typename IdxLin, typename ... DimTypes >
struct TypedOffsetLayout < IdxLin, camp :: tuple < DimTypes ... > >
: public OffsetLayout < sizeof ... ( DimTypes ), Index_type >
{
   using Self = TypedOffsetLayout < IdxLin, camp :: tuple < DimTypes ... >>;
   using Base = OffsetLayout < sizeof ... ( DimTypes ), Index_type >;
   using DimArr = std :: array < Index_type, sizeof ... ( DimTypes ) >;
   using Base :: Base;
  inline __attribute__ ( ( always_inline ) ) constexpr IdxLin operator ( ) ( DimTypes ... indices ) const
  ;
};
template < size_t n_dims, typename IdxLin = Index_type >
auto make_offset_layout ( const std :: array < IdxLin, n_dims > & lower,
                        const std :: array < IdxLin, n_dims > & upper )
    -> OffsetLayout < n_dims, IdxLin >
{
  return OffsetLayout < n_dims, IdxLin > { lower, upper };
}
template < size_t Rank, typename IdxLin = Index_type >
auto make_permuted_offset_layout ( const std :: array < IdxLin, Rank > & lower,
                                 const std :: array < IdxLin, Rank > & upper,
                                 const std :: array < IdxLin, Rank > & permutation )
    -> decltype ( make_offset_layout < Rank, IdxLin > ( lower, upper ) )
{
  std :: array < IdxLin, Rank > sizes;
  for ( size_t i = 0; i < Rank; ++ i ) {
    sizes [ i ] = upper [ i ] - lower [ i ] + 1;
  }
  return internal :: OffsetLayout_impl < camp :: make_idx_seq_t < Rank >, IdxLin > ::
      from_layout_and_offsets ( lower, make_permuted_layout ( sizes, permutation ) );
}
}
namespace RAJA
{
namespace detail
{
template < typename IdxLin, typename Range, typename Sizes, typename Strides >
struct StaticLayoutBase_impl;
template < typename IdxLin,
          IdxLin ... RangeInts,
          IdxLin ... Sizes,
          IdxLin ... Strides >
struct StaticLayoutBase_impl < IdxLin,
                             camp :: int_seq < IdxLin, RangeInts ... >,
                             camp :: int_seq < IdxLin, Sizes ... >,
                             camp :: int_seq < IdxLin, Strides ... > > {
  using IndexLinear = IdxLin;
  using sizes = camp :: int_seq < IdxLin, Sizes ... >;
  using strides = camp :: int_seq < IdxLin, Strides ... >;
  inline __attribute__ ( ( always_inline ) ) constexpr StaticLayoutBase_impl ( );
  inline __attribute__ ( ( always_inline ) ) static void print ( )
  ;
  template < typename ... Indices >
  inline __attribute__ ( ( always_inline ) ) constexpr IdxLin operator ( ) (
      Indices ... indices ) const
  {
    return sum < IdxLin > ( ( IdxLin ( indices * Strides ) ) ... );
  }
  template < typename ... Indices >
  static inline __attribute__ ( ( always_inline ) ) constexpr IdxLin s_oper ( Indices ... indices )
  {
    return sum < IdxLin > ( ( IdxLin ( indices * Strides ) ) ... );
  }
  static constexpr IdxLin s_size =
      RAJA :: product < IdxLin > ( ( Sizes == IdxLin ( 0 ) ? IdxLin ( 1 ) : Sizes ) ... );
  inline __attribute__ ( ( always_inline ) ) static constexpr IdxLin size ( )
  ;
};
template < typename IdxLin, IdxLin N, IdxLin Idx, IdxLin ... Sizes >
struct StrideCalculatorIdx {
  static_assert ( N == sizeof ... ( Sizes ), "" );
  using sizes_seq = camp :: int_seq < IdxLin, Sizes ... >;
  static constexpr IdxLin size = camp :: seq_at < Idx, sizes_seq > :: value;
  static constexpr IdxLin size_last =
      StrideCalculatorIdx < IdxLin, N, Idx + 1, Sizes ... > :: size;
  static constexpr IdxLin value =
      ( size_last > 0 ? size_last : 1 ) *
      StrideCalculatorIdx < IdxLin, N, Idx + 1, Sizes ... > :: value;
  static constexpr IdxLin stride = size > 0 ? value : 0;
};
template < typename IdxLin, IdxLin N, IdxLin ... Sizes >
struct StrideCalculatorIdx < IdxLin, N, N, Sizes ... > {
  static_assert ( N == sizeof ... ( Sizes ), "" );
  static constexpr IdxLin size = 1;
  static constexpr IdxLin value = 1;
  static constexpr IdxLin stride = size > 0 ? value : 0;
};
template < typename IdxLin, typename Range, typename Perm, typename Sizes >
struct StrideCalculator;
template < typename IdxLin, IdxLin ... Range, camp :: idx_t ... Perm, IdxLin ... Sizes >
struct StrideCalculator < IdxLin,
                        camp :: int_seq < IdxLin, Range ... >,
                        camp :: idx_seq < Perm ... >,
                        camp :: int_seq < IdxLin, Sizes ... > > {
  static_assert ( sizeof ... ( Sizes ) == sizeof ... ( Perm ), "" );
  using sizes = camp :: int_seq < IdxLin, Sizes ... >;
  static constexpr IdxLin N = sizeof ... ( Sizes );
  using range = camp :: int_seq < IdxLin, Range ... >;
  using perm = camp :: idx_seq < Perm ... >;
  using inv_perm = invert_permutation < perm >;
  using strides_unperm =
      camp :: int_seq < IdxLin, StrideCalculatorIdx < IdxLin, N, Range, camp :: seq_at < Perm, sizes > :: value ... > :: stride ... >;
  using strides = camp :: int_seq < IdxLin, camp :: seq_at < camp :: seq_at < Range, inv_perm > :: value, strides_unperm > :: value ... >;
};
template < typename Layout, typename DimTypeList >
struct TypedStaticLayoutImpl;
template < typename Layout, typename ... DimTypes >
struct TypedStaticLayoutImpl < Layout, camp :: list < DimTypes ... > > {
  using IndexLinear = typename Layout :: IndexLinear;
  static inline __attribute__ ( ( always_inline ) ) constexpr IndexLinear s_oper (
      DimTypes ... indices )
  ;
  static constexpr IndexLinear s_size = Layout :: s_size;
  inline __attribute__ ( ( always_inline ) ) constexpr static IndexLinear size ( )
  ;
  inline __attribute__ ( ( always_inline ) )
  static void print ( );
};
}
template < typename Perm, typename IdxLin, camp :: idx_t ... Sizes >
using StaticLayoutT = detail :: StaticLayoutBase_impl <
    IdxLin,
    camp :: make_int_seq_t < IdxLin, sizeof ... ( Sizes ) >,
    camp :: int_seq < IdxLin, Sizes ... >,
    typename detail :: StrideCalculator < IdxLin,
                                      camp :: make_int_seq_t < IdxLin, sizeof ... ( Sizes ) >,
                                      Perm,
                                      camp :: int_seq < IdxLin, Sizes ... >> :: strides >;
template < typename Perm, camp :: idx_t ... Sizes >
using StaticLayout = StaticLayoutT < Perm, camp :: idx_t, Sizes ... >;
template < typename Perm, typename IdxLin, typename TypeList, camp :: idx_t ... Sizes >
using TypedStaticLayout =
    detail :: TypedStaticLayoutImpl < StaticLayoutT < Perm, IdxLin, Sizes ... >, TypeList >;
}
namespace RAJA
{

struct auto_atomic 
{
}
;
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicAdd ( auto_atomic, T volatile * acc, T value )
{
  return atomicAdd ( RAJA :: seq_atomic { }, acc, value );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicSub ( auto_atomic, T volatile * acc, T value )
{
  return atomicSub ( RAJA :: seq_atomic { }, acc, value );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicMin ( auto_atomic, T volatile * acc, T value )
{
  return atomicMin ( RAJA :: seq_atomic { }, acc, value );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicMax ( auto_atomic, T volatile * acc, T value )
{
  return atomicMax ( RAJA :: seq_atomic { }, acc, value );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicInc ( auto_atomic, T volatile * acc )
{
  return atomicInc ( RAJA :: seq_atomic { }, acc );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicInc ( auto_atomic,
                                         T volatile * acc,
                                         T compare )
{
  return atomicInc ( RAJA :: seq_atomic { }, acc, compare );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicDec ( auto_atomic, T volatile * acc )
{
  return atomicDec ( RAJA :: seq_atomic { }, acc );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicDec ( auto_atomic,
                                         T volatile * acc,
                                         T compare )
{
  return atomicDec ( RAJA :: seq_atomic { }, acc, compare );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicAnd ( auto_atomic, T volatile * acc, T value )
{
  return atomicAnd ( RAJA :: seq_atomic { }, acc, value );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicOr ( auto_atomic, T volatile * acc, T value )
{
  return atomicOr ( RAJA :: seq_atomic { }, acc, value );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicXor ( auto_atomic, T volatile * acc, T value )
{
  return atomicXor ( RAJA :: seq_atomic { }, acc, value );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T atomicExchange ( auto_atomic,
                                              T volatile * acc,
                                              T value )
{
  return atomicExchange ( RAJA :: seq_atomic { }, acc, value );
}
template < typename T >
inline __attribute__ ( ( always_inline ) ) T
atomicCAS ( auto_atomic, T volatile * acc, T compare, T value )
{
  return atomicCAS ( RAJA :: seq_atomic { }, acc, compare, value );
}
}
namespace RAJA
{
namespace util
{
template < typename A, typename B >
inline __attribute__ ( ( always_inline ) ) constexpr B reinterp_A_as_B ( A const & val )
{
  static_assert ( sizeof ( A ) == sizeof ( B ), "A and B must be same size" );
  return reinterpret_cast < B const volatile & > ( val );
}
template < typename A, typename B >
inline __attribute__ ( ( always_inline ) ) constexpr B reinterp_A_as_B ( A volatile const & val )
{
  static_assert ( sizeof ( A ) == sizeof ( B ), "A and B must be same size" );
  return reinterpret_cast < B const volatile & > ( val );
}
}
}
namespace RAJA
{

struct builtin_atomic 
{
}
;
namespace detail
{

inline unsigned int  __attribute__((always_inline)) builtin_atomic_CAS(volatile unsigned int *acc,unsigned int compare,unsigned int value)
{
false;
return compare;
}

inline unsigned long long  __attribute__((always_inline)) builtin_atomic_CAS(volatile unsigned long long *acc,unsigned long long compare,unsigned long long value)
{
false;
return compare;
}
template < typename T >
 inline __attribute__ ( ( always_inline ) )
    typename std :: enable_if < sizeof ( T ) == sizeof ( unsigned ), T > :: type
    builtin_atomic_CAS ( T volatile * acc, T compare, T value )
{
  return RAJA :: util :: reinterp_A_as_B < unsigned, T > (
      builtin_atomic_CAS ( ( unsigned volatile * ) acc,
                         RAJA :: util :: reinterp_A_as_B < T, unsigned > ( compare ),
                         RAJA :: util :: reinterp_A_as_B < T, unsigned > ( value ) ) );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) )
    typename std :: enable_if < sizeof ( T ) == sizeof ( unsigned long long ), T > :: type
    builtin_atomic_CAS ( T volatile * acc, T compare, T value )
{
  return RAJA :: util :: reinterp_A_as_B < unsigned long long, T > ( builtin_atomic_CAS (
      ( unsigned long long volatile * ) acc,
      RAJA :: util :: reinterp_A_as_B < T, unsigned long long > ( compare ),
      RAJA :: util :: reinterp_A_as_B < T, unsigned long long > ( value ) ) );
}
template < size_t BYTES >
struct BuiltinAtomicCAS;
template < size_t BYTES >
struct BuiltinAtomicCAS {
  static_assert ( ! ( BYTES == 4 || BYTES == 8 ),
                "builtin atomic cas assumes 4 or 8 byte targets" );
};
template<> struct BuiltinAtomicCAS< 4UL > 
{
template < typename T, typename OPER, typename ShortCircuit >
  inline __attribute__ ( ( always_inline ) ) T operator ( ) ( T volatile * acc,
                                           OPER const & oper,
                                           ShortCircuit const & sc ) const
  {
    unsigned oldval, newval, readback;
    oldval = RAJA :: util :: reinterp_A_as_B < T, unsigned > ( * acc );
    newval = RAJA :: util :: reinterp_A_as_B < T, unsigned > (
        oper ( RAJA :: util :: reinterp_A_as_B < unsigned, T > ( oldval ) ) );
    while ( ( readback = builtin_atomic_CAS ( ( unsigned * ) acc, oldval, newval ) ) !=
           oldval ) {
      if ( sc ( readback ) ) break;
      oldval = readback;
      newval = RAJA :: util :: reinterp_A_as_B < T, unsigned > (
          oper ( RAJA :: util :: reinterp_A_as_B < unsigned, T > ( oldval ) ) );
    }
    return RAJA :: util :: reinterp_A_as_B < unsigned, T > ( oldval );
  }
};
template<> struct BuiltinAtomicCAS< 8UL > 
{
template < typename T, typename OPER, typename ShortCircuit >
  inline __attribute__ ( ( always_inline ) ) T operator ( ) ( T volatile * acc,
                                           OPER const & oper,
                                           ShortCircuit const & sc ) const
  {
    unsigned long long oldval, newval, readback;
    oldval = RAJA :: util :: reinterp_A_as_B < T, unsigned long long > ( * acc );
    newval = RAJA :: util :: reinterp_A_as_B < T, unsigned long long > (
        oper ( RAJA :: util :: reinterp_A_as_B < unsigned long long, T > ( oldval ) ) );
    while ( ( readback = builtin_atomic_CAS ( ( unsigned long long * ) acc,
                                          oldval,
                                          newval ) ) != oldval ) {
      if ( sc ( readback ) ) break;
      oldval = readback;
      newval = RAJA :: util :: reinterp_A_as_B < T, unsigned long long > (
          oper ( RAJA :: util :: reinterp_A_as_B < unsigned long long, T > ( oldval ) ) );
    }
    return RAJA :: util :: reinterp_A_as_B < unsigned long long, T > ( oldval );
  }
};
template < typename T, typename OPER >
 inline __attribute__ ( ( always_inline ) ) T builtin_atomic_CAS_oper ( T volatile * acc,
                                                      OPER && oper )
{
  BuiltinAtomicCAS < sizeof ( T ) > cas;
  return cas ( acc, std :: forward < OPER > ( oper ), [ ] ( T const & ) { return false; } );
}
template < typename T, typename OPER, typename ShortCircuit >
 inline __attribute__ ( ( always_inline ) ) T builtin_atomic_CAS_oper_sc ( T volatile * acc,
                                                         OPER && oper,
                                                         ShortCircuit const & sc )
{
  BuiltinAtomicCAS < sizeof ( T ) > cas;
  return cas ( acc, std :: forward < OPER > ( oper ), sc );
}
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicAdd ( builtin_atomic,
                                        T volatile * acc,
                                        T value )
{
  return detail :: builtin_atomic_CAS_oper ( acc, [ = ] ( T a ) { return a + value; } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicSub ( builtin_atomic,
                                        T volatile * acc,
                                        T value )
{
  return detail :: builtin_atomic_CAS_oper ( acc, [ = ] ( T a ) { return a - value; } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicMin ( builtin_atomic,
                                        T volatile * acc,
                                        T value )
{
  if ( * acc < value ) {
    return * acc;
  }
  return detail :: builtin_atomic_CAS_oper_sc ( acc,
                                            [ = ] ( T a ) {
                                              return a < value ? a : value;
                                            },
                                            [ = ] ( T current ) {
                                              return current < value;
                                            } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicMax ( builtin_atomic,
                                        T volatile * acc,
                                        T value )
{
  if ( * acc > value ) {
    return * acc;
  }
  return detail :: builtin_atomic_CAS_oper_sc ( acc,
                                            [ = ] ( T a ) {
                                              return a > value ? a : value;
                                            },
                                            [ = ] ( T current ) {
                                              return current > value;
                                            } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicInc ( builtin_atomic, T volatile * acc )
{
  return detail :: builtin_atomic_CAS_oper ( acc, [ = ] ( T a ) { return a + 1; } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicInc ( builtin_atomic, T volatile * acc, T val )
{
  return detail :: builtin_atomic_CAS_oper ( acc, [ = ] ( T old ) {
    return ( ( old >= val ) ? 0 : ( old + 1 ) );
  } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicDec ( builtin_atomic, T volatile * acc )
{
  return detail :: builtin_atomic_CAS_oper ( acc, [ = ] ( T a ) { return a - 1; } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicDec ( builtin_atomic, T volatile * acc, T val )
{
  return detail :: builtin_atomic_CAS_oper ( acc, [ = ] ( T old ) {
    return ( ( ( old == 0 ) | ( old > val ) ) ? val : ( old - 1 ) );
  } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicAnd ( builtin_atomic,
                                        T volatile * acc,
                                        T value )
{
  return detail :: builtin_atomic_CAS_oper ( acc, [ = ] ( T a ) { return a & value; } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicOr ( builtin_atomic, T volatile * acc, T value )
{
  return detail :: builtin_atomic_CAS_oper ( acc, [ = ] ( T a ) { return a | value; } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicXor ( builtin_atomic,
                                        T volatile * acc,
                                        T value )
{
  return detail :: builtin_atomic_CAS_oper ( acc, [ = ] ( T a ) { return a ^ value; } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T atomicExchange ( builtin_atomic,
                                             T volatile * acc,
                                             T value )
{
  return detail :: builtin_atomic_CAS_oper ( acc, [ = ] ( T ) { return value; } );
}
template < typename T >
 inline __attribute__ ( ( always_inline ) ) T
atomicCAS ( builtin_atomic, T volatile * acc, T compare, T value )
{
  return detail :: builtin_atomic_CAS ( acc, compare, value );
}
}
namespace RAJA
{
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicAdd ( T volatile * acc, T value )
{
  return RAJA :: atomicAdd ( Policy { }, acc, value );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicSub ( T volatile * acc, T value )
{
  return RAJA :: atomicSub ( Policy { }, acc, value );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicMin ( T volatile * acc, T value )
{
  return RAJA :: atomicMin ( Policy { }, acc, value );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicMax ( T volatile * acc, T value )
{
  return RAJA :: atomicMax ( Policy { }, acc, value );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicInc ( T volatile * acc )
{
  return RAJA :: atomicInc ( Policy { }, acc );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicInc ( T volatile * acc, T compare )
{
  return RAJA :: atomicInc ( Policy { }, acc, compare );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicDec ( T volatile * acc )
{
  return RAJA :: atomicDec ( Policy { }, acc );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicDec ( T volatile * acc, T compare )
{
  return RAJA :: atomicDec ( Policy { }, acc, compare );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicAnd ( T volatile * acc, T value )
{
  static_assert ( std :: is_integral < T > :: value,
                "atomicAnd can only be used on integral types" );
  return RAJA :: atomicAnd ( Policy { }, acc, value );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicOr ( T volatile * acc, T value )
{
  static_assert ( std :: is_integral < T > :: value,
                "atomicOr can only be used on integral types" );
  return RAJA :: atomicOr ( Policy { }, acc, value );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicXor ( T volatile * acc, T value )
{
  static_assert ( std :: is_integral < T > :: value,
                "atomicXor can only be used on integral types" );
  return RAJA :: atomicXor ( Policy { }, acc, value );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicExchange ( T volatile * acc, T value )
{
  return RAJA :: atomicExchange ( Policy { }, acc, value );
}
template < typename Policy, typename T >
inline __attribute__ ( ( always_inline ) ) T atomicCAS ( T volatile * acc, T compare, T value )
{
  return RAJA :: atomicCAS ( Policy { }, acc, compare, value );
}
template < typename T, typename Policy = auto_atomic >
class AtomicRef
{
public :
  using value_type = T;
  inline __attribute__ ( ( always_inline ) )
  constexpr explicit AtomicRef ( value_type * value_ptr )
                                ;
  inline __attribute__ ( ( always_inline ) )
  constexpr AtomicRef ( AtomicRef const & c )
                                    ;
  AtomicRef & operator = ( AtomicRef const & ) = delete;
  inline __attribute__ ( ( always_inline ) )
  value_type volatile * getPointer ( ) const;
  inline __attribute__ ( ( always_inline ) )
  void store ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type operator = ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type load ( ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  operator value_type ( ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type exchange ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type CAS ( value_type compare, value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  bool compare_exchange_strong ( value_type & expect, value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  bool compare_exchange_weak ( value_type & expect, value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type operator ++ ( ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type operator ++ ( int ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type operator -- ( ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type operator -- ( int ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type fetch_add ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type operator += ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type fetch_sub ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type operator -= ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type fetch_min ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type min ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type fetch_max ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type max ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type fetch_and ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type operator &= ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type fetch_or ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type operator |= ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type fetch_xor ( value_type rhs ) const
  ;
  inline __attribute__ ( ( always_inline ) )
  value_type operator ^= ( value_type rhs ) const
  ;
private :
  value_type volatile * m_value_ptr;
};
}
namespace RAJA
{
template < typename layout >
struct add_offset
{
  using type = RAJA :: OffsetLayout < layout :: n_dims >;
};
template < typename IdxLin, typename ... DimTypes >
struct add_offset < RAJA :: TypedLayout < IdxLin, camp :: tuple < DimTypes ... > > >
{
  using type = RAJA :: TypedOffsetLayout < IdxLin, camp :: tuple < DimTypes ... >>;
};
template < typename ValueType,
          typename LayoutType,
          typename PointerType = ValueType * >
struct View {
  using value_type = ValueType;
  using pointer_type = PointerType;
  using layout_type = LayoutType;
  using nc_value_type = typename std :: remove_const < value_type > :: type;
  using nc_pointer_type = typename std :: add_pointer < typename std :: remove_const <
      typename std :: remove_pointer < pointer_type > :: type > :: type > :: type;
  using NonConstView = View < nc_value_type, layout_type, nc_pointer_type >;
  layout_type const layout;
  pointer_type data;
  template < typename ... Args >
  inline __attribute__ ( ( always_inline ) ) constexpr View ( pointer_type data_ptr, Args ... dim_sizes )
      : layout ( dim_sizes ... ), data ( data_ptr )
  {
  }
  inline __attribute__ ( ( always_inline ) ) constexpr View ( pointer_type data_ptr, layout_type && layout )
      ;
  inline __attribute__ ( ( always_inline ) ) constexpr View ( View const & V )
      ;
  template < bool IsConstView = std :: is_const < value_type > :: value >
  inline __attribute__ ( ( always_inline ) ) constexpr View (
      typename std :: enable_if < IsConstView, NonConstView > :: type const & rhs )
      : layout ( rhs . layout ), data ( rhs . data )
  {
  }
  inline __attribute__ ( ( always_inline ) ) void set_data ( pointer_type data_ptr );
  template < size_t n_dims = layout_type :: n_dims, typename IdxLin = Index_type >
  inline __attribute__ ( ( always_inline ) ) RAJA :: View < ValueType, typename add_offset < layout_type > :: type >
  shift ( const std :: array < IdxLin, n_dims > & shift )
  {
    static_assert ( n_dims == layout_type :: n_dims, "Dimension mismatch in view shift" );
    typename add_offset < layout_type > :: type shift_layout ( layout );
    shift_layout . shift ( shift );
    return RAJA :: View < ValueType, typename add_offset < layout_type > :: type > ( data, shift_layout );
  }
  template < typename ... Args >
  inline __attribute__ ( ( always_inline ) ) value_type & operator ( ) ( Args ... args ) const
  {
    auto idx = stripIndexType ( layout ( args ... ) );
    return data [ idx ];
  }
};
template < typename ValueType,
          typename PointerType,
          typename LayoutType,
          typename ... IndexTypes >
struct TypedViewBase {
  using Base = View < ValueType, LayoutType, PointerType >;
  Base base_;
  template < typename ... Args >
  inline __attribute__ ( ( always_inline ) ) constexpr TypedViewBase ( PointerType data_ptr, Args ... dim_sizes )
      : base_ ( data_ptr, dim_sizes ... )
  {
  }
  template < typename CLayoutType >
  inline __attribute__ ( ( always_inline ) ) constexpr TypedViewBase ( PointerType data_ptr,
                                      CLayoutType && layout )
      : base_ ( data_ptr, std :: forward < CLayoutType > ( layout ) )
  {
  }
  inline __attribute__ ( ( always_inline ) ) void set_data ( PointerType data_ptr );
  template < size_t n_dims = Base :: layout_type :: n_dims, typename IdxLin = Index_type >
  inline __attribute__ ( ( always_inline ) ) RAJA :: TypedViewBase < ValueType, ValueType *, typename add_offset < LayoutType > :: type, IndexTypes ... >
  shift ( const std :: array < IdxLin, n_dims > & shift )
  {
    static_assert ( n_dims == Base :: layout_type :: n_dims, "Dimension mismatch in view shift" );
    typename add_offset < LayoutType > :: type shift_layout ( base_ . layout );
    shift_layout . shift ( shift );
    return RAJA :: TypedViewBase < ValueType, ValueType *, typename add_offset < LayoutType > :: type, IndexTypes ... > ( base_ . data, shift_layout );
  }
  inline __attribute__ ( ( always_inline ) ) ValueType & operator ( ) ( IndexTypes ... args ) const
  ;
};
template < typename ValueType, typename LayoutType, typename ... IndexTypes >
using TypedView =
    TypedViewBase < ValueType, ValueType *, LayoutType, IndexTypes ... >;
template < typename ViewType, typename AtomicPolicy = RAJA :: auto_atomic >
struct AtomicViewWrapper {
  using base_type = ViewType;
  using pointer_type = typename base_type :: pointer_type;
  using value_type = typename base_type :: value_type;
  using atomic_type = RAJA :: AtomicRef < value_type, AtomicPolicy >;
  base_type base_;
  inline __attribute__ ( ( always_inline ) )
  constexpr explicit AtomicViewWrapper ( ViewType view );
  inline __attribute__ ( ( always_inline ) ) void set_data ( pointer_type data_ptr );
  template < typename ... ARGS >
  inline __attribute__ ( ( always_inline ) ) atomic_type operator ( ) ( ARGS && ... args ) const
  {
    return atomic_type ( & base_ . operator ( ) ( std :: forward < ARGS > ( args ) ... ) );
  }
};
template < typename ViewType >
struct AtomicViewWrapper < ViewType, RAJA :: seq_atomic > {
  using base_type = ViewType;
  using pointer_type = typename base_type :: pointer_type;
  using value_type = typename base_type :: value_type;
  using atomic_type = RAJA :: AtomicRef < value_type, RAJA :: seq_atomic >;
  base_type base_;
  inline __attribute__ ( ( always_inline ) )
  constexpr explicit AtomicViewWrapper ( ViewType const & view );
  inline __attribute__ ( ( always_inline ) ) void set_data ( pointer_type data_ptr );
  template < typename ... ARGS >
  inline __attribute__ ( ( always_inline ) ) value_type & operator ( ) ( ARGS && ... args ) const
  {
    return base_ . operator ( ) ( std :: forward < ARGS > ( args ) ... );
  }
};
template < typename AtomicPolicy, typename ViewType >
inline __attribute__ ( ( always_inline ) ) AtomicViewWrapper < ViewType, AtomicPolicy > make_atomic_view (
    ViewType const & view )
{
  return RAJA :: AtomicViewWrapper < ViewType, AtomicPolicy > ( view );
}
}
namespace RAJA
{
template < camp :: idx_t ... Sizes >
using ParamList = camp :: idx_seq < Sizes ... >;
template < typename DataType, typename Perm, typename Sizes, typename ... IndexTypes >
struct TypedLocalArray
{
};
template < typename DataType, camp :: idx_t ... Perm, camp :: idx_t ... Sizes, typename ... IndexTypes >
struct TypedLocalArray < DataType, camp :: idx_seq < Perm ... >, RAJA :: SizeList < Sizes ... >, IndexTypes ... >
{
  DataType * m_arrayPtr = nullptr;
  using element_t = DataType;
  using layout_t = StaticLayout < camp :: idx_seq < Perm ... >, Sizes ... >;
  static const camp :: idx_t NumElem = layout_t :: size ( );
  element_t & operator ( ) ( IndexTypes ... indices ) const
  ;
};
template < typename AtomicPolicy, typename DataType, typename Perm,
         typename Sizes, typename ... IndexTypes >
struct AtomicTypedLocalArray {
};
template < typename AtomicPolicy, typename DataType, camp :: idx_t ... Perm,
         camp :: idx_t ... Sizes, typename ... IndexTypes >
struct AtomicTypedLocalArray < AtomicPolicy, DataType, camp :: idx_seq < Perm ... >,
                             RAJA :: SizeList < Sizes ... >, IndexTypes ... > {
  DataType * m_arrayPtr = nullptr;
  using element_t = DataType;
  using atomic_ref_t = RAJA :: AtomicRef < element_t, AtomicPolicy >;
  using layout_t = RAJA :: StaticLayout < camp :: idx_seq < Perm ... >, Sizes ... >;
  static const camp :: idx_t NumElem = layout_t :: size ( );
  atomic_ref_t operator ( ) ( IndexTypes ... indices ) const
  ;
};
template < typename DataType, typename Perm, typename Sizes >
struct LocalArray
{
};
template < typename DataType, camp :: idx_t ... Perm, camp :: idx_t ... Sizes >
struct LocalArray < DataType, camp :: idx_seq < Perm ... >, RAJA :: SizeList < Sizes ... > >
{
  DataType * m_arrayPtr = nullptr;
  using element_t = DataType;
  using layout_t = StaticLayout < camp :: idx_seq < Perm ... >, Sizes ... >;
  static const camp :: idx_t NumElem = layout_t :: size ( );
  template < typename ... Indices >
  element_t & operator ( ) ( Indices ... indices ) const
  {
    return m_arrayPtr [ layout_t :: s_oper ( indices ... ) ];
  }
};
}
namespace RAJA
{
template < size_t Width, size_t Shift >
  struct BitMask {
    static constexpr size_t shift = Shift;
    static constexpr size_t width = Width;
    static constexpr size_t max_input_size = 1 << ( Shift + Width );
    static constexpr size_t max_masked_size = 1 << Width;
    static constexpr size_t max_shifted_size = 1 << Shift;
    template < typename T >
    static constexpr T maskValue ( T input ) {
      return ( ( input >> ( ( T ) Shift ) ) & ( T ) ( ( 1 << ( Width ) ) - 1 ) );
    }
  };
}
namespace RAJA
{
template < typename Policy >
void synchronize ( )
{
  synchronize_impl ( Policy { } );
}
}
namespace RAJA
{
template < typename CONTAINER_T, typename ... SEG_TYPES >
inline __attribute__ ( ( always_inline ) ) void getIndices ( CONTAINER_T & con,
                            const TypedIndexSet < SEG_TYPES ... > & iset )
{
  CONTAINER_T tcon;
  forall < ExecPolicy < seq_segit, seq_exec > > ( iset, [ & ] ( Index_type idx ) {
    tcon . push_back ( idx );
  } );
  con = tcon;
}
template < typename CONTAINER_T, typename SEGMENT_T >
inline __attribute__ ( ( always_inline ) ) void getIndices ( CONTAINER_T & con, const SEGMENT_T & iset )
{
  CONTAINER_T tcon;
  forall < seq_exec > ( iset, [ & ] ( Index_type idx ) { tcon . push_back ( idx ); } );
  con = tcon;
}
template < typename CONTAINER_T, typename ... SEG_TYPES, typename CONDITIONAL >
inline __attribute__ ( ( always_inline ) ) void getIndicesConditional ( CONTAINER_T & con,
                                       const TypedIndexSet < SEG_TYPES ... > & iset,
                                       CONDITIONAL conditional )
{
  CONTAINER_T tcon;
  forall < ExecPolicy < seq_segit, seq_exec > > ( iset, [ & ] ( Index_type idx ) {
    if ( conditional ( idx ) ) tcon . push_back ( idx );
  } );
  con = tcon;
}
template < typename CONTAINER_T, typename SEGMENT_T, typename CONDITIONAL >
inline __attribute__ ( ( always_inline ) ) void getIndicesConditional ( CONTAINER_T & con,
                                       const SEGMENT_T & iset,
                                       CONDITIONAL conditional )
{
  CONTAINER_T tcon;
  forall < seq_exec > ( iset, [ & ] ( Index_type idx ) {
    if ( conditional ( idx ) ) tcon . push_back ( idx );
  } );
  con = tcon;
}
}
namespace RAJA
{
namespace detail
{
template < typename Iter >
using IterVal = camp :: decay < decltype ( * camp :: val < Iter > ( ) ) >;
template < typename Container >
using ContainerVal =
    camp :: decay < decltype ( * camp :: val < camp :: iterator_from < Container >> ( ) ) >;
}
template < typename ExecPolicy,
          typename Iter,
          typename Function = operators :: plus < detail :: IterVal < Iter > > >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy >,
                    type_traits :: is_iterator < Iter > >
inclusive_scan_inplace ( const ExecPolicy & p,
                       Iter begin,
                       Iter end,
                       Function binop = Function { } )
{
  using R = detail :: IterVal < Iter >;
  static_assert ( type_traits :: is_binary_function < Function, R, R, R > :: value,
                "Function must model BinaryFunction" );
  static_assert ( type_traits :: is_random_access_iterator < Iter > :: value,
                "Iterator must model RandomAccessIterator" );
  if ( begin == end ) {
    return;
  }
  impl :: scan :: inclusive_inplace ( p, begin, end, binop );
}
template < typename ExecPolicy,
          typename Iter,
          typename T = detail :: IterVal < Iter >,
          typename Function = operators :: plus < T > >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy >,
                    type_traits :: is_iterator < Iter > >
exclusive_scan_inplace ( const ExecPolicy & p,
                       Iter begin,
                       Iter end,
                       Function binop = Function { },
                       T value = Function :: identity ( ) )
{
  using R = detail :: IterVal < Iter >;
  static_assert ( type_traits :: is_binary_function < Function, R, T, R > :: value,
                "Function must model BinaryFunction" );
  static_assert ( type_traits :: is_random_access_iterator < Iter > :: value,
                "Iterator must model RandomAccessIterator" );
  if ( begin == end ) {
    return;
  }
  impl :: scan :: exclusive_inplace ( p, begin, end, binop, value );
}
template < typename ExecPolicy,
          typename Iter,
          typename IterOut,
          typename Function = operators :: plus < detail :: IterVal < Iter > > >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy >,
                    type_traits :: is_iterator < Iter >,
                    type_traits :: is_iterator < IterOut > >
inclusive_scan ( const ExecPolicy & p,
               Iter begin,
               Iter end,
               IterOut out,
               Function binop = Function { } )
{
  using R = detail :: IterVal < IterOut >;
  using T = detail :: IterVal < Iter >;
  static_assert ( type_traits :: is_binary_function < Function, R, T, R > :: value,
                "Function must model BinaryFunction" );
  static_assert ( type_traits :: is_random_access_iterator < Iter > :: value,
                "Iterator must model RandomAccessIterator" );
  static_assert ( type_traits :: is_random_access_iterator < IterOut > :: value,
                "Output Iterator must model RandomAccessIterator" );
  if ( begin == end ) {
    return;
  }
  impl :: scan :: inclusive ( p, begin, end, out, binop );
}
template < typename ExecPolicy,
          typename Iter,
          typename IterOut,
          typename T = detail :: IterVal < Iter >,
          typename Function = operators :: plus < T > >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy >,
                    type_traits :: is_iterator < Iter >,
                    type_traits :: is_iterator < IterOut > >
exclusive_scan ( const ExecPolicy & p,
               Iter begin,
               Iter end,
               IterOut out,
               Function binop = Function { },
               T value = Function :: identity ( ) )
{
  using R = detail :: IterVal < IterOut >;
  using U = detail :: IterVal < Iter >;
  static_assert ( type_traits :: is_binary_function < Function, R, T, U > :: value,
                "Function must model BinaryFunction" );
  static_assert ( type_traits :: is_random_access_iterator < Iter > :: value,
                "Iterator must model RandomAccessIterator" );
  static_assert ( type_traits :: is_random_access_iterator < IterOut > :: value,
                "Output Iterator must model RandomAccessIterator" );
  if ( begin == end ) {
    return;
  }
  impl :: scan :: exclusive ( p, begin, end, out, binop, value );
}
template < typename ExecPolicy,
          typename Container,
          typename Function = operators :: plus < detail :: ContainerVal < Container > > >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy >,
                    type_traits :: is_range < Container > >
inclusive_scan_inplace ( const ExecPolicy & p,
                       Container & c,
                       Function binop = Function { } )
{
  using R = detail :: ContainerVal < Container >;
  static_assert ( type_traits :: is_binary_function < Function, R, R, R > :: value,
                "Function must model BinaryFunction" );
  static_assert ( type_traits :: is_random_access_range < Container > :: value,
                "Container must model RandomAccessRange" );
  if ( std :: begin ( c ) == std :: end ( c ) ) {
    return;
  }
  impl :: scan :: inclusive_inplace ( p, std :: begin ( c ), std :: end ( c ), binop );
}
template < typename ExecPolicy,
          typename Container,
          typename T = detail :: ContainerVal < Container >,
          typename Function = operators :: plus < T > >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy >,
                    type_traits :: is_range < Container > >
exclusive_scan_inplace ( const ExecPolicy & p,
                       Container & c,
                       Function binop = Function { },
                       T value = Function :: identity ( ) )
{
  using R = detail :: ContainerVal < Container >;
  static_assert ( type_traits :: is_binary_function < Function, R, T, R > :: value,
                "Function must model BinaryFunction" );
  static_assert ( type_traits :: is_random_access_range < Container > :: value,
                "Container must model RandomAccessRange" );
  if ( std :: begin ( c ) == std :: end ( c ) ) {
    return;
  }
  impl :: scan :: exclusive_inplace ( p, std :: begin ( c ), std :: end ( c ), binop, value );
}
template < typename ExecPolicy,
          typename Container,
          typename IterOut,
          typename Function = operators :: plus < detail :: ContainerVal < Container > > >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy >,
                    type_traits :: is_range < Container >,
                    type_traits :: is_iterator < IterOut > >
inclusive_scan ( const ExecPolicy & p,
               const Container & c,
               IterOut out,
               Function binop = Function { } )
{
  using R = detail :: IterVal < IterOut >;
  using T = detail :: ContainerVal < Container >;
  static_assert ( type_traits :: is_binary_function < Function, R, T, R > :: value,
                "Function must model BinaryFunction" );
  static_assert ( type_traits :: is_random_access_range < Container > :: value,
                "Container must model RandomAccessRange" );
  static_assert ( type_traits :: is_random_access_iterator < IterOut > :: value,
                "Output Iterator must model RandomAccessIterator" );
  if ( std :: begin ( c ) == std :: end ( c ) ) {
    return;
  }
  impl :: scan :: inclusive ( p, std :: begin ( c ), std :: end ( c ), out, binop );
}
template < typename ExecPolicy,
          typename Container,
          typename IterOut,
          typename T = detail :: ContainerVal < Container >,
          typename Function = operators :: plus < T > >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy >,
                    type_traits :: is_range < Container >,
                    type_traits :: is_iterator < IterOut > >
exclusive_scan ( const ExecPolicy & p,
               const Container & c,
               IterOut out,
               Function binop = Function { },
               T value = Function :: identity ( ) )
{
  using R = detail :: IterVal < IterOut >;
  using U = detail :: ContainerVal < Container >;
  static_assert ( type_traits :: is_binary_function < Function, R, T, U > :: value,
                "Function must model BinaryFunction" );
  static_assert ( type_traits :: is_random_access_range < Container > :: value,
                "Container must model RandomAccessRange" );
  static_assert ( type_traits :: is_random_access_iterator < IterOut > :: value,
                "Output Iterator must model RandomAccessIterator" );
  if ( std :: begin ( c ) == std :: end ( c ) ) {
    return;
  }
  impl :: scan :: exclusive ( p, std :: begin ( c ), std :: end ( c ), out, binop, value );
}
template < typename ExecPolicy, typename ... Args >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy > >
exclusive_scan ( Args && ... args )
{
  exclusive_scan ( ExecPolicy { }, std :: forward < Args > ( args ) ... );
}
template < typename ExecPolicy, typename ... Args >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy > >
inclusive_scan ( Args && ... args )
{
  inclusive_scan ( ExecPolicy { }, std :: forward < Args > ( args ) ... );
}
template < typename ExecPolicy, typename ... Args >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy > >
exclusive_scan_inplace ( Args && ... args )
{
  exclusive_scan_inplace ( ExecPolicy { }, std :: forward < Args > ( args ) ... );
}
template < typename ExecPolicy, typename ... Args >
concepts :: enable_if < type_traits :: is_execution_policy < ExecPolicy > >
inclusive_scan_inplace ( Args && ... args )
{
  inclusive_scan_inplace ( ExecPolicy { }, std :: forward < Args > ( args ) ... );
}
}
namespace RAJA
{

class ChronoTimer 
{
using ElapsedType = double ;
using ClockType = struct ::std::chrono::_V2::steady_clock ;
using TimeType = ::std::chrono::_V2::steady_clock::time_point ;
using DurationType = struct ::std::chrono::duration< ElapsedType  , class ::std::ratio< 1 , 1L >  > ;

public: inline ChronoTimer() : tstart(::std::chrono::_V2::steady_clock::now()), tstop(::std::chrono::_V2::steady_clock::now()), telapsed(0)
{
}

inline void start()
{
(this) -> tstart = ::std::chrono::_V2::steady_clock::now();
}

inline void stop()
{
(this) -> tstop = ::std::chrono::_V2::steady_clock::now();
(this) -> telapsed += ::std::chrono::duration_cast< DurationType  , int64_t  , ::std::nano  > (((this) -> tstop-(this) -> tstart)) . count();
}

inline ElapsedType elapsed() const
{
return (this) -> telapsed;
}

inline void reset()
{
(this) -> telapsed = 0;
}
private: TimeType tstart;
TimeType tstop;
ElapsedType telapsed;
}
;
using TimerBase = class ChronoTimer ;
}
namespace RAJA
{

class Timer : public ChronoTimer
{
public: 
using RAJA::ChronoTimer::start;
using RAJA::ChronoTimer::stop;

inline void start(const char *)
{
(this) ->  start ();
}

inline void stop(const char *)
{
(this) ->  stop ();
}
}
;
}
namespace memoryManager
{
template < typename T >
T * allocate ( RAJA :: Index_type size )
{
  T * ptr;
  ptr = new T [ size ];
  return ptr;
}
template < typename T >
void deallocate ( T * & ptr )
{
  if ( ptr ) {
    delete [ ] ptr;
    ptr = nullptr;
  }
}
}
using RAJA::Index_type;
#if 1

int main(int ,char **)
{
  const int N_c = 3;
  const int N_r = 3;
  const RAJA::Index_type N = 8000000;
  const int NITER = 20;
  double minRun;
  double *rose_temp__4;
  {
    RAJA::Index_type size__2 = (N_c * N_r) * N;
    double *ptr;
    ptr = (new double [size]);
    {
      rose_temp__4 = ptr;
      goto rose_inline_end__3;
    }
rose_inline_end__3:
    ;
  }
  double *A = rose_temp__4;
  double *rose_temp__8;
  {
    RAJA::Index_type size__6 = (N_c * N_r) * N;
    double *ptr;
    ptr = (new double [size]);
    {
      rose_temp__8 = ptr;
      goto rose_inline_end__7;
    }
rose_inline_end__7:
    ;
  }
  double *B = rose_temp__8;
  double *rose_temp__12;
  {
    RAJA::Index_type size__10 = (N_c * N_r) * N;
    double *ptr;
    ptr = (new double [size]);
    {
      rose_temp__12 = ptr;
      goto rose_inline_end__11;
    }
rose_inline_end__11:
    ;
  }
  double *C = rose_temp__12;
  struct std::array< camp::idx_t  , 3UL > perm1 = {/* Need explicit braces: is this where we insert the class name? */ {(0), (1), (2)}};
  RAJA::Layout< 3UL , RAJA::Index_type  , -1L > rose_temp__17;
  {
    struct std::array< camp::idx_t  , 3UL > sizes__14 = {/* Need explicit braces: is this where we insert the class name? */ {(N), (N_r), (N_c)}};
    struct std::array< camp::idx_t  , 3UL > permutation__15 = perm1;
    struct std::array< camp::idx_t  , 3UL > strides;
    struct std::array< camp::idx_t  , 3UL > folded_strides;
    for (size_t i = 0; i < 3UL; ++i) {
      folded_strides[i] = (((sizes__14[(permutation__15[i])])?1 : 0));
      for (size_t j = i + 1; j < 3UL; ++j) {
        folded_strides[i] *= ((sizes__14[(permutation__15[j])])?sizes__14[(permutation__15[j])] : 1);
      }
    }
    for (size_t i = 0; i < 3UL; ++i) {
      strides[(permutation__15[i])] = folded_strides[i];
    }
    auto ret = RAJA::detail::LayoutBase_impl< class camp::int_seq< camp::idx_t  , 0L , 1L , 2L > ,RAJA::Index_type ,-1L> ();
    for (size_t i = 0; i < 3UL; ++i) {
      ret . sizes[i] = sizes__14[i];
      ret . strides[i] = strides[i];
      ret . inv_strides[i] = ((strides[i])?strides[i] : 1);
      ret . inv_mods[i] = ((sizes__14[i])?sizes__14[i] : 1);
    }
    {
      rose_temp__17 = ret;
      goto rose_inline_end__16;
    }
rose_inline_end__16:
    ;
  }
  auto layout1 = rose_temp__17;
  struct RAJA::View< double  , RAJA::Layout< 3UL , RAJA::Index_type  , 2L >  , double * > Aview(A,layout1);
  struct RAJA::View< double  , RAJA::Layout< 3UL , RAJA::Index_type  , 2L >  , double * > Bview(B,layout1);
  struct RAJA::View< double  , RAJA::Layout< 3UL , RAJA::Index_type  , 2L >  , double * > Cview(C,layout1);
  double *rose_temp__21;
  {
    RAJA::Index_type size__19 = (N_c * N_r) * N;
    double *ptr;
    ptr = (new double [size]);
    {
      rose_temp__21 = ptr;
      goto rose_inline_end__20;
    }
rose_inline_end__20:
    ;
  }
  double *A2 = rose_temp__21;
  double *rose_temp__25;
  {
    RAJA::Index_type size__23 = (N_c * N_r) * N;
    double *ptr;
    ptr = (new double [size]);
    {
      rose_temp__25 = ptr;
      goto rose_inline_end__24;
    }
rose_inline_end__24:
    ;
  }
  double *B2 = rose_temp__25;
  double *rose_temp__29;
  {
    RAJA::Index_type size__27 = (N_c * N_r) * N;
    double *ptr;
    ptr = (new double [size]);
    {
      rose_temp__29 = ptr;
      goto rose_inline_end__28;
    }
rose_inline_end__28:
    ;
  }
  double *C2 = rose_temp__29;
  struct std::array< camp::idx_t  , 3UL > perm2 = {/* Need explicit braces: is this where we insert the class name? */ {(1), (2), (0)}};
  RAJA::Layout< 3UL , RAJA::Index_type  , -1L > rose_temp__34;
  {
    struct std::array< camp::idx_t  , 3UL > sizes__31 = {/* Need explicit braces: is this where we insert the class name? */ {(N), (N_r), (N_c)}};
    struct std::array< camp::idx_t  , 3UL > permutation__32 = perm2;
    struct std::array< camp::idx_t  , 3UL > strides;
    struct std::array< camp::idx_t  , 3UL > folded_strides;
    for (size_t i = 0; i < 3UL; ++i) {
      folded_strides[i] = (((sizes__31[(permutation__32[i])])?1 : 0));
      for (size_t j = i + 1; j < 3UL; ++j) {
        folded_strides[i] *= ((sizes__31[(permutation__32[j])])?sizes__31[(permutation__32[j])] : 1);
      }
    }
    for (size_t i = 0; i < 3UL; ++i) {
      strides[(permutation__32[i])] = folded_strides[i];
    }
    auto ret = RAJA::detail::LayoutBase_impl< class camp::int_seq< camp::idx_t  , 0L , 1L , 2L > ,RAJA::Index_type ,-1L> ();
    for (size_t i = 0; i < 3UL; ++i) {
      ret . sizes[i] = sizes__31[i];
      ret . strides[i] = strides[i];
      ret . inv_strides[i] = ((strides[i])?strides[i] : 1);
      ret . inv_mods[i] = ((sizes__31[i])?sizes__31[i] : 1);
    }
    {
      rose_temp__34 = ret;
      goto rose_inline_end__33;
    }
rose_inline_end__33:
    ;
  }
  auto layout2 = rose_temp__34;
  struct RAJA::View< double  , RAJA::Layout< 3UL , RAJA::Index_type  , 0L >  , double * > Aview2(A2,layout2);
  struct RAJA::View< double  , RAJA::Layout< 3UL , RAJA::Index_type  , 0L >  , double * > Bview2(B2,layout2);
  struct RAJA::View< double  , RAJA::Layout< 3UL , RAJA::Index_type  , 0L >  , double * > Cview2(C2,layout2);
  using INIT_POL = struct RAJA::policy::loop::loop_exec ;
  {
    RAJA::RangeSegment &&args__36 = RAJA::TypedRangeSegment< RAJA::Index_type ,RAJA::make_signed_t< RAJA::strip_index_type_t< RAJA::Index_type  >  > > (0,N);
    class &&args__37 =  [=] (RAJA::Index_type e)
    {
      for (RAJA::Index_type row = 0; row < ( N_r); ++row) {
        for (RAJA::Index_type col = 0; col < ( N_c); ++col) {
          Aview(e,row,col) = row;
          Bview(e,row,col) = col;
          Cview(e,row,col) = 0;
          Aview2(e,row,col) = row;
          Bview2(e,row,col) = col;
          Cview2(e,row,col) = 0;
        }
      }
    };
    struct RAJA::RAJA::util::PluginContext rose_temp__41;
    {
      {
        rose_temp__41 = RAJA::RAJA::util::PluginContext{camp::resources::v1::Platform(1)};
        goto rose_inline_end__40;
      }
rose_inline_end__40:
      ;
    }
    struct RAJA::RAJA::util::PluginContext context = rose_temp__41;
    {
      struct RAJA::RAJA::util::PluginContext p__43 = context;
      for (auto plugin = RAJA::RAJA::util::Registry< class RAJA::RAJA::util::PluginStrategy > ::begin(); plugin != RAJA::RAJA::util::Registry< class RAJA::RAJA::util::PluginStrategy > ::end();  ++ plugin) {
        auto rose_temp__53 =  * plugin;
        class std::shared_ptr< class RAJA::RAJA::util::PluginStrategy  > rose_temp__56;
        {
          const RAJA::RAJA::util::Registry< class RAJA::RAJA::util::PluginStrategy > ::entry *this__54 = &rose_temp__53;
          {
            rose_temp__56 = (this__54 -> object);
            goto rose_inline_end__55;
          }
rose_inline_end__55:
          ;
        }
        rose_temp__56 ->  preLaunch (p__43);
      }
rose_inline_end__44:
      ;
    }
    {
      struct RAJA::policy::loop::loop_exec &&p__46 = RAJA::policy::loop::loop_exec ();
      RAJA::RangeSegment &&c__47 = std::forward< RAJA::RangeSegment  > (args__36);
      class &&loop_body__48 = std::forward<   > (args__36);
      using RAJA::internal::trigger_updates_before;
      std::remove_reference< &> ::type rose_temp__60;
      {
        class &item__58 = loop_body__48;
        {
          rose_temp__60 = (item__58);
          goto rose_inline_end__59;
        }
rose_inline_end__59:
        ;
      }
      auto body = rose_temp__60;
      {
        const struct RAJA::policy::loop::loop_exec &__62 = std::forward< class RAJA::policy::loop::loop_exec  > (p__46);
        RAJA::RangeSegment &&iter__63 = std::forward< RAJA::RangeSegment  > (c__47);
        std::remove_reference< &> ::type &body__64 = body;
        using std::begin;
        using std::end;
        using std::distance;
        auto begin_it = std::begin(iter__63);
        auto end_it = std::end(iter__63);
        auto distance_it = std::distance(begin_it,end_it);
        for (std::__iterator_traits< ,std::__void_t<   > > ::difference_type i = 0; i < distance_it; ++i) {
          auto rose_temp__70 = body__64;
          {
            RAJA::Index_type e__72 = operator*();
            for (RAJA::Index_type row = 0; row < N_r; ++row) {
              for (RAJA::Index_type col = 0; col < N_c; ++col) {
                e__72operator()row = row;
                e__72operator()row = col;
                e__72operator()row = 0;
                e__72operator()row = row;
                e__72operator()row = col;
                e__72operator()row = 0;
              }
            }
rose_inline_end__73:
            ;
          }
        }
rose_inline_end__65:
        ;
      }
rose_inline_end__49:
      ;
    }
    {
      struct RAJA::RAJA::util::PluginContext p__51 = context;
      for (auto plugin = RAJA::RAJA::util::Registry< class RAJA::RAJA::util::PluginStrategy > ::begin(); plugin != RAJA::RAJA::util::Registry< class RAJA::RAJA::util::PluginStrategy > ::end();  ++ plugin) {
        auto rose_temp__66 =  * plugin;
        class std::shared_ptr< class RAJA::RAJA::util::PluginStrategy  > rose_temp__69;
        {
          const RAJA::RAJA::util::Registry< class RAJA::RAJA::util::PluginStrategy > ::entry *this__67 = &rose_temp__66;
          {
            rose_temp__69 = (this__67 -> object);
            goto rose_inline_end__68;
          }
rose_inline_end__68:
          ;
        }
        rose_temp__69 ->  postLaunch (p__51);
      }
rose_inline_end__52:
      ;
    }
rose_inline_end__38:
    ;
  }
  return 0;
}
#endif
